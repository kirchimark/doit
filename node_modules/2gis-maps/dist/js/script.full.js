(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.DG = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var css = ".leaflet-image-layer,.leaflet-layer,.leaflet-map-pane canvas,.leaflet-map-pane svg,.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-pane,.leaflet-tile,.leaflet-tile-container,.leaflet-zoom-box{position:absolute;left:0;top:0}.leaflet-container{overflow:hidden}.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-tile{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.leaflet-safari .leaflet-tile{image-rendering:-webkit-optimize-contrast}.leaflet-safari .leaflet-tile-container{width:1600px;height:1600px;-webkit-transform-origin:0 0}.leaflet-marker-icon,.leaflet-marker-shadow{display:block}.leaflet-container .leaflet-marker-pane img,.leaflet-container .leaflet-overlay-pane svg,.leaflet-container .leaflet-tile-pane img,.leaflet-container img.leaflet-image-layer{max-width:none!important}.leaflet-container.leaflet-touch-zoom{-ms-touch-action:pan-x pan-y;touch-action:pan-x pan-y}.leaflet-container.leaflet-touch-drag{-ms-touch-action:pinch-zoom}.leaflet-container.leaflet-touch-drag.leaflet-touch-drag{-ms-touch-action:none;touch-action:none}.leaflet-tile{-webkit-filter:inherit;filter:inherit;visibility:hidden}.leaflet-tile-loaded{visibility:inherit}.leaflet-zoom-box{width:0;height:0;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:800}.leaflet-overlay-pane svg{-moz-user-select:none}.leaflet-pane{z-index:400}.leaflet-tile-pane{z-index:200}.leaflet-overlay-pane{z-index:400}.leaflet-shadow-pane{z-index:500}.leaflet-marker-pane{z-index:600}.leaflet-tooltip-pane{z-index:650}.leaflet-popup-pane{z-index:700}.leaflet-map-pane canvas{z-index:100}.leaflet-map-pane svg{z-index:200}.leaflet-vml-shape{width:1px;height:1px}.lvml{behavior:url(#default#VML);display:inline-block;position:absolute}.leaflet-control{position:relative;z-index:800;pointer-events:visiblePainted;pointer-events:auto}.leaflet-bottom,.leaflet-top{position:absolute;z-index:1000;pointer-events:none}.leaflet-top{top:0}.leaflet-right{right:0}.leaflet-bottom{bottom:0}.leaflet-left{left:0}.leaflet-control{float:left;clear:both}.leaflet-right .leaflet-control{float:right}.leaflet-top .leaflet-control{margin-top:10px}.leaflet-bottom .leaflet-control{margin-bottom:10px}.leaflet-left .leaflet-control{margin-left:10px}.leaflet-right .leaflet-control{margin-right:10px}.leaflet-fade-anim .leaflet-tile{will-change:opacity}.leaflet-fade-anim .leaflet-popup{opacity:0;-webkit-transition:opacity .2s linear;transition:opacity .2s linear}.leaflet-fade-anim .leaflet-map-pane .leaflet-popup{opacity:1}.leaflet-zoom-animated{-webkit-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0}.leaflet-zoom-anim .leaflet-zoom-animated{will-change:transform;-webkit-transition:-webkit-transform .25s cubic-bezier(0,0,.25,1);transition:-webkit-transform .25s cubic-bezier(0,0,.25,1);transition:transform .25s cubic-bezier(0,0,.25,1);transition:transform .25s cubic-bezier(0,0,.25,1),-webkit-transform .25s cubic-bezier(0,0,.25,1)}.leaflet-pan-anim .leaflet-tile,.leaflet-zoom-anim .leaflet-tile{-webkit-transition:none;transition:none}.leaflet-zoom-anim .leaflet-zoom-hide{visibility:hidden}.leaflet-interactive{cursor:pointer}.leaflet-grab{cursor:-webkit-grab;cursor:-moz-grab}.leaflet-crosshair,.leaflet-crosshair .leaflet-interactive{cursor:crosshair}.leaflet-control,.leaflet-popup-pane{cursor:auto}.leaflet-dragging .leaflet-grab,.leaflet-dragging .leaflet-grab .leaflet-interactive,.leaflet-dragging .leaflet-marker-draggable{cursor:move;cursor:-webkit-grabbing;cursor:-moz-grabbing}.leaflet-image-layer,.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-pane>svg path,.leaflet-tile-container{pointer-events:none}.leaflet-image-layer.leaflet-interactive,.leaflet-marker-icon.leaflet-interactive,.leaflet-pane>svg path.leaflet-interactive{pointer-events:visiblePainted;pointer-events:auto}.leaflet-container{outline:0}.leaflet-container a{color:#0078A8}.leaflet-container a.leaflet-active{outline:orange solid 2px}.leaflet-zoom-box{border:2px dotted #38f;background:rgba(255,255,255,.5)}.leaflet-container{font:12px/1.5 \"Helvetica Neue\",Arial,Helvetica,sans-serif}.leaflet-bar{-webkit-box-shadow:0 1px 5px rgba(0,0,0,.65);box-shadow:0 1px 5px rgba(0,0,0,.65);border-radius:4px}.leaflet-bar a,.leaflet-bar a:hover{background-color:#fff;border-bottom:1px solid #ccc;width:26px;height:26px;line-height:26px;display:block;text-align:center;text-decoration:none;color:#000}.leaflet-bar a,.leaflet-control-layers-toggle{background-position:50% 50%;background-repeat:no-repeat;display:block}.leaflet-bar a:hover{background-color:#f4f4f4}.leaflet-bar a:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.leaflet-bar a:last-child{border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-bottom:none}.leaflet-bar a.leaflet-disabled{cursor:default;background-color:#f4f4f4;color:#bbb}.leaflet-touch .leaflet-bar a{width:30px;height:30px;line-height:30px}.leaflet-control-zoom-in,.leaflet-control-zoom-out{font:700 18px 'Lucida Console',Monaco,monospace;text-indent:1px}.leaflet-control-zoom-out{font-size:20px}.leaflet-touch .leaflet-control-zoom-in{font-size:22px}.leaflet-touch .leaflet-control-zoom-out{font-size:24px}.leaflet-control-layers{-webkit-box-shadow:0 1px 5px rgba(0,0,0,.4);box-shadow:0 1px 5px rgba(0,0,0,.4);background:#fff;border-radius:5px}.leaflet-control-layers-toggle{background-image:url(dist/css/images/layers.png);width:36px;height:36px}.leaflet-retina .leaflet-control-layers-toggle{background-image:url(dist/css/images/layers-2x.png);background-size:26px 26px}.leaflet-touch .leaflet-control-layers-toggle{width:44px;height:44px}.leaflet-control-layers .leaflet-control-layers-list,.leaflet-control-layers-expanded .leaflet-control-layers-toggle{display:none}.leaflet-control-layers-expanded .leaflet-control-layers-list{display:block;position:relative}.leaflet-control-layers-expanded{padding:6px 10px 6px 6px;color:#333;background:#fff}.leaflet-control-layers-scrollbar{overflow-y:scroll;padding-right:5px}.leaflet-control-layers-selector{margin-top:2px;position:relative;top:1px}.leaflet-control-layers label{display:block}.leaflet-control-layers-separator{height:0;border-top:1px solid #ddd;margin:5px -10px 5px -6px}.leaflet-default-icon-path{background-image:url(dist/css/images/marker-icon.png)}.leaflet-container .leaflet-control-attribution{background:#fff;background:rgba(255,255,255,.7);margin:0}.leaflet-control-attribution,.leaflet-control-scale-line{padding:0 5px;color:#333}.leaflet-control-attribution a{text-decoration:none}.leaflet-control-attribution a:hover{text-decoration:underline}.leaflet-container .leaflet-control-attribution,.leaflet-container .leaflet-control-scale{font-size:11px}.leaflet-left .leaflet-control-scale{margin-left:5px}.leaflet-bottom .leaflet-control-scale{margin-bottom:5px}.leaflet-control-scale-line{border:2px solid #777;border-top:none;line-height:1.1;padding:2px 5px 1px;font-size:11px;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;background:#fff;background:rgba(255,255,255,.5)}.leaflet-control-scale-line:not(:first-child){border-top:2px solid #777;border-bottom:none;margin-top:-2px}.leaflet-control-scale-line:not(:first-child):not(:last-child){border-bottom:2px solid #777}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-attribution,.leaflet-touch .leaflet-control-layers{-webkit-box-shadow:none;box-shadow:none}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-layers{border:2px solid rgba(0,0,0,.2);background-clip:padding-box}.leaflet-popup{position:absolute;text-align:center}.leaflet-popup-content-wrapper{text-align:left}.leaflet-popup-tip-container{width:40px;position:absolute;left:50%;margin-left:-20px;overflow:hidden;pointer-events:none}.leaflet-popup-tip{width:17px;height:17px;padding:1px;margin:-10px auto 0;-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg)}.leaflet-popup-content-wrapper,.leaflet-popup-tip{background:#fff;color:#333;-webkit-box-shadow:0 3px 14px rgba(0,0,0,.4);box-shadow:0 3px 14px rgba(0,0,0,.4)}.leaflet-container a.leaflet-popup-close-button{border:none;font:16px/14px Tahoma,Verdana,sans-serif;color:#c3c3c3;text-decoration:none;background:0 0}.leaflet-container a.leaflet-popup-close-button:hover{color:#999}.leaflet-oldie .leaflet-popup-content-wrapper{zoom:1}.leaflet-oldie .leaflet-popup-tip{width:24px;margin:0 auto;-ms-filter:\"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\";filter:progid:DXImageTransform.Microsoft.Matrix(M11=.70710678, M12=.70710678, M21=-.70710678, M22=.70710678)}.leaflet-oldie .leaflet-popup-tip-container{margin-top:-1px}.leaflet-oldie .leaflet-control-layers,.leaflet-oldie .leaflet-control-zoom,.leaflet-oldie .leaflet-popup-content-wrapper,.leaflet-oldie .leaflet-popup-tip{border:1px solid #999}.leaflet-div-icon{background:#fff;border:1px solid #666}.leaflet-tooltip{position:absolute;padding:6px;background-color:#fff;border:1px solid #fff;border-radius:3px;color:#222;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.4);box-shadow:0 1px 3px rgba(0,0,0,.4)}.leaflet-tooltip.leaflet-clickable{cursor:pointer;pointer-events:auto}.leaflet-tooltip-bottom:before,.leaflet-tooltip-left:before,.leaflet-tooltip-right:before,.leaflet-tooltip-top:before{position:absolute;pointer-events:none;border:6px solid transparent;background:0 0;content:\"\"}.leaflet-tooltip-bottom{margin-top:6px}.leaflet-tooltip-top{margin-top:-6px}.leaflet-tooltip-bottom:before,.leaflet-tooltip-top:before{left:50%;margin-left:-6px}.leaflet-tooltip-top:before{bottom:0;margin-bottom:-12px;border-top-color:#fff}.leaflet-tooltip-bottom:before{top:0;margin-top:-12px;margin-left:-6px;border-bottom-color:#fff}.leaflet-tooltip-left{margin-left:-6px}.leaflet-tooltip-right{margin-left:6px}.leaflet-tooltip-left:before,.leaflet-tooltip-right:before{top:50%;margin-top:-6px}.leaflet-tooltip-left:before{right:0;margin-right:-12px;border-left-color:#fff}.leaflet-tooltip-right:before{left:0;margin-left:-12px;border-right-color:#fff}[class^=dg-],[class^=dg-]:after,[class^=dg-]:before{-webkit-box-sizing:content-box;box-sizing:content-box;margin:0;padding:0;vertical-align:baseline;font-weight:inherit;font-style:inherit;font-size:1em;font-family:inherit;line-height:1.2}[class^=dg-]>[class^=dg-]:last-child{margin-bottom:0}[class^=dg-] abbr,[class^=dg-] fieldset,[class^=dg-] img{border:0}[class^=dg-] blockquote,[class^=dg-] q{quotes:none}[class^=dg-] blockquote:after,[class^=dg-] blockquote:before,[class^=dg-] q:after,[class^=dg-] q:before{content:'';content:none}[class^=dg-] ol,[class^=dg-] ul{list-style:none}[class^=dg-] table{border-spacing:0;border-collapse:collapse}[class^=dg-] caption,[class^=dg-] th{text-align:left}[class^=dg-] td,[class^=dg-] th{vertical-align:middle}[class^=dg-] button::-moz-focus-inner,[class^=dg-] input::-moz-focus-inner{padding:0;border:0}.dg-label{position:absolute;top:0;left:0;max-width:none;max-height:none;width:300px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.dg-label__content{display:inline-block;overflow:hidden;padding:3px 7px;min-width:30px;max-width:300px;width:auto;border-width:1px;border-style:solid;border-radius:2px;vertical-align:top;font-size:12px}.leaflet-top .dg-label_name_location-error{top:5px}.leaflet-right .dg-label_name_location-error{right:40px;left:auto;text-align:right}.leaflet-bottom .dg-label_name_location-error{top:4px}.leaflet-left .dg-label_name_location-error{left:40px}.dg-label__content{border-color:#323232;border-color:rgba(50,50,50,.85);background:#323232;background:rgba(50,50,50,.85);color:#ffd26e}.leaflet-popup{margin-bottom:0}.leaflet-popup-tip-container{height:0}.leaflet-popup-content-wrapper{overflow:hidden;padding:0;min-width:60px;min-height:50px;border:0;border-radius:3px;background:0 0;-webkit-box-shadow:none;box-shadow:none;color:#e6e6e6;font-size:14px;-webkit-transition:opacity ease-out .2s,max-height ease-out .2s,height ease-out .2s;transition:opacity ease-out .2s,max-height ease-out .2s,height ease-out .2s;-webkit-transform-origin:50% 100%;-ms-transform-origin:50% 100%;transform-origin:50% 100%}.leaflet-popup-content-wrapper:before{float:right;width:30px;height:17px;content:''}.leaflet-popup-content{position:relative;margin:16px;width:auto;line-height:1.4}.leaflet-popup a{outline:0}.leaflet-popup-content p{margin:0}.leaflet-popup-scrolled{overflow:visible;border:0}.leaflet-popup-inner{position:relative;z-index:0}.leaflet-popup_show_true{-webkit-transition:opacity ease-in-out .2s,height ease-out .2s,-webkit-transform ease-in-out .2s;transition:opacity ease-in-out .2s,height ease-out .2s,-webkit-transform ease-in-out .2s;transition:transform ease-in-out .2s,opacity ease-in-out .2s,height ease-out .2s;transition:transform ease-in-out .2s,opacity ease-in-out .2s,height ease-out .2s,-webkit-transform ease-in-out .2s;-webkit-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}.leaflet-popup_show_false{opacity:0!important;-webkit-transition:all ease-in-out .1s;transition:all ease-in-out .1s;-webkit-transform:scale(0.2);-ms-transform:scale(0.2);transform:scale(0.2)}.leaflet-popup_preloader_true{width:384px;height:52px}.leaflet-map-pane .leaflet-popup-tip-container{position:absolute;top:auto;bottom:0;left:50%;margin-left:-29px;width:58px;height:47px;background-repeat:no-repeat;-webkit-transform:translateY(47px);-ms-transform:translateY(47px);transform:translateY(47px);pointer-events:none}.leaflet-popup-tip{display:none}.leaflet-popup-tip-container_svg{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGPopup__popupShadow.png);background-position:50% 95%;background-size:36px 12px}.leaflet-retina .leaflet-popup-tip-container_svg{background-image:url(https://maps.api.2gis.ru/2.0/img/DGPopup__popupShadow@2x.png)}.leaflet-container a.leaflet-popup-close-button{position:absolute;top:3px;right:3px;z-index:1;overflow:hidden;padding:0;width:30px;height:30px;text-align:center;font-weight:400;font-size:18px;line-height:30px;cursor:pointer}.no-touch .leaflet-container a.leaflet-popup-close-button:hover{border-radius:2px;-webkit-transition:all .2s;transition:all .2s}.leaflet-container a.leaflet-popup-close-button:active{color:#777}.leaflet-container a.leaflet-popup-close-button:after{position:absolute;z-index:2;content:''}.leaflet-popup-content-wrapper{background-color:rgba(50,50,50,.9)}.leaflet-popup-tip-container_image{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2258%22%20height%3D%2247%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M0%200c12.643%200%2028%207.115%2028%2044h2c0-36.885%2015.358-44%2028-44h-58z%22%20fill%3D%22rgba(50%2C50%2C50%2C.9)%22%3E%3C%2Fpath%3E%0A%3C%2Fsvg%3E%0A\")}.leaflet-map-pane .leaflet-popup-tip-container_svg{fill:rgba(50,50,50,.9)}.no-touch .leaflet-container a.leaflet-popup-close-button:hover{background-color:#222;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.5);box-shadow:0 1px 3px rgba(0,0,0,.5)}.leaflet-container a.leaflet-popup-close-button:after{top:-3px;right:-5px;width:40px;height:40px}.dg-wrapper{position:relative;overflow:hidden}.dg-scroller{height:100%;overflow-y:scroll;border:0}.dg-scroller__bar{z-index:1;right:0;background:#999}.dg-scroller__bar_h{bottom:2px;height:8px}.dg-header__title{width:100%;margin:0;-webkit-box-sizing:border-box;box-sizing:border-box;background:#999}.dg-header__title_state_fixed{position:absolute;z-index:1}.dg-scroller_hidden_true{overflow:auto}.dg-scroller::-webkit-scrollbar{width:0}.dg-scroller__wrapper{position:relative;overflow:hidden}.dg-scroller__bar-wrapper{position:absolute;top:18px;right:3px;bottom:4px;width:7px;border-radius:5px}.dg-scroller_hidden_true .dg-scroller__bar-wrapper{visibility:hidden}.dg-popup__header+.dg-popup__container-wrapper .dg-scroller__bar-wrapper{top:4px}.dg-scroller__bar{position:absolute;min-height:20px;width:7px;border-radius:3px;pointer-events:auto}.scroller__bar-wrapper .scroller__bar{background-color:#665b4f}.scroller__bar-wrapper:hover .scroller__bar{background-color:#897a6b}.dg-popup__container{margin:0}.leaflet-popup-scrolled .dg-popup__container{padding:8px 14px 8px 0}.dg-popup__header{position:relative;padding-bottom:12px}.leaflet-popup-scrolled .dg-popup__header:after{position:relative;top:12px;display:block;width:100%;height:1px;content:''}.dg-popup__footer{position:relative;bottom:0;overflow:hidden}.leaflet-popup-scrolled .dg-popup__footer:before{display:block;width:100%;height:1px;content:''}.dg-popup_hidden_true{display:none}.leaflet-popup-scrolled .dg-popup__footer:before,.leaflet-popup-scrolled .dg-popup__header:after{border-bottom:1px solid #636363;background-color:#494949}.dg-control-round{position:relative;padding:5px;width:30px;height:30px;border-radius:50%;cursor:default}.dg-control-round__icon{position:relative;display:block;width:30px;height:30px;border-radius:50%;background-color:#f0f0f0;background-image:-webkit-gradient(linear,left top,left bottom,color-stop(0,#fff),to(#e0e0e0));background-image:-webkit-linear-gradient(top,#fff 0,#e0e0e0 100%);background-image:linear-gradient(to bottom,#fff 0,#e0e0e0 100%);color:#2b2a29;text-align:center;text-decoration:none;text-shadow:0 1px 0 #fff;font-size:22px;line-height:30px;cursor:pointer}.no-touch .dg-control-round__icon:hover{background-color:#f5f5f5;background-image:-webkit-gradient(linear,left top,left bottom,color-stop(0,#ebebeb),to(#fff));background-image:-webkit-linear-gradient(top,#ebebeb 0,#fff 100%);background-image:linear-gradient(to bottom,#ebebeb 0,#fff 100%)}.dg-control-round__icon:active,.dg-control-round__icon_state_active,.no-touch .dg-control-round__icon:active{background-color:#ebebeb;background-image:-webkit-gradient(linear,left top,left bottom,color-stop(0,#d6d6d6),to(#fff));background-image:-webkit-linear-gradient(top,#d6d6d6 0,#fff 100%);background-image:linear-gradient(to bottom,#d6d6d6 0,#fff 100%)}.leaflet-disabled .dg-control-round__icon,.leaflet-disabled .dg-control-round__icon:active,.no-touch .leaflet-disabled .dg-control-round__icon:hover{background-image:none;cursor:default}.leaflet-touch .dg-control-round__icon:before{position:absolute;top:-10px;right:-15px;bottom:-10px;left:-15px;content:''}.dg-control-round_is-hidden_true{display:none}.dg-control-round{background-color:#3d3d3d;-webkit-box-shadow:0 3px 5px 0 rgba(0,0,0,.3);box-shadow:0 3px 5px 0 rgba(0,0,0,.3)}.dg-control-round__icon{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,.4);box-shadow:0 2px 2px 0 rgba(0,0,0,.4)}.no-touch .dg-control-round__icon:hover{-webkit-box-shadow:inset 0 1px #fff,0 0 0 1px rgba(0,0,0,.3),0 1px 0 1px rgba(0,0,0,.4);box-shadow:inset 0 1px #fff,0 0 0 1px rgba(0,0,0,.3),0 1px 0 1px rgba(0,0,0,.4)}.dg-control-round__icon:active,.dg-control-round__icon_state_active,.no-touch .dg-control-round__icon:active{-webkit-box-shadow:inset 0 1px 1px 1px rgba(0,0,0,.2),0 0 0 1px rgba(0,0,0,.3),0 -1px 1px 0 #000;box-shadow:inset 0 1px 1px 1px rgba(0,0,0,.2),0 0 0 1px rgba(0,0,0,.3),0 -1px 1px 0 #000}.leaflet-disabled .dg-control-round__icon,.leaflet-disabled .dg-control-round__icon:active,.no-touch .leaflet-disabled .dg-control-round__icon:hover{background-color:#b8b8b8;-webkit-box-shadow:none;box-shadow:none}.leaflet-container{z-index:0;background:#f7f3df;cursor:default}.leaflet-container:-webkit-full-screen{width:100%!important;height:100%!important}.leaflet-container:-moz-full-screen{width:100%!important;height:100%!important}.leaflet-container:-ms-fullscreen{width:100%!important;height:100%!important}.leaflet-container:fullscreen{width:100%!important;height:100%!important}.leaflet-dragging,.leaflet-dragging .leaflet-clickable,.leaflet-dragging .leaflet-container{cursor:move}.leaflet-control a,.leaflet-control a:focus{outline:0!important}.leaflet-container .leaflet-control-attribution{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.dg-customization__marker{background-repeat:no-repeat}.dg-customization__marker:before{position:absolute;top:0;left:0;width:100%;height:100%;background-image:inherit;background-size:contain;background-repeat:no-repeat;-webkit-transition:opacity ease-in-out .2s,-webkit-transform ease-in-out .2s;transition:opacity ease-in-out .2s,-webkit-transform ease-in-out .2s;transition:opacity ease-in-out .2s,transform ease-in-out .2s;transition:opacity ease-in-out .2s,transform ease-in-out .2s,-webkit-transform ease-in-out .2s;-webkit-transform:scale(1,1);-ms-transform:scale(1,1);transform:scale(1,1);-webkit-transform-origin:50% 100%;-ms-transform-origin:50% 100%;transform-origin:50% 100%}.dg-customization__marker_type_mushroom{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__marker.png);background-size:22px 34px;width:22px;height:34px;-webkit-transform-origin:50% 100%;-ms-transform-origin:50% 100%;transform-origin:50% 100%;-webkit-animation:dg-customization__show-marker .2s;animation:dg-customization__show-marker .2s}.leaflet-retina .dg-customization__marker_type_mushroom{background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__marker@2x.png)}.dg-customization__marker_type_mushroom:focus{outline:0}.no-touch .dg-customization__marker_type_mushroom:hover{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerHover.png);background-size:22px 34px}.leaflet-retina .no-touch .dg-customization__marker_type_mushroom:hover{background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerHover@2x.png)}.dg-customization__marker_type_mushroom:active,.no-touch .dg-customization__marker_type_mushroom:active{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerActive.png);background-size:22px 34px}.leaflet-retina .dg-customization__marker_type_mushroom:active,.leaflet-retina .no-touch .dg-customization__marker_type_mushroom:active{background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerActive@2x.png)}@-webkit-keyframes dg-customization__show-marker{from{opacity:0}to{opacity:1}}@keyframes dg-customization__show-marker{from{opacity:0}to{opacity:1}}.dg-customization__marker_appear{background-position:999px}.dg-customization__marker_appear:before{content:''}.dg-customization__marker_disappear{background-position:999px;pointer-events:none}.dg-customization__marker_disappear:before{visibility:hidden;content:'';opacity:0;-webkit-transform:scale(1.2,1.8);-ms-transform:scale(1.2,1.8);transform:scale(1.2,1.8);-webkit-animation:dg-customization__marker-to-callout .2s;animation:dg-customization__marker-to-callout .2s}@-webkit-keyframes dg-customization__marker-to-callout{0%{visibility:visible;opacity:1;-webkit-transform:scale(1,1);transform:scale(1,1)}100%{visibility:visible;opacity:0;-webkit-transform:scale(1.2,1.8);transform:scale(1.2,1.8)}}@keyframes dg-customization__marker-to-callout{0%{visibility:visible;opacity:1;-webkit-transform:scale(1,1);transform:scale(1,1)}100%{visibility:visible;opacity:0;-webkit-transform:scale(1.2,1.8);transform:scale(1.2,1.8)}}.dg-dragging-false{touch-action:auto;-ms-touch-action:auto}.leaflet-image-layer,.leaflet-tile-container{pointer-events:auto}.dg-zoom{width:40px;height:74px}.dg-zoom__in{position:absolute;top:0;left:0}.leaflet-touch .dg-zoom__in:before{position:absolute;top:-5px;right:-10px;bottom:0;left:-10px;content:''}.dg-zoom__in:after{position:absolute;right:0;bottom:-1px;left:0;z-index:-1;margin:auto;width:12px;height:2px;-webkit-box-shadow:0 0 3px 2px rgba(0,0,0,.3);box-shadow:0 0 3px 2px rgba(0,0,0,.3);content:''}.dg-zoom__button_type_in:after,.dg-zoom__button_type_in:before,.leaflet-touch .dg-zoom__button_type_in:before{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;width:14px;height:2px;background-color:#7a7a7a;-webkit-box-shadow:0 1px #fff;box-shadow:0 1px #fff;content:''}.dg-zoom__button_type_in:after{width:2px;height:14px}.no-touch .dg-zoom__button_type_in:hover:after,.no-touch .dg-zoom__button_type_in:hover:before{background-color:#616161}.dg-zoom__button_type_in:active:after,.dg-zoom__button_type_in:active:before,.no-touch .dg-zoom__button_type_in:active:after,.no-touch .dg-zoom__button_type_in:active:before{background-color:#575757}.leaflet-disabled .dg-zoom__button_type_in:active:after,.leaflet-disabled .dg-zoom__button_type_in:active:before,.leaflet-disabled .dg-zoom__button_type_in:after,.leaflet-disabled .dg-zoom__button_type_in:before,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:after,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:before{-webkit-box-shadow:none;box-shadow:none}.dg-zoom__out{position:absolute;top:40px;right:0;left:0;margin:auto;width:22px;height:22px}.dg-zoom__out:after{position:absolute;top:-1px;right:0;left:0;margin:auto;width:12px;height:2px;content:''}.dg-zoom__button_type_out{width:22px;height:22px}.leaflet-touch .dg-zoom__button_type_out:before{top:-5px;right:-19px;bottom:-19px;left:-19px}.dg-zoom__button_type_out:after{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;width:10px;height:2px;background:#7a7a7a;-webkit-box-shadow:0 1px #fff;box-shadow:0 1px #fff;content:''}.no-touch .dg-zoom__button_type_out:hover:after{background:#616161}.dg-zoom__button_type_out:active:after,.no-touch .dg-zoom__button_type_out:active:after{background:#575757}.leaflet-disabled .dg-zoom__button_type_out:active:after,.leaflet-disabled .dg-zoom__button_type_out:after,.no-touch .leaflet-disabled .dg-zoom__button_type_out:hover:after{-webkit-box-shadow:none;box-shadow:none}.dg-zoom__out{-webkit-box-shadow:0 2px 3px 0 rgba(0,0,0,.3);box-shadow:0 2px 3px 0 rgba(0,0,0,.3)}.dg-zoom__out:after{background-color:#3d3d3d}.leaflet-disabled .dg-zoom__button_type_in:active:after,.leaflet-disabled .dg-zoom__button_type_in:active:before,.leaflet-disabled .dg-zoom__button_type_in:after,.leaflet-disabled .dg-zoom__button_type_in:before,.leaflet-disabled .dg-zoom__button_type_out:active:after,.leaflet-disabled .dg-zoom__button_type_out:after,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:after,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:before,.no-touch .leaflet-disabled .dg-zoom__button_type_out:hover:after{background-color:#707070}.dg-attribution{background-color:transparent!important}.dg-attribution__copyright{margin:0 55px 5px 0;text-align:right;white-space:nowrap;font-size:9px;font-family:Helvetica,Arial,sans-serif}.dg-attribution__links{display:inline-block;margin:0;padding:0 5px 0 0}.dg-attribution__link-item{padding:0;list-style-type:none}.leaflet-container .dg-attribution__link{background:-webkit-gradient(linear,left top,right top,from(rgba(8,8,8,.3)),to(rgba(8,8,8,.3))) 0 95%/10px 1px repeat-x;background:-webkit-linear-gradient(left,rgba(8,8,8,.3),rgba(8,8,8,.3) 100%) 0 95%/10px 1px repeat-x;background:linear-gradient(to right,rgba(8,8,8,.3),rgba(8,8,8,.3) 100%) 0 95%/10px 1px repeat-x;color:#333;text-decoration:none;font-size:9px;font-family:Helvetica,Arial,sans-serif;cursor:pointer}.leaflet-container .dg-attribution__link:hover{background-image:-webkit-gradient(linear,left top,right top,from(#080808),to(#080808));background-image:-webkit-linear-gradient(left,#080808,#080808 100%);background-image:linear-gradient(to right,#080808,#080808 100%);color:#333;text-decoration:none}.dg-attribution__logo-url{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%2224%22%20width%3D%2255%22%3E%0A%20%3Cpath%20fill%3D%22%23a2c124%22%20d%3D%22m24.395%2012c0-1.4545-0.22177-2.6545-0.66532-4-0.14785%204.2545-4.879%207.8182-7.4664%2010h6.7641c0.70229-2%201.3676-3.9273%201.3676-6m-4.731-9.3455c-2.033-1.6-4.62-2.6545-7.466-2.6545-6.7276%200-12.198%205.4182-12.198%2012s5.4704%2012%2012.198%2012c3.1048%200%205.9509-1.4545%208.1317-3.3455h-8.797v-2.6545c5.3595-4.5455%208.797-7.3455%208.797-10%200-1.1273-0.81317-2.6545-2.6983-2.6545-1.4785%200-2.6983%201.3455-2.6983%204.6545h-3.4005c-0.73925-4.2182%201.8481-7.6727%206.2466-7.6727%200.66532%200%201.2567%200.21818%201.8851%200.32727%22%2F%3E%0A%20%3Cpath%20fill%3D%22%233c4347%22%20d%3D%22m36.593%209.3455h1.3676c0-2-0.66532-5.1273-4.7312-5.2727-4.732-0.2183-6.1%202.6181-6.1%205.9272v5.3455c0%204.4%203.4375%205.3455%206.0988%205.3455%201.5524%200%203.4005-0.87273%204.7312-2v-6.6909h-5.4335v2.6545h2.6983v2.6545c-1.3676%201.3455-5.4335%201.3455-5.4335-2.6545v-5.3091c0-4%205.9509-4.1455%205.6183%200h1.1828zm18.296%206.6545c0-5.8182-6.9859-4.0727-6.9859-7.6%200-1.2%200.81317-2%202.1808-2%201.4415%200%202.2547%201.0182%202.2547%202.9818h2.5874c0-2-0.66532-5.3455-4.7312-5.3455-2.7722%200-4.879%201.4182-4.879%204.3273%200%206.0727%207.1707%204.0727%207.0598%207.6727-0.07392%201.4545-1.1458%202.0727-2.3656%202.0727-1.4415%200-2.6983-0.72727-2.4395-3.3818h-2.6613c-0.25874%203.3455%201.4415%206%205.3595%206%202.699%200%204.732-2.145%204.732-5.345l-0.111%200.618zm-12.198%204h-2.6983v-16h2.6983v16z%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:55px;height:24px;background-size:55px 24px;position:absolute;margin:0 3px 0 0}.dg-location__pin{background-repeat:no-repeat;width:20px;height:20px;background-image:url(https://maps.api.2gis.ru/2.0/img/sprite.basic.png);background-position:-55px 0;background-size:87px 74px}.leaflet-retina .dg-location__pin{background-image:url(https://maps.api.2gis.ru/2.0/img/sprite@2x.basic.png);background-position:-55px 0;background-size:91px 71.5px}.dg-location__pin_state_following{background-repeat:no-repeat;width:20px;height:20px;background-image:url(https://maps.api.2gis.ru/2.0/img/sprite.basic.png);background-position:-22px -24px;background-size:87px 74px}.leaflet-retina .dg-location__pin_state_following{background-image:url(https://maps.api.2gis.ru/2.0/img/sprite@2x.basic.png);background-position:-21px -24px;background-size:91px 71.5px}.dg-control-round__icon_name_locate:after{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_state_active.dg-control-round__icon_name_locate:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_locate:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_locate:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2218%22%20height%3D%2218%22%3E%0A%20%20%20%20%3Cg%20fill%3D%22%2323a5d4%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.553%200.447%2C10%201%2C10%20H%202.08%20C%202.52%2C13.063%204.936%2C15.48%208%2C15.92%20V%2017%20c%200%2C0.553%200.447%2C1%201%2C1%200.553%2C0%201%2C-0.447%201%2C-1%20V%2015.92%20C%2013.064%2C15.481%2015.48%2C13.064%2015.92%2C10%20H%2017%20C%2017.553%2C10%2018%2C9.553%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20z%20M%209%2C14%20C%206.24%2C14%204%2C11.762%204%2C9%204%2C6.238%206.24%2C4%209%2C4%20c%202.761%2C0%205%2C2.238%205%2C5%200%2C2.762%20-2.239%2C5%20-5%2C5%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Ccircle%20cx%3D%229%22%20cy%3D%229%22%20r%3D%223%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2014%2C10.004%20C%2014%2C9.834%2013.991%2C9.667%2013.975%2C9.502%2013.723%2C12.027%2011.592%2C14%209%2C14%206.408%2C14%204.277%2C12.027%204.025%2C9.502%204.009%2C9.667%204%2C9.834%204%2C10.004%20c%200%2C2.762%202.24%2C5%205%2C5%202.761%2C0%205%2C-2.238%205%2C-5%20z%20M%2010%2C3.083%20c%203.064%2C0.439%205.48%2C2.856%205.92%2C5.921%20H%2017%20c%200.369%2C0%200.688%2C0.201%200.86%2C0.498%20C%2017.947%2C9.354%2018%2C9.184%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%203.083%20z%20M%201%2C9.004%20H%202.08%20C%202.52%2C5.939%204.936%2C3.522%208%2C3.083%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.184%200.053%2C9.354%200.14%2C9.502%200.312%2C9.205%200.631%2C9.004%201%2C9.004%20z%20m%208%2C-8%20c%200.553%2C0%201%2C0.447%201%2C1%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20v%201.004%20c%200%2C-0.553%200.447%2C-1%201%2C-1%20z%22%20fill%3D%22%232685aa%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%209%2C7%20c%201.486%2C0%202.717%2C1.082%202.955%2C2.5%20C%2011.982%2C9.337%2012%2C9.171%2012%2C9%2012%2C7.344%2010.656%2C6%209%2C6%207.344%2C6%206%2C7.344%206%2C9%206%2C9.171%206.018%2C9.337%206.045%2C9.5%206.283%2C8.082%207.514%2C7%209%2C7%20z%22%20fill%3D%22%231c85ab%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}@-webkit-keyframes DGLocation__locateIconRequestingAnim{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes DGLocation__locateIconRequestingAnim{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.dg-control-round__icon_name_locate:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2218%22%20height%3D%2218%22%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23616161%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.553%200.447%2C10%201%2C10%20H%202.08%20C%202.52%2C13.063%204.936%2C15.48%208%2C15.92%20V%2017%20c%200%2C0.553%200.447%2C1%201%2C1%200.553%2C0%201%2C-0.447%201%2C-1%20V%2015.92%20C%2013.064%2C15.481%2015.48%2C13.064%2015.92%2C10%20H%2017%20C%2017.553%2C10%2018%2C9.553%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20z%20M%209%2C14%20C%206.24%2C14%204%2C11.762%204%2C9%204%2C6.238%206.24%2C4%209%2C4%20c%202.761%2C0%205%2C2.238%205%2C5%200%2C2.762%20-2.239%2C5%20-5%2C5%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Ccircle%20cx%3D%229%22%20cy%3D%229%22%20r%3D%223%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23444%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2014%2C10.004%20C%2014%2C9.834%2013.991%2C9.667%2013.975%2C9.502%2013.723%2C12.027%2011.592%2C14%209%2C14%206.408%2C14%204.277%2C12.027%204.025%2C9.502%204.009%2C9.667%204%2C9.834%204%2C10.004%20c%200%2C2.762%202.24%2C5%205%2C5%202.761%2C0%205%2C-2.238%205%2C-5%20z%20M%2010%2C3.083%20c%203.064%2C0.439%205.48%2C2.856%205.92%2C5.921%20H%2017%20c%200.369%2C0%200.688%2C0.201%200.86%2C0.498%20C%2017.947%2C9.354%2018%2C9.184%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%203.083%20z%20M%201%2C9.004%20H%202.08%20C%202.52%2C5.939%204.936%2C3.522%208%2C3.083%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.184%200.053%2C9.354%200.14%2C9.502%200.312%2C9.205%200.631%2C9.004%201%2C9.004%20z%20m%208%2C-8%20c%200.553%2C0%201%2C0.447%201%2C1%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20v%201.004%20c%200%2C-0.553%200.447%2C-1%201%2C-1%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%209%2C7%20c%201.486%2C0%202.717%2C1.082%202.955%2C2.5%20C%2011.982%2C9.337%2012%2C9.171%2012%2C9%2012%2C7.344%2010.656%2C6%209%2C6%207.344%2C6%206%2C7.344%206%2C9%206%2C9.171%206.018%2C9.337%206.045%2C9.5%206.283%2C8.082%207.514%2C7%209%2C7%20z%22%20fill%3D%22%23444%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:18px;height:18px;background-size:18px 18px}.dg-control-round__icon_name_locate:active:after,.no-touch .dg-control-round__icon_name_locate:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2218%22%20height%3D%2218%22%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23424242%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.553%200.447%2C10%201%2C10%20H%202.08%20C%202.52%2C13.063%204.936%2C15.48%208%2C15.92%20V%2017%20c%200%2C0.553%200.447%2C1%201%2C1%200.553%2C0%201%2C-0.447%201%2C-1%20V%2015.92%20C%2013.064%2C15.481%2015.48%2C13.064%2015.92%2C10%20H%2017%20C%2017.553%2C10%2018%2C9.553%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20z%20M%209%2C14%20C%206.24%2C14%204%2C11.762%204%2C9%204%2C6.238%206.24%2C4%209%2C4%20c%202.761%2C0%205%2C2.238%205%2C5%200%2C2.762%20-2.239%2C5%20-5%2C5%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Ccircle%20cx%3D%229%22%20cy%3D%229%22%20r%3D%223%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%232e2e2e%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2014%2C10.004%20C%2014%2C9.834%2013.991%2C9.667%2013.975%2C9.502%2013.723%2C12.027%2011.592%2C14%209%2C14%206.408%2C14%204.277%2C12.027%204.025%2C9.502%204.009%2C9.667%204%2C9.834%204%2C10.004%20c%200%2C2.762%202.24%2C5%205%2C5%202.761%2C0%205%2C-2.238%205%2C-5%20z%20M%2010%2C3.083%20c%203.064%2C0.439%205.48%2C2.856%205.92%2C5.921%20H%2017%20c%200.369%2C0%200.688%2C0.201%200.86%2C0.498%20C%2017.947%2C9.354%2018%2C9.184%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%203.083%20z%20M%201%2C9.004%20H%202.08%20C%202.52%2C5.939%204.936%2C3.522%208%2C3.083%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.184%200.053%2C9.354%200.14%2C9.502%200.312%2C9.205%200.631%2C9.004%201%2C9.004%20z%20m%208%2C-8%20c%200.553%2C0%201%2C0.447%201%2C1%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20v%201.004%20c%200%2C-0.553%200.447%2C-1%201%2C-1%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%209%2C7%20c%201.486%2C0%202.717%2C1.082%202.955%2C2.5%20C%2011.982%2C9.337%2012%2C9.171%2012%2C9%2012%2C7.344%2010.656%2C6%209%2C6%207.344%2C6%206%2C7.344%206%2C9%206%2C9.171%206.018%2C9.337%206.045%2C9.5%206.283%2C8.082%207.514%2C7%209%2C7%20z%22%20fill%3D%22%232e2e2e%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:active:after,.dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:after,.no-touch .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:hover:after{background-repeat:no-repeat;width:24px;height:24px;background-image:url(https://maps.api.2gis.ru/2.0/img/sprite.dark.png);background-position:0 0;background-size:78px 65px;-webkit-animation:DGLocation__locateIconRequestingAnim 1s linear infinite;animation:DGLocation__locateIconRequestingAnim 1s linear infinite;image-rendering:optimizeQuality}.leaflet-retina .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:active:after,.leaflet-retina .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:after,.leaflet-retina .no-touch .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:hover:after{background-image:url(https://maps.api.2gis.ru/2.0/img/sprite@2x.dark.png);background-position:0 0;background-size:78px 65px}.dg-control-round__icon_name_fullscreen:after{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_state_active.dg-control-round__icon_name_fullscreen:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_fullscreen:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_fullscreen:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C1%20H%201%20V%206%20H%203%20V%203%20h%203%20z%20m%204%2C14%20h%205%20v%20-5%20h%20-2%20v%203%20H%2010%20z%20M%2015%2C6%20V%201%20h%20-5%20v%202%20h%203%20V%206%20z%20M%201%2C10%20v%205%20H%206%20V%2013%20H%203%20v%20-3%20z%22%20fill%3D%22%230da4d4%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C1%20H%206%20V%202%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%20m%203%2C9%20h%202%20v%201%20h%20-2%20z%20m%20-3%2C3%20h%203%20v%201%20h%20-3%20z%20m%20-7%2C0%20h%203%20v%201%20H%203%20z%20M%201%2C10%20h%202%20v%201%20H%201%20z%22%20fill%3D%22%230a84ab%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C6%20H%203%20V%207%20H%201%20z%20m%2012%2C0%20h%202%20V%207%20H%2013%20z%20M%201%2C15%20h%205%20v%201%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_name_fullscreen:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C3%20H%206%20V%204%20H%201%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C1%20H%201%20V%206%20H%203%20V%203%20h%203%20z%20m%204%2C14%20h%205%20v%20-5%20h%20-2%20v%203%20h%20-3%20z%22%20fill%3D%22%236c6c6c%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2010%2C3%20h%205%20v%201%20h%20-5%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2015%2C6%20V%201%20h%20-5%20v%202%20h%203%20V%206%20z%20M%201%2C10%20v%205%20H%206%20V%2013%20H%203%20v%20-3%20z%22%20fill%3D%22%236c6c6c%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C1%20H%206%20V%202%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%20m%203%2C9%20h%202%20v%201%20h%20-2%20z%20m%20-3%2C3%20h%203%20v%201%20h%20-3%20z%20m%20-7%2C0%20h%203%20v%201%20H%203%20z%20M%201%2C10%20h%202%20v%201%20H%201%20z%22%20fill%3D%22%234b4b4b%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C6%20H%203%20V%207%20H%201%20z%20m%2012%2C0%20h%202%20V%207%20H%2013%20z%20M%201%2C15%20h%205%20v%201%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:16px;height:16px;background-size:16px 16px}.dg-control-round__icon_name_fullscreen:active:after,.no-touch .dg-control-round__icon_name_fullscreen:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012%2C9%20h%204%20v%207%20h%20-4%20z%20m%20-3%2C3%20h%205%20v%204%20H%209%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2010%2C15%20h%205%20v%20-5%20h%20-2%20v%203%20h%20-3%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%200%2C9%20h%204%20v%207%20H%200%20z%20m%202%2C3%20h%205%20v%204%20H%202%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%201%2C10%20v%205%20H%206%20V%2013%20H%203%20v%20-3%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%204%20V%207%20H%200%20z%20m%209%2C0%20h%205%20V%204%20H%209%20z%20m%203%2C0%20h%204%20v%207%20h%20-4%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2015%2C6%20V%201%20h%20-5%20v%202%20h%203%20v%203%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%202%2C0%20H%207%20V%204%20H%202%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C1%20H%201%20V%206%20H%203%20V%203%20h%203%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-building-callout__body{position:relative}.dg-building-callout__list{margin-bottom:8px;padding-left:24px;color:#ffe6aa;list-style:none}.dg-building-callout__list-item{position:relative;margin-bottom:4px;font-size:12px}.dg-building-callout__list-item:before{position:absolute;top:5px;left:-21px;content:'';background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%226%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%203%2C-0.002%20C%204.654%2C-0.002%205.994%2C1.342%205.994%2C3%205.994%2C4.658%204.655%2C6.002%203%2C6.002%201.345%2C6.002%200.005%2C4.658%200.005%2C3%200.005%2C1.342%201.346%2C-0.002%203%2C-0.002%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:6px;height:6px;background-size:6px 6px}.dg-map-geoclicker__address{margin-bottom:10px;font-size:16px}.dg-map-geoclicker__purpose+.dg-map-geoclicker__address{margin-top:-6px}.dg-map-geoclicker__address-header{position:relative;margin-bottom:4px;padding-left:24px}.dg-map-geoclicker__address-header:first-child:before{position:absolute;top:5px;left:1px;content:''}.dg-map-geoclicker__address-drilldown{position:relative;margin-bottom:4px;padding-left:24px;color:#aaa;font-size:12px}.dg-map-geoclicker__address-drilldown:first-child:before{position:absolute;top:2px;left:1px;content:''}.dg-map-geoclicker__purpose{position:relative;margin-bottom:10px;padding-left:24px;font-size:16px}.dg-map-geoclicker__address+.dg-map-geoclicker__purpose{margin-top:-6px}.dg-map-geoclicker__purpose:before{position:absolute;top:4px;left:2px;content:''}.dg-map-geoclicker__purpose_type_street:before{top:4px}.dg-map-geoclicker__sight-description{overflow:hidden;padding:.5em 0 0 24px;max-height:3.6em}a.dg-map-geoclicker__show-more-sights-link{position:relative;margin-left:24px;border-bottom:1px dotted;text-decoration:none}a.dg-map-geoclicker__show-more-sights-link:after{position:absolute;top:4px;margin-left:5px;width:6px;height:10px;content:'';font-weight:700}.dg-map-geoclicker__clamped-line{display:block;white-space:nowrap}.dg-map-geoclicker__clamped-line_last{overflow:hidden;width:100%;text-overflow:ellipsis}.dg-map-geoclicker__preloader-wrapper{display:table-cell;vertical-align:middle;text-align:center}.dg-map-geoclicker__drilldown{margin-bottom:10px}.dg-map-geoclicker__address-drilldown:first-child:before,.dg-map-geoclicker__address-header:first-child:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%204.958%2C11%20C%204.958%2C9.036%206.756%2C6.751%208.719%2C6.751%208.885%2C6.223%209%2C5.656%209%2C5.063%209%2C2.267%206.985%2C0%204.5%2C0%202.015%2C0%200%2C2.267%200%2C5.063%200%2C5.656%200.114%2C6.222%200.28%2C6.751%202.243%2C6.751%204.018%2C9.012%204.018%2C11%20h%200.94%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:9px;height:11px;background-size:9px 11px}.dg-map-geoclicker__purpose:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%228%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%203.582%2C8%20c%200.211%2C0%200.798%2C0.035%201%2C0%20v%204%20l%20-2%2C-1%20V%208%20c%200.372%2C0.066%200.861%2C0%201%2C0%20z%20M%200.44%2C5.384%20C%200.163%2C4.866%200%2C4.276%200%2C3.646%200%2C1.633%201.604%2C0.002%203.582%2C0.002%20c%201.978%2C0%203.582%2C1.631%203.582%2C3.644%200%2C0.647%20-0.169%2C1.254%20-0.461%2C1.781%20L%206.641%2C5.495%206.618%2C5.567%20C%205.954%2C6.549%204.844%2C7.192%203.584%2C7.192%202.25%2C7.192%201.084%2C6.467%200.44%2C5.384%20z%20M%202.613%2C1.276%20c%20-0.549%2C0%20-0.995%2C0.453%20-0.995%2C1.013%200%2C0.559%200.446%2C1.013%200.995%2C1.013%200.551%2C0%200.996%2C-0.454%200.996%2C-1.013%200%2C-0.56%20-0.445%2C-1.013%20-0.996%2C-1.013%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:8px;height:12px;background-size:8px 12px}.dg-map-geoclicker__purpose_type_street:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%208.8%2C0%20H%203.199%20L%200%2C12%20H%2012%20L%208.8%2C0%20z%20M%207%2C12%20H%205%20V%209%20h%202%20v%203%20z%20M%207%2C8%20H%205%20V%206%20H%207%20V%208%20z%20M%207%2C5%20H%205%20V%203%20H%207%20V%205%20z%20M%207%2C2%20H%205%20V%200%20h%202%20v%202%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:12px;background-size:12px 12px}.dg-map-geoclicker__purpose_type_sight:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%228%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%207%2C0%20H%202.547%20C%200.547%2C0%200%2C0.828%200%2C2.5%200%2C3.734%200.5%2C5%202%2C5%203.359%2C5%204%2C3.844%204%2C3%204%2C2.281%202.859%2C2%202%2C2%202%2C2.766%202.234%2C3%203%2C3%203%2C3.69%202.48%2C4%202%2C4%201.234%2C4%201%2C3.329%201%2C2.5%201%2C1.693%201.375%2C1%202.5%2C1%204.391%2C1%205%2C1.656%205%2C3%205%2C4.6%204.338%2C5.119%203%2C6%20v%204%20H%202%20v%202%20H%208%20V%201%20L%207%2C0%20z%20M%204%2C10%20V%206%20l%201%2C1%20v%203%20H%204%20z%20m%202%2C0%20V%206%20l%201%2C1%20v%203%20H%206%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:8px;height:12px;background-size:8px 12px}.dg-map-geoclicker__purpose_type_settlement:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%209%2C9%20C%208.235%2C9%207.762%2C9.522%207.259%2C10.022%207.795%2C10.38%208.051%2C11.05%207.879%2C12%20H%2012%20C%2012%2C10.46%2010.535%2C9%209%2C9%20z%20m%20-2.868%2C1.248%20c%20-0.965%2C0%20-1.747%2C0.784%20-1.747%2C1.751%20h%203.494%20c%200%2C-0.967%20-0.782%2C-1.751%20-1.747%2C-1.751%20z%20M%2010%2C1%20V%200%20H%207%20V%201%20H%205%20V%206%20L%206%2C7%20V%202%20H%207%20V%207%20L%208%2C8%20V%202%20h%201%20v%206%20h%201%20V%202%20h%201%20v%207%20l%201%2C0.607%20V%201%20H%2010%20z%20M%206.66%2C9.539%206.721%2C9.479%20C%206.903%2C9.297%207.104%2C9.14%207.314%2C9.004%20V%208.414%20L%206.131%2C7.187%203%2C8%20v%204%20H%203.62%20C%203.62%2C10.612%204.747%2C9.483%206.132%2C9.483%206.312%2C9.482%206.49%2C9.502%206.66%2C9.539%20z%20M%202%2C12%20z%20M%201%2C2%200%2C5%20v%207%20H%202%20V%205%20L%201%2C2%20z%20M%201.111%2C6.955%20C%200.804%2C6.955%200.556%2C6.706%200.556%2C6.4%20c%200%2C-0.307%200.248%2C-0.555%200.555%2C-0.555%200.307%2C0%200.554%2C0.248%200.554%2C0.555%200%2C0.306%20-0.247%2C0.555%20-0.554%2C0.555%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:12px;background-size:12px 12px}a.dg-map-geoclicker__show-more-sights-link{color:#ffe6aa}.no-touch a.dg-map-geoclicker__show-more-sights-link:hover{color:#9cd}a.dg-map-geoclicker__show-more-sights-link:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%226%22%20height%3D%2210%22%20viewBox%3D%220%200%206%2010%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C5%20V%205.4%20L%201.4%2C10%20H%200%20L%200%2C8.6%203.6%2C5%200%2C1.4%200%2C0%201.4%2C0%206%2C4.6%20V%205%20l%200%2C0%200%2C0%200%2C0%200%2C0%200%2C0%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-map-geoclicker__drilldown{color:#aaa}.dg-preloader{position:relative;margin:0 auto;width:200px;height:44px;vertical-align:middle}.dg-preloader_animation_false{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGPreloader__preloader.gif);background-size:100px 26px;background-attachment:scroll;background-position:50% 50%}.dg-preloader_animation_true:before{position:absolute;top:50%;left:50%;margin:-22px 0 0 -22px;width:44px;height:44px;outline:transparent solid 1px;content:'';-webkit-animation:dg-preloader__outer 5s linear infinite;animation:dg-preloader__outer 5s linear infinite;image-rendering:optimizeQuality}.dg-preloader_animation_true.dg-preloader_size_small:before{margin:-12px 0 0 -12px;width:24px;height:24px}.dg-preloader_animation_true.dg-preloader_scheme_regular:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2244%22%20height%3D%2244%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2035.68%2C10.32%20C%2038.368%2C13.465%2040%2C17.539%2040%2C22%2040%2C31.941%2031.941%2C40%2022%2C40%2012.059%2C40%204%2C31.941%204%2C22%204%2C17.539%205.632%2C13.465%208.32%2C10.32%20L%205.48%2C7.48%20C%202.07%2C11.354%200%2C16.434%200%2C22%200%2C34.15%209.85%2C44%2022%2C44%2034.15%2C44%2044%2C34.15%2044%2C22%2044%2C16.434%2041.93%2C11.354%2038.52%2C7.48%20l%20-2.84%2C2.84%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%209.271%2C9.272%20C%2012.529%2C6.015%2017.029%2C4%2022%2C4%2026.971%2C4%2031.471%2C6.015%2034.729%2C9.272%20L%2037.557%2C6.444%20C%2033.575%2C2.462%2028.075%2C0%2022%2C0%2015.925%2C0%2010.425%2C2.462%206.443%2C6.444%20l%202.828%2C2.828%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:44px 44px}.dg-preloader_animation_true.dg-preloader_scheme_regular.dg-preloader_size_small:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2018.564%2C7.435%20C%2019.467%2C8.73%2020%2C10.302%2020%2C12%2020%2C16.418%2016.418%2C20%2012%2C20%207.582%2C20%204%2C16.418%204%2C12%204%2C10.302%204.533%2C8.73%205.436%2C7.435%20L%202.581%2C4.581%20C%200.969%2C6.623%200%2C9.195%200%2C12%200%2C18.627%205.373%2C24%2012%2C24%2018.627%2C24%2024%2C18.627%2024%2C12%2024%2C9.195%2023.031%2C6.623%2021.419%2C4.581%20l%20-2.855%2C2.854%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2012%2C0%20C%208.686%2C0%205.686%2C1.343%203.516%2C3.515%20L%206.343%2C6.343%20C%207.791%2C4.895%209.791%2C4%2012%2C4%20c%202.209%2C0%204.209%2C0.895%205.657%2C2.343%20L%2020.484%2C3.515%20C%2018.314%2C1.343%2015.314%2C0%2012%2C0%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:24px 24px}.dg-preloader_animation_true:after{position:absolute;top:50%;left:50%;margin:-16px 0 0 -16px;width:32px;height:32px;outline:transparent solid 1px;content:'';-webkit-animation:dg-preloader__inner 4s linear infinite;animation:dg-preloader__inner 4s linear infinite;image-rendering:optimizeQuality}.dg-preloader_animation_true.dg-preloader_size_small:after{margin:-6px 0 0 -6px;width:12px;height:12px}.dg-preloader_animation_true.dg-preloader_scheme_regular:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2232%22%20height%3D%2232%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206.581%2C23.419%20C%204.969%2C21.377%204%2C18.804%204%2C16%204%2C9.373%209.373%2C4%2016%2C4%20c%206.627%2C0%2012%2C5.373%2012%2C12%200%2C2.804%20-0.969%2C5.377%20-2.581%2C7.419%20l%202.847%2C2.847%20C%2030.594%2C23.487%2032%2C19.909%2032%2C16%2032%2C7.163%2024.837%2C0%2016%2C0%207.163%2C0%200%2C7.163%200%2C16%20c%200%2C3.909%201.406%2C7.487%203.734%2C10.266%20l%202.847%2C-2.847%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2027.314%2C27.314%2024.486%2C24.486%20C%2022.314%2C26.657%2019.314%2C28%2016%2C28%2012.686%2C28%209.686%2C26.657%207.516%2C24.485%20L%204.688%2C27.313%20C%207.582%2C30.209%2011.582%2C32%2016%2C32%20c%204.418%2C0%208.418%2C-1.791%2011.314%2C-4.686%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:32px 32px}.dg-preloader_animation_true.dg-preloader_scheme_regular.dg-preloader_size_small:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%203.141%2C6.86%20C%203.059%2C6.586%203%2C6.301%203%2C6%203%2C4.343%204.343%2C3%206%2C3%207.657%2C3%209%2C4.343%209%2C6%209%2C6.301%208.941%2C6.586%208.859%2C6.86%20l%202.26%2C2.259%20C%2011.674%2C8.209%2012%2C7.144%2012%2C6%2012%2C2.686%209.314%2C0%206%2C0%202.686%2C0%200%2C2.686%200%2C6%200%2C7.144%200.326%2C8.209%200.881%2C9.119%20L%203.141%2C6.86%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%206%2C12%20c%201.657%2C0%203.157%2C-0.672%204.243%2C-1.757%20L%208.122%2C8.122%20C%207.578%2C8.664%206.828%2C9%206%2C9%205.172%2C9%204.422%2C8.664%203.879%2C8.121%20L%201.758%2C10.242%20C%202.843%2C11.328%204.343%2C12%206%2C12%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:12px 12px}@-webkit-keyframes dg-preloader__outer{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes dg-preloader__outer{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes dg-preloader__inner{to{-webkit-transform:rotate(-360deg);transform:rotate(-360deg)}}@keyframes dg-preloader__inner{to{-webkit-transform:rotate(-360deg);transform:rotate(-360deg)}}.dg-popup__footer-buttons{display:table;margin-top:10px;width:100%}.dg-popup__footer-button-wrapper{display:table-cell}.dg-popup__footer-button{position:relative;display:inline-block;-webkit-box-sizing:border-box;box-sizing:border-box;margin-left:5%;width:95%;border-radius:2px;text-align:center;text-decoration:none;font:12px/24px Arial,sans-serif;cursor:pointer;-webkit-transition:all .1s;transition:all .1s}.dg-popup__footer-button-wrapper:first-child .dg-popup__footer-button{margin:0;width:100%}.no-touch .dg-popup__footer-button:hover{-webkit-transition:all .2s;transition:all .2s}.dg-popup__footer-icon-button:before{display:inline-block;margin:-2px 5px 0 0;width:12px;height:12px;background-size:contain;background-repeat:no-repeat;content:'';vertical-align:middle}.dg-popup__button_name_back:before,.dg-popup__button_name_firm-card-back:before,.dg-popup__button_name_firm-list-back:before{width:9px;height:6px}.dg-popup__show-less-house-link{position:relative;top:6px;margin:0 15px 10px;color:#0070c0;text-decoration:none;font-size:12px;line-height:24px}.dg-popup__header-links{margin:8px 18px 0 0}.dg-popup__header-title_for_firmcard{position:relative;overflow:hidden;max-height:3.4em}.dg-popup__header-teaser{display:-webkit-box;height:3.3em;-webkit-line-clamp:3;-webkit-box-orient:vertical}.dg-popup__header-title{display:block;white-space:normal;font:22px/24px 'Arial narrow',Arial,sans-serif}.dg-popup__header-link{display:inline-block;margin-left:2.6em;vertical-align:middle;white-space:nowrap}.dg-popup__header-link:first-child{margin-left:1.2em}.dg-popup__rating{display:inline-block;margin:0 .4em 3px 0;width:70px;height:14px;vertical-align:middle}.dg-popup__rating-stars{background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2214%22%20height%3D%2214%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206.999%2C0%208.748%2C4.989%2013.997%2C4.991%209.83%2C8.708%2011.324%2C14.002%206.999%2C10.871%202.674%2C14.002%204.168%2C8.708%200%2C4.991%205.249%2C4.989%206.999%2C0%20z%22%20fill%3D%22%23ffc84b%22%2F%3E%0A%3C%2Fsvg%3E%0A\");float:left;height:100%}.dg-popup__link{position:relative;background-position:center bottom;background-size:10px 1px;background-repeat:repeat-x;text-decoration:none;-webkit-tap-highlight-color:transparent}.dg-popup__link_type_flamp_reviews{margin-left:.1em}.dg-popup__link_type_photos:before{position:absolute;top:2px;left:-18px;display:inherit;content:''}.dg-popup__link_type_booklet:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2210%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%200%2C8%203%2C2%20V%202%20L%200%2C0%20V%208%20z%20M%204%2C10%208%2C8%20V%200%20L%204%2C2%20v%208%20z%20M%209%2C0%20v%208%20l%203%2C2%20V%202%20L%209%2C0%20z%22%20fill%3D%22%237dc814%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:10px;background-size:12px 10px;position:absolute;top:2px;left:-18px;display:inherit;content:''}a.dg-popup__link{background-image:-webkit-gradient(linear,left top,right top,from(rgba(255,230,170,.3)),to(rgba(255,230,170,.3)));background-image:-webkit-linear-gradient(left,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);background-image:linear-gradient(to right,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);color:#ffe6aa}.no-touch a.dg-popup__link:hover{background-image:-webkit-gradient(linear,left top,right top,from(rgba(153,204,221,.3)),to(rgba(153,204,221,.3)));background-image:-webkit-linear-gradient(left,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);background-image:linear-gradient(to right,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);color:#9cd}.dg-popup__header-title{color:#ffc84b}.dg-popup__footer-button-wrapper .dg-popup__footer-button,.dg-popup__footer-button-wrapper .dg-popup__footer-button:hover{color:#e6e6e6}.dg-popup__footer-button{background:rgba(0,0,0,.2);-webkit-box-shadow:0 1px rgba(0,0,0,.1);box-shadow:0 1px rgba(0,0,0,.1)}.no-touch .dg-popup__footer-button:hover{background:#222;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.5);box-shadow:0 1px 3px rgba(0,0,0,.5)}.dg-popup__rating{background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2214%22%20height%3D%2214%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%207.002%2C0%208.751%2C4.989%2014%2C4.991%209.833%2C8.708%2011.327%2C14.002%207.002%2C10.871%202.677%2C14.002%204.171%2C8.708%200.003%2C4.991%205.252%2C4.989%207.002%2C0%20z%22%20fill%3D%22%23aaa%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-popup__link_type_photos:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2210%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2011%2C1%20H%2010%20L%209%2C0%20H%206%20L%205%2C1%20H%201%20L%200%2C2%20v%207%20l%201%2C1%20H%2011%20L%2012%2C9%20V%202%20L%2011%2C1%20z%20M%203%2C4%20H%202%20V%203%20h%201%20v%201%20z%20m%204.518%2C3.992%20c%20-1.381%2C0%20-2.5%2C-1.119%20-2.5%2C-2.5%200%2C-1.38%201.119%2C-2.5%202.5%2C-2.5%201.38%2C0%202.5%2C1.12%202.5%2C2.5%200%2C1.381%20-1.121%2C2.5%20-2.5%2C2.5%20z%22%20fill%3D%22%2379b0bc%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:10px;background-size:12px 10px}.dg-popup__button_name_firm-card-back:before,.dg-popup__button_name_firm-list-back:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C3%204%2C6%20V%204%20H%209%20V%202%20H%204%20V%200%20z%22%20fill%3D%22%239f9f9f%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-popup__button_name_back:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C3%204%2C6%20V%204%20H%209%20V%202%20H%204%20V%200%20z%22%20fill%3D%22%239f9f9f%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:9px;height:6px;background-size:9px 6px}.dg-popup__button_name_goto:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%227%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2016.5%2C0%20C%2014.738%2C0%2013.295%2C1.306%2013.051%2C3%20H%204.949%20C%204.718%2C1.858%203.71%2C1%202.5%2C1%201.119%2C1%200%2C2.119%200%2C3.5%200%2C4.881%201.119%2C6%202.5%2C6%203.71%2C6%204.718%2C5.142%204.949%2C4%20h%208.102%20C%2013.295%2C5.693%2014.739%2C7%2016.5%2C7%2018.433%2C7%2020%2C5.433%2020%2C3.5%2020%2C1.566%2018.433%2C0%2016.5%2C0%20z%22%20fill%3D%22%239f9f9f%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:20px;height:7px;background-size:20px 7px}.dg-popup__button_name_show-entrance:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205%2C9%209%2C6%205%2C3%20V%205%20H%200%20V%207%20H%205%20V%209%20z%20M%209.6%2C0%20H%202.4%20C%201.074%2C0%200%2C1.074%200%2C2.4%20V%204%20H%202%20V%203.6%20C%202%2C2.716%202.716%2C2%203.6%2C2%20H%208.4%20C%209.283%2C2%2010%2C2.716%2010%2C3.6%20V%208.4%20C%2010%2C9.284%209.283%2C10%208.4%2C10%20H%203.6%20C%202.716%2C10%202%2C9.284%202%2C8.4%20V%208%20H%200%20V%209.6%20C%200%2C10.925%201.074%2C12%202.4%2C12%20H%209.6%20C%2010.926%2C12%2012%2C10.925%2012%2C9.6%20V%202.4%20C%2012%2C1.074%2010.926%2C0%209.6%2C0%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-firm-card__icon{position:relative;padding-left:24px}.dg-firm-card__icon:before{position:absolute;top:0;left:0;margin:auto;background-position:0 50%;background-repeat:no-repeat;content:''}.dg-firm-card__link{overflow:hidden;margin-bottom:4px;text-overflow:ellipsis;white-space:nowrap;word-wrap:normal;line-height:16px}.dg-firm-card__link a{background-position:center bottom;background-size:10px 1px;background-repeat:repeat-x;text-decoration:none}.dg-firm-card__address{margin-bottom:10px;font-size:16px}.dg-firm-card__address:before{position:absolute;top:5px;left:1px;content:''}.dg-firm-card__comment{position:relative;margin-left:5px;font-size:12px}.dg-firm-card__phone{overflow:hidden;margin-bottom:4px;text-overflow:ellipsis;line-height:16px}.dg-firm-card__phone:before{top:3px;left:1px}.dg-firm-card__site:before{top:3px}.dg-firm-card__email:before{top:5px}.dg-firm-card__rubrics{overflow:hidden;margin-bottom:4px;font-size:12px;line-height:16px}.dg-firm-card__rubrics-list{margin:0;padding:0;list-style:none}.dg-firm-card__rubrics-list-item{display:inline;cursor:default}.dg-firm-card__rubrics-list-item:before{display:inline-block;margin:0 4px;content:''}.dg-firm-card__rubrics-list-item:first-child:before{margin:0;content:''}.dg-firm-card__aa{margin:0 0 4px;padding:0 0 0 24px;font-size:12px}.dg-firm-card__aa-list{display:inline;margin:0;padding:0;list-style:none;line-height:16px}.dg-firm-card__aa-list-item{display:inline;-webkit-box-sizing:border-box;box-sizing:border-box;max-width:100%;cursor:default}.dg-firm-card__aa-list-item:before{display:inline-block;margin:0 4px;content:''}.dg-firm-card__aa-list-item:first-child:before{margin:0;content:''}.dg-firm-card__aa-list-additional{display:inline;margin:0;padding:0;list-style:none;line-height:16px}.dg-firm-card__schedule{margin-bottom:10px}.dg-firm-card__link a{background-image:-webkit-gradient(linear,left top,right top,from(rgba(255,230,170,.3)),to(rgba(255,230,170,.3)));background-image:-webkit-linear-gradient(left,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);background-image:linear-gradient(to right,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);color:#ffe6aa}.no-touch .dg-firm-card__link a:hover{background-image:-webkit-gradient(linear,left top,right top,from(rgba(153,204,221,.3)),to(rgba(153,204,221,.3)));background-image:-webkit-linear-gradient(left,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);background-image:linear-gradient(to right,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);color:#9cd}.dg-firm-card__comment,.dg-firm-card__rubrics{color:#aaa}.dg-firm-card__rubrics-list-item:after{color:#6e6964}.dg-firm-card__aa-list-item:after{color:#e6e6e6}.dg-firm-card__address:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%204.958%2C11%20C%204.958%2C9.036%206.756%2C6.751%208.719%2C6.751%208.885%2C6.223%209%2C5.656%209%2C5.063%209%2C2.267%206.985%2C0%204.5%2C0%202.015%2C0%200%2C2.267%200%2C5.063%200%2C5.656%200.114%2C6.222%200.28%2C6.751%202.243%2C6.751%204.018%2C9.012%204.018%2C11%20h%200.94%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:9px;height:11px;background-size:9px 11px}.dg-firm-card__phone:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%2210%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%209.181%2C9.05%20C%208.673%2C9.556%208.047%2C9.873%207.391%2C10%206.156%2C9.841%205.008%2C9.417%203.998%2C8.788%20L%201.293%2C6.092%20C%200.639%2C5.053%200.203%2C3.865%200.052%2C2.589%200.19%2C1.964%200.494%2C1.368%200.983%2C0.882%20L%201.803%2C0.065%203.987%2C2.241%20V%202.79%20L%203.441%2C3.332%20c%20-0.452%2C0.451%20-0.453%2C1.183%200%2C1.634%20L%205.082%2C6.6%20c%200.452%2C0.451%201.187%2C0.451%201.639%2C0%20L%207.244%2C6.079%20H%207.838%20L%2010%2C8.233%209.181%2C9.05%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:10px;height:10px;background-size:10px 10px}.dg-firm-card__site:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.538%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.538%208.537%2C11%205.5%2C11%20z%20m%200%2C-9%20C%203.566%2C2%202%2C3.567%202%2C5.5%202%2C7.433%203.566%2C9%205.5%2C9%205.655%2C9%205.804%2C8.974%205.954%2C8.954%20L%203%2C6%20V%205%20L%205.571%2C3.286%205.984%2C2.049%20C%205.824%2C2.026%205.666%2C2%205.5%2C2%20z%20M%208.949%2C5%20H%207.375%20C%207.021%2C5.505%206.545%2C6.082%206%2C6.497%20V%208.95%20C%207.693%2C8.705%209%2C7.262%209%2C5.5%209%2C5.329%208.974%2C5.165%208.949%2C5%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-firm-card__email:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%227%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2011%2C1.555%20v%203.89%20C%2011%2C6.303%2010.242%2C7%209.309%2C7%20H%201.692%20C%200.758%2C7%200%2C6.303%200%2C5.444%20V%201.554%20L%205.5%2C4.826%2011%2C1.555%20z%20M%200.191%2C0%20H%2010.808%20L%205.5%2C3.111%200.191%2C0%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:7px;background-size:11px 7px}.dg-schedule__today{position:relative;display:inline-block;margin-left:24px;max-width:84%;background-position:center bottom;background-size:2px 1px;background-repeat:repeat-x;font-size:14px;line-height:16px;cursor:pointer}.dg-schedule__today:before{position:absolute;top:3px;left:-24px;content:''}.dg-schedule__today:after{position:absolute;right:-15px;bottom:4px;content:''}.dg-schedule__today-inner{overflow:hidden;width:100%;text-overflow:ellipsis;white-space:nowrap}.dg-schedule_works-everyday_true .dg-schedule__today{background-image:none;cursor:default}.dg-schedule_works-everyday_true .dg-schedule__today:after{background-image:none}.dg-schedule_open_true .dg-schedule__today:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.537%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.537%208.537%2C11%205.5%2C11%20z%20M%206%2C5.293%20V%202%20H%205%20V%205.707%20L%207.646%2C8.353%208.353%2C7.646%206%2C5.293%20z%22%20fill%3D%22%2370bf00%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-schedule__now{margin:2px 7px 0 36px;font-size:12px}.dg-schedule__string{padding:3px 16px 3px 24px;text-align:left;font-size:14px}.dg-schedule__string-time{white-space:nowrap}.dg-schedule__table{display:none;text-align:center;font-size:0}.dg-schedule__table-cell-group{white-space:nowrap}.dg-schedule__tc{display:inline-block;padding:2px 0 15px;width:44px;vertical-align:top;white-space:normal;font-size:14px}.dg-schedule__tc_pre{width:19px}.dg-schedule__day-name{margin:0;color:#8c8782;text-transform:capitalize}.dg-schedule__td{margin:10px 0 0}.dg-schedule_state_expanded .dg-schedule__popup{display:block;visibility:visible;max-height:1000px;opacity:1}.dg-schedule__table-clock{margin:13px 0 0}.dg-schedule__table-lunch{margin:31px 0 0}.dg-schedule__today{background-image:-webkit-gradient(linear,left top,right top,from(rgba(230,230,230,.55)),color-stop(50%,rgba(230,230,230,.55)),color-stop(51%,rgba(0,0,0,0)),to(rgba(0,0,0,0)));background-image:-webkit-linear-gradient(left,rgba(230,230,230,.55),rgba(230,230,230,.55) 50%,rgba(0,0,0,0) 51%,rgba(0,0,0,0) 100%);background-image:linear-gradient(to right,rgba(230,230,230,.55),rgba(230,230,230,.55) 50%,rgba(0,0,0,0) 51%,rgba(0,0,0,0) 100%)}.dg-schedule__now{color:#aaa}.dg-schedule__td{color:#e6e6e6}.dg-schedule__tc_active_true{background:rgba(255,255,255,.1)}.dg-schedule__string-time{color:#e6e6e6}.dg-schedule__table-clock{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.537%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.537%208.537%2C11%205.5%2C11%20z%20M%206%2C5.293%20V%202%20H%205%20V%205.707%20L%207.646%2C8.353%208.353%2C7.646%206%2C5.293%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-schedule__table-lunch{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%204%2C7%20H%208%20C%208.58%2C7%209.461%2C6.084%209.826%2C4.977%20V%205%20C%2011.047%2C5%2012%2C3.453%2012%2C2.031%2012%2C1.453%2011.531%2C1%2011.016%2C1%20H%2010%20C%2010%2C0.188%209.781%2C0%209%2C0%20H%203%20C%202.297%2C0%202%2C0.188%202%2C1%20v%203%20c%200%2C1.49%201.137%2C3%202%2C3%20z%20m%206%2C-5%20h%200.5%20C%2010.875%2C2%2011%2C2.219%2011%2C2.5%2011%2C3.625%2010.562%2C4%2010%2C4%20V%202%20z%20M%200%2C9%20c%200%2C0.448%201.791%2C1%203%2C1%200%2C0.405%200.646%2C1%201%2C1%20h%204%20c%200.354%2C0%201%2C-0.595%201%2C-1%201.208%2C0%203%2C-0.552%203%2C-1%20V%208%20H%200%20v%201%20z%22%20fill%3D%22%23aaa5a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:11px;background-size:12px 11px}.dg-schedule_open_false .dg-schedule__today:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.537%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.537%208.537%2C11%205.5%2C11%20z%20M%206%2C5.293%20V%202%20H%205%20V%205.707%20L%207.646%2C8.353%208.353%2C7.646%206%2C5.293%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-schedule__today:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205%2C6%20H%204.586%20L%200%2C1.414%20V%200%20H%201.414%20L%205%2C3.586%208.586%2C0%20H%2010%20V%201.414%20L%205.414%2C6%20H%205%20z%22%20fill%3D%22%23a5a09c%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:10px;height:6px;background-size:10px 6px}.dg-schedule__today_shown_true:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205%2C0%20H%205.414%20L%2010%2C4.586%20V%206%20H%208.586%20L%205%2C2.414%201.414%2C6%20H%200%20V%204.586%20L%204.586%2C0%20H%205%20z%22%20fill%3D%22%23a5a09c%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:10px;height:6px;background-size:10px 6px}.dg-link,.dg-link:hover{background-position:0 95%;background-size:10px 1px;background-repeat:repeat-x}.dg-link_type_local{background:-webkit-gradient(linear,left top,right top,from(#9cd),color-stop(50%,#9cd),color-stop(50%,transparent));background:-webkit-linear-gradient(left,#9cd,#9cd 50%,transparent 50%);background:linear-gradient(to right,#9cd,#9cd 50%,transparent 50%)}.no-touch .dg-link_type_local:hover{background:-webkit-gradient(linear,left top,right top,from(#9bc),color-stop(50%,#9bc),color-stop(50%,transparent));background:-webkit-linear-gradient(left,#9bc,#9bc 50%,transparent 50%);background:linear-gradient(to right,#9bc,#9bc 50%,transparent 50%)}.dg-link.dg-link_type_local,.dg-link.dg-link_type_local:hover{background-size:6px 1px}.dg-control-round__icon_name_traffic:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2214%22%20viewBox%3D%220%200%2020%2014%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2018%2C5%20C%2018%2C4%2017%2C1%2015%2C1%20H%2012%2010%20C%208%2C1%207%2C4%207%2C5%20H%205%20v%202%20h%201%20v%204%20c%200%2C0.6%200%2C1%201%2C1%20v%202%20h%202%20v%20-2%20h%207%20v%202%20h%202%20v%20-2%20c%201%2C0%201%2C-0.4%201%2C-1%20V%207%20h%201%20V%205%20H%2018%20z%20M%2010%2C3%20h%202%203%20c%202%2C0%202%2C1%202%2C3%20H%208%20C%208%2C4%208%2C3%2010%2C3%20z%20M%209%2C10%20H%208%20C%207.4%2C10%207%2C9.6%207%2C9%207%2C8.4%207.4%2C8%208%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20m%208%2C0%20H%2016%20C%2015.4%2C10%2015%2C9.6%2015%2C9%2015%2C8.4%2015.4%2C8%2016%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20M%204%2C4%20H%206%20V%203%20H%204%20C%201%2C3%201%2C6%201%2C7%20H%200%20v%201%20h%201%20v%204%20H%203%20V%2011%20H%205%20V%207%20H%202%20C%202%2C6%202%2C4%204%2C4%20z%20M%203%2C9%204%2C10%20H%202%20V%209%20h%201%20z%22%20fill%3D%22%23616161%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23fff%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2016%2C8%20h%201%20c%200.4%2C0%200.7%2C0.2%200.8%2C0.5%20C%2017.9%2C8.4%2018%2C8.2%2018%2C8%2018%2C7.4%2017.6%2C7%2017%2C7%20h%20-1%20c%20-0.6%2C0%20-1%2C0.4%20-1%2C1%200%2C0.2%200.1%2C0.4%200.2%2C0.5%20C%2015.3%2C8.2%2015.6%2C8%2016%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C8%20H%209%20C%209.4%2C8%209.7%2C8.2%209.8%2C8.5%209.9%2C8.4%2010%2C8.2%2010%2C8%2010%2C7.4%209.6%2C7%209%2C7%20H%208%20C%207.4%2C7%207%2C7.4%207%2C8%207%2C8.2%207.1%2C8.4%207.2%2C8.5%207.3%2C8.2%207.6%2C8%208%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%206%2C3%20H%204%20C%204%2C3%204%2C3%204%2C3%202%2C3%202%2C5%202%2C6%20H%202%20C%202.1%2C5%202.5%2C4%204%2C4%20H%205%206%20V%203%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M0%207H1V8H0z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2015%2C2%20H%2012%2010%20C%208%2C2%208%2C3%208%2C5%20H%208%20C%208%2C3.7%208.3%2C3%2010%2C3%20h%202%203%20c%201.7%2C0%201.9%2C0.7%202%2C2%20h%200%20C%2017%2C3%2017%2C2%2015%2C2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%209L4%209%203%208%202%208%202%209%202%209%202%209%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%207%2C11%20C%206%2C11%206%2C10.6%206%2C10%20v%201%20c%200%2C0.6%200%2C1%201%2C1%20v%20-1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2018%2C11%20v%201%20c%201%2C0%201%2C-0.4%201%2C-1%20v%20-1%20c%200%2C0.6%200%2C1%20-1%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M19%206H20V7H19z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%2011L1%2011%201%2012%203%2012%203%2011%205%2011%205%207%205%207%205%2010%203%2010z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M16%2013H18V14H16z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M5%206H6V7H5z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M9%2013L7%2013%207%2014%209%2014%209%2012%2016%2012%2016%2011%209%2011z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23444%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%202%2C6%20C%202%2C6.4%202%2C6.7%202%2C7%20H%205%20V%206%20H%202%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M2%209L2%2010%204%2010%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%204%2C3%20H%206%20V%202%20H%204%20C%201%2C2%201%2C5%201%2C6%20H%200%20V%207%20H%201%20C%201%2C6%201%2C3%204%2C3%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2018%2C4%20C%2018%2C3%2017%2C0%2015%2C0%20H%2012%2010%20C%208%2C0%207%2C3%207%2C4%20H%206%205%20V%205%20H%207%20C%207%2C4%208%2C1%2010%2C1%20h%202%203%20c%202%2C0%203%2C3%203%2C4%20h%202%20V%204%20h%20-2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C10%20H%209%20C%209.6%2C10%2010%2C9.6%2010%2C9%2010%2C8.8%209.9%2C8.6%209.8%2C8.5%209.7%2C8.8%209.4%2C9%209%2C9%20H%208%20C%207.6%2C9%207.3%2C8.8%207.2%2C8.5%207.1%2C8.6%207%2C8.8%207%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C6%20C%2017%2C5.6%2017%2C5.3%2017%2C5%20H%208%20c%200%2C0.3%200%2C0.6%200%2C1%20h%209%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017.8%2C8.5%20C%2017.7%2C8.8%2017.4%2C9%2017%2C9%20H%2016%20C%2015.6%2C9%2015.3%2C8.8%2015.2%2C8.5%2015.1%2C8.6%2015%2C8.8%2015%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20h%201%20c%200.6%2C0%201%2C-0.4%201%2C-1%200%2C-0.2%20-0.1%2C-0.4%20-0.2%2C-0.5%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E%0A\");width:20px;height:14px;background-size:20px 14px;position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_name_traffic:active:after,.no-touch .dg-control-round__icon_name_traffic:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2214%22%20viewBox%3D%220%200%2020%2014%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2018%2C5%20C%2018%2C4%2017%2C1%2015%2C1%20H%2012%2010%20C%208%2C1%207%2C4%207%2C5%20H%205%20v%202%20h%201%20v%204%20c%200%2C0.6%200%2C1%201%2C1%20v%202%20h%202%20v%20-2%20h%207%20v%202%20h%202%20v%20-2%20c%201%2C0%201%2C-0.4%201%2C-1%20V%207%20h%201%20V%205%20H%2018%20z%20M%2010%2C3%20h%202%203%20c%202%2C0%202%2C1%202%2C3%20H%208%20C%208%2C4%208%2C3%2010%2C3%20z%20M%209%2C10%20H%208%20C%207.4%2C10%207%2C9.6%207%2C9%207%2C8.4%207.4%2C8%208%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20m%208%2C0%20H%2016%20C%2015.4%2C10%2015%2C9.6%2015%2C9%2015%2C8.4%2015.4%2C8%2016%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20M%204%2C4%20H%206%20V%203%20H%204%20C%201%2C3%201%2C6%201%2C7%20H%200%20v%201%20h%201%20v%204%20H%203%20V%2011%20H%205%20V%207%20H%202%20C%202%2C6%202%2C4%204%2C4%20z%20M%203%2C9%204%2C10%20H%202%20V%209%20h%201%20z%22%20fill%3D%22%23424242%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23fff%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2016%2C8%20h%201%20c%200.4%2C0%200.7%2C0.2%200.8%2C0.5%20C%2017.9%2C8.4%2018%2C8.2%2018%2C8%2018%2C7.4%2017.6%2C7%2017%2C7%20h%20-1%20c%20-0.6%2C0%20-1%2C0.4%20-1%2C1%200%2C0.2%200.1%2C0.4%200.2%2C0.5%20C%2015.3%2C8.2%2015.6%2C8%2016%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C8%20H%209%20C%209.4%2C8%209.7%2C8.2%209.8%2C8.5%209.9%2C8.4%2010%2C8.2%2010%2C8%2010%2C7.4%209.6%2C7%209%2C7%20H%208%20C%207.4%2C7%207%2C7.4%207%2C8%207%2C8.2%207.1%2C8.4%207.2%2C8.5%207.3%2C8.2%207.6%2C8%208%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%206%2C3%20H%204%20C%204%2C3%204%2C3%204%2C3%202%2C3%202%2C5%202%2C6%20H%202%20C%202.1%2C5%202.5%2C4%204%2C4%20H%205%206%20V%203%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M0%207H1V8H0z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2015%2C2%20H%2012%2010%20C%208%2C2%208%2C3%208%2C5%20H%208%20C%208%2C3.7%208.3%2C3%2010%2C3%20h%202%203%20c%201.7%2C0%201.9%2C0.7%202%2C2%20h%200%20C%2017%2C3%2017%2C2%2015%2C2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%209L4%209%203%208%202%208%202%209%202%209%202%209%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%207%2C11%20C%206%2C11%206%2C10.6%206%2C10%20v%201%20c%200%2C0.6%200%2C1%201%2C1%20v%20-1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2018%2C11%20v%201%20c%201%2C0%201%2C-0.4%201%2C-1%20v%20-1%20c%200%2C0.6%200%2C1%20-1%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M19%206H20V7H19z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%2011L1%2011%201%2012%203%2012%203%2011%205%2011%205%207%205%207%205%2010%203%2010z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M16%2013H18V14H16z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M5%206H6V7H5z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M9%2013L7%2013%207%2014%209%2014%209%2012%2016%2012%2016%2011%209%2011z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%232e2e2e%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%202%2C6%20C%202%2C6.4%202%2C6.7%202%2C7%20H%205%20V%206%20H%202%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M2%209L2%2010%204%2010%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%204%2C3%20H%206%20V%202%20H%204%20C%201%2C2%201%2C5%201%2C6%20H%200%20V%207%20H%201%20C%201%2C6%201%2C3%204%2C3%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2018%2C4%20C%2018%2C3%2017%2C0%2015%2C0%20H%2012%2010%20C%208%2C0%207%2C3%207%2C4%20H%206%205%20V%205%20H%207%20C%207%2C4%208%2C1%2010%2C1%20h%202%203%20c%202%2C0%203%2C3%203%2C4%20h%202%20V%204%20h%20-2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C10%20H%209%20C%209.6%2C10%2010%2C9.6%2010%2C9%2010%2C8.8%209.9%2C8.6%209.8%2C8.5%209.7%2C8.8%209.4%2C9%209%2C9%20H%208%20C%207.6%2C9%207.3%2C8.8%207.2%2C8.5%207.1%2C8.6%207%2C8.8%207%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C6%20C%2017%2C5.6%2017%2C5.3%2017%2C5%20H%208%20c%200%2C0.3%200%2C0.6%200%2C1%20h%209%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017.8%2C8.5%20C%2017.7%2C8.8%2017.4%2C9%2017%2C9%20H%2016%20C%2015.6%2C9%2015.3%2C8.8%2015.2%2C8.5%2015.1%2C8.6%2015%2C8.8%2015%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20h%201%20c%200.6%2C0%201%2C-0.4%201%2C-1%200%2C-0.2%20-0.1%2C-0.4%20-0.2%2C-0.5%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_state_active.dg-control-round__icon_name_traffic:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_traffic:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_traffic:hover:after{background-image:none}a.dg-traffic-control{z-index:0;color:#f2f2f2;text-decoration:none;text-shadow:0 1px 2px rgba(0,0,0,.3);font:400 15px/32px 'Arial narrow',Arial,sans-serif}a.dg-traffic-control_color_green:after,a.dg-traffic-control_color_red:after,a.dg-traffic-control_color_yellow:after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;margin:auto;width:22px;height:22px;border-radius:50%;-webkit-box-shadow:inset 0 1px 0 0 rgba(0,0,0,.2),0 1px 0 0 #fff;box-shadow:inset 0 1px 0 0 rgba(0,0,0,.2),0 1px 0 0 #fff}.no-touch a.dg-traffic-control:hover{color:#f2f2f2}.no-touch a.dg-traffic-control_color_green:hover:after,.no-touch a.dg-traffic-control_color_red:hover:after,.no-touch a.dg-traffic-control_color_yellow:hover:after{width:22px;height:22px}a.dg-traffic-control_color_green:after{background:#3fc03b}.no-touch a.dg-traffic-control_color_green:hover:after,a.dg-traffic-control_color_green:active:after{background:-webkit-gradient(linear,left bottom,left top,from(#2aa731),to(#53e13a)) #3ec435;background:-webkit-linear-gradient(bottom,#2aa731,#53e13a) #3ec435;background:linear-gradient(to top,#2aa731,#53e13a) #3ec435}a.dg-traffic-control_color_yellow:after{background:#f3b223}.no-touch a.dg-traffic-control_color_yellow:hover:after,a.dg-traffic-control_color_yellow:active:after{background:-webkit-gradient(linear,left bottom,left top,from(#ef931b),to(#f7be26)) #f4a820;background:-webkit-linear-gradient(bottom,#ef931b,#f7be26) #f4a820;background:linear-gradient(to top,#ef931b,#f7be26) #f4a820}a.dg-traffic-control_color_red:after{background:#eb240c}.no-touch a.dg-traffic-control_color_red:hover:after,a.dg-traffic-control_color_red:active:after{background:-webkit-gradient(linear,left bottom,left top,from(#c01c0a),to(#f73416)) #db2811;background:-webkit-linear-gradient(bottom,#c01c0a,#f73416) #db2811;background:linear-gradient(to top,#c01c0a,#f73416) #db2811}.leaflet-rulerMarker-pane{z-index:600}.dg-ruler__label{position:absolute;top:0;left:0;z-index:200;-webkit-tap-highlight-color:transparent}.dg-ruler__label-spacer{display:block}.dg-ruler__label-container{display:none;padding:2px 4px;border:4px solid #fff;border-radius:13px;background:#0da5d5;background-clip:padding-box;color:#fff;white-space:nowrap;font-size:12px}.dg-ruler__point{display:inline-block;margin:2px 4px 0 0;width:10px;height:10px;border-radius:5px;background:#fff}.dg-ruler__label-remove-link{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C0%20C%202.687%2C0%200%2C2.687%200%2C6%200%2C9.313%202.687%2C12%206%2C12%209.313%2C12%2012%2C9.313%2012%2C6%2012%2C2.687%209.313%2C0%206%2C0%20z%20M%209.401%2C9.398%208.8%2C9.6%206%2C6.8%203.199%2C9.6%202.59%2C9.415%202.375%2C8.774%205.199%2C6%202.399%2C3.175%202.62%2C2.591%203.175%2C2.375%205.949%2C5.225%208.774%2C2.375%209.415%2C2.605%209.566%2C3.196%206.824%2C6%209.6%2C8.8%209.401%2C9.398%20z%22%20fill%3D%22%23fff%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:12px;background-size:12px 12px;display:none;margin:1px 0 0 4px;vertical-align:top;-webkit-transition:all .2s ease;transition:all .2s ease}.no-touch .dg-ruler__label-remove-link:hover{-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.dg-ruler__remove-link-overlay{position:absolute;top:-7px;right:-7px;bottom:-7px;width:40px}.no-touch .dg-ruler__remove-link-overlay{display:none}.dg-control-round__icon_name_ruler:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%229%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012.999%2C0%20v%204.001%20h%20-1%20V%200%20h%20-2%20v%202%20h%20-1%20V%200%20h%20-2%20V%202%20H%206%20V%200%20H%203.998%20v%204.001%20h%20-1%20V%200%20h%20-3%20V%208%20H%2016%20V%200%20z%22%20fill%3D%22%23616161%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%202.999%2C4%20h%201%20v%201%20h%20-1%20z%20m%203%2C-2%20h%201%20v%201%20h%20-1%20z%20m%203%2C0%20h%201%20v%201%20h%20-1%20z%20m%203%2C2%20h%201%20v%201%20h%20-1%20z%22%20fill%3D%22%23444%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C8%20H%2016%20V%209%20H%200%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%203%20V%201%20H%200%20z%20m%2013%2C0%20h%203%20v%201%20h%20-3%20z%20m%20-3%2C0%20h%202%20V%201%20H%2010%20z%20M%207%2C0%20H%209%20V%201%20H%207%20z%20M%204%2C0%20H%206%20V%201%20H%204%20z%22%20fill%3D%22%23444%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:16px;height:9px;background-size:16px 9px;position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_name_ruler:active:after,.no-touch .dg-control-round__icon_name_ruler:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%229%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012.999%2C0%20v%204.001%20h%20-1%20V%200%20h%20-2%20v%202%20h%20-1%20V%200%20h%20-2%20V%202%20H%206%20V%200%20H%203.998%20v%204.001%20h%20-1%20V%200%20h%20-3%20V%208%20H%2016%20V%200%20z%22%20fill%3D%22%23424242%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%202.999%2C4%20h%201%20v%201%20h%20-1%20z%20m%203%2C-2%20h%201%20v%201%20h%20-1%20z%20m%203%2C0%20h%201%20v%201%20h%20-1%20z%20m%203%2C2%20h%201%20v%201%20h%20-1%20z%22%20fill%3D%22%232e2e2e%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C8%20H%2016%20V%209%20H%200%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%203%20V%201%20H%200%20z%20m%2013%2C0%20h%203%20v%201%20h%20-3%20z%20m%20-3%2C0%20h%202%20V%201%20H%2010%20z%20M%207%2C0%20H%209%20V%201%20H%207%20z%20M%204%2C0%20H%206%20V%201%20H%204%20z%22%20fill%3D%22%232e2e2e%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_state_active.dg-control-round__icon_name_ruler:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_ruler:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_ruler:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%229%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012.999%2C0%20v%204.001%20h%20-1%20V%200%20h%20-2%20v%202%20h%20-1%20V%200%20h%20-2%20V%202%20H%206%20V%200%20H%203.999%20v%204.001%20h%20-1%20V%200%20h%20-3%20V%208%20H%2016%20V%200%20z%22%20fill%3D%22%2321a7d6%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%202.999%2C4%20h%201%20v%201%20h%20-1%20z%20m%203%2C-2%20h%201%20v%201%20h%20-1%20z%20m%203%2C0%20h%201%20v%201%20h%20-1%20z%20m%203%2C2%20h%201%20v%201%20h%20-1%20z%22%20fill%3D%22%23147596%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C8%20H%2016%20V%209%20H%200%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%203%20V%201%20H%200%20z%20m%2013%2C0%20h%203%20v%201%20h%20-3%20z%20m%20-3%2C0%20h%202%20V%201%20H%2010%20z%20M%207%2C0%20H%209%20V%201%20H%207%20z%20M%204%2C0%20H%206%20V%201%20H%204%20z%22%20fill%3D%22%23147596%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}"; (_dereq_("browserify-css").createStyle(css, { "href": "dist/css/styles.full.dark.css" }, { "insertAt": "bottom" })); module.exports = css;
},{"browserify-css":3}],2:[function(_dereq_,module,exports){
(function (process){
/* reduce implemintation by Mozila https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FReduce*/
if ('function' !== typeof Array.prototype.reduce) {
  Array.prototype.reduce = function(callback, opt_initialValue){
    'use strict';
    if (null === this || 'undefined' === typeof this) {
      // At the moment all modern browsers, that support strict mode, have
      // native implementation of Array.prototype.reduce. For instance, IE8
      // does not support strict mode, so this check is actually useless.
      throw new TypeError(
          'Array.prototype.reduce called on null or undefined');
    }
    if ('function' !== typeof callback) {
      throw new TypeError(callback + ' is not a function');
    }
    var index, value,
        length = this.length >>> 0,
        isValueSet = false;
    if (1 < arguments.length) {
      value = opt_initialValue;
      isValueSet = true;
    }
    for (index = 0; length > index; ++index) {
      if (this.hasOwnProperty(index)) {
        if (isValueSet) {
          value = callback(value, this[index], index, this);
        }
        else {
          value = this[index];
          isValueSet = true;
        }
      }
    }
    if (!isValueSet) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    return value;
  };
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.com/#x15.4.4.18
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function forEach(callback, thisArg) {
    'use strict';
    var T, k;

    if (this == null) {
      throw new TypeError("this is null or not defined");
    }

    var kValue,
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        O = Object(this),

        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        len = O.length >>> 0; // Hack to convert O.length to a UInt32

    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if ({}.toString.call(callback) !== "[object Function]") {
      throw new TypeError(callback + " is not a function");
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length >= 2) {
      T = thisArg;
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as the this value and
        // argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
  Object.keys = (function () {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
        dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [], prop, i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }());
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some)
{
  Array.prototype.some = function(fun /*, thisArg */)
  {
    'use strict';

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== 'function')
      throw new TypeError();

    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      if (i in t && fun.call(thisArg, t[i], i, t))
        return true;
    }

    return false;
  };
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
if (!Array.prototype.map)
{
  Array.prototype.map = function(fun /*, thisArg */)
  {
    "use strict";

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function")
      throw new TypeError();

    var res = new Array(len);
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      // NOTE: Absolute correctness would demand Object.defineProperty
      //       be used.  But this method is fairly new, and failure is
      //       possible only if Object.prototype or Array.prototype
      //       has a property |i| (very unlikely), so use a less-correct
      //       but more portable alternative.
      if (i in t)
        res[i] = fun.call(thisArg, t[i], i, t);
    }

    return res;
  };
}

//From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
if (!Array.prototype.filter)
{
  Array.prototype.filter = function(fun /*, thisArg */)
  {
    "use strict";

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun != "function")
      throw new TypeError();

    var res = [];
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      if (i in t)
      {
        var val = t[i];

        // NOTE: Technically this should Object.defineProperty at
        //       the next index, as push can be affected by
        //       properties on Object.prototype and Array.prototype.
        //       But that method's new, and collisions should be
        //       rare, so use the more-compatible alternative.
        if (fun.call(thisArg, val, i, t))
          res.push(val);
      }
    }

    return res;
  };
}

//From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5 internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP = function () {},
        fBound = function () {
          return fToBind.apply(this instanceof fNOP && oThis
                                 ? this
                                 : oThis,
                               aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
}

//From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (searchElement, fromIndex) {
    if ( this === undefined || this === null ) {
      throw new TypeError( '"this" is null or not defined' );
    }

    var length = this.length >>> 0; // Hack to convert object.length to a UInt32

    fromIndex = +fromIndex || 0;

    if (Math.abs(fromIndex) === Infinity) {
      fromIndex = 0;
    }

    if (fromIndex < 0) {
      fromIndex += length;
      if (fromIndex < 0) {
        fromIndex = 0;
      }
    }

    for (;fromIndex < length; fromIndex++) {
      if (this[fromIndex] === searchElement) {
        return fromIndex;
      }
    }

    return -1;
  };
}

if (typeof Promise !== 'function') {
  (function() {
  var define, requireModule, _dereq_, requirejs;

  (function() {
    var registry = {}, seen = {};

    define = function(name, deps, callback) {
      registry[name] = { deps: deps, callback: callback };
    };

    requirejs = _dereq_ = requireModule = function(name) {
    requirejs._eak_seen = registry;

      if (seen[name]) { return seen[name]; }
      seen[name] = {};

      if (!registry[name]) {
        throw new Error("Could not find module " + name);
      }

      var mod = registry[name],
          deps = mod.deps,
          callback = mod.callback,
          reified = [],
          exports;

      for (var i=0, l=deps.length; i<l; i++) {
        if (deps[i] === 'exports') {
          reified.push(exports = {});
        } else {
          reified.push(requireModule(resolve(deps[i])));
        }
      }

      var value = callback.apply(this, reified);
      return seen[name] = exports || value;

      function resolve(child) {
        if (child.charAt(0) !== '.') { return child; }
        var parts = child.split("/");
        var parentBase = name.split("/").slice(0, -1);

        for (var i=0, l=parts.length; i<l; i++) {
          var part = parts[i];

          if (part === '..') { parentBase.pop(); }
          else if (part === '.') { continue; }
          else { parentBase.push(part); }
        }

        return parentBase.join("/");
      }
    };
  })();

  define("promise/all",
    ["./utils","exports"],
    function(__dependency1__, __exports__) {
      "use strict";
      /* global toString */

      var isArray = __dependency1__.isArray;
      var isFunction = __dependency1__.isFunction;

      /**
        Returns a promise that is fulfilled when all the given promises have been
        fulfilled, or rejected if any of them become rejected. The return promise
        is fulfilled with an array that gives all the values in the order they were
        passed in the `promises` array argument.

        Example:

        ```javascript
        var promise1 = RSVP.resolve(1);
        var promise2 = RSVP.resolve(2);
        var promise3 = RSVP.resolve(3);
        var promises = [ promise1, promise2, promise3 ];

        RSVP.all(promises).then(function(array){
          // The array here would be [ 1, 2, 3 ];
        });
        ```

        If any of the `promises` given to `RSVP.all` are rejected, the first promise
        that is rejected will be given as an argument to the returned promises's
        rejection handler. For example:

        Example:

        ```javascript
        var promise1 = RSVP.resolve(1);
        var promise2 = RSVP.reject(new Error("2"));
        var promise3 = RSVP.reject(new Error("3"));
        var promises = [ promise1, promise2, promise3 ];

        RSVP.all(promises).then(function(array){
          // Code here never runs because there are rejected promises!
        }, function(error) {
          // error.message === "2"
        });
        ```

        @method all
        @for RSVP
        @param {Array} promises
        @param {String} label
        @return {Promise} promise that is fulfilled when all `promises` have been
        fulfilled, or rejected if any of them become rejected.
      */
      function all(promises) {
        /*jshint validthis:true */
        var Promise = this;

        if (!isArray(promises)) {
          throw new TypeError('You must pass an array to all.');
        }

        return new Promise(function(resolve, reject) {
          var results = [], remaining = promises.length,
          promise;

          if (remaining === 0) {
            resolve([]);
          }

          function resolver(index) {
            return function(value) {
              resolveAll(index, value);
            };
          }

          function resolveAll(index, value) {
            results[index] = value;
            if (--remaining === 0) {
              resolve(results);
            }
          }

          for (var i = 0; i < promises.length; i++) {
            promise = promises[i];

            if (promise && isFunction(promise.then)) {
              promise.then(resolver(i), reject);
            } else {
              resolveAll(i, promise);
            }
          }
        });
      }

      __exports__.all = all;
    });
  define("promise/asap",
    ["exports"],
    function(__exports__) {
      "use strict";
      var browserGlobal = (typeof window !== 'undefined') ? window : {};
      var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
      var local = window;

      // node
      function useNextTick() {
        return function() {
          process.nextTick(flush);
        };
      }

      function useMutationObserver() {
        var iterations = 0;
        var observer = new BrowserMutationObserver(flush);
        var node = document.createTextNode('');
        observer.observe(node, { characterData: true });

        return function() {
          node.data = (iterations = ++iterations % 2);
        };
      }

      function useSetTimeout() {
        return function() {
          local.setTimeout(flush, 1);
        };
      }

      var queue = [];
      function flush() {
        for (var i = 0; i < queue.length; i++) {
          var tuple = queue[i];
          var callback = tuple[0], arg = tuple[1];
          callback(arg);
        }
        queue = [];
      }

      var scheduleFlush;

      // Decide what async method to use to triggering processing of queued callbacks:
      if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
        scheduleFlush = useNextTick();
      } else if (BrowserMutationObserver) {
        scheduleFlush = useMutationObserver();
      } else {
        scheduleFlush = useSetTimeout();
      }

      function asap(callback, arg) {
        var length = queue.push([callback, arg]);
        if (length === 1) {
          // If length is 1, that means that we need to schedule an async flush.
          // If additional callbacks are queued before the queue is flushed, they
          // will be processed by this flush that we are scheduling.
          scheduleFlush();
        }
      }

      __exports__.asap = asap;
    });
  define("promise/config",
    ["exports"],
    function(__exports__) {
      "use strict";
      var config = {
        instrument: false
      };

      function configure(name, value) {
        if (arguments.length === 2) {
          config[name] = value;
        } else {
          return config[name];
        }
      }

      __exports__.config = config;
      __exports__.configure = configure;
    });
  define("promise/polyfill",
    ["./promise","./utils","exports"],
    function(__dependency1__, __dependency2__, __exports__) {
      "use strict";
      /*global self*/
      var RSVPPromise = __dependency1__.Promise;
      var isFunction = __dependency2__.isFunction;

      function polyfill() {
        var local;

        if (typeof window !== 'undefined' && window.document) {
          local = window;
        } else {
          local = self;
        }

        var es6PromiseSupport =
          "Promise" in local &&
          // Some of these methods are missing from
          // Firefox/Chrome experimental implementations
          "resolve" in local.Promise &&
          "reject" in local.Promise &&
          "all" in local.Promise &&
          "race" in local.Promise &&
          // Older version of the spec had a resolver object
          // as the arg rather than a function
          (function() {
            var resolve;
            new local.Promise(function(r) { resolve = r; });
            return isFunction(resolve);
          }());

        if (!es6PromiseSupport) {
          local.Promise = RSVPPromise;
        }
      }

      __exports__.polyfill = polyfill;
    });
  define("promise/promise",
    ["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],
    function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
      "use strict";
      var config = __dependency1__.config;
      var configure = __dependency1__.configure;
      var objectOrFunction = __dependency2__.objectOrFunction;
      var isFunction = __dependency2__.isFunction;
      var now = __dependency2__.now;
      var all = __dependency3__.all;
      var race = __dependency4__.race;
      var staticResolve = __dependency5__.resolve;
      var staticReject = __dependency6__.reject;
      var asap = __dependency7__.asap;

      var counter = 0;

      config.async = asap; // default async is asap;

      function Promise(resolver) {
        if (!isFunction(resolver)) {
          throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
        }

        if (!(this instanceof Promise)) {
          throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
        }

        this._subscribers = [];

        invokeResolver(resolver, this);
      }

      function invokeResolver(resolver, promise) {
        function resolvePromise(value) {
          resolve(promise, value);
        }

        function rejectPromise(reason) {
          reject(promise, reason);
        }

        try {
          resolver(resolvePromise, rejectPromise);
        } catch(e) {
          rejectPromise(e);
        }
      }

      function invokeCallback(settled, promise, callback, detail) {
        var hasCallback = isFunction(callback),
            value, error, succeeded, failed;

        if (hasCallback) {
          try {
            value = callback(detail);
            succeeded = true;
          } catch(e) {
            failed = true;
            error = e;
          }
        } else {
          value = detail;
          succeeded = true;
        }

        if (handleThenable(promise, value)) {
          return;
        } else if (hasCallback && succeeded) {
          resolve(promise, value);
        } else if (failed) {
          reject(promise, error);
        } else if (settled === FULFILLED) {
          resolve(promise, value);
        } else if (settled === REJECTED) {
          reject(promise, value);
        }
      }

      var PENDING   = void 0;
      var SEALED    = 0;
      var FULFILLED = 1;
      var REJECTED  = 2;

      function subscribe(parent, child, onFulfillment, onRejection) {
        var subscribers = parent._subscribers;
        var length = subscribers.length;

        subscribers[length] = child;
        subscribers[length + FULFILLED] = onFulfillment;
        subscribers[length + REJECTED]  = onRejection;
      }

      function publish(promise, settled) {
        var child, callback, subscribers = promise._subscribers, detail = promise._detail;

        for (var i = 0; i < subscribers.length; i += 3) {
          child = subscribers[i];
          callback = subscribers[i + settled];

          invokeCallback(settled, child, callback, detail);
        }

        promise._subscribers = null;
      }

      Promise.prototype = {
        constructor: Promise,

        _state: undefined,
        _detail: undefined,
        _subscribers: undefined,

        then: function(onFulfillment, onRejection) {
          var promise = this;

          var thenPromise = new this.constructor(function() {});

          if (this._state) {
            var callbacks = arguments;
            config.async(function invokePromiseCallback() {
              invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
            });
          } else {
            subscribe(this, thenPromise, onFulfillment, onRejection);
          }

          return thenPromise;
        },

        'catch': function(onRejection) {
          return this.then(null, onRejection);
        }
      };

      Promise.all = all;
      Promise.race = race;
      Promise.resolve = staticResolve;
      Promise.reject = staticReject;

      function handleThenable(promise, value) {
        var then = null,
        resolved;

        try {
          if (promise === value) {
            throw new TypeError("A promises callback cannot return that same promise.");
          }

          if (objectOrFunction(value)) {
            then = value.then;

            if (isFunction(then)) {
              then.call(value, function(val) {
                if (resolved) { return true; }
                resolved = true;

                if (value !== val) {
                  resolve(promise, val);
                } else {
                  fulfill(promise, val);
                }
              }, function(val) {
                if (resolved) { return true; }
                resolved = true;

                reject(promise, val);
              });

              return true;
            }
          }
        } catch (error) {
          if (resolved) { return true; }
          reject(promise, error);
          return true;
        }

        return false;
      }

      function resolve(promise, value) {
        if (promise === value) {
          fulfill(promise, value);
        } else if (!handleThenable(promise, value)) {
          fulfill(promise, value);
        }
      }

      function fulfill(promise, value) {
        if (promise._state !== PENDING) { return; }
        promise._state = SEALED;
        promise._detail = value;

        config.async(publishFulfillment, promise);
      }

      function reject(promise, reason) {
        if (promise._state !== PENDING) { return; }
        promise._state = SEALED;
        promise._detail = reason;

        config.async(publishRejection, promise);
      }

      function publishFulfillment(promise) {
        publish(promise, promise._state = FULFILLED);
      }

      function publishRejection(promise) {
        publish(promise, promise._state = REJECTED);
      }

      __exports__.Promise = Promise;
    });
  define("promise/race",
    ["./utils","exports"],
    function(__dependency1__, __exports__) {
      "use strict";
      /* global toString */
      var isArray = __dependency1__.isArray;

      /**
        `RSVP.race` allows you to watch a series of promises and act as soon as the
        first promise given to the `promises` argument fulfills or rejects.

        Example:

        ```javascript
        var promise1 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            resolve("promise 1");
          }, 200);
        });

        var promise2 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            resolve("promise 2");
          }, 100);
        });

        RSVP.race([promise1, promise2]).then(function(result){
          // result === "promise 2" because it was resolved before promise1
          // was resolved.
        });
        ```

        `RSVP.race` is deterministic in that only the state of the first completed
        promise matters. For example, even if other promises given to the `promises`
        array argument are resolved, but the first completed promise has become
        rejected before the other promises became fulfilled, the returned promise
        will become rejected:

        ```javascript
        var promise1 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            resolve("promise 1");
          }, 200);
        });

        var promise2 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            reject(new Error("promise 2"));
          }, 100);
        });

        RSVP.race([promise1, promise2]).then(function(result){
          // Code here never runs because there are rejected promises!
        }, function(reason){
          // reason.message === "promise2" because promise 2 became rejected before
          // promise 1 became fulfilled
        });
        ```

        @method race
        @for RSVP
        @param {Array} promises array of promises to observe
        @param {String} label optional string for describing the promise returned.
        Useful for tooling.
        @return {Promise} a promise that becomes fulfilled with the value the first
        completed promises is resolved with if the first completed promise was
        fulfilled, or rejected with the reason that the first completed promise
        was rejected with.
      */
      function race(promises) {
        /*jshint validthis:true */
        var Promise = this;

        if (!isArray(promises)) {
          throw new TypeError('You must pass an array to race.');
        }
        return new Promise(function(resolve, reject) {
          var results = [], promise;

          for (var i = 0; i < promises.length; i++) {
            promise = promises[i];

            if (promise && typeof promise.then === 'function') {
              promise.then(resolve, reject);
            } else {
              resolve(promise);
            }
          }
        });
      }

      __exports__.race = race;
    });
  define("promise/reject",
    ["exports"],
    function(__exports__) {
      "use strict";
      /**
        `RSVP.reject` returns a promise that will become rejected with the passed
        `reason`. `RSVP.reject` is essentially shorthand for the following:

        ```javascript
        var promise = new RSVP.Promise(function(resolve, reject){
          reject(new Error('WHOOPS'));
        });

        promise.then(function(value){
          // Code here doesn't run because the promise is rejected!
        }, function(reason){
          // reason.message === 'WHOOPS'
        });
        ```

        Instead of writing the above, your code now simply becomes the following:

        ```javascript
        var promise = RSVP.reject(new Error('WHOOPS'));

        promise.then(function(value){
          // Code here doesn't run because the promise is rejected!
        }, function(reason){
          // reason.message === 'WHOOPS'
        });
        ```

        @method reject
        @for RSVP
        @param {Any} reason value that the returned promise will be rejected with.
        @param {String} label optional string for identifying the returned promise.
        Useful for tooling.
        @return {Promise} a promise that will become rejected with the given
        `reason`.
      */
      function reject(reason) {
        /*jshint validthis:true */
        var Promise = this;

        return new Promise(function (resolve, reject) {
          reject(reason);
        });
      }

      __exports__.reject = reject;
    });
  define("promise/resolve",
    ["exports"],
    function(__exports__) {
      "use strict";
      function resolve(value) {
        /*jshint validthis:true */
        if (value && typeof value === 'object' && value.constructor === this) {
          return value;
        }

        var Promise = this;

        return new Promise(function(resolve) {
          resolve(value);
        });
      }

      __exports__.resolve = resolve;
    });
  define("promise/utils",
    ["exports"],
    function(__exports__) {
      "use strict";
      function objectOrFunction(x) {
        return isFunction(x) || (typeof x === "object" && x !== null);
      }

      function isFunction(x) {
        return typeof x === "function";
      }

      function isArray(x) {
        return Object.prototype.toString.call(x) === "[object Array]";
      }

      // Date.now is not available in browsers < IE9
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
      var now = Date.now || function() { return new Date().getTime(); };


      __exports__.objectOrFunction = objectOrFunction;
      __exports__.isFunction = isFunction;
      __exports__.isArray = isArray;
      __exports__.now = now;
    });
  requireModule('promise/polyfill').polyfill();
  }());
}

_dereq_('leaflet');
_dereq_('html5shiv');

// DG inheritance
var oldDG = window.DG;
var DG = new (
    (function() {
        var DgApi = function() {},
            DgApiCore = function() {};

        DgApiCore.prototype = L;
        DgApi.prototype = new DgApiCore();

        return DgApi;
    })()
)();

for (var prop in oldDG) {
    if (oldDG.hasOwnProperty(prop) && typeof DG[prop] === 'undefined') {
        DG[prop] = oldDG[prop];
    }
}

window.__dgApi__ = window.__dgApi__ || {};
DG.version = window.__dgApi__.version;
DG.Icon.Default.imagePath  = '../img/vendors/leaflet';

DG.Map.addInitHook((function() {
    var inited = false;

    // Analytics inited once
    return function() {
        if (!inited) {
            /*eslint-disable */
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script',DG.config.protocol+DG.config.googleAnalytics,'ga');
            /*eslint-enable */

            inited = true;
        }

        /*eslint-disable */
        ga('create', DG.config.gaCode, 'none', {name: 'mapsapi2gis'});
        ga('mapsapi2gis.send', 'pageview');
        /*eslint-enable */

        var newImg = new Image();
        newImg.src = DG.config.protocol + DG.config.analytics + '?' +
            'sr=' + window.screen.width + 'x' + window.screen.height + '&' +
            'v=' + DG.version;
    };
})());

// Improve IHandler
DG.Map.include({
    addHandler: function(name, HandlerClass) {
        if (!HandlerClass) { return this; }

        var options = this.options[name],
            param = (options === Object(options)) ? options : null,
            handler = this[name] = new HandlerClass(this, param);

        this._handlers.push(handler);

        if (options) {
            handler.enable();
        }

        return this;
    }
});

// Apply class to map container for detect when we dont need hover effects
DG.Map.addInitHook(function() {
    if (!DG.Browser.touchEnabled) {
        DG.DomUtil.addClass(this._container, 'no-touch');
    }
});

window.DG = DG;
module.exports = DG;

var handlers = window.__dgApi__.callbacks || [],
    chain = Promise.resolve();

handlers.forEach(function(handlers) {
    chain = chain.then(handlers[0], handlers[1]);
});

DG.then = function(resolve, reject) {
    return chain.then(resolve, reject);
};

// IE8 throw error if `chain.catch`
/* eslint-disable dot-notation, no-console */
chain['catch'](function(err) {
    console.error(err);
});
/* eslint-enable dot-notation, no-console */

DG.plugin = function(plugins) {
    var count,
        jsReg = new RegExp(/.js$/i),
        cssReg = new RegExp(/.css$/i);

    return new Promise(function(resolve) {
        function checkLoading() {
            count--;

            if (count === 0) {
                resolve();
            }
        }

        function appendJS(link) {
            var js = document.createElement('script');
            js.setAttribute('type', 'text/javascript');
            js.setAttribute('src', link);
            js.onload = function() {
                checkLoading();
            };
            js.onerror = function() {
                checkLoading();
            };
            // load/error for IE
            js.onreadystatechange = function() {
                if (js.readyState === 'complete' || js.readyState === 'loaded') {
                    checkLoading();
                }
            };

            document.getElementsByTagName('head')[0].appendChild(js);
        }

        function appendCSS(link) {
            var css = document.createElement('link');
            css.setAttribute('rel', 'stylesheet');
            css.setAttribute('type', 'text/css');
            css.setAttribute('href', link);
            document.getElementsByTagName('head')[0].appendChild(css);

            checkLoading();
        }

        function isJs(url) {
            return jsReg.test(url);
        }

        function isCss(url) {
            return cssReg.test(url);
        }

        function appendAsset(asset) {
            if (isJs(asset)) {
                appendJS(asset);
            } else if (isCss(asset)) {
                appendCSS(asset);
            } else {
                count--;
            }
        }

        if (DG.Util.isArray(plugins)) {
            count = plugins.length;
            plugins.forEach(function(plugin) {
                appendAsset(plugin);
            });
        }

        if (typeof plugins === 'string') {
            count = 1;
            appendAsset(plugins);
        }
    });
};

DG.ajax = (function() {

    var win = window,
        doc = document,

        rurl = /^([\w.+-]+:)?(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
        twoHundo = /^20\d$/,

        // Document location
        ajaxLocParts,
        ajaxLocation,

        byTag = 'getElementsByTagName',
        readyState = 'readyState',
        contentType = 'Content-Type',
        requestedWith = 'X-Requested-With',
        head = doc[byTag]('head')[0],
        uniqid = 0,
        callbackPrefix = 'l_dg_ajax_callback_' + (+new Date()),
        lastValue, // data stored by the most recent JSONP callback
        xmlHttpRequest = 'XMLHttpRequest',
        xDomainRequest = 'XDomainRequest', // IE 8 and 9 only
        noop = function() {},
        defaultHeaders = {
            contentType: 'application/x-www-form-urlencoded',
            requestedWith: xmlHttpRequest,
            accept: {
                '*':  'text/javascript, text/html, application/xml, text/xml, */*',
                xml:  'application/xml, text/xml',
                html: 'text/html',
                text: 'text/plain',
                json: 'application/json, text/javascript',
                js:   'application/javascript, text/javascript'
            }
        },
        /*global XDomainRequest:false */
        xhr = function(o) {
            // is it x-domain
            if (o.crossDomain === true) {
                var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;
                if (xhr && 'withCredentials' in xhr) {
                    return xhr;
                } else if (win[xDomainRequest]) {
                    return new XDomainRequest();
                } else {
                    throw new Error('Browser does not support cross-origin requests');
                }
            } else {
                return new XMLHttpRequest();
            }
        },

        globalSetupOptions = {
            dataFilter: function(data) {
                return data;
            }
        };

    // IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement('a');
        ajaxLocation.href = '';
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    function handleReadyState(r, success, error) {
        return function() {
            // use _aborted to mitigate against IE err c00c023f
            // (can't read props on aborted request objects)
            if (r._aborted) {
                return error(r.request);
            }
            if (r.request && r.request[readyState] === 4) {
                r.request.onreadystatechange = noop;
                if (twoHundo.test(r.request.status)) {
                    success(r.request);
                } else {
                    error(r.request);
                }
            }
        };
    }

    function setHeaders(http, o) {
        var headers = o.headers || {},
            h;

        headers.Accept = headers.Accept || defaultHeaders.accept[o.dataType] || defaultHeaders.accept['*'];

        // breaks cross-origin requests with legacy browsers
        if (!o.crossDomain && !headers[requestedWith]) {
            headers[requestedWith] = defaultHeaders.requestedWith;
        }
        if (!headers[contentType]) {
            headers[contentType] = o.contentType || defaultHeaders.contentType;
        }
        for (h in headers) {
            if (headers.hasOwnProperty(h) && 'setRequestHeader' in http) {
                http.setRequestHeader(h, headers[h]);
            }
        }
    }

    function setCredentials(http, o) {
        if (typeof o.withCredentials !== 'undefined' && typeof http.withCredentials !== 'undefined') {
            http.withCredentials = !!o.withCredentials;
        }
    }

    function generalCallback(data) {
        lastValue = data;
    }

    function urlappend(url, s) {
        return url + (/\?/.test(url) ? '&' : '?') + s;
    }

    function handleJsonp(o, fn, err, url) {
        var reqId = uniqid++,
            cbkey = o.jsonpCallback || 'callback', // the 'callback' key
            cbval = o.jsonpCallbackName || callbackPrefix,
            cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)'),
            match = url.match(cbreg),
            script = doc.createElement('script'),
            loaded = 0,
            isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1;

        if (match) {
            if (match[3] === '?') {
                url = url.replace(cbreg, '$1=' + cbval); // wildcard callback func name
            } else {
                cbval = match[3]; // provided callback func name
            }
        } else {
            url = urlappend(url, cbkey + '=' + cbval); // no callback details, add 'em
        }

        win[cbval] = generalCallback;

        script.type = 'text/javascript';
        script.src = url;
        script.async = true;
        if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
            // need this for IE due to out-of-order onreadystatechange(), binding script
            // execution to an event listener gives us control over when the script
            // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
            //
            // if this hack is used in IE10 jsonp callback are never called
            script.event = 'onclick';
            script.htmlFor = script.id = '_request_' + reqId;
        }

        script.onerror = function() {
            script.onerror = script.onload = script.onreadystatechange = null;
            err({}, 'Request unknown error', {});
            lastValue = undefined;
            head.removeChild(script);
            loaded = 1;
        };
        script.onload = script.onreadystatechange = function() {
            if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
                return false;
            }
            script.onerror = script.onload = script.onreadystatechange = null;
            if (script.onclick) {
                script.onclick();
            }
            // Call the user callback with the last value stored and clean up values and scripts.
            fn(lastValue);
            lastValue = undefined;
            head.removeChild(script);
            loaded = 1;
        };

        // Add the script to the DOM head
        head.appendChild(script);

        // Enable JSONP timeout
        return {
            abort: function() {
                script.onerror = script.onload = script.onreadystatechange = null;
                err({}, 'Request is aborted: timeout', {});
                lastValue = undefined;
                head.removeChild(script);
                loaded = 1;
            }
        };
    }

    function getRequest(fn, err) {
        var o = this.options,
            method = (o.type || 'GET').toUpperCase(),
            url = typeof o === 'string' ? o : o.url,
            // convert non-string objects to query-string form unless o.processData is false
            data = (o.processData !== false && o.data && typeof o.data !== 'string') ? Ajax.toQueryString(o.data) : (o.data || null),
            http,
            sendWait = false;

        // if we're working on a GET request and we have data then we should append
        // query string to end of URL and not post data
        if ((o.type === 'jsonp' || method === 'GET') && data) {
            url = urlappend(url, data);
            data = null;
        }

        if (o.type === 'jsonp') {
            return handleJsonp(o, fn, err, url);
        }

        http = xhr(o);
        http.open(method, url, o.async !== false);

        setHeaders(http, o);
        setCredentials(http, o);

        if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
            http.onload = fn;
            http.onprogress = function() {};
            http.ontimeout = function() {};
            http.onerror = err;
            sendWait = true;
        } else {
            http.onreadystatechange = handleReadyState(this, fn, err);
        }
        if (sendWait) {
            setTimeout(function() {
                http.send(data);
            }, 200);
        } else {
            http.send(data);
        }
        return http;
    }

    function buildParams(prefix, obj, traditional, add) {
        var name, i, v,
            rbracket = /\[\]$/;

        if (DG.Util.isArray(obj)) {
        // Serialize array item.
            for (i = 0; obj && i < obj.length; i++) {
                v = obj[i];
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                }
            }
        } else if (obj && obj.toString() === '[object Object]') {
            // Serialize object item.
            for (name in obj) {
                if (obj.hasOwnProperty(name)) {
                    buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
                }
            }
        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    function setType(url) {
        var m = url.match(/\.(json|jsonp|html|xml)(\?|$)/);
        return m ? m[1] : 'js';
    }

    function isCrossDomain(url) {
        var parts = rurl.exec(url.toLowerCase());
        return !!(parts &&
                (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
                    (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !==
                        (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443')))
            );
    }

    function doRequest(o) {

        if (!('crossDomain' in o)) {
            o.crossDomain = isCrossDomain(o.url);
        }

        var self = {};
        self.promise = new Promise(function(resolve, reject) {
            self.abort = function() {
                self._aborted = true;
                reject('aborted');
            };

            self.url = o.url;
            self.timeout = null;
            self.options = o;

            self._aborted = false;
            self._erred = false;
            self._responseArgs = {};

            var type = o.type === 'jsonp' ? o.type : (o.dataType || setType(self.url));

            if (o.timeout) {
                self.timeout = setTimeout(function() {
                    self.abort();
                }, o.timeout);
            }

            function complete(resp) {
                if (o.timeout) {
                    clearTimeout(self.timeout);
                }
                self.timeout = null;
                if (self._erred) {
                    reject(resp);
                } else {
                    resolve(resp);
                }
            }

            function success(resp) {
                resp = (type !== 'jsonp') ? self.request : resp;
                // use global data filter on response text
                var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type),
                    r = filteredResponse;

                try {
                    resp.responseText = r;
                } catch (e) {
                    // can't assign this in IE<=8, just ignore
                }
                /* eslint-disable no-eval */
                if (r) {
                    switch (type) {
                        case 'json':
                            try {
                                resp = win.JSON.parse(r);
                            } catch (err) {
                                return error(resp, 'Could not parse JSON in response', err);
                            }
                            break;
                        case 'js':
                            resp = eval('(' + r + ')');
                            break;
                        case 'html':
                            resp = r;
                            break;
                        case 'xml':
                            resp = resp.responseXML && resp.responseXML.parseError && resp.responseXML.parseError.errorCode && resp.responseXML.parseError.reason ? null : resp.responseXML;
                            break;
                    }
                }
                /* eslint-enable no-eval */
                self._responseArgs.resp = resp;
                complete(resp);
            }

            function error(resp, msg, t) {
                resp = self.request;
                self._responseArgs.resp = resp;
                self._responseArgs.msg = msg;
                self._responseArgs.t = t;
                self._erred = true;
                complete(resp);
            }

            self.request = getRequest.call(self, success, error);
        });

        return self;
    }

    function Ajax(url, options) {

        if (Object.prototype.toString.call(url) === '[object Object]') {
            options = url;
            url = undefined;
        }
        options = options || {};
        options.url = url || options.url;

        var requestPromise = doRequest(options),
            resultPromise = requestPromise.promise;

        if (options.success || options.error || options.complete) {
            resultPromise.then(options.success, options.error);
        }

        resultPromise.abort = requestPromise.abort;

        return resultPromise;
    }

    Ajax.setup = function(options) {
        options = options || {};
        for (var k in options) {
            if (options.hasOwnProperty(k)) {
                globalSetupOptions[k] = options[k];
            }
        }
    };

    Ajax.toQueryString = function(o, trad) {
        var prefix, i,
            traditional = trad || false,
            s = [],
            enc = encodeURIComponent,
            add = function(key, value) {
                // If value is a function, invoke it and return its value
                if (typeof value == 'function') {
                    value = value();
                } else {
                    value = value || '';
                }

                s[s.length] = enc(key) + '=' + enc(value);
            };

        // If an array was passed in, assume that it is an array of form elements.
        if (DG.Util.isArray(o)) {
            for (i = 0; o && i < o.length; i++) {
                add(o[i].name, o[i].value);
            }
        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in o) {
                if (o.hasOwnProperty(prefix)) {
                    buildParams(prefix, o[prefix], traditional, add);
                }
            }
        }

        // spaces should be + according to spec
        return s.join('&').replace(/%20/g, '+');
    };

    var testxhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;

    Ajax.corsSupport = !(!(testxhr && 'withCredentials' in testxhr) && !win[xDomainRequest]) &&
        // cors not available in IE and with cyrillic domain
        !(DG.Browser.ie && document.location.host.toLowerCase().search(/[-]/) != -1);

    return Ajax;
})();

DG.Wkt = {};

DG.Wkt.toGeoJSON = function (data) {
    if (DG.Util.isArray(data)) {
        data = data[0];
    }
    var parts = data.split(';');
    data = parts.pop();

    var i = 0,
        srid = (parts.shift() || '').split('=').pop();

    function $(re) {
        var match = data.substring(i).match(re);
        if (!match) {
            return null;
        }
        else {
            i += match[0].length;
            return match[0];
        }
    }

    function crs(obj) {
        if (obj && srid.match(/\d+/)) {
            obj.crs = {
                type: 'name',
                'properties': {
                    name: 'urn:ogc:def:crs:EPSG::' + srid
                }
            };
        }

        return obj;
    }

    function white() { $(/^\s*/); }

    function multicoords() {
        white();
        var depth = 0, rings = [], stack = [rings],
            pointer = rings, elem;
        while (elem =
            $(/^(\()/) ||
            $(/^(\))/) ||
            $(/^(\,)/) ||
            $(/^[-+]?([0-9]*\.[0-9]+|[0-9]+)/)) {
            if (elem === '(') {
                stack.push(pointer);
                pointer = [];
                stack[stack.length - 1].push(pointer);
                depth++;
            } else if (elem === ')') {
                pointer = stack.pop();
                depth--;
                if (depth === 0) {
                    break;
                }
            } else if (elem === ',') {
                pointer = [];
                stack[stack.length - 1].push(pointer);
            } else {
                pointer.push(parseFloat(elem));
            }
            white();
        }
        stack.length = 0;
        if (depth !== 0) {
            return null;
        }
        return rings;
    }

    function coords() {
        var list = [], item, pt;
        while (pt =
            $(/^[-+]?([0-9]*\.[0-9]+|[0-9]+)/) ||
            $(/^(\,)/)) {
            if (pt === ',') {
                list.push(item);
                item = [];
            } else {
                if (!item) {
                    item = [];
                }
                item.push(parseFloat(pt));
            }
            white();
        }
        if (item) {
            list.push(item);
        }
        return list.length ? list : null;
    }

    function point() {
        if (!$(/^(point)/i)) { return null; }
        white();
        if (!$(/^(\()/)) { return null; }
        var c = coords();
        white();
        if (!$(/^(\))/)) { return null; }
        return {
            type: 'Point',
            coordinates: c[0]
        };
    }

    function multipoint() {
        if (!$(/^(multipoint)/i)) { return null; }
        white();
        var c = multicoords();
        white();
        return {
            type: 'MultiPoint',
            coordinates: c
        };
    }

    function multilinestring() {
        if (!$(/^(multilinestring)/i)) { return null; }
        white();
        var c = multicoords();
        white();
        return {
            type: 'MultiLineString',
            coordinates: c
        };
    }

    function linestring() {
        if (!$(/^(linestring)/i)) { return null; }
        white();
        if (!$(/^(\()/)) { return null; }
        var c = coords();
        if (!$(/^(\))/)) { return null; }
        return {
            type: 'LineString',
            coordinates: c
        };
    }

    function polygon() {
        if (!$(/^(polygon)/i)) { return null; }
        white();
        return {
            type: 'Polygon',
            coordinates: multicoords()
        };
    }

    function multipolygon() {
        if (!$(/^(multipolygon)/i)) { return null; }
        white();
        return {
            type: 'MultiPolygon',
            coordinates: multicoords()
        };
    }

    function geometrycollection() {
        var geometries = [], geometry;

        if (!$(/^(geometrycollection)/i)) { return null; }
        white();

        if (!$(/^(\()/)) { return null; }
        while (geometry = root()) {
            geometries.push(geometry);
            white();
            $(/^(\,)/);
            white();
        }
        if (!$(/^(\))/)) { return null; }

        return {
            type: 'GeometryCollection',
            geometries: geometries
        };
    }

    function root() {
        return point() ||
            linestring() ||
            polygon() ||
            multipoint() ||
            multilinestring() ||
            multipolygon() ||
            geometrycollection();
    }

    return crs(root());
};

DG.Wkt.geoJsonLayer = function (data, opts) {
    return DG.geoJson(DG.Wkt.toGeoJSON(data), opts);
};

DG.Wkt._coordsToLatLngs = function (coords) {
    if (DG.Util.isArray(coords) && !DG.Util.isArray(coords[0])) {
        return [DG.GeoJSON.coordsToLatLng(coords)];
    }

    return coords.map(function (el) {
            return DG.Wkt._coordsToLatLngs(el);
        })
        .reduce(function (arr, coord) {
            return arr.concat(coord);
        });
};

DG.Wkt.toLatLngs = function (data) {
    if (!DG.Util.isArray(data)) {
        data = [data];
    }

    return data.map(function (el) {
        var coords = DG.Wkt.toGeoJSON(el).coordinates;

        return DG.Wkt._coordsToLatLngs(coords);
    }).reduce(function (arr, coord) {
        return arr.concat(coord);
    });
};

DG.Wkt.toPoints = function (data) {
    return DG.Wkt.toGeoJSON(data).coordinates;
};

DG.Wkt.pointsToLatLngOnMap = function (wkt, map) {
    return (function parsePoints(points) {
        return (Array.isArray(points) && Array.isArray(points[0])) ?
            points.map(parsePoints) :
            map.containerPointToLatLng(points);
    })(DG.Wkt.toPoints(wkt));
};

DG.ProjectDetector = DG.Handler.extend({
    initialize: function(map) { // (Object)
        this._map = map;
        this._osmViewport = false;
        this._project = undefined;
        this._loadProjectList();
    },

    addHooks: function() {
        this._map.on('move', this._projectWatch, this);
    },

    removeHooks: function() {
        this._map.off('move', this._projectWatch, this);
    },

    getProject: function() {
        if (!this._project) { return false; }

        return DG.Util.extend({}, this._project);
    },

    getProjectsList: function() {
        return this._projectList.slice(0);
    },

    isProjectHere: function(coords, project, checkMethod) {
        if (!coords) { return null; }

        if (!(coords instanceof DG.LatLng) && !(coords instanceof DG.LatLngBounds)) {
            coords = DG.latLng(coords);
        }

        coords = (coords instanceof DG.LatLngBounds) ?
            DG.latLngBounds(coords.getSouthWest().wrap(), coords.getNorthEast().wrap()) : coords.wrap();

        checkMethod = checkMethod || ((coords instanceof DG.LatLngBounds) ?  'intersects' : 'contains');

        var method = checkMethod == 'intersects' ? this._testProjectIntersects : this._testProjectContains;
        method = method.bind(this, coords);

        if (project) {
            return method(project);
        } else {
            return this._projectList.filter(method)[0];
        }
    },

    _projectWatch: function() {
        if (this._osmViewport === (this._project && this._centerInProject(this._project, 'contains'))) {
            this._osmViewport = !this._osmViewport;
            this._map.attributionControl._update(null, this._osmViewport);
        }

        if (this._project && this._zoomInProject(this._project) && this._centerInProject(this._project)) {
            return;
        }

        this._searchProject();

        if (this._project) {
            if (this._osmViewport === (this._project && this._centerInProject(this._project, 'contains'))) {
                this._osmViewport = !this._osmViewport;
            }
            this._map.attributionControl._update(null, this._osmViewport, this._project.country_code);
        }
    },

    _checkProjectData: function(project) {
        function check(value) {
            return value !== undefined && value !== null;
        }

        return project &&
                project.bounds &&
                check(project.code) &&
                check(project.domain) &&
                check(project.country_code) &&
                project.zoom_level &&
                    check(project.zoom_level.min) &&
                    check(project.zoom_level.max) &&
                project.time_zone &&
                    check(project.time_zone.offset);
    },

    _loadProjectList: function() {
        DG.fallbackProjectsList = DG.fallbackProjectsList || [];

        if (!DG.projectsList) {
            DG.projectsList = DG.fallbackProjectsList;
        }
        delete DG.fallbackProjectsList;

        this._projectList = DG.projectsList
            .filter(this._checkProjectData)
            .map(function(project) {
                var bound = DG.Wkt.toGeoJSON(project.bounds);
                var latLngBounds = DG.geoJSON(bound).getBounds();
                var defaultPos = project.default_pos ? DG.latLng(project.default_pos.lat, project.default_pos.lon) : null;


                /* eslint-disable camelcase */
                return {
                    id: project.id,
                    code: project.code,
                    minZoom: project.zoom_level.min,
                    maxZoom: project.zoom_level.max,
                    timeOffset: project.time_zone.offset,
                    bound: bound,
                    latLngBounds: latLngBounds,
                    traffic: !!project.flags.traffic,
                    transport: !!project.flags.public_transport,
                    roads: !!project.flags.road_network,
                    country_code: project.country_code,
                    domain: project.domain,
                    defaultPos: defaultPos
                };
                /* eslint-enable camelcase */
            });
    },

    _searchProject: function() {
        //     
        var filteredByZoom = this._projectList.filter(this._zoomInProject, this);

        //        
        var foundProjects = filteredByZoom.filter(this._centerInProject, this);

        //     ,         
        if (foundProjects.length === 0) {
            var mapBounds = this._map.getBounds();
            foundProjects = filteredByZoom.filter(DG.bind(this._testProjectIntersects, this, mapBounds));

            if (foundProjects.length > 1) {
                var mapCenter = this._map.getCenter();
                var neareastProject = foundProjects[0];
                for (var i = 1; i < foundProjects.length; i++) {
                    var currentProject = foundProjects[i];
                    if (currentProject.defaultPos &&
                        mapCenter.distanceTo(neareastProject.defaultPos) >
                        mapCenter.distanceTo(currentProject.defaultPos)
                    ) {
                        neareastProject = currentProject;
                    }
                }
                foundProjects = [neareastProject];
            }
        }

        var newProject = foundProjects[0] || null;

        if (this._project === newProject) {
            return;
        }

        var self = this;

        if (this._project !== null) {
            this._project = null;
            setTimeout(function() {
                self._map.fire('projectleave');
            }, 1);
        }

        if (newProject) {
            this._project = newProject;
            setTimeout(function() {
                self._map.fire('projectchange', {getProject: self.getProject.bind(self)});
            }, 1);
        }
    },

    _testProjectIntersects: function(bounds, project) {
        return project.latLngBounds.intersects(bounds);
    },

    _testProjectContains: function(latlng, project) {
        return DG.PolyUtil.inside([latlng.lng, latlng.lat], project.bound);
    },

    _centerInProject: function(project, checkMethod) {
        return this.isProjectHere(this._map.getCenter(), project, checkMethod);
    },

    _zoomInProject: function(project) {
        return (this._map.getZoom() >= project.minZoom);
    }
});

DG.Map.mergeOptions({
    projectDetector: true
});

DG.Map.addInitHook('addHandler', 'projectDetector', DG.ProjectDetector);

/*
 * Utility functions
 */

DG.Metric = function() {};

/*
 * DG.Metric.Segments class can calculate total pushed segments length and used to shortcut
 * 'get Something by provided Length' calculations (segment's Index, segment's Length, etc...)
 */
DG.Metric.Segments = function() {
    this.length = 0;
};

DG.Metric.Segments.prototype = {
    push: function(len) {
        this[this.length] = this.length > 0 ? this[this.length - 1] + len : len;
        this.length += 1;

        return this;
    },

    getLength: function() {
        return this[this.length - 1];
    },

    getReverse: function() {
        var segments = new DG.Metric.Segments();
        var i = this.length - 1;

        if (i < 0) { return segments; }

        while (i--) {
            segments.push(this[i + 1] - this[i]);
        }

        return segments.push(this[0]);
    },

    getIndex: function(len) {
        var i = this.length - 1;

        if (i < 0) { return i; }

        while (i--) {
            if (this[i] <= len) { break; }
        }

        return i + 1;
    },

    getSegRatio: function(len) {
        var i = this.getIndex(len);
        var sub = i > 0 ? this[i - 1] : 0;

        return (len - sub) / (this[i] - sub);
    },

    getSegLength: function(len) {
        var i = this.getIndex(len);
        var sub = i > 0 ? this[i - 1] : 0;

        return len - sub;
    }
};

/*
 * DG.VertexTransform is a classic 2D matrix transformation class
 *
 * Prototype methods can scale/rotate/translate vertices
 *
 * Static methods do the same but return simple array instances with attached
 * .clone() method which can reconstruct full DG.VertexTransform object
 */

DG.VertexTransform = DG.Class.extend({
    initialize: function(vertices) {
        this._vertices = vertices;

        this._scale = null;
        this._angle = null;
        this._trans = null;
        this._matrix = null;

        this.load();
    },

    load: function() {
        this.vertices = this._vertices.map(function(vertex) { return vertex.clone(); });
        this.vertices.clone = DG.VertexTransform.clone;

        return this;
    },

    save: function() {
        this._vertices = this.vertices.map(function(vertex) { return vertex.clone(); });

        return this;
    },

    setScale: function(scale) {
        this._scale = scale;
        return this;
    },

    getScale: function() {
        return this._scale;
    },

    setAngle: function(angle) {
        this._angle = angle;
        return this;
    },

    getAngle: function() {
        return this._angle;
    },

    setTranslation: function(trans) {
        this._trans = trans;
        return this;
    },

    getTranslation: function() {
        return this._trans;
    },

    setMatrix: function(matrix) {
        this._matrix = matrix;
        return this;
    },

    getMatrix: function() {
        return this._matrix;
    },

    scale: function(scale) {
        var v = this.vertices;
        var i = v.length;

        scale = scale || this._scale || 1;
        while (i--) {
            v[i].x *= scale;
            v[i].y *= scale;
        }

        return this;
    },

    unScale: function(scale) {
        scale = scale || this._scale || 1;      //  Also safeguard against zero scale
        return this.scale(1 / scale);
    },

    rotate: function(angle) {
        var cos = angle ? angle.cos : (this._angle ? this._angle.cos : 1);
        var sin = angle ? angle.sin : (this._angle ? this._angle.sin : 0);
        var v = this.vertices;
        var i = v.length;
        var x, y;

        while (i--) {
            x = v[i].x;
            y = v[i].y;
            v[i].x = x * cos - y * sin;
            v[i].y = x * sin + y * cos;
        }

        return this;
    },

    unRotate: function(angle) {
        var cos = angle ? angle.cos : (this._angle ? this._angle.cos : 1);
        var sin = angle ? angle.sin : (this._angle ? this._angle.sin : 0);

        return this.rotate({cos: cos, sin: -sin});
    },

    translate: function(trans) {
        var dx = trans ? trans.x : (this._trans ? this._trans.x : 0);
        var dy = trans ? trans.y : (this._trans ? this._trans.y : 0);
        var v = this.vertices;
        var i = v.length;

        while (i--) {
            v[i].x += dx;
            v[i].y += dy;
        }

        return this;
    },

    unTranslate: function(trans) {
        var dx = trans ? trans.x : (this._trans ? this._trans.x : 0);
        var dy = trans ? trans.y : (this._trans ? this._trans.y : 0);

        return this.translate({x: -dx, y: -dy});
    },

    transform: function(matrix) {
        var a, b, c, d, dx, dy;
        var v = this.vertices;
        var i = v.length;
        var x, y;

        if (matrix) {
            a = matrix[0]; b = matrix[1]; dx = matrix[2];
            c = matrix[3]; d = matrix[4]; dy = matrix[5];
        } else if (this._matrix) {
            a = this._matrix[0]; b = this._matrix[1]; dx = this._matrix[2];
            c = this._matrix[3]; d = this._matrix[4]; dy = this._matrix[5];
        } else {
            a = 1; b = 0; dx = 0;
            c = 0; d = 1; dy = 0;
        }

        while (i--) {
            x = v[i].x;
            y = v[i].y;
            v[i].x = x * a + y * b + dx;
            v[i].y = x * c + y * d + dy;
        }

        return this;
    },

    statics: {
        scale: function(vt, scale) {
            var v = vt.vertices;
            var result = [];
            var x, y;

            scale = scale || 1;
            for (var i = 0; i < v.length; i++) {
                x = v[i].x * scale;
                y = v[i].y * scale;
                result.push(new DG.Point(x, y));
            }
            result.clone = DG.VertexTransform.clone;

            return result;
        },

        unScale: function(vt, scale) {
            scale = scale || 1;         //  Also safeguard against zero scale
            return DG.VertexTransform.scale(vt, 1 / scale);
        },

        rotate: function(vt, angle) {
            var cos = angle ? angle.cos : 1;
            var sin = angle ? angle.sin : 0;
            var v = vt.vertices;
            var x, y, rx, ry;
            var result = [];

            for (var i = 0; i < v.length; i++) {
                rx = v[i].x;
                ry = v[i].y;
                x = rx * cos - ry * sin;
                y = rx * sin + ry * cos;
                result.push(new DG.Point(x, y));
            }
            result.clone = DG.VertexTransform.clone;

            return result;
        },

        unRotate: function(vt, angle) {
            var cos = angle ? angle.cos : 1;
            var sin = angle ? angle.sin : 0;

            return DG.VertexTransform.rotate(vt, {cos: cos, sin: -sin});
        },

        translate: function(vt, trans) {
            var dx = trans ? trans.x : 0;
            var dy = trans ? trans.y : 0;
            var v = vt.vertices;
            var result = [];
            var x, y;

            for (var i = 0; i < v.length; i++) {
                x = v[i].x + dx;
                y = v[i].y + dy;
                result.push(new DG.Point(x, y));
            }
            result.clone = DG.VertexTransform.clone;

            return result;
        },

        unTranslate: function(vt, trans) {
            var dx = trans ? trans.x : 0;
            var dy = trans ? trans.y : 0;

            return DG.VertexTransform.translate(vt, {x: -dx, y: -dy});
        },

        clone: function() {
            //  'this' is an array
            return new DG.VertexTransform(this).save();
        },

        getLength: function(vec1, vec2) {
            var dx, dy;

            if (typeof vec1 === 'number') {
                //  'vec1' and 'vec2' are absolute coordinates of vector
                return Math.sqrt(vec1 * vec1 + vec2 * vec2);
            } else {
                //  'vec1' and 'vec2' are vector objects
                dx = vec2.x - vec1.x;
                dy = vec2.y - vec1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        },

        getScaled: function(vec1, vec2, scale) {
            var dx, dy;

            if (typeof vec1 === 'number') {
                //  'vec1' and 'vec2' are absolute coordinates of vector
                return new DG.Point(vec1 * scale, vec2 * scale);
            } else {
                //  'vec1' and 'vec2' are vector objects
                dx = (vec2.x - vec1.x) * scale;
                dy = (vec2.y - vec1.y) * scale;
                return new DG.Point(vec1.x + dx, vec1.y + dy);
            }
        },

        getAngle: function(vec1, vec2, origin) {
            var l, sp, x1, y1, x2, y2;

            if (typeof vec1 === 'number') {
                //  'vec1' and 'vec2' are absolute coordinates of vector
                l = Math.sqrt(vec1 * vec1 + vec2 * vec2);
                if (l > 0) {
                    return {cos: vec1 / l, sin: vec2 / l};
                } else {
                    return {cos: 1, sin: 0};
                }
            } else {
                //  'vec1' and 'vec2' are vector objects
                x1 = vec1.x; y1 = vec1.y;
                x2 = vec2.x; y2 = vec2.y;
                if (origin) {
                    x1 -= origin.x; y1 -= origin.y;
                    x2 -= origin.x; y2 -= origin.y;
                }
                sp = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2);
                return {
                    cos: (x1 * x2 + y1 * y2) / sp,
                    sin: (x1 * y2 - x2 * y1) / sp
                };
            }
        },

        getAnglesSum: function(angle1, angle2) {
            return {
                cos: angle1.cos * angle2.cos - angle1.sin * angle2.sin,
                sin: angle1.sin * angle2.cos + angle1.cos * angle2.sin
            };
        },

        getAnglesDif: function(angle1, angle2) {
            return {
                cos: angle1.cos * angle2.cos + angle1.sin * angle2.sin,
                sin: angle1.sin * angle2.cos - angle1.cos * angle2.sin
            };
        }
    }
});

/*
 * DG.ArrowPathTransform class is a core of arrow's body calculations
 *
 * General ideas are:
 *      We construct arrow body with stroke points making arcs on outer path turns
 *      Processing is done segment by segment around {0, 0} virtual point
 *          and resulting 'path' finally rotated to it's original map's angle (.fullAngle)
 *      Subset of this vertices lately used in .subPath() calculations which can be used
 *          in animations for ex.
 *
 *  Final translation (see DG.Entrance.Arrow) moves arrow objects to their original positions
 */

DG.ArrowPathTransform = DG.VertexTransform.extend({
    initialize: function(path) {
        //  'path.offset' is initial points offset (-x / +x) to compensate arrow tip length

        //  Skip super initialization as we need only subset of DG.VertexTransform power
        this._lengths = new DG.Metric.Segments();
        this._vertices = [[], []];
        this._drawings = [[], []];
        //  this._arcs = [];    //  initialized in _setPath()

        this._setPath(path);
        this.subPath(1);
    },

    load: function() {
        return this.subPath(1);
    },

    save: function() {
        return this;    //  NoOp
    },

    //  Method constructs new path points with some displacement from original 'path'
    //  Outer corners will be smoothed by arcs (cubic Bzier curves)
    _setPath: function(path) {
        var transform = DG.ArrowPathTransform.transform;
        var vertices = this._vertices;
        var drawings = this._drawings;
        var Point = DG.Point;
        var width = path.width;
        var arcs = [[], [], []];
        var lengths = [];

        var i, x,
            ax, bx, cx,
            angles, angle;

        vertices.push(path.vertices);   //  expect .pop() in final transform
        vertices[0].push(new DG.Point(path.offset, +width));
        vertices[1].push(new DG.Point(path.offset, -width));
        angles = DG.ArrowPathTransform.getAngles(path);

        cx = -path.offset;
        for (i = 0; i < angles.length; i++) {
            x = path.vertices[i + 1].x;
            ax = width * angles[i].cot;

            //  http://pomax.github.io/bezierinfo/#circles_cubic
            //  actual equation is (4/3 * tan(/4) * radius)
            bx = angles[i].tan * width * 8 / 3;

            //  Next code can be combined by -/+ inversion but for simplicity it is left as is
            if (ax > 0) {
                vertices[0].push(new Point(x + ax,      +width));
                drawings[0].push('L');

                arcs[2].push(1);
                arcs[1].push(vertices[1].length);
                vertices[1].push(new Point(x + ax,      -width));
                vertices[1].push(new Point(x + ax - bx, -width));

                transform(vertices, angles[i], {x: x, y: 0});

                vertices[1].push(new Point(0 - ax + bx, -width));
                vertices[1].push(new Point(0 - ax,      -width));
                drawings[1].push('L', 'C');

                lengths.push(Math.abs(x + ax) - cx); cx = +ax;
            } else {
                vertices[1].push(new Point(x - ax,      -width));
                drawings[1].push('L');

                arcs[2].push(0);
                arcs[0].push(vertices[0].length);
                vertices[0].push(new Point(x - ax,      +width));
                vertices[0].push(new Point(x - ax + bx, +width));

                transform(vertices, angles[i], {x: x, y: 0});

                vertices[0].push(new Point(0 + ax - bx, +width));
                vertices[0].push(new Point(0 + ax,      +width));
                drawings[0].push('L', 'C');

                lengths.push(Math.abs(x - ax) - cx); cx = -ax;
            }
        }

        //  Final segments and tail arc
        ax = path.vertices[i + 1].x;
        bx = width * 4 / 3; // tan(PI/4) = 1

        vertices[0].push(new Point(ax, +width));
        vertices[1].push(new Point(ax, -width));

        vertices[0].push(new Point(ax - bx, +width));
        vertices[1].push(new Point(ax - bx, -width));

        drawings[0].push('L');
        drawings[1].push('L');

        lengths.push(Math.abs(ax) - cx);

        //  Reverse right path
        vertices[1].reverse();
        drawings[1].reverse();

        //  Move vertices into original position (before last translation)
        angle = DG.VertexTransform.getAnglesSum(angles.fullAngle, path.getAngle());
        transform(vertices, angle, vertices.pop()[0]);  //  path.vertices[0]

        //  We need to reconstruct arc's indexes but too many variables already touched, reuse some of them
        ax = vertices[0].length;
        bx = vertices[1].length;
        this._arcs = arcs[2].map(function(i) {
            cx = arcs[i].shift();
            if (i > 0) {
                return new DG.ArcBezier(vertices[1].slice(bx - cx - 4, bx - cx));
            } else {
                return new DG.ArcBezier(vertices[0].slice(cx, cx + 4).reverse());
            }
        }).reverse();

        this._lengths.push(lengths.pop());
        lengths.reverse().forEach(function(l, i) {
            this._lengths.push(this._arcs[i].getLength()).push(l);
        }, this);

        //  Shortcut border cases (0%-length sub-path and full-path)
        this[0] = {
            vertices: [vertices[0][ax - 2], vertices[0][ax - 1], vertices[1][0], vertices[1][1]],
            drawings: ['M', 'C']
        };
        this[1] = {
            vertices: vertices[0].concat(vertices[1]),
            drawings: ['M'].concat(drawings[0], 'C', drawings[1])
        };
    },

    _setAngleAndDisplacement: function(vL, vR) { // Used in DG.ArrowTipTransform.subShape()
        this.angle = DG.VertexTransform.getAngle({x: vL.x - vR.x, y: vL.y - vR.y}, {x: 0, y: 1});
        this.displ = vR.clone();
    },

    subPath: function(pathRatio) {
        pathRatio = pathRatio > 1 ? 1 : pathRatio;

        //  Shortcut border cases (0%-length sub-path and full-path)
        if (pathRatio === 0 || pathRatio === 1) {
            this.vertices = this[pathRatio].vertices.map(function(vertex) { return vertex.clone(); });
            this.drawings = this[pathRatio].drawings;
            this._setAngleAndDisplacement(this.vertices[0], this.vertices[this.vertices.length - 1]);
            return this;
        }

        var getScaled = DG.VertexTransform.getScaled;
        var vertices = this._vertices;
        var drawings = this._drawings;
        var lengths = this._lengths;
        var len = lengths.getLength() * pathRatio;
        var segIndex = lengths.getIndex(len);
        var segRatio = lengths.getSegRatio(len);
        var vertexIndexLeft = vertices[0].length - 2;
        var vertexIndexRight = 1;
        var drawingIndexLeft = drawings[0].length - 1;
        var drawingIndexRight = 0;
        var vertexLeft, vertexRight;
        var arc = 0, aed = 0;

        while (aed++ < segIndex) {
            if (aed % 2 == 1) {
                vertexIndexLeft--;
                drawingIndexLeft--;
                vertexIndexRight++;
                drawingIndexRight++;
            } else {
                if (drawings[0][drawingIndexLeft] === 'C') {
                    vertexIndexLeft -= 3;
                    drawingIndexLeft -= 1;
                } else {
                    vertexIndexRight += 3;
                    drawingIndexRight += 1;
                }
                arc++;
            }
        }

        if (segIndex % 2 == 1) {
            //  One path ends with an arc
            arc = this._arcs[arc];
            if (drawings[0][drawingIndexLeft] === 'C') {
                arc = arc.getCurveBefore(arc.getTbyL(lengths.getSegLength(len)));
                vertexLeft = arc.points[3];
                vertexRight = vertices[1][vertexIndexRight];
                this.vertices = arc.points.slice(1).reverse()
                    .concat(vertices[0].slice(vertexIndexLeft), vertices[1].slice(0, vertexIndexRight + 1))
                    .map(function(vertex) { return vertex.clone(); });
                this.drawings = ['M'].concat(drawings[0].slice(drawingIndexLeft), 'C', drawings[1].slice(0, drawingIndexRight));
            } else {
                arc = arc.getCurveBefore(arc.getTbyL(lengths.getSegLength(len)));
                vertexLeft = vertices[0][vertexIndexLeft];
                vertexRight = arc.points[3];
                this.vertices = vertices[0].slice(vertexIndexLeft)
                    .concat(vertices[1].slice(0, vertexIndexRight + 1), arc.points.slice(1))
                    .map(function(vertex) { return vertex.clone(); });
                this.drawings = ['M'].concat(drawings[0].slice(drawingIndexLeft + 1), 'C', drawings[1].slice(0, drawingIndexRight + 1));
            }
        } else {
            //  Both paths end with lines
            vertexLeft = getScaled(vertices[0][vertexIndexLeft], vertices[0][vertexIndexLeft - 1], segRatio);
            vertexRight = getScaled(vertices[1][vertexIndexRight], vertices[1][vertexIndexRight + 1], segRatio);
            this.vertices = [vertexLeft]
                .concat(vertices[0].slice(vertexIndexLeft), vertices[1].slice(0, vertexIndexRight + 1), vertexRight)
                .map(function(vertex) { return vertex.clone(); });
            this.drawings = ['M'].concat(drawings[0].slice(drawingIndexLeft), 'C', drawings[1].slice(0, drawingIndexRight + 1));
        }

        this._setAngleAndDisplacement(vertexLeft, vertexRight);
        return this;
    },

    statics: {
        getAngles: function(path) {
            var getAngle = DG.VertexTransform.getAngle;
            var fullAngle = {cos: 1, sin: 0};
            var vertices = path.vertices;
            var angles = [];

            var absSin, angle,
                cos, sin, cot, temp, sign;

            for (var i = 1, len = vertices.length - 1; i < len; i++) {
                angle = getAngle(vertices[i - 1], vertices[i + 1], vertices[i]);

                absSin = Math.abs(angle.sin);
                if (absSin < 0.000001) {
                    //  Exclude 180 angle from vertices array
                    vertices.splice(vertices.length - i - 1, 1);
                    len--;
                    i--;
                } else {
                    //  This is half  cotangent, sign describes angle direction and used to shortcut stroke calculations
                    //  '-1' - right angle is inner angle, '1' - left angle is inner angle (if seen from [0, 0] to [-1, 0])
                    angle.cot = (1 + angle.cos) / angle.sin;

                    //  We need to rotate next segment to [-1, 0] axis, so we need complementary angle actually
                    angle.cos = -angle.cos;

                    //  Complimentary angle also used to calculate it's quaternary  tangent
                    //   tangent used in approximation of outer arc segment by Bzier curve
                    cot = (1 + angle.cos) / angle.sin;
                    sign = cot < 0 ? -1 : 1;
                    temp = sign * Math.sqrt(4 * cot * cot + 4);
                    angle.tan = -0.5 * (cot + cot - temp);

                    angles.push(angle);

                    cos = fullAngle.cos * angle.cos - fullAngle.sin * angle.sin;
                    sin = fullAngle.sin * angle.cos + fullAngle.cos * angle.sin;

                    fullAngle = {cos: cos, sin: sin};
                }
            }

            //  Used in final stroke points translation
            angles.fullAngle =  {cos: fullAngle.cos, sin: -fullAngle.sin};
            return angles;
        },

        //  TODO - if length of 'latlngs' array is less than 2 or it is undefined next function produces exception
        //  check this condition in outer routines?!
        getTranslatedPath: function(map, latlngs) {
            var path = new DG.VertexTransform([]);
            var i = latlngs.length - 1;
            var v = map.project(latlngs[i]);
            var dx = v.x, dy = v.y;

            path.vertices.push(new DG.Point(0, 0));
            while (i--) {
                v = map.project(latlngs[i]);
                path.vertices.push(new DG.Point(v.x - dx, v.y - dy));
            }
            return path
                .setAngle(DG.VertexTransform.getAngle(-path.vertices[1].x, -path.vertices[1].y))
                .unRotate();
        },

        transform: function(rings, angle, vector) {
            var i = rings.length;
            var cos = angle.cos;
            var sin = angle.sin;
            var dx = vector.x;
            var dy = vector.y;
            var ring, x, y, j;

            while (i--) {
                ring = rings[i];
                j = ring.length;
                while (j--) {
                    x = ring[j].x - dx;
                    y = ring[j].y - dy;
                    ring[j].x = x * cos - y * sin;
                    ring[j].y = x * sin + y * cos;
                }
            }
        }
    }
});

/*
 * DG.ArrowTipTransform class is a core of arrow's tip calculations
 *
 * .subShape() routine 'bound' arrow's tip to the ending points of .subPath()
 * calculated separately in DG.ArrowPathTransform
 *
 *  Final translation (see DG.Entrance.Arrow) moves arrow objects to their original positions
 */

DG.ArrowTipTransform = DG.VertexTransform.extend({
    initialize: function(path, shape) {
        this.drawings = shape.drawings; //  static mapping
        this._vertices = shape.vertices;

        this._setShape(path, shape);
    },

    _setShape: function(path, shape) {
        var sp = shape.vertices[0];
        var width = Math.abs(sp.y);
        var pl = path.vertices[1].x;    //  negative value
        var length = sp.x;              //  negative value
        var offset = pl - length + width + width;

        path.width = width;
        path.offset = length + (offset > 0 ? offset : 0);
        if (path.vertices.length < 3 && length > -10) {
            path.offset += 2.5;
        }

        this._vertices = this.load().unTranslate(sp).vertices;
    },

    subShape: function(transform) {
        this.load().unRotate(transform.angle).translate(transform.displ);
        return this;
    }
});

/*
 * DG.ComplexPath is a simple vector layer class with empty .getEvents() object(!)
 * It's drawing logic is maintained in DG.Entrance.Arrow class
 *
 * _pxBounds is a pixel bounds of this drawings and they are used in L.Canvas
 */

DG.ComplexPath = DG.Path.extend({
    options: {
        fill: true,
        fillOpacity: 1,
        interactive: false
    },

    initialize: function(options) {
        DG.setOptions(this, options);

        this._empty = [];

        this._pxEmpty = DG.bounds(
            DG.point(0, 0), DG.point(0, 0)
        );
        this._pxBounds = this._pxEmpty;

        this._vertices = [this._empty];
        this._drawings = [this._empty];
    },

    getEvents: function() {
        return {};
    },

    _project: function() {
        var opts = this.options,
            zoom, weight;

        if (this._map) {
            zoom = this._map.getZoom();
        } else {
            return;
        }

        if (opts.visibility.isShown && opts.transform[zoom]) {
            //  Next numbers was empirically selected in order to provide visual compliance
            //  to the original arrow's implementation
            weight = 2.2 - ((19 - zoom) * 0.2);
            if (opts.weight !== weight) {
                this.setStyle({weight: +weight.toFixed(2)});
            }

            this._vertices[0] = opts.transform[zoom].vertices;
            this._drawings[0] = opts.transform[zoom].drawings;

            this._pxBounds = opts.transform[zoom]._pxBounds;
        } else {
            this._vertices[0] = this._empty;
            this._drawings[0] = this._empty;

            this._pxBounds = this._pxEmpty;
        }
    },

    _update: function() {
        if (this._map) {
            this._updatePath();
        }
    },

    _updatePath: function() {  //  used in Canvas renderer
        this._renderer._updateComplexPath(this);
    }
});

/*
 * Actual painting methods that can draw complex objects with curves
 *
 * Point coordinates must be provided in layer._vertices object
 * And types of line must be provided in layer._drawings object
 */

DG.extend(L.Canvas.prototype, {
    _updateComplexPath: function(layer, closed) {
        var i, j, k, d, x, y, _x, _y, $x, $y, points;
        var drawings = layer._drawings;
        var vertices = layer._vertices;
        var ctx = this._ctx;

        this._drawnLayers[layer._leaflet_id] = layer;

        //  TODO: Do we need to do a 'beginPath()' and possible 'closePath()' per ring?!
        ctx.beginPath();

        for (i = 0; i < vertices.length; i++) {
            points = vertices[i];
            x = y = 0;
            j = k = 0;
            while (j < points.length) {
                d = drawings[i][k++];
                switch (d) {
                    case 'M':
                        x = points[j].x;
                        y = points[j].y;
                        j += 1;
                        ctx.moveTo(x, y);
                        break;

                    case 'm':
                        x += points[j].x;
                        y += points[j].y;
                        j += 1;
                        ctx.moveTo(x, y);
                        break;

                    case 'L':
                        x = points[j].x;
                        y = points[j].y;
                        j += 1;
                        ctx.lineTo(x, y);
                        break;

                    case 'l':
                        x += points[j].x;
                        y += points[j].y;
                        j += 1;
                        ctx.lineTo(x, y);
                        break;

                    case 'C':
                        _x = points[j].x;
                        _y = points[j].y;
                        j += 1;
                        $x = points[j].x;
                        $y = points[j].y;
                        j += 1;
                        x = points[j].x;
                        y = points[j].y;
                        j += 1;
                        ctx.bezierCurveTo(_x, _y, $x, $y, x, y);
                        break;

                    case 'c':
                        _x = x + points[j].x;
                        _y = y + points[j].y;
                        j += 1;
                        $x = x + points[j].x;
                        $y = y + points[j].y;
                        j += 1;
                        x = x + points[j].x;
                        y = y + points[j].y;
                        j += 1;
                        ctx.bezierCurveTo(_x, _y, $x, $y, x, y);
                        break;

                    case 'Q':
                        _x = points[j].x;
                        _y = points[j].y;
                        j += 1;
                        x = points[j].x;
                        y = points[j].y;
                        j += 1;
                        ctx.quadraticCurveTo(_x, _y, x, y);
                        break;

                    case 'q':
                        _x = x + points[j].x;
                        _y = y + points[j].y;
                        j += 1;
                        x = x + points[j].x;
                        y = y + points[j].y;
                        j += 1;
                        ctx.quadraticCurveTo(_x, _y, x, y);
                        break;
                }
            }
            if (closed) {
                ctx.closePath();
            }
        }

        this._fillStroke(ctx, layer);
    }
});


DG.extend(L.SVG.prototype, {
    _updateComplexPath: function(layer, closed) {
        this._setPath(layer, L.SVG.complexPointsToPath(layer._vertices, layer._drawings, closed));
    }
});


DG.extend(L.SVG, {
    complexPointsToPath: function(vertices, drawings, closed) {
        var str = '';
        var svg = DG.Browser.svg;
        var i, j, k, n, d, points;

        for (i = 0; i < vertices.length; i++) {
            points = vertices[i];

            //  Speedup hot path by removing if/ternary condition checks but duplicating loops
            if (svg) {
                j = k = 0;
                while (j < points.length) {
                    d = drawings[i][k++];
                    switch (d) {
                        case 'C':
                        case 'c':   n = 3; break;
                        case 'Q':
                        case 'q':   n = 2; break;

                        default:    n = 1;  //  'M', 'm', 'L', 'l', ...
                    }
                    str += d;
                    while (n--) {
                        str += points[j].x.toFixed(4) + ',' + points[j].y.toFixed(4) + ' ';
                        j += 1;
                    }
                }
            } else {
                //  vml in IE8 can support only integer values in 'path', sorry about loss of precision
                j = k = 0;
                while (j < points.length) {
                    d = drawings[i][k++];
                    switch (d) {
                        case 'M':   d = 'm'; n = 1; break;
                        case 'm':   d = 't'; n = 1; break;
                        case 'L':   d = 'l'; n = 1; break;
                        case 'l':   d = 'r'; n = 1; break;
                        case 'C':   d = 'c'; n = 3; break;
                        case 'c':   d = 'v'; n = 3; break;
                        case 'Q':
                            //  VML spec has 'qb' command in 'v' attribute string but no 'relativeTo' compliment
                            //  So we'll emulate Cubic Bzier curve by applying Quadratic variant in both cases
                            //  TODO: Both control points will use the same value but this is not true solution
                            str += 'C' +
                                points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' +
                                points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' +
                                points[j + 1].x.toFixed(0) + ',' + points[j + 1].y.toFixed(0) + ' ';
                            j += 2;
                            d = '';
                            n = 0;
                            break;
                        case 'q':
                            str += 'c' +
                                points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' +
                                points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' +
                                points[j + 1].x.toFixed(0) + ',' + points[j + 1].y.toFixed(0) + ' ';
                            j += 2;
                            d = '';
                            n = 0;
                            break;

                        default:    n = 1;
                    }
                    str += d;
                    while (n--) {
                        str += points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ';
                        j += 1;
                    }
                }
            }

            str += closed ? (svg ? 'z' : 'x') : '';
        }

        // SVG complains about empty path strings
        return str || 'm0,0';
    }
});

/*
 * DGBezierCurves is a collection of three classes:
 * Original DG.Bezier class provides basic math for Cubic and Quadratic Bzier curves
 * DG.TimeBezier used in animation effects it can return 'Distance' (Y) by Time (X) value
 * DG.ArcBezier can return 't' value by curve's segment length
 * Actual calculations can be very hard (in math terms) so we use LUT's to optimize them
 *
 * Original ideas come from this source:   https://pomax.github.io/bezierinfo/
 */

DG.Bezier = DG.Class.extend({
    /**
     * Initialize curve object by provided control points
     * @param {Array<DG.Point>} coords Curve's control points in DG.Point format (up to four control points supported)
     * @param {boolean} [clone] Clone original points or not (Default)
     */
    initialize: function(coords, clone) {
        if (clone) {
            this.points = coords.map(function(coord) { return coord.clone(); });
        } else {
            this.points = coords;
        }
        this.dpoints = this._getDerivatives();
        this.order = this.points.length - 1;
        this._lut = [];
    },

    getPoint: function(t) {
        var p = this.points;
        var mt, mt2, t2;
        var a, b, c, d;

        if (t === 0) { return p[0]; }
        if (t === 1) { return p[this.order]; }

        mt = 1 - t;
        mt2 = mt * mt;
        t2 = t * t;

        if (this.order > 2) {
            a = mt2 * mt;
            b = mt2 * t * 3;
            c = mt * t2 * 3;
            d = t * t2;
        } else {
            p = [p[0], p[1], p[2], {x: 0, y: 0}];
            a = mt2;
            b = mt * t * 2;
            c = t2;
            d = 0;
        }

        return new DG.Point(
            a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
            a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y
        );
    },

    derivative: function(t) {
        var p = this.dpoints[0];
        var mt = 1 - t;
        var a, b, c;

        if (this.order > 2) {
            a = mt * mt;
            b = mt * t * 2;
            c = t * t;
        } else {
            p = [p[0], p[1], {x: 0, y: 0}];
            a = mt; b = t; c = 0;
        }

        return new DG.Point(
            a * p[0].x + b * p[1].x + c * p[2].x,
            a * p[0].y + b * p[1].y + c * p[2].y
        );
    },

    getLength: function() {
        /* eslint-disable camelcase */
        var w_i = DG.Bezier.WEIGHT;
        var x_i = DG.Bezier.ABSCISSA;
        var z = 0.5;
        var sum = 0;
        var d, l, t;

        for (var i = 0; i < x_i.length; i++) {
            t = z * x_i[i] + z;
            d = this.derivative(t);
            l = d.x * d.x + d.y * d.y;
            sum += w_i[i] * Math.sqrt(l);
        }
        /* eslint-enable camelcase */

        return z * sum;
    },

    getCurveBefore: function(z) {
        var p = this.points;
        var z2, z3, mz, mz2, mz3;
        var b$3, b$4, c$4;
        var curve;

        if (z === 1) { return this.clone(); }

        curve = [];
        z2 = z * z;
        mz = z - 1;
        mz2 = mz * mz;

        curve[0] = new DG.Point(
            p[0].x,
            p[0].y
        );

        curve[1] = new DG.Point(
            z * p[1].x - mz * p[0].x,
            z * p[1].y - mz * p[0].y
        );

        b$3 = z * mz * 2;
        curve[2] = new DG.Point(
            z2 * p[2].x - b$3 * p[1].x + mz2 * p[0].x,
            z2 * p[2].y - b$3 * p[1].y + mz2 * p[0].y
        );

        if (this.order > 2) {
            z3 = z2 * z;
            mz3 = mz2 * mz;
            b$4 = z2 * mz * 3;
            c$4 = z * mz2 * 3;
            curve[3] = new DG.Point(
                z3 * p[3].x - b$4 * p[2].x + c$4 * p[1].x - mz3 * p[0].x,
                z3 * p[3].y - b$4 * p[2].y + c$4 * p[1].y - mz3 * p[0].y
            );
        }

        return new DG.Bezier(curve);
    },

    getCurveAfter: function(z) {
        var p = this.points;
        var n = this.order;
        var z2, z3, mz, mz2, mz3;
        var b$3, b$4, c$4;
        var curve;

        if (z === 1) { return this.clone(); }

        curve = [];
        z2 = z * z;
        mz = z - 1;
        mz2 = mz * mz;

        curve[n] = new DG.Point(
            p[n].x,
            p[n].y
        );

        curve[--n] = new DG.Point(
            z * p[n + 1].x - mz * p[n].x,
            z * p[n + 1].y - mz * p[n].y
        );

        b$3 = z * mz * 2;
        curve[--n] = new DG.Point(
            z2 * p[n + 2].x - b$3 * p[n + 1].x + mz2 * p[n].x,
            z2 * p[n + 2].y - b$3 * p[n + 1].y + mz2 * p[n].y
        );

        if (this.order > 2) {
            z3 = z2 * z;
            mz3 = mz2 * mz;
            b$4 = z2 * mz * 3;
            c$4 = z * mz2 * 3;
            curve[--n] = new DG.Point(
                z3 * p[n + 3].x - b$4 * p[n + 2].x + c$4 * p[n + 1].x - mz3 * p[n].x,
                z3 * p[n + 3].y - b$4 * p[n + 2].y + c$4 * p[n + 1].y - mz3 * p[n].y
            );
        }

        return new DG.Bezier(curve);
    },

    _getDerivatives: function() {
        var p = this.points;
        var d, c, j, list;
        var result = [];

        for (d = p.length, c = d - 1; d > 1; d--, c--) {
            list = [];
            for (j = 0; j < c; j++) {
                list.push(new DG.Point(
                    c * (p[j + 1].x - p[j].x),
                    c * (p[j + 1].y - p[j].y)
                ));
            }
            result.push(list);
            p = list;
        }

        return result;
    },

    getLUT: function(steps) {
        steps = steps || 125;

        if (this._lut.length !== steps + 1) {
            if (this.order > 2) {
                this._setLUT3(steps);
            } else {
                this._setLUT2(steps);
            }
        }

        return this._lut;
    },

    _setLUT2: function(steps) {
        var lut = this._lut = [];
        var p = this.points;
        var t, mt;
        var a, b, c;

        lut.push({x: p[0].x, y: p[0].y, l: 0});
        for (var s = 1; s < steps; s++) {
            t = s / steps;
            mt = 1 - t;
            a = mt * mt;
            b = mt * t * 2;
            c = t * t;
            lut.push({
                x: a * p[0].x + b * p[1].x + c * p[2].x,
                y: a * p[0].y + b * p[1].y + c * p[2].y
            });
        }
        lut.push({x: p[2].x, y: p[2].y, l: 0});
    },

    _setLUT3: function(steps) {
        var lut = this._lut = [];
        var p = this.points;
        var t, t2, mt, mt2;
        var a, b, c, d;

        lut.push({x: p[0].x, y: p[0].y, l: 0});
        for (var s = 1; s < steps; s++) {
            t = s / steps;
            mt = 1 - t;
            mt2 = mt * mt;
            t2 = t * t;
            a = mt2 * mt;
            b = mt2 * t * 3;
            c = mt * t2 * 3;
            d = t * t2;
            lut.push({
                x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
                y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y
            });
        }
        lut.push({x: p[3].x, y: p[3].y, l: 0});
    },

    clone: function() {
        return new DG.Bezier(this.points, true);
    }
});

DG.bezier = function(coords) {
    if (typeof coords === 'number' || coords instanceof DG.Point) {
        coords = Array.prototype.slice.call(arguments);
    }

    if (typeof coords[0] === 'number') {
        if (coords.length < 7) {
            coords = [
                new DG.Point(coords[0], coords[1]),
                new DG.Point(coords[2], coords[3]),
                new DG.Point(coords[4], coords[5])
            ];
        } else {
            coords = [
                new DG.Point(coords[0], coords[1]),
                new DG.Point(coords[2], coords[3]),
                new DG.Point(coords[4], coords[5]),
                new DG.Point(coords[6], coords[7])
            ];
        }
        return new DG.Bezier(coords);
    } else {
        return new DG.Bezier(coords, true);
    }
};

/* eslint-disable indent */
DG.Bezier.WEIGHT = [
    0.3626837833783620,
    0.3626837833783620,
    0.3137066458778873,
    0.3137066458778873,
    0.2223810344533745,
    0.2223810344533745,
    0.1012285362903763,
    0.1012285362903763
];
DG.Bezier.ABSCISSA = [
   -0.1834346424956498,
    0.1834346424956498,
   -0.5255324099163290,
    0.5255324099163290,
   -0.7966664774136267,
    0.7966664774136267,
   -0.9602898564975363,
    0.9602898564975363
];
/* eslint-enable indent */


//  This curve is monotonically ordered by 'X' coordinate and has P[0] = {0, 0} and P[3] = {1, 1}
//  We can utilize this facts to shortcut calculations
DG.TimeBezier = DG.Bezier.extend({
    initialize: function(controlPoint1, controlPoint2, clone) {
        DG.Bezier.prototype.initialize.call(
            this,
            [DG.TimeBezier.START, controlPoint1, controlPoint2, DG.TimeBezier.END],
            clone
        );
    },

    getYbyX: function(x) {
        var lut = this.getLUT();
        var max = lut.length - 1;
        var min = 0;
        var mid;

        if (x <= 0) { return 0; }
        if (x >= 1) { return 1; }

        //  'X' is monotonically increasing so we can do a simple binary search (LUT)
        //  and then fine-tune the result by linear interpolation assuming 'Y' is not changed so radically
        while (true) {
            mid = min + (max - min >> 1);
            if (x < lut[mid].x) {
                max = mid;
            } else {
                min = mid;
            }
            if (max - min < 2) { break; }
        }
        x = (x - lut[min].x) / (lut[max].x - lut[min].x);

        return (lut[min].y + (lut[max].y - lut[min].y) * x);
    },

    getLUT: function(steps) {
        var p = this.points;
        var t, t2, mt;
        var b, c, d;
        var lut;

        steps = steps || 240;
        if (this._lut.length === steps + 1) {
            return this._lut;
        } else {
            this._lut = lut = [];
        }

        lut.push({x: 0, y: 0});
        for (var s = 1; s < steps; s++) {
            t = s / steps;
            mt = 1 - t;
            t2 = t * t;
            //  We don't need 'a' coefficient because p[0] is {0, 0}
            b = mt * mt * t * 3;
            c = mt * t2 * 3;
            d = t * t2;
            lut.push({
                x: b * p[1].x + c * p[2].x + d,
                y: b * p[1].y + c * p[2].y + d
            });
        }
        lut.push({x: 1, y: 1});

        return lut;
    },

    clone: function() {
        return new DG.TimeBezier(this.points, true);
    }
});

DG.TimeBezier.START = DG.point(0, 0);
DG.TimeBezier.END = DG.point(1, 1);


//  This is cubic Bezier describing circular arc
DG.ArcBezier = DG.Bezier.extend({
    initialize: function(coords, clone) {
        DG.Bezier.prototype.initialize.call(this, coords, clone);
        this.getLUT();
        this._setLutLengths();
    },

    getTbyL: function(l) {
        var lut = this.getLUT();
        var max = lut.length - 1;
        var min = 0;
        var mid;
        var x, y;

        if (l <= 0) { return 0; }
        if (l >= lut[max].l) { return 1; }

        //  'L' is monotonically increasing so we can do a binary search (LUT)
        //  and then fine-tune the result by linear interpolation
        while (true) {
            mid = min + (max - min >> 1);
            if (l < lut[mid].l) {
                max = mid;
            } else {
                min = mid;
            }
            if (max - min < 2) { break; }
        }
        l = (l - lut[min].l) / (lut[max].l - lut[min].l);

        x = (lut[min].x + (lut[max].x - lut[min].x) * l);
        y = (lut[min].y + (lut[max].y - lut[min].y) * l);

        //  BUT this is a part of story, we need a projection of this point to the actual curve and it's reverse 't' val
        var p, dx, dy, t;
        var et = max / lut.length;
        var dt = min / lut.length;
        var s = 1 / lut.length / 10;    //  TODO
        var d = Math.pow(2, 53) - 1;

        for (t = dt; dt < et; dt += s) {
            p = this.getPoint(dt);
            dx = p.x - x; dy = p.y - y;
            l = Math.sqrt(dx * dx + dy * dy);
            if (l < d) {
                d = l;
                t = dt;
            }
        }

        return t;
    },

    _setLutLengths: function() {
        var lut = this._lut;
        var dx, dy;

        lut[0].l = 0;
        for (var i = 1; i < lut.length; i++) {
            dx = lut[i].x - lut[i - 1].x;
            dy = lut[i].y - lut[i - 1].y;
            lut[i].l = lut[i - 1].l + Math.sqrt(dx * dx + dy * dy);
        }
    },

    getLength: function() {
        return this._lut[this._lut.length - 1].l;
    },

    clone: function() {
        return new DG.ArcBezier(this.points, true);
    }
});

/*
 * DG.Animation provides tick (step) logic returning progression values
 * calculated over provided or custom Bzier curves
 * Original input can be array object btw...
 */

DG.Animation = DG.Evented.extend({
    options: {
        // animation: {    //  Or array of objects
        //     function: DG.Animation.EASE,
        //     duration: 2000,
        //     frames: null
        // }

        //offset: 0
        //repeat: 0
    },

    initialize: function(options) {
        DG.setOptions(this, options);

        this._animID = -1;
        this._startTime = 0;
        this._running = false;
        this._animation = null;
        this._durations = null;
    },

    start: function() {
        this.stop();
        this._prepare();

        this._running = true;

        this.fire('start');

        //  Date.now(), but... IE9+
        this._startTime = new Date().getTime();

        this._animate();
    },

    stop: function() {
        if (this._running) {
            this._run(this._durations.getLength());
        }
    },

    _prepare: function() {
        this._animation = DG.Util.isArray(this.options.animation) ? this.options.animation : [this.options.animation];

        this._durations = new DG.Metric.Segments();
        this._animation.forEach(function(animation) {
            this.push(animation.duration);
        }, this._durations);
    },

    _animate: function() {
        this._animID = DG.Util.requestAnimFrame(this._animate, this);
        this._run();
    },

    _run: function(elapsed) {
        var el, index, progress;
        //  Possible skip zero delta time but who cares?!
        elapsed = elapsed ? elapsed : new Date().getTime() - this._startTime;

        if (elapsed < this._durations.getLength()) {
            index = this._durations.getIndex(elapsed);
            el = this._durations.getSegRatio(elapsed);
            progress = this._animation[index]['function'].getYbyX(el);
            this._step(this._getFrameValues(index, progress));
        } else {
            index = this._durations.length - 1;
            this._step(this._getFrameValues(index, 1));
            this._complete();
        }
    },

    _step: function(obj) {
        this.fire('step', obj);
    },

    _complete: function() {
        DG.Util.cancelAnimFrame(this._animID);

        this._durations = null;
        this._animation = null;
        this._running = false;
        this.fire('end');
    },

    _getFrameValues: function(index, progress) {
        var frames = this._animation[index].frames;
        var obj = {progress: progress};
        var fr, to;

        if (frames) {
            for (var key in frames) {
                if (frames[key].progress) {
                    obj[key] = frames[key].progress(progress);
                } else {
                    fr = frames[key].from;
                    to = frames[key].to;
                    obj[key] = fr + (to - fr) * progress;
                }
            }
        }
        return obj;
    }
});

DG.animation = function(options) {
    return new DG.Animation(options);
};

DG.Animation.LINEAR         = new DG.TimeBezier(DG.point(0.00, 0.0), DG.point(1.00, 1.0));
DG.Animation.EASE           = new DG.TimeBezier(DG.point(0.25, 0.1), DG.point(0.25, 1.0));
DG.Animation.EASE_IN        = new DG.TimeBezier(DG.point(0.42, 0.0), DG.point(1.00, 1.0));
DG.Animation.EASE_IN_OUT    = new DG.TimeBezier(DG.point(0.42, 0.0), DG.point(0.58, 1.0));
DG.Animation.EASE_OUT       = new DG.TimeBezier(DG.point(0.00, 0.0), DG.point(0.58, 1.0));

/*
 * DG.Entrance is a main class that hosts actual arrow layers
 * It orchestrates animation and provides user space methods like .show() and .hide()
 */

DG.Entrance = DG.FeatureGroup.extend({

    options: {
        vectors: [],

        fillColor: '#0085a0',
        strokeColor: '#fff',

        enableAnimation: true,
        interactive: false,

        autoClose: true
    },

    initialize: function(options) {
        DG.LayerGroup.prototype.initialize.call(this);

        DG.setOptions(this, options);

        this._bounds =
            new DG.LatLngBounds();
        this._animations = {
            bounce: DG.animation(DG.Entrance.BOUNCE_ANIMATION),
            path: DG.animation(DG.Entrance.PATH_ANIMATION)
        };

        this._initArrows();

        this._isShown = false;
    },

    onAdd: function(map) {
        DG.LayerGroup.prototype.onAdd.call(this, map);
        this.show();
    },

    onRemove: function(map) {
        this.hide();
        DG.LayerGroup.prototype.onRemove.call(this, map);
    },

    getEvents: function() {
        var events = {};

        if (this.options.autoClose) {
            events['layeradd'] = this._removeEntrance;  //  eslint-disable-line dot-notation
        }
        if (this.options.enableAnimation) {
            events['zoomend'] = this._animate;          //  eslint-disable-line dot-notation
        }

        return events;
    },

    show: function(fitBounds) {
        if (this._layers) {
            if (fitBounds) {
                this.fitBounds();
            }
            if (!this._isShown) {
                this._isShown = true;
                this.eachLayer(function(arrow) {
                    arrow.setVisibility(true);
                });
                if (this.options.enableAnimation) {
                    this._animate();
                }
                this._map.fire('entranceshow');
            }
        }

        return this;
    },

    hide: function() {
        if (this._layers && this._isShown) {
            this._isShown = false;
            this.eachLayer(function(arrow) {
                arrow.setVisibility(false);
            });
            this._map.fire('entrancehide');
        }

        return this;
    },

    isShown: function() {
        return this._isShown;
    },

    getBounds: function() {
        return this._bounds;
    },

    setFillColor: function(color) {
        this.eachLayer(function(arrow) {
            arrow.setStyle({fillColor: color});
        });
    },

    setStrokeColor: function(color) {
        this.eachLayer(function(arrow) {
            arrow.setStyle({color: color});
        });
    },

    _initArrows: function() {
        var base = {
            color: this.options.strokeColor,
            fillColor: this.options.fillColor,
            interactive: this.options.interactive
        };

        this.options.vectors
            .map(function(vector) {
                return DG.Wkt.toLatLngs(vector);
            })
            .forEach(function(latlngs) {
                var options = DG.Util.create(base),
                    bounds = DG.latLngBounds(latlngs);

                this._bounds.extend(bounds);

                options.latlngs = latlngs;
                options.bounds = bounds;
                if (this.options.enableAnimation) {
                    if (latlngs.length > 2) {
                        options.animation = this._animations.path;
                    } else {
                        options.animation = this._animations.bounce;
                        options.distance = true;
                    }
                }

                this.addLayer(DG.entrance.arrow(options));
            }, this);
    },


    _animate: function() {
        if (this._isShown) {
            this._animations.bounce.start();
            this._animations.path.start();
        }
    },

    //  Current logic of next four methods extracted from original arrow's implementation
    fitBounds: function() {
        var map = this._map, fitZoom,
            bounds = this.getBounds();

        if (!map.getBounds().contains(bounds) || !this._isAllowedZoom()) {
            fitZoom = this._getFitZoom();
            if (!map.projectDetector.getProject()) {
                map.once('moveend', function() {
                    map.setZoom(this._getFitZoom());
                }, this);
            }
            map.setView(bounds.getCenter(), fitZoom, {animate: true});
        }

        return this;
    },

    _getFitZoom: function() {
        return this._map.projectDetector.getProject().maxZoom || DG.Entrance.SHOW_FROM_ZOOM;
    },

    _isAllowedZoom: function() {
        return this._map.getZoom() >= DG.Entrance.SHOW_FROM_ZOOM;
    },

    _removeEntrance: function(e) {
        if (e.layer instanceof DG.Popup ||
            (e.layer instanceof DG.Entrance && e.layer !== this)) {

            this.remove();
        }
    }
});

DG.entrance = function(options) {
    return new DG.Entrance(options);
};

DG.Entrance.SHOW_FROM_ZOOM = 16;
DG.Entrance.PATH_ANIMATION = {
    animation: {
        'function': DG.Animation.EASE_IN_OUT,
        'duration': 750
    }
};
DG.Entrance.BOUNCE_ANIMATION = {
    animation: [
        {'function': DG.Animation.EASE_IN_OUT, 'duration': 250, 'frames': {'distance': {'from': 0, 'to': 0.6}}},
        {'function': DG.Animation.EASE_IN, 'duration': 135, 'frames': {'distance': {'from': 0.6, 'to': 0}}},
        {'function': DG.Animation.EASE_OUT, 'duration': 135, 'frames': {'distance': {'from': 0, 'to': 0.16}}},
        {'function': DG.Animation.EASE_IN, 'duration': 90, 'frames': {'distance': {'from': 0.16, 'to': 0}}},
        {'function': DG.Animation.EASE_OUT, 'duration': 90, 'frames': {'distance': {'from': 0, 'to': 0.06}}},
        {'function': DG.Animation.EASE_IN, 'duration': 50, 'frames': {'distance': {'from': 0.06, 'to': 0}}}
    ]
};

/*
 * DG.Entrance.Arrow class hosts two layers, one for arrow body (path) and one for arrow tip
 * It overrides projection events from hosted layers to minimize total overhead
 * Actual calculations produced in DG.ArrowPathTransform and DG.ArrowTipTransform classes
 */

DG.Entrance.Arrow = DG.FeatureGroup.extend({
    initialize: function(options) {
        DG.LayerGroup.prototype.initialize.call(this);

        DG.setOptions(this, options);

        this._progress = 1;
        this._distance = 0;
        this._visibility = {
            isShown: false
        };
        this._position =
            options.latlngs[options.latlngs.length - 1];
        this._shape =
            this.options.shape ||
            DG.Entrance.Arrow.SHAPE;

        this._apt = {}; // DG.ArrowPathTransform objects by zoom levels
        this._att = {}; // DG.ArrowTipTransform objects by zoom levels
    },

    beforeAdd: function(map) {
        //  this._map is not initialized yet, so we can freely addLayer(s)
        var opts = this.options;

        //  TODO: Check Canvas processing order
        //  Additional logic to DISABLE animation on Canvas for now!
        if (opts.animation && !map.options.preferCanvas && !DG.Browser.ielt9) {
            opts.animation.on('step', this._animation, this);
        } else {
            opts.animation = null;
        }

        this.projection();

        this.addLayer(new DG.ComplexPath({
            lineCap: 'butt',
            color: opts.color,
            fillColor: opts.fillColor,
            interactive: opts.interactive,
            visibility: this._visibility,
            transform: this._apt
        }));

        this.addLayer(new DG.ComplexPath({
            lineJoin: 'miter',
            color: opts.color,
            fillColor: opts.fillColor,
            interactive: opts.interactive,
            visibility: this._visibility,
            transform: this._att
        }));
    },

    getEvents: function() {
        return {
            zoomend: this._project,
            moveend: this._update,
            viewreset: this._reset
        };
    },

    setVisibility: function(isShown) {
        if (this._visibility.isShown !== isShown) {
            this._visibility.isShown = isShown;
            if (isShown) {
                if (!this.options.animation) {
                    this._reset();
                }
            } else {
                this._reset();
            }
        }
    },

    getBounds: function() {
        return this.options.bounds;
    },

    projection: function() {
        var map = this._map || this._mapToAdd;
        var zoom = map ? map.getZoom() : 0;
        var vertices = this._shape.vertices[zoom];
        var drawings = this._shape.drawings[zoom];
        var latlngs = this.options.latlngs;
        var shape, path, lastPoint, prevPoint;

        if (zoom && vertices && drawings) {
            if (!this._att[zoom]) {
                path = DG.ArrowPathTransform.getTranslatedPath(map, latlngs);
                shape = {vertices: vertices, drawings: drawings};
                this._att[zoom] = new DG.ArrowTipTransform(path, shape);
                this._apt[zoom] = new DG.ArrowPathTransform(path);
            }

            lastPoint = map.latLngToLayerPoint(this._position);
            prevPoint = map.latLngToLayerPoint(latlngs[latlngs.length - 2]);
            if (!this._apt[zoom]._pxBounds) {
                //  One-time action per 'viewreset' event
                //  Caching _pxBounds for using with Canvas renderer
                this._setBounds(lastPoint, prevPoint, this._apt[zoom], this._att[zoom]);
            }
            if (this.options.distance) {
                //  Arrow position recalculated for Bounce animation effect
                lastPoint = DG.VertexTransform.getScaled(lastPoint, prevPoint, this._distance);
            }

            //  Main calculations
            //  Get part of the arrow path and move (bound) arrow tip to it
            this._apt[zoom].subPath(this._progress).translate(lastPoint);
            this._att[zoom].subShape(this._apt[zoom]).translate(lastPoint);
        }

        return this;
    },

    _animation: function(e) {
        if (e.distance != undefined) {
            this._distance = e.distance;    //  bounce animation effect
        } else {
            this._progress = e.progress;    //  path animation effect
        }
        if (this._visibility.isShown) {
            //  TODO: Additional logic for animation on Canvas
            // this.projection().invoke('redraw');

            this._project();
            this._update();
        }
    },

    _project: function() {
        this.projection().invoke('_project');
    },

    _update: function() {
        this.invoke('_update');
    },

    _reset: function() {
        this._resetBounds();

        this._project();
        this._update();
    },

    _resetBounds: function() {
        //  Canvas renderer specific
        var z;

        for (z in this._apt) {
            this._apt[z]._pxBounds = null;
        }

        for (z in this._att) {
            this._att[z]._pxBounds = null;
        }
    },

    _setBounds: function(pl, pp, apt, att) {
        var _apt = apt.subPath(1).translate(pl).vertices,
            _att = att.subShape(apt).translate(pl).vertices;

/*
        //  TODO: Additional logic for animation on Canvas
        if (this.options.distance) {
            pl = DG.VertexTransform.getScaled(pl, pp, 1);
            _apt = _apt.concat(apt.subPath(1).translate(pl).vertices);
            _att = _att.concat(att.subShape(apt).translate(pl).vertices);
        }
*/
        apt._pxBounds = new DG.Bounds(_apt);
        att._pxBounds = new DG.Bounds(_att);
    }
});

DG.entrance.arrow = function(options) {
    return new DG.Entrance.Arrow(options);
};

/*
 * Predefined arrow tips
 */

/* eslint-disable array-bracket-spacing */
DG.Entrance.Arrow.SHAPE = {
    vertices: {
        16: [
            [ -6.5000,  -1.8000],
            [ -6.0522,  -1.8000],
            [ -7.0975,  -5.2537],
            [ -6.6619,  -6.2565], [ -6.5980,  -6.3550], [ -6.1757,  -6.1470],
            [  0.8371,  -0.3552],
            [  0.9275,  -0.1764], [  0.9275,   0.1764], [  0.8371,   0.3552],
            [ -6.1757,   6.1470],
            [ -6.5980,   6.3550], [ -6.6619,   6.2565], [ -7.0975,   5.2537],
            [ -6.0522,   1.8000],
            [ -6.5000,   1.8000]
        ],
        17: [
            [ -9.0000,  -2.4000],
            [ -7.8890,  -2.4000],
            [ -9.9245,  -7.2548],
            [ -9.3363,  -8.6404], [ -9.3448,  -8.6448], [ -8.8717,  -8.3508],
            [  1.0285,  -0.3552],
            [  1.1190,  -0.1764], [  1.1190,   0.1764], [  1.0285,   0.3552],
            [ -8.8717,   8.3508],
            [ -9.3448,   8.6448], [ -9.3363,   8.6404], [ -9.9245,   7.2548],
            [ -7.8890,   2.4000],
            [ -9.0000,   2.4000]
        ],
        18: [
            [-11.5000,  -3.0000],
            [-10.0795,  -3.0000],
            [-12.4909,  -9.3173],
            [-11.8402, -10.7654], [-11.5986, -10.7073], [-10.9380, -10.2258],
            [  1.1497,  -0.3552],
            [  1.2402,  -0.1764], [  1.2402,   0.1764], [  1.1497,   0.3552],
            [-10.9380,  10.2258],
            [-11.5986,  10.7073], [-11.8402,  10.7654], [-12.4909,   9.3173],
            [-10.0795,   3.0000],
            [-11.5000,   3.0000]
        ],
        19: [
            [-13.0000,  -3.6000],
            [-11.6600,  -3.6000],
            [-14.1696, -10.8351],
            [-13.5189, -12.2832], [-13.2773, -12.2251], [-12.6167, -11.7436],
            [  1.3061,  -0.3552],
            [  1.3966,  -0.1764], [  1.3966,   0.1764], [  1.3061,   0.3552],
            [-12.6167,  11.7436],
            [-13.2773,  12.2251], [-13.5189,  12.2832], [-14.1696,  10.8351],
            [-11.6600,   3.6000],
            [-13.0000,   3.6000]
        ]
    },
    drawings: {
        16: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L'],
        17: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L'],
        18: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L'],
        19: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L']
    }
};
/* eslint-enable array-bracket-spacing */


(function(vertices) {
    for (var i in vertices) {
        vertices[i] = vertices[i].map(function(vertex) { return DG.point(vertex); });
    }
})(DG.Entrance.Arrow.SHAPE.vertices);

DG.Label = DG.Layer.extend({

    options: {
        offset: new DG.Point(12, 15),
        className: 'dg-label',
        zIndexOffset: 0
    },

    _typeOfString : Object.prototype.toString.call('s'),
    _defaultZIndex: 100,

    initialize: function(content, options) {
        DG.Util.setOptions(this, options);

        this._animated = DG.Browser.any3d;
        this._content = content;
    },

    onAdd: function(map) {
        this._map = map;

        if (!this._el) {
            this._initDOM();
        }

        this._visible = true;

        this
            .setContent(this._content)
            ._onViewReset();

        map
            .on('viewreset', this._onViewReset, this)
            .on('zoomanim', this._onZoomAnimation, this);
    },

    onRemove: function(map) {
        map
            .off('viewreset', this._onViewReset, this)
            .off('zoomanim', this._onZoomAnimation, this);

        this._visible = false;

        this._el.removeChild(this._container);
        DG.Util.falseFn(this._container.offsetWidth); // we need reflow here
        this._container = null;

        map.getPanes().tooltipPane.removeChild(this._el);
        this._el = null;
    },

    _initDOM: function() {
        this._el = DG.DomUtil.create(
                        'div',
                        this.options.className + ' leaflet-zoom-' + (this._animated ? 'animated' : 'hide'),
                        this._map.getPanes().tooltipPane);
        this._el.style.zIndex = this._defaultZIndex + this.options.zIndexOffset;

        this._container = DG.DomUtil.create('div', this.options.className + '__content', this._el);
        DG.DomEvent
            .disableClickPropagation(this._el)
            .on(this._container, 'mousewheel', DG.DomEvent.stopPropagation)
            .on(this._container, 'contextmenu', DG.DomEvent.stopPropagation);
    },

    _onViewReset: function() {
        if (this._visible && this._latlng) {
            DG.DomUtil.setPosition(this._el, this._map.latLngToLayerPoint(this._latlng).add(this.options.offset), DG.Browser.ie);
        }
    },

    _onZoomAnimation: function(opt) {
        if (this._latlng) {
            DG.DomUtil.setPosition(this._el, this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).add(this.options.offset));
        }
    },

    setOffset: function(point) {
        if (point instanceof DG.Point) {
            this.options.offset = point;
            this._onViewReset();
        }
        return this;
    },

    setZIndexOffset: function(zIndex) {
        if (!isNaN(+zIndex)) {
            this.options.zIndexOffset = +zIndex;
            if (this._visible) {
                this._el.style.zIndex = this._defaultZIndex + this.options.zIndexOffset;
            }
        }
        return this;
    },

    setContent: function(content) {
        if (Object.prototype.toString.call(content) !== this._typeOfString) {
            return this;
        }
        this._content = content;
        if (this._visible) {
            this._container.innerHTML = content;
        }
        return this;
    },

    setPosition: function(latlng) {
        if (!(latlng instanceof DG.LatLng)) {
            return this;
        }

        this._latlng = latlng;
        this._onViewReset();
        return this;
    }
});

DG.label = function(content, options) {
    return new DG.Label(content, options);
};

DG.Marker.include({

    bindLabel: function(content, options) {
        if (this._label) {
            this._label.setContent(content);
            if (options) {
                if (this.options.offset !== options.offset) {
                    this._label.setOffset(this.options.offset = options.offset);
                }
                if (this.options.static !== options.static) {
                    this.unbindLabel().bindLabel(content, options);
                }
            }
        } else {
            options = DG.extend({
                offset: new DG.Point(5, 5)
            }, options);

            this._label = DG.label(content, options);

            this.once('remove', this._onMarkerRemove);

            if (options.static) {
                this.showLabel();
            } else {
                this
                    .on('mouseover', this._mouseOverLabel)
                    .on('mouseout', this._mouseOutLabel)
                    .on('dragstart', this._dragStartLabel)
                    .on('dragend', this._dragEndLabel);
            }

            if (typeof this._map !== 'undefined') {
                this._updateLabelZIndex();
            } else {
                this.once('add', this._updateLabelZIndex);
            }
        }
        return this;
    },

    unbindLabel: function() {
        if (this._label) {
            this
                .hideLabel()
                .off('remove', this.unbindLabel)
                .off('mouseover', this._mouseOverLabel)
                .off('mouseout', this._mouseOutLabel)
                .off('dragstart', this._dragStartLabel)
                .off('dragend', this._dragEndLabel)
                .off('move', this._updatePosition)
                .off('add', this._updateLabelZIndex);

            this._label = null;
        }
        return this;
    },

    _onMarkerRemove: function() {
        if (this._label) {
            var content = this._label._content;
            this.once('add', function() {
                if (this._label) { return; } // new label added after removing marker
                this.bindLabel(content);
            });
            this.unbindLabel();
        }
    },

    getLabel: function() {
        return this._label ? this._label : null;
    },

    _originalUpdateZIndex: DG.Marker.prototype._updateZIndex,
    _updateZIndex: function(offset) {
        if (!this._zIndex) {
            this._zIndex = 0;
        }
        this._originalUpdateZIndex(offset);
        this._updateLabelZIndex();
        return this;
    },

    _updateLabelZIndex: function() {
        if (this._label && this._icon) {
            this._label.setZIndexOffset(this._icon.style.zIndex);
        }
        return this;
    },

    showLabel : function() {
        if (this._label) {
            this
                .on('move', this._updatePosition)
                ._map.addLayer(this._label.setPosition(this.getLatLng()));
        }

        return this;
    },

    hideLabel : function() {
        if (this._label) {
            this
                .off('move', this._updatePosition)
                ._map.removeLayer(this._label);
        }
        return this;
    },

    _updatePosition : function() {
        this._label.setPosition(this.getLatLng());
    },

    _dragStartLabel: function() {
        this._label.isMarkerDragging = true;

        this.hideLabel();
    },

    _dragEndLabel: function() {
        this._label.isMarkerDragging = false;

        if (this._label.isMouseOverMarker) {
            this.showLabel();
        }
    },

    _mouseOverLabel: function() {
        this._label.isMouseOverMarker = true;

        if (!this._label.isMarkerDragging) {
            this.showLabel();
        }
    },

    _mouseOutLabel: function() {
        this._label.isMouseOverMarker = false;

        this.hideLabel();
    }
});

DG.Marker.addInitHook(function() {
    if (typeof this.options.label !== 'undefined') {
        this.bindLabel(this.options.label);
    }
});

DG.Path.include({
    bindLabel: function(content, options) {

        if (!this._label) {
            this._label = DG.label(content, options);
            this.on(this._labelEvents, this);
        } else {
            this._label.setContent(content);

            if (this._label.options.offset !== options.offset) {
                this._label.setOffset(options.offset);
            }
        }
        return this;
    },

    unbindLabel: function() {
        if (this._label) {
            this.off(this._labelEvents, this);
            this._map.removeLayer(this._label);
            this._label = null;
        }
        return this;
    },

    getLabel: function() {
        return this._label ? this._label : null;
    },

    _labelEvents : {
        mouseover: function(event) {
            this._map.addLayer(this._label.setPosition(event.latlng));
            DG.DomEvent.stop(event);
        },
        mousemove: function(event) {
            this._label.setPosition(event.latlng);
            DG.DomEvent.stop(event);
        },
        mouseout: function() {
            this._map.removeLayer(this._label);
            DG.DomEvent.stop(event);
        },
        remove: function() {
            this._map.removeLayer(this._label);
        }
    }
});

DG.Path.addInitHook(function() {
    if (typeof this.options.label !== 'undefined') {
        this.bindLabel(this.options.label);
    }
});

DG.Entrance.include({
    bindLabel: function(content, options) {

        if (!this._label) {
            this._label = DG.label(content, options);
            this.on(this._labelEvents, this);
        } else {
            this._label.setContent(content);

            if (this._label.options.offset !== options.offset) {
                this._label.setOffset(options.offset);
            }
        }
        return this;
    },

    unbindLabel: function() {
        if (this._label) {
            this.off(this._labelEvents, this);
            this._map.removeLayer(this._label);
            this._label = null;
        }
        return this;
    },

    getLabel: function() {
        return this._label ? this._label : null;
    },

    _labelEvents : {
        mouseover: function(event) {
            this._map.addLayer(this._label.setPosition(event.latlng));
            DG.DomEvent.stop(event);
        },
        mousemove: function(event) {
            this._label.setPosition(event.latlng);
            DG.DomEvent.stop(event);
        },
        mouseout: function() {
            this._label.remove();
        },
        remove: function() {
            this._label.remove();
        }
    }
});

DG.Entrance.addInitHook(function() {
    if (typeof this.options.label !== 'undefined') {
        this.bindLabel(this.options.label);
    }
});

DG.configTheme = DG.configTheme || {};

DG.configTheme.balloonOptions = {
    offset: {
        x: 1,
        y: -43
    }
};

_dereq_('../../../vendors/baron');

// 2GIS-related popup content wrapper and offset
(function() {
    var offsetX = DG.configTheme.balloonOptions.offset.x,
        offsetY = DG.configTheme.balloonOptions.offset.y,
        originalInitialize = DG.Popup.prototype.initialize,
        originalInitLayout = DG.Popup.prototype._initLayout,
        originalOnAdd = DG.Popup.prototype.onAdd,
        originalAdjustPan = DG.Popup.prototype._adjustPan,
        graf = baron.noConflict();

    var BaronDomHelper = function(element) {
        this[0] = element;
        this.length = 1;
    };
    BaronDomHelper.prototype = {
        setAttribute: function(name, value) {
            this[0].setAttribute(name, value);
            return this;
        },
        getAttribute: function(name) {
            return this[0].getAttribute(name);
        },
        removeAttribute: function(name) {
            this[0].removeAttribute(name);
            return this;
        },
        css: function(style, value) {
            if (value) {
                this[0].style[style] = value;
                return this;
            } else {
                return DG.DomUtil.getStyle(this[0], style);
            }
        }
    };

    DG.Popup.prototype.options.offset = DG.point(offsetX, offsetY);

    DG.Popup.mergeOptions({
        border: 16,
        mapControlsWidth: 60
    });

    DG.Popup.include({
        _headerContent: null,
        _footerContent: null,

        //baron elements references
        _scroller: null,
        _scrollerBar: null,
        _barWrapper: null,
        _baron: null,
        _isBaronExist: false,

        _popupShowClass: 'leaflet-popup_show_true',
        _popupHideClass: 'leaflet-popup_show_false',

        _popupTipClass: 'leaflet-popup-tip-container',
        _tipSVGPath: 'M0 0c12.643 0 28 7.115 28 44h2c0-36.885 15.358-44 28-44h-58z',

        _isAutoPanPaddingUserDefined: false,

        initialize: function(options, source) { // (Object, Object)
            this._popupStructure = {};
            this._isAutoPanPaddingUserDefined = options && options.hasOwnProperty('autoPanPadding');
            originalInitialize.call(this, options, source);
        },

        onAdd: function(map) { // (Map)
            map.on({
                entranceshow: this._closePopup,
                resize: this.resize
            }, this);
            originalOnAdd.call(this, map);
            this._animateOpening();
        },

        onRemove: function(map) { // (Map)
            this._animateClosing();
            map.off({
                entranceshow: this._closePopup,
                resize: this.resize
            }, this);

            if (DG.DomUtil.TRANSITION) {
                this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
            } else {
                L.DomUtil.remove(this._container);
            }

            map.fire('popupclose', {popup: this});

            if (this._source) {
                this._source.fire('popupclose', {popup: this}, true);
            }
        },

        setContent: function(content) { // (DOMElement | Object | HTML) -> Popup
            if (!this._isNode(content) && typeof content === 'object') {
                Object.keys(content).forEach(function(item) {
                    this['_' + item + 'Content'] = content[item];
                }, this);
            } else {
                this._bodyContent = content;
            }

            this.update();

            return this;
        },

        setHeaderContent: function(content) { // (HTML) -> Popup
            this._headerContent = content;
            this.update();

            return this;
        },

        setFooterContent: function(content) { // (HTML) -> Popup
            this._footerContent = content;
            this.update();

            return this;
        },

        getContent: function() { // () -> HTML
            return this._bodyContent;
        },

        getHeaderContent: function() { // () -> HTML
            return this._headerContent;
        },

        getFooterContent: function() { // () -> HTML
            return this._footerContent;
        },

        clear: function() { // () -> Popup
            Object.keys(this._popupStructure).forEach(this._clearElement, this);

            // think about move this set to another public method
            this._isBaronExist = false;
            return this;
        },

        clearHeader: function() { // () -> Popup
            return this._clearElement('header');
        },

        clearFooter: function() { // () -> Popup
            return this._clearElement('footer');
        },

        findElement: function(element) { // (String) -> DOMElement
            return this._contentNode.querySelector(element);
        },

        _animateOpening: function() {
            DG.DomUtil.addClass(this._innerContainer, this._popupShowClass);
            DG.DomUtil.removeClass(this._innerContainer, this._popupHideClass);
        },

        _animateClosing: function() {
            DG.DomUtil.addClass(this._innerContainer, this._popupHideClass);
            DG.DomUtil.removeClass(this._innerContainer, this._popupShowClass);
        },

        _closePopup: function() {
            this._map.closePopup(this);
        },

        _isNode: function(o) { // (Object) -> Boolean
            return (o.nodeName ? true : false);
        },

        _close: function() {
            if (this._map) {
                if (DG.Browser.mobile && this._map.geoclicker &&
                    (this.options.closeOnClick || this._map.options.closePopupOnClick)) {
                    //  We need to signal geoclicker that popup was open before 'click' event
                    //  But by time it will get it's event the popup will be already closed
                    //  See 'DGGeoclicker' for '_mapEventsListeners' and '_singleClick' method
                    this._map.geoclicker.popupWasOpen = true;
                }

                this._map.closePopup(this);
            }
        },

        _initLayout: function() {
            originalInitLayout.call(this);
            this._innerContainer = DG.DomUtil.create('div', 'leaflet-popup-inner ' + this._popupHideClass, this._container);

            // Prevents mouse events from leaking through close button
            // See https://github.com/2gis/mapsapi/pull/153/
            DG.DomEvent.disableClickPropagation(this._innerContainer);

            if (this.options.closeButton) {
                this._innerContainer.appendChild(this._detachEl(this._closeButton));
            }

            this._innerContainer.appendChild(this._detachEl(this._wrapper));

            var tip = this._detachEl(this._tipContainer);

            if (DG.Browser.svg) {
                var path = DG.SVG.create('path');
                var svgClass = this._popupTipClass + ' ' + this._popupTipClass + '_svg';

                path.setAttribute('d', this._tipSVGPath);

                tip = DG.SVG.create('svg');
                tip.setAttribute('class', svgClass);

                tip.appendChild(path);
                DG.DomEvent.disableClickPropagation(path);
            } else {
                DG.DomUtil.addClass(tip, this._popupTipClass + '_image');
                DG.DomEvent.disableClickPropagation(tip);
            }

            this._innerContainer.appendChild(tip);
        },

        _clearElement: function(elem) { // (DOMElement) -> Popup
            this['_' + elem + 'Content'] = null;
            this._detachEl(this._popupStructure[elem]);
            delete this._popupStructure[elem];
            return this;
        },

        _updateScrollPosition: function() {
            if (this._baron) {
                this._baron.update();
            }
        },

        resize: function() {
            var scrolled = this._updateLayout();
            this._updatePosition();

            if (!scrolled) {
                if (this._isBaronExist) {
                    this._scrollerWrapper.style.height = '';
                    DG.DomUtil.removeClass(this._scroller, 'dg-scroller');

                    DG.DomUtil.addClass(this._scroller, 'dg-scroller_hidden_true');
                    DG.DomUtil.removeClass(this._scroller, 'dg-scroller');
                    DG.DomEvent.off(this._scroller, 'scroll', this._onScroll);
                }
            } else if (this._isBaronExist) {
                DG.DomUtil.removeClass(this._scroller, 'dg-scroller_hidden_true');
                DG.DomUtil.addClass(this._scroller, 'dg-scroller');

                var scrollTop = this._isBaronExist ? this._scroller.scrollTop : false;

                if (scrollTop) {
                    this._scroller.scrollTop = scrollTop;
                }

                var innerHeight = this.options.maxHeight - this.options.border * 2 - this._getDelta();
                this._scrollerWrapper.style.height = innerHeight + 'px';

                this._updateScrollPosition();
            } else if (!this._isContentHeightEnough()) {
                this._initBaronScroller();
                this._initBaron();
            }

            this._adjustPan();
            this._bindAdjustPanOnTransitionEnd();
        },

        _adjustPan: function(e) {
            if (!this._map) { return; }

            if (e) {
                if (e.propertyName === 'max-height') {
                    setTimeout(originalAdjustPan.bind(this), 1); //JSAPI-3409 fix safari glich
                    DG.DomEvent.off(this._wrapper, DG.DomUtil.TRANSITION_END, this._adjustPan);
                }

                return;
            }

            var options = this.options;

            if (!options.autoPan) { return; }

            var map = this._map,
                containerHeight = this._container.offsetHeight,
                containerWidth = this._containerWidth,
                layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

            if (this._zoomAnimated) {
                layerPos._add(L.DomUtil.getPosition(this._container));
            }

            var autoPanPadding = [options.autoPanPadding[0], options.autoPanPadding[1]];

            // if width of map is more then width of popup and controls
            // set default autoPanPadding to width controls
            if (
                !this._isAutoPanPaddingUserDefined &&
                    this._map._container.offsetWidth >= options.maxWidth + options.mapControlsWidth * 2
            ) {
                autoPanPadding[0] = options.mapControlsWidth;
            }

            var containerPos = map.layerPointToContainerPoint(layerPos),
                padding = L.point(autoPanPadding),
                paddingTL = L.point(options.autoPanPaddingTopLeft || padding),
                paddingBR = L.point(options.autoPanPaddingBottomRight || padding),
                size = map.getSize(),
                dx = 0,
                dy = 0;

            if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
                dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) { // left
                dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
                dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) { // top
                dy = containerPos.y - paddingTL.y;
            }

            if (dx || dy) {
                map
                    .fire('autopanstart')
                    .panBy([dx, dy]);
            }
        },

        _bindAdjustPanOnTransitionEnd: function() {
            if (DG.DomUtil.TRANSITION) {
                DG.DomEvent.on(this._wrapper, DG.DomUtil.TRANSITION_END, this._adjustPan, this);
            } else {
                this._adjustPan();
            }
        },

        _isContentHeightEnough: function() { // () -> Boolean
            var options = this.options;

            if (!options.maxHeight) {
                return true;
            }

            var popupHeight = this._popupStructure.body ?
                this._popupStructure.body.offsetHeight + this._getDelta() :
                this._contentNode.offsetHeight;

            popupHeight += options.border * 2;

            return popupHeight <= options.maxHeight;
        },

        _initBaronScroller: function() {
            var contentNode = this._popupStructure.body.parentNode,
                scrollerWrapper = this._scrollerWrapper = DG.DomUtil.create('div', 'dg-scroller__wrapper', contentNode),
                scroller = this._scroller = DG.DomUtil.create('div', 'dg-scroller', scrollerWrapper),
                barWrapper = this._barWrapper = DG.DomUtil.create('div', 'dg-scroller__bar-wrapper', scroller),
                innerHeight = this.options.maxHeight - this.options.border * 2;

            this._scrollerBar = DG.DomUtil.create('div', 'dg-scroller__bar', barWrapper);
            scroller.appendChild(this._detachEl(this._popupStructure.body));

            innerHeight -= this._getDelta();
            scrollerWrapper.style.height = Math.max(18, innerHeight) + 'px';
            scrollerWrapper.style.width = contentNode.offsetWidth + 5 + 'px'; //TODO

            this._isBaronExist = true;

            this._switchEvents();
        },

        _onScroll: function(e) {
            this.fire('scroll', {originalEvent: e});
        },

        _onClick: function(e) {
            e.target = e.target || e.srcElement;

            if (!this._moving) {
                this.fire('click', {originalEvent: e});
            }
        },

        _onStart: function(e) {
            this._moved = false;

            if (this._moving) { return; }

            var first = e.touches ? e.touches[0] : e;

            this._startPoint = new DG.Point(first.clientX, first.clientY);

            this._toggleTouchEvents();
        },

        _onEnd: function(e) {
            this._toggleTouchEvents(true);

            this._onClick(e);

            this._moving = false;
        },

        _onMove: function(e) {

            if (e.touches && e.touches.length > 1) {
                this._moved = true;
                return;
            }

            var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
                newPoint = DG.point(first.clientX, first.clientY),
                offset = Math.abs(newPoint.subtract(this._startPoint).y);

            if (!offset || offset < 10) { return; }

            this._moving = this._moved = true;

        },

        _initBaron: function() {
            var context = this._scrollerWrapper;
            this._baron = graf({
                scroller: '.dg-scroller',
                bar: '.dg-scroller__bar',
                track: '.dg-scroller__bar-wrapper',
                $: function(selector) {
                    var node = {}.toString.call(selector) === '[object String]' ?
                        context.querySelector(selector) : selector;

                    return new BaronDomHelper(node);
                },
                event: function(elem, event, func, mode) {
                    event.split(' ').forEach(function(type) {
                        DG.DomEvent[mode || 'on'](elem, type, func);
                    });
                }
            });
        },

        _initHeader: function() {
            this._popupStructure.header = DG.DomUtil.create('header', 'dg-popup__header', this._contentNode);
        },

        _initFooter: function() {
            this._popupStructure.footer = DG.DomUtil.create('footer', 'dg-popup__footer', this._contentNode);
        },

        _initBodyContainer: function() {
            this._popupStructure.wrapper = DG.DomUtil.create('div', 'dg-popup__container-wrapper', this._contentNode);
            this._popupStructure.body = DG.DomUtil.create('div', 'dg-popup__container', this._popupStructure.wrapper);
        },

        update: function() {
            if (!this._map) { return; }

            if (!DG.Browser.ielt9) {
                this._container.style.visibility = 'hidden';
            }
            this._switchEvents(true);

            this._clearNode(this._contentNode);
            this._isBaronExist = false;

            // init popup content dom structure
            if (this._headerContent) { this._initHeader(); }
            if (this._bodyContent) { this._initBodyContainer(); }
            if (this._footerContent) { this._initFooter(); }

            this._updatePopupStructure();
            this.resize();

            DG.DomEvent.on(this._wrapper, 'click', DG.DomEvent.stopPropagation);
            this._switchEvents();

            if (DG.Browser.ielt9) {
                var elem = this._popupStructure.footer;
                if (elem) {
                    elem.className += ' ie8';
                }
            }

            if (!DG.Browser.ielt9) {
                this._container.style.visibility = '';
            }
        },

        _getDelta: function() { // () -> Number
            var delta = 0,
                popup = this._popupStructure;

            if (popup.header) {
                delta += popup.header.offsetHeight;
            }
            if (popup.footer) {
                delta += popup.footer.offsetHeight;
            }

            return delta;
        },

        _updateLayout: function() {
            var opts = this.options,
                content = this._contentNode, // leaflet-popup-content
                wrapper = this._wrapper, // leaflet-popup-content-wrapper
                style = content.style,
                wrapperStyle = wrapper.style,
                width,
                scrolledClass = 'leaflet-popup-scrolled',
                result = false;

            style.margin = opts.border + 'px';

            DG.DomUtil.removeClass(content, scrolledClass);

            if (this._isContentHeightEnough()) {
                wrapperStyle.maxHeight = content.offsetHeight + opts.border * 2 + 'px';
            } else {
                wrapperStyle.maxHeight = opts.maxHeight + 'px';
                DG.DomUtil.addClass(content, scrolledClass);
                result = true;
            }

            var availableWidth = opts.autoPanPadding[0] * 2;

            if (opts.sprawling) {
                width = opts.maxWidth;

                width = Math.min(width, this._map._container.offsetWidth - availableWidth);
                width = Math.max(width, opts.minWidth);
            } else {
                wrapperStyle.width = '';

                style.whiteSpace = 'nowrap';
                width = wrapper.offsetWidth;
                style.whiteSpace = '';

                width = Math.min(width, this._map._container.offsetWidth - availableWidth);
                width = Math.min(Math.max(width, opts.minWidth), opts.maxWidth);
            }

            wrapperStyle.width = width + 'px';

            this._containerWidth = this._container.offsetWidth;

            return result;
        },

        _updatePopupStructure: function() {
            Object.keys(this._popupStructure).forEach(function(item) {
                this._insertContent(this['_' + item + 'Content'], this._popupStructure[item]);
            }, this);

            this.fire('contentupdate');
        },

        _insertContent: function(content, node) { // (String | DOMElement, DOMElement)
            if (!content || !node) { return; }

            content = (typeof content === 'function') ? content(this._source || this) : content;

            if (typeof content === 'string') {
                node.innerHTML = content;
            } else {
                this._clearNode(node);
                node.appendChild(content);
            }
        },

        _clearNode: function(node) { // (DOMElement)
            while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
            }
        },

        _detachEl: function(elem) { // (DOMElement) -> DOMElement
            if (elem.parentNode) {
                elem.parentNode.removeChild(elem);
            }
            return elem;
        },

        _switchEvents: function(on) { // (Boolean)
            var switcher = on ? 'off' : 'on';

            if (!DG.Browser.touch) {
                DG.DomEvent[switcher](this._contentNode, 'click', this._onClick, this);
            } else {
                DG.DomEvent[switcher](this._contentNode, 'touchstart mousedown mousemove', this._onStart, this);
            }

            if (this._isBaronExist) {
                DG.DomEvent[switcher](this._scroller, 'scroll', this._onScroll, this);
            }
        },

        _toggleTouchEvents: function(on) {
            var switcher = on ? 'off' : 'on';

            DG.DomEvent[switcher](this._contentNode, 'touchmove', this._onMove, this);
            DG.DomEvent[switcher](this._contentNode, 'touchend', this._onEnd, this);
        }

    });
}());


DG.Map.include({
    _markerClass: 'dg-customization__marker_type_mushroom',
    _markerShowClass: 'dg-customization__marker_appear',
    _markerHideClass: 'dg-customization__marker_disappear',
    _dgHideClass: 'dg-popup_hidden_true',
    openPopup: function(popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
        if (!(popup instanceof L.Popup)) {
            var content = popup;

            popup = new L.Popup(options).setContent(content);
        }

        if (latlng) {
            popup.setLatLng(latlng);
        }

        if (this.hasLayer(popup)) {
            return this;
        }

        if (this._popup && this._popup.options.autoClose) {
            this.closePopup();
        }

        this._popup = popup;

        if (popup._source && popup._source._icon) {
            if (popup._source._icon.className.indexOf(this._markerClass) !== -1) {
                DG.DomUtil.removeClass(popup._source._icon, this._markerShowClass);
                DG.DomUtil.addClass(popup._source._icon, this._markerHideClass);
            } else {
                DG.DomUtil.addClass(popup._source._icon, this._dgHideClass);
                if (popup._source._shadow) {
                    DG.DomUtil.addClass(popup._source._shadow, this._dgHideClass);
                }
            }
        }

        return this.addLayer(popup);
    },

    closePopup: function(popup) {  // (Popup) -> Popup
        if (!popup || popup === this._popup) {
            popup = this._popup;
            this._popup = null;
        }
        if (popup) {
            if (popup._source && popup._source._icon) {
                if (popup._source._icon.className.indexOf(this._markerClass) !== -1) {
                    DG.DomUtil.removeClass(popup._source._icon, this._markerHideClass);
                    DG.DomUtil.addClass(popup._source._icon, this._markerShowClass);
                } else {
                    DG.DomUtil.removeClass(popup._source._icon, this._dgHideClass);
                    if (popup._source._shadow) {
                        DG.DomUtil.removeClass(popup._source._shadow, this._dgHideClass);
                    }
                }
            }
            this.removeLayer(popup);
        }

        return this;
    }
});

DG.Dictionary = {};

DG.Dictionary.ru = {
    pluralRules: function(n) { // (Number)
        if (n % 10 === 1 && n % 100 !== 11) { // 1, 21
            return 0;
        }
        if ((n % 10 >= 2 && n % 10 <= 4 && (n % 10) % 1 === 0) && (n % 100 < 12 || n % 100 > 14)) { // 2, 3
            return 1;
        }

        if ((n % 10 === 0) || (n % 10 >= 5 && n % 10 <= 9 && (n % 10) % 1 === 0) || (n % 100 >= 11 && (n % 100) <= 14 && (n % 100) % 1 === 0)) { // 13, 17
            return 2;
        }
    }
};

DG.Dictionary.en = {
    pluralRules: function(n) { // (Number)
        if (n === 1) { // 1
            return 0;
        } else {
            return 1; //0, 2, 3, 4 ..
        }
    }
};

DG.Dictionary.it = {
    pluralRules: function(n) { // (Number)
        if (n === 1) { // 1
            return 0;
        } else {
            return 1; //0, 2, 3, 4 ..
        }
    }
};

DG.Dictionary.cs = {
    pluralRules: function(n) { // (Number)
        return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2;
    }
};

DG.Dictionary.es = {
    pluralRules: function(n) { // (Number)
        return (n >= 2) ? 1 : 0;
    }
};

DG.Locale = {
    t: function(msg, argument) { // (String, Number) -> String
        var result,
            lang = this._map.getLang(),
            msgIsset = false,
            dictionaryMsg,
            exp;

        if (typeof this.constructor.Dictionary[lang] === 'undefined') {
            lang = DG.config.defaultLang;
            this._map.setLang(lang);
        }
        dictionaryMsg = this.constructor.Dictionary[lang][msg];
        msgIsset = typeof dictionaryMsg !== 'undefined';
        if (!msgIsset) {
            return msg;
        }
        result = msgIsset ? dictionaryMsg : msg;

        if (argument !== undefined) {
            argument = parseInt(argument, 10);
            argument = isNaN(argument) ? 0 : argument;
            exp = this.constructor.Dictionary[lang].pluralRules(argument);
            result = dictionaryMsg[exp];
        }

        result = DG.Util.template(result, {n: argument});
        return result ? result : msg;
    }
};

DG.Map.include({
    setLang: function(lang) { // (String)
        if (lang && Object.prototype.toString.call(lang) === '[object String]') {
            this.options.currentLang = lang;
            this.fire('langchange', {'lang': lang});
        }
    },

    getLang: function() { // () -> String
        // If the language hasn't been set before, set it to page language or
        // default language from config
        if (!this.options.currentLang) {
            var root = document.documentElement;
            var lang = root.lang || (root.getAttributeNS && root.getAttributeNS('http://www.w3.org/XML/1998/namespace', 'lang')) || DG.config.defaultLang;

            this.options.currentLang = lang;
        }

        return this.options.currentLang;
    }
});

DG.RoundControl = DG.Control.extend({
    includes: DG.Mixin.Events,

    options: {
        position: 'topright',
        iconClass: 'default'
    },

    onAdd: function(map) {
        var controlClass = this._controlCLass = 'dg-control-round',
            controlIconClass = this._controlIconCLass = this._controlCLass + '__icon',
            container = DG.DomUtil.create('div', '');

        if (this._disable) {
            return container;
        }
        DG.DomUtil.addClass(container, controlClass);

        var link = this._link = DG.DomUtil.create(
            'a',
            controlIconClass + ' ' + controlIconClass + '_name_' + this.options.iconClass,
            container
        );

        link.href = '#';

        this._renderTranslation();

        this._map = map;

        DG.DomEvent
            .on(container, 'click', this._toggleControl, this)
            .on(container, 'dblclick', DG.DomEvent.stopPropagation)
            .on(link, 'mousedown', DG.DomEvent.stopPropagation);

        this.fireEvent('add');

        return container;
    },

    onRemove: function() {
        this.fireEvent('remove');
        DG.DomEvent.off(this._link, 'click', this._toggleControl);
    },

    setState: function(state) {
        if (!this._link || !this._container) {
            return this;
        }

        if (this._state) {
            DG.DomUtil.removeClass(this._container, this._controlCLass + '_state_' + this._state);
            DG.DomUtil.removeClass(this._link, this._controlIconCLass + '_state_' + this._state);

            this._state = null;
        }

        if (state) {
            this._state = state;

            DG.DomUtil.addClass(this._container, this._controlCLass + '_state_' + this._state);
            DG.DomUtil.addClass(this._link, this._controlIconCLass + '_state_' + this._state);
        }

        return this;
    },

    _toggleControl: function(e) {
        DG.DomEvent.stop(e);
        this.fireEvent('click');
    }
});

DG.RoundControl.include(DG.Locale);

DG.roundControl = function(options) {
    return new DG.RoundControl(options);
};

DG.configTheme = DG.configTheme || {};

DG.configTheme.markersData = {
    iconSize: [22, 34],
    className: 'dg-customization__marker dg-customization__marker_type_mushroom',
    iconAnchor: [10, 32]
};

// Fix a lot of bugs with pinch-zooming
// See https://github.com/2gis/mapsapi/issues/327
DG.Map.mergeOptions({
    bounceAtZoomLimits: false
});

//Inject observing localization change
var controlAddTo = DG.Control.prototype.addTo;

DG.Control.include({
    addTo: function(map) {
        map.on('langchange', this._renderTranslation, this);

        return controlAddTo.call(this, map);
    },
    _renderTranslation: function() {}
});

// Add some browser detection
DG.Browser.safari51 = DG.Browser.safari && navigator.userAgent.indexOf('Version/5.1') !== -1;

// DG.Browser.touch checks whether touch events supported or not; touchEnabled checks if it's a touch device
var msPointer = navigator.msPointerEnabled && navigator.msMaxTouchPoints && !window.PointerEvent;
var pointer = (window.PointerEvent && navigator.pointerEnabled && navigator.maxTouchPoints) || msPointer;
var documentTouch = window.DocumentTouch && document instanceof window.DocumentTouch;
DG.Browser.touchEnabled = pointer || 'ontouchstart' in window || documentTouch;

// Applies 2GIS divIcon to marker
DG.Marker.prototype.options.icon = DG.divIcon(DG.configTheme.markersData);

// support old option clickable
var utilSetOptions = DG.Util.setOptions;

DG.setOptions = L.setOptions = DG.Util.setOptions = function(obj, options) {
    if (options && typeof options.clickable !== 'undefined') {
        options.interactive = options.clickable;
    }

    return utilSetOptions.call(this, obj, options);
};

DG.Layer.mergeOptions({
    nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
});

var initMap = DG.Map.prototype.initialize,
    panBy = DG.Map.prototype.panBy,
    getBoundsZoom = DG.Map.prototype.getBoundsZoom,
    setMaxZoom = DG.Map.prototype.setMaxZoom;

// Restrict zoom level according to 2gis projects, in case if dgTileLayer is only one
DG.Map.include({

    // number of tileLayers without 2gis layers
    _tileLayersNumber: 0,

    _mapMaxZoomCache: null,

    //TODO try refactor it after up on new leaflet (> 0.7)
    initialize: function(id, options) { // (HTMLElement or String, Object)
        // Override default wheelPxPerZoomLevel value to avoid zooming too fast
        // on mouse wheel rotation
        // See https://github.com/2gis/mapsapi/issues/343
        options = DG.extend({wheelPxPerZoomLevel: 10000}, options);

        this.metaLayers = [];

        initMap.call(this, id, options);

        //  Project must be checked after BaseLayer init which occurs in InitHook (see orig method definition)
        if (this.options.center && this.options.zoom !== undefined) {
            this.setView(DG.latLng(this.options.center), this.options.zoom, {reset: true});
        }
    },

    setView: function(center, zoom, options) {
        this._restrictZoom(center, zoom);

        zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
        center = this._limitCenter(DG.latLng(center), zoom, this.options.maxBounds);
        options = options || {};

        if (options.animate) {
            options.animate = this._testAnimation(center);
        }

        this._stop();

        if (this._loaded && !options.reset && options !== true) {

            if (options.animate !== undefined) {
                options.zoom = DG.extend({
                    animate: options.animate,
                    duration: options.duration
                }, options.zoom);
                options.pan = DG.extend({
                    animate: options.animate,
                    duration: options.duration
                }, options.pan);
            }

            // try animating pan or zoom
            var animated = (this._zoom !== zoom) ?
            this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
                this._tryAnimatedPan(center, options.pan);

            if (animated) {
                // prevent resize handler call, the view will refresh after animation anyway
                clearTimeout(this._sizeTimer);
                return this;
            }
        }

        // animation didn't start, just reset the map view
        this._resetView(center, zoom);

        return this;
    },

    panBy: function(offset, options) {
        var map = panBy.call(this, offset, options);

        var zoom = this._restrictZoom(this.getCenter());
        if (this.getZoom() > zoom) {
            this.setZoom(zoom);
        }

        return map;
    },

    getBoundsZoom: function(bounds, inside, padding) {
        bounds = DG.latLngBounds(bounds);
        this._restrictZoom(bounds);
        return getBoundsZoom.call(this, bounds, inside, padding);
    },

    getTileLayersNumber: function() {
        return this._tileLayersNumber;
    },

    setMaxZoom: function(zoom) {
        this._mapMaxZoomCache = null;
        return setMaxZoom.call(this, zoom);
    },

    _testAnimation: function(coords) {//if we jump to other project - disable animation
        if (this.projectDetector.enabled()) {
            var projectFrom = this.projectDetector.getProject(),
                projectTo = this.projectDetector.isProjectHere(coords);

            if (projectFrom && projectTo) {
                return projectFrom.code === projectTo.code;
            }
        }

        return true;
    },

    _updateTileLayers: function(e) {
        if (!(e.layer instanceof DG.TileLayer) || e.layer._isDg) { return; }

        if (e.type === 'layeradd') {
            this._tileLayersNumber++;
        } else {
            this._tileLayersNumber--;
        }
    },

    _getNewBounds: function(coords, zoom) {
        if (coords instanceof DG.LatLngBounds) {
            return coords;
        }

        var point = this.project(coords, zoom);
        var screenSize = this.getSize().divideBy(2);

        var sw = this.unproject(point.subtract(screenSize), zoom);
        var ne = this.unproject(point.add(screenSize), zoom);

        return DG.latLngBounds(sw, ne);
    },

    _restrictZoom: function(coords, zoom) {
        if (this._layers &&
            this.projectDetector.enabled() &&
            (this._tileLayersNumber === 0)) {

            var mapOptions = this.options,
                isMapMaxZoom = !!mapOptions.maxZoom,
                dgTileLayer = this.baseLayer,
                bounds = this._getNewBounds(coords, zoom),
                project = this.projectDetector.isProjectHere(bounds);

            if (isMapMaxZoom) {
                if (!this._mapMaxZoomCache) {
                    if (this.baseLayer.options.detectRetina && DG.Browser.retina && mapOptions.maxZoom > 0) {
                        mapOptions.maxZoom--;
                    }

                    this._mapMaxZoomCache = mapOptions.maxZoom;
                }
                mapOptions.maxZoom = (this._mapMaxZoomCache && project) ? this._mapMaxZoomCache :  DG.config.projectLeaveMaxZoom;
                if (project) {
                    this._mapMaxZoomCache = mapOptions.maxZoom;
                }

                return mapOptions.maxZoom;
            } else {
                if (project) {
                    if (dgTileLayer.options.detectRetina && DG.Browser.retina && project.maxZoom > 0) {
                        dgTileLayer.options.maxZoom = project.maxZoom - 1;
                    } else {
                        dgTileLayer.options.maxZoom = project.maxZoom;
                    }
                } else {
                    dgTileLayer.options.maxZoom = DG.config.projectLeaveMaxZoom;
                }

                dgTileLayer.options.maxNativeZoom = dgTileLayer.options.maxZoom;
                this._updateZoomLevels();

                return dgTileLayer.options.maxZoom;
            }
        }
    },

    // Added meta layers events processing before map events
    _fireDOMEvent: function(e, type, targets) {
        if (e.keyCode === 13) {
            // https://github.com/Leaflet/Leaflet/issues/5499
            return;
        }
        if (e.type === 'click') {
            // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
            // @event preclick: MouseEvent
            // Fired before mouse click on the map (sometimes useful when you
            // want something to happen on click before any existing click
            // handlers start running).
            var synth = L.Util.extend({}, e);
            synth.type = 'preclick';
            this._fireDOMEvent(synth, synth.type, targets);
        }

        if (e._stopped) { return; }

        // Find the layer the event is propagating from and its parents.
        targets = (targets || []).concat(this._findEventTargets(e, type));

        if (!targets.length) { return; }

        var target = targets[0];
        if (type === 'contextmenu' && target.listens(type, true)) {
            L.DomEvent.preventDefault(e);
        }

        var data = {
            originalEvent: e
        };

        if (e.type !== 'keypress') {
            var isMarker = target instanceof L.Marker;
            data.containerPoint = isMarker ?
                    this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
            data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
            data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
        }

        for (var i = 0; i < targets.length; i++) {
            // Check metalayers before dispatch the event to the map
            if (targets[i] === this) {
                this.metaLayers.forEach(function(metaLayer) {
                    var listener = metaLayer.mapEvents[type];
                    if (listener) {
                        listener.call(metaLayer, data);
                    }
                });
                // If the event wasn't stopped in metalayers, dispatch it to the map
                if (!data.originalEvent._stopped) {
                    targets[i].fire(type, data, true);
                }
            } else {
                targets[i].fire(type, data, true);
            }

            if (data.originalEvent._stopped ||
                (targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1)) { return; }
        }
    }
});

DG.Map.addInitHook(function() {
    this.on('layeradd layerremove', this._updateTileLayers);
});

// Set css property touch-action to auto if dragging is false.
// Need for scrolling page in mobile using our map dom element.
// todo: I made issue in leaflet https://github.com/Leaflet/Leaflet/issues/4415
DG.Map.addInitHook(function() {
    if (this.options.dragging == false && this.options.tap == false) {
        DG.DomUtil.addClass(this._container, 'dg-dragging-false');
    }
});

DG.Map.addInitHook(function() {
    var errorUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEX28t5R0k5UAAAAH0lEQVR4Xu3AAQkAAADCMPunNsdhWxwAAAAAAAAAwAEhAAABg2UP5AAAAABJRU5ErkJggg==';
    var errorRuUrl = DG.config.protocol + DG.config.baseUrl + '/img/nomap_ru.png';

    var TileLayer = DG.Browser.mobile ? DG.MobileTileLayer : DG.TileLayer;

    var BaseLayer = TileLayer.extend({
        initialize: function(url, options) {
            this._isDg = true;
            TileLayer.prototype.initialize.call(this, url, options);
        },

        getTiles: function() {
            return this._tiles;
        }
    });

    var tileUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaTileServer : DG.config.tileServer);

    this.baseLayer = new BaseLayer(tileUrl, {
        subdomains: '0123',
        errorTileUrl: this.getLang() === 'ru' ? errorRuUrl : errorUrl,
        detectRetina: DG.config.detectRetina,
        maxZoom: 19,
        maxNativeZoom: 19,
        zIndex: 0
    }).addTo(this);

    function updateErrorTileUrl() {
        var lang = this.getLang();
        var project = this.projectDetector && this.projectDetector.getProject();

        if (lang === 'ru' && !project) {
            this.baseLayer.options.errorTileUrl = errorRuUrl;
        } else {
            this.baseLayer.options.errorTileUrl = errorUrl;
        }
    }

    this.on({
        langchange: updateErrorTileUrl,
        projectchange: updateErrorTileUrl,
        projectleave: updateErrorTileUrl
    }, this);
});

DG.Map.mergeOptions({
    tilesCheck: true
});

DG.Map.TilesCheck = DG.Handler.extend({
    initialize: function(map) {
        this._map = map;
        this._layer = map.baseLayer;

        this._moveStartEventCounter = 0;
        this._moveEndEventCounter = 0;

        this._loadingEventCounter = 0;
        this._loadEventCounter = 0;
    },

    addHooks: function() {
        this._map.on(this._mapEvents, this);
        this._layer.on(this._layerEvents, this);
    },

    removeHooks: function() {
        this._map.off(this._mapEvents, this);
        this._layer.off(this._layerEvents, this);
    },

    _mapEvents: {
        layeradd: function(e) {
            if (e.layer == this._layer) {
                this.enable();
            }
        },

        layerremove: function(e) {
            if (e.layer == this._layer) {
                this.disable();
            }
        },

        movestart: function() {
            this._stopWaiting();

            this._moveStartEventCounter++;
            this._isWaiting = true;
        },

        moveend: function() {
            this._moveEndEventCounter++;

            if (!this._isWaiting && this._moveStartEventCounter !== this._moveEndEventCounter) { return; }

            this._isMoveEnd = true;

            this._checkWaiting();
        }
    },

    _layerEvents: {
        loading: function() {
            this._loadingEventCounter++;
        },

        load: function() {
            this._loadEventCounter++;

            if (!this._isWaiting && this._loadingEventCounter !== this._loadEventCounter) { return; }

            this._isLoad = true;

            this._checkWaiting();
        }
    },

    _stopWaiting: function() {
        this._isWaiting = false;
        this._isMoveEnd = false;
        this._isLoad = false;
    },

    _checkWaiting: function() {
        if (this._isWaiting && this._isLoad && this._isMoveEnd) {
            this._stopWaiting();
            this._resetCounters();
            this._checkTiles();
        }
    },

    _checkTiles: function() {
        if (this._map.getTileLayersNumber() !== 0 || !this._map._loaded) { return; }

        var zoom = this._map.getZoom();
        var errorUrl = this._layer.options.errorTileUrl;
        var tiles = this._layer.getTiles();

        for (var i in tiles) {
            if (tiles[i].coords.z === zoom && tiles[i].el.src !== errorUrl) {
                return;
            }
        }

        this._map.zoomOut();
    },

    _resetCounters: function() {
        this._moveStartEventCounter = 0;
        this._moveEndEventCounter = 0;

        this._loadingEventCounter = 0;
        this._loadEventCounter = 0;
    }
});

DG.Map.addInitHook('addHandler', 'tilesCheck', DG.Map.TilesCheck);

/**
 * This customization fixes unwanted inertia movement after sudden drag stops
 * See https://github.com/Leaflet/Leaflet/pull/4048.
 * If this PR ever gets merged, this file can be removed.
 */
var onDragEnd = DG.Map.Drag.prototype._onDragEnd;

DG.Map.Drag.include({
    _rememberTimeAndPosition: function() {
        var time = this._lastTime = +new Date(),
            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

        this._positions.push(pos);
        this._times.push(time);

        // Remove all data points older than 50 ms
        while (time - this._times[0] > 50) {
            this._positions.shift();
            this._times.shift();
        }
    },

    _onDrag: function(e) {
        if (this._map.options.inertia) {
            this._rememberTimeAndPosition();
        }

        this._map
            .fire('move', e)
            .fire('drag', e);
    },

    _onDragEnd: function() {
        if (this._map.options.inertia && !DG.Browser.touch) {
            this._rememberTimeAndPosition();
        }

        onDragEnd.call(this);
    }
});

// from https://github.com/Turfjs/turf-inside/blob/master/index.js
DG.PolyUtil.inside = function(point, polygon, pointReduce) {
    pointReduce = pointReduce || DG.PolyUtil._defaultPointReduce;
    var polys = polygon.coordinates;
    var pt = pointReduce(point);

    // normalize to multipolygon
    if (polygon.type === 'Polygon') {
        polys = [polys];
    }

    var insidePoly = false;
    var i = 0;
    while (i < polys.length && !insidePoly) {
        // check if it is in the outer ring first
        if (this._inRing(pt, polys[i][0], pointReduce)) {
            var inHole = false;
            var k = 1;
            // check for the point in any of the holes
            while (k < polys[i].length && !inHole) {
                if (this._inRing(pt, polys[i][k], pointReduce)) {
                    inHole = true;
                }
                k++;
            }
            if (!inHole)  {
                insidePoly = true;
            }
        }
        i++;
    }
    return insidePoly;
};

// pt is [x,y] and ring is [[x,y], [x,y],..]
DG.PolyUtil._inRing = function(pt, ring, pointReduce) {
    var isInside = false;
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var pi = pointReduce(ring[i]);
        var pj = pointReduce(ring[j]);
        var xi = pi[0], yi = pi[1];
        var xj = pj[0], yj = pj[1];
        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
            (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);

        if (intersect) {
            isInside = !isInside;
        }
    }
    return isInside;
};

DG.PolyUtil._defaultPointReduce = function(point) {
    return point;
};

/**
 *          
 */

if (DG.Browser.mobile) {
    (function() {
        /**
         *  addClass  removeClass,       
         *  ,        
         * 
         * leaflet-dragging  leaflet-drag-target   recalculate style
         */
        var addClass = L.DomUtil.addClass;
        L.DomUtil.addClass = function(el, name) {
            if (name === 'leaflet-dragging' ||
                name === 'leaflet-drag-target'
            ) {
                return;
            }

            addClass(el, name);
        };

        var removeClass = L.DomUtil.removeClass;
        L.DomUtil.removeClass = function(el, name) {
            if (name === 'leaflet-dragging' ||
                name === 'leaflet-drag-target'
            ) {
                return;
            }

            removeClass(el, name);
        }

        L.Draggable.include({
            /**
             *    this._startPos.add(offset)._round()
             *     if (this._newPos && this._newPos.x == pos.x && this._newPos.y == pos.y) {
             *   dom     
             *   leaflet-dragging  leaflet-drag-target
             */
            _onMove: function(e) {
                // Ignore simulated events, since we handle both touch and
                // mouse explicitly; otherwise we risk getting duplicates of
                // touch events, see #4315.
                // Also ignore the event if disabled; this happens in IE11
                // under some circumstances, see #3666.
                if (e._simulated || !this._enabled) { return; }

                if (e.touches && e.touches.length > 1) {
                    this._moved = true;
                    return;
                }

                var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
                    newPoint = new L.Point(first.clientX, first.clientY),
                    offset = newPoint.subtract(this._startPoint);

                if (!offset.x && !offset.y) { return; }
                if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

                L.DomEvent.preventDefault(e);

                if (!this._moved) {
                    // @event dragstart: Event
                    // Fired when a drag starts
                    this.fire('dragstart');

                    this._moved = true;
                    this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

                    this._lastTarget = e.target || e.srcElement;
                    // IE and Edge do not give the <use> element, so fetch it
                    // if necessary
                    if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
                        this._lastTarget = this._lastTarget.correspondingUseElement;
                    }
                }

                var pos = this._startPos.add(offset)._round();
                this._moving = true;

                L.Util.cancelAnimFrame(this._animRequest);
                this._lastEvent = e;

                if (this._newPos && this._newPos.x == pos.x && this._newPos.y == pos.y) {
                    return;
                }

                this._newPos = pos;
                this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);
            }
        });

        /**
         *        1 
         */
        L.Map.Drag.include({
            _onDragEnd: function(e) {
                var map = this._map,
                    options = map.options,

                    noInertia = !options.inertia || this._times.length < 2;

                map.fire('dragend', e);

                if (noInertia) {
                    map.fire('moveend');

                } else {

                    var direction = this._lastPos.subtract(this._positions[0]),
                        duration = (this._lastTime - this._times[0]) / 1000,
                        ease = options.easeLinearity,

                        speedVector = direction.multiplyBy(ease / duration),
                        speed = speedVector.distanceTo([0, 0]),

                        limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
                        limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

                        decelerationDuration = 1, // limitedSpeed / (options.inertiaDeceleration * ease),
                        offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

                    if (!offset.x && !offset.y) {
                        map.fire('moveend');

                    } else {
                        offset = map._limitOffset(offset, map.options.maxBounds);

                        L.Util.requestAnimFrame(function() {
                            map.panBy(offset, {
                                duration: decelerationDuration,
                                easeLinearity: ease,
                                noMoveStart: true,
                                animate: true
                            });
                        });
                    }
                }
            }
        })
    })();
}

L.MobileTileLayer = L.TileLayer.extend({
    initialize: function(url, options) {
        L.TileLayer.prototype.initialize.call(this, url, options);

        this._previewUrl = DG.config.protocol +
            (DG.Browser.retina ? DG.config.previewRetinaTileServer : DG.config.previewTileServer);
    },

    /**
     *   ,  L.DomUtil.on   
     */
    createTile: function(coords, done, url) {
        var tile = document.createElement('img');
        tile.onload = L.bind(this._tileOnLoad, this, done, tile);
        tile.onerror = L.bind(this._tileOnError, this, done, tile);

        if (this.options.crossOrigin) {
            tile.crossOrigin = '';
        }

        /*
         Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
         http://www.w3.org/TR/WCAG20-TECHS/H67
        */
        tile.alt = '';
        tile.src = this.getTileUrl(coords, url);

        return tile;
    },

    /**
     *   leaflet-tile
     *     
     */
    _initTile: function(tile) {
        tile.style.position = 'absolute';

        var tileSize = this.getTileSize();
        tile.style.width = tileSize.x + 'px';
        tile.style.height = tileSize.y + 'px';

        tile.style.visibility = 'hidden';

        tile.onselectstart = L.Util.falseFn;
        tile.onmousemove = L.Util.falseFn;

        // without this hack, tiles disappear after zoom on Chrome for Android
        // https://github.com/Leaflet/Leaflet/issues/2078
        if (L.Browser.android && !L.Browser.android23) {
            tile.style.WebkitBackfaceVisibility = 'hidden';
        }

        return tile;
    },

    /**
     *   leaflet-tile-container
     */
    _updateLevels: function() {

        var zoom = this._tileZoom,
            maxZoom = this.options.maxZoom;

        if (zoom === undefined) { return undefined; }

        for (var z in this._levels) {
            if (this._levels[z].el.children.length || z === zoom) {
                this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
            } else {
                L.DomUtil.remove(this._levels[z].el);
                this._removeTilesAtZoom(z);
                delete this._levels[z];
            }
        }

        var level = this._levels[zoom],
            map = this._map;

        if (!level) {
            level = this._levels[zoom] = {};

            level.el = L.DomUtil.create('div', 'leaflet-zoom-animated', this._container);

            level.el.style.zIndex = maxZoom;

            level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
            level.zoom = zoom;

            this._setZoomTransform(level, map.getCenter(), map.getZoom());

            // force the browser to consider the newly added element for transition
            L.Util.falseFn(level.el.offsetWidth);
        }

        this._level = level;

        return level;
    },

    /**
     *     documentFragment
     */
    _update: function(center) {
        var map = this._map;
        if (!map) { return; }
        var zoom = map.getZoom();

        if (center === undefined) { center = map.getCenter(); }
        if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

        var pixelBounds = this._getTiledPixelBounds(center),
            tileRange = this._pxBoundsToTileRange(pixelBounds),
            tileCenter = tileRange.getCenter(),
            queue = [],
            margin = this.options.keepBuffer,
            noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
                                      tileRange.getTopRight().add([margin, -margin]));

        for (var key in this._tiles) {
            var c = this._tiles[key].coords;
            if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
                this._tiles[key].current = false;
            }
        }

        // _update just loads more tiles. If the tile zoom level differs too much
        // from the map's, let _setView reset levels and prune old tiles.
        if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

        // create a queue of coordinates to load tiles from
        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                var coords = new L.Point(i, j);
                coords.z = this._tileZoom;

                if (!this._isValidTile(coords)) { continue; }

                var tile = this._tiles[this._tileCoordsToKey(coords)];
                if (tile) {
                    tile.current = true;
                } else {
                    queue.push(coords);
                }
            }
        }

        // sort tile queue to load tiles in order of their distance to center
        queue.sort(function(a, b) {
            return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
        });

        if (queue.length !== 0) {
            // if it's the first batch of tiles to load
            if (!this._loading) {
                this._loading = true;
                // @event loading: Event
                // Fired when the grid layer starts loading tiles.
                this.fire('loading');
            }

            for (i = 0; i < queue.length; i++) {
                this._addTile(queue[i], this._level.el);
            }
        }
    },

    /**
     *      ,       
     */
    _needPreviewTile: function(coords) {
        var coords2 = L.point(
            coords.x / 2,
            coords.y / 2
        )._floor();

        coords2.z = coords.z - 1;

        var key = this._tileCoordsToKey(coords2)

        return !this._tiles[key];
    },

    /**
     *     
     */
    _addTile: function(coords, container) {
        var tilePos = this._getTilePos(coords),
            key = this._tileCoordsToKey(coords);

        var wrapCoords = this._wrapCoords(coords);
        var needPreview = this._needPreviewTile(wrapCoords);

        var url = needPreview ? this._previewUrl : this._url;
        var tile = this.createTile(wrapCoords, L.bind(this._tileReady, this, coords), url);

        this._initTile(tile, needPreview);

        L.DomUtil.setPosition(tile, tilePos);

        // save tile in cache
        this._tiles[key] = {
            el: tile,
            preview: needPreview,
            coords: coords,
            current: true
        };

        container.appendChild(tile);
        // @event tileloadstart: TileEvent
        // Fired when a tile is requested and starts loading.
        this.fire('tileloadstart', {
            tile: tile,
            coords: coords
        });
    },

    /**
     *  fadeAnimated   leaflet-tile-loaded
     */
    _tileReady: function(coords, err, tile) {
        if (!this._map) { return; }

        if (err) {
            // @event tileerror: TileErrorEvent
            // Fired when there is an error loading a tile.
            this.fire('tileerror', {
                error: err,
                tile: tile,
                coords: coords
            });
        }

        var key = this._tileCoordsToKey(coords);

        tile = this._tiles[key];
        if (!tile) { return; }

        //       ( ) ,
        //     
        if (tile.originalEl && tile.el.parentNode) {
            tile.el.parentNode.replaceChild(tile.originalEl, tile.el);
            tile.el = tile.originalEl;

            tile.originalEl = null;
            tile.preview = false;

        //      ,     
        //    
        } else if (tile.preview) {
            tile.originalEl = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords), this._url);
            this._initTile(tile.originalEl);
            L.DomUtil.setPosition(tile.originalEl, this._getTilePos(coords));

            if (!err) {
                tile.el.style.visibility = '';
            }

            return;
        }

        tile.loaded = +new Date();
        tile.active = true;

        if (!err) {
            tile.el.style.visibility = '';

            // @event tileload: TileEvent
            // Fired when a tile loads.
            this.fire('tileload', {
                tile: tile.el,
                coords: coords
            });
        }

        if (this._noTilesToLoad()) {
            this._loading = false;
            // @event load: Event
            // Fired when the grid layer loaded all visible tiles.
            this.fire('load');

            if (L.Browser.ielt9 || !this._map._fadeAnimated) {
                L.Util.requestAnimFrame(this._pruneTiles, this);
            } else {
                // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
                // to trigger a pruning.
                setTimeout(L.bind(this._pruneTiles, this), 250);
            }
        }
    },

    /**
     *     ,  url  
     */
    getTileUrl: function(coords, url) {
        var data = {
            r: L.Browser.retina ? '@2x' : '',
            s: this._getSubdomain(coords),
            x: coords.x,
            y: coords.y,
            z: this._getZoomForUrl()
        };
        if (this._map && !this._map.options.crs.infinite) {
            var invertedY = this._globalTileRange.max.y - coords.y;
            if (this.options.tms) {
                data['y'] = invertedY;
            }
            data['-y'] = invertedY;
        }

        return L.Util.template(url, L.extend(data, this.options));
    },
});

DG.Control.Zoom.include(DG.Locale);
DG.Control.Zoom.Dictionary = {};

DG.Control.Zoom.include({
    onAdd: function(map) {
        var zoomName = 'dg-zoom',
            buttonTemplate = '<div class="dg-control-round__icon ' + zoomName + '__control ' + zoomName + '__button ' + zoomName + '__button_type_{type}"></div>',
            container = DG.DomUtil.create('div', zoomName);

        this._map = map;

        this._zoomInButton = this._createButton(DG.Util.template(buttonTemplate, {type : 'in'}), this.t('zoom_in'), 'dg-control-round ' + zoomName + '__in', container, this._zoomIn, this);
        this._zoomOutButton = this._createButton(DG.Util.template(buttonTemplate, {type : 'out'}), this.t('zoom_out'), 'dg-control-round ' + zoomName + '__out', container, this._zoomOut, this);

        this._updateDisabled();
        map.on('zoomend zoomlevelschange', this._updateDisabled, this);

        return container;
    },

    _originalCreateButton: DG.Control.Zoom.prototype._createButton,

    // set active state control on mobile devices
    _createButton: function() {
        var args = Array.prototype.slice.call(arguments);
        var link = this._originalCreateButton.apply(this, args);

        var icon = link.children[0];
        var linkActiveClass = 'dg-control-round_state_active';
        var iconActiveClass = 'dg-control-round__icon_state_active';

        DG.DomEvent
            .on(link, 'touchstart', function() {
                DG.DomUtil.addClass(link, linkActiveClass);
                DG.DomUtil.addClass(icon, iconActiveClass);
            })
            .on(link, 'touchend touchcancel', function() {
                DG.DomUtil.removeClass(link, linkActiveClass);
                DG.DomUtil.removeClass(icon, iconActiveClass);
            });

        return link;
    },

    _renderTranslation: function() {
        if (!this._zoomInButton || !this._zoomOutButton) {
            return;
        }

        this._zoomInButton.title = this.t('zoom_in');
        this._zoomOutButton.title = this.t('zoom_out');
    }
});

DG.Control.Zoom.Dictionary.ru = {
    zoom_in : '',
    zoom_out : ''
};
DG.Control.Zoom.Dictionary.it = {
    zoom_in : 'Zoom avanti',
    zoom_out : 'Zoom indietro'
};
DG.Control.Zoom.Dictionary.cs = {
    zoom_in : 'Piblit',
    zoom_out : 'Oddlit'
};
DG.Control.Zoom.Dictionary.en = {
    zoom_in : 'Zoom in',
    zoom_out : 'Zoom out'
};
DG.Control.Zoom.Dictionary.es = {
    zoom_in : 'Acercar',
    zoom_out : 'Alejar'
};

var dust = _dereq_('dustjs-linkedin');
_dereq_('dustjs-helpers');

DG.dust = function(name, data) {
    var result;

    // The callback is called synchronously, so this works
    dust.render(name, data, function(err, html) {
        result = html;
    });

    return result;
};

DG.Control.Attribution.include(DG.Locale);
DG.Control.Attribution.Dictionary = {};
DG.Control.Attribution.include({
    options: {
        position: 'bottomright'
    },

    _getLink: function(linkType) {
        /* eslint-disable camelcase */
        var dictionary = {
            ru: {
                copyright_logo: 'http://info.2gis.ru/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://api.2gis.ru/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.ru/api-rules/'
            },

            it: {
                copyright_logo: 'http://2gis.it/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://2gis.it/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.it/licensing-agreement/'
            },

            cz: {
                copyright_logo: 'http://praha.2gis.cz/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://praha.2gis.cz/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.cz/api-rules/'
            },

            cl: {
                copyright_logo: 'http://santiago.2gis.cl/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://santiago.2gis.cl/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.cl/api-rules/'
            },

            cy: {
                copyright_logo: 'http://info.2gis.com.cy/lemesos?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://info.2gis.com.cy/lemesos?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.com.cy/api-rules/'
            },

            ae: {
                copyright_logo: 'http://info.2gis.ae/dubai?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://info.2gis.ae/dubai?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.ae/api-rules/'
            }
        };
        /* eslint-enable camelcase */

        var countryCode = (this._countryCode in dictionary) ? this._countryCode : 'ru';

        return dictionary[countryCode][linkType];
    },

    onAdd: function(map) {
        if (!map._copyright) {
            map._copyright = true;
            this._first = true;
        }

        map.attributionControl = this;
        this._container = DG.DomUtil.create('div', 'dg-attribution');
        DG.DomEvent.disableClickPropagation(this._container);

        for (var i in map._layers) {
            if (map._layers[i].getAttribution) {
                this.addAttribution(map._layers[i].getAttribution());
            }
        }

        this._update();

        return this._container;
    },

    _update: function(lang, osm, countryCode) {
        if (!this._map) { return; }

        if (typeof osm !== 'undefined') {
            this._osm = osm;
        }

        if (typeof countryCode !== 'undefined') {
            this._countryCode = countryCode;
        }

        var attribs = [];

        for (var i in this._attributions) {
            if (this._attributions[i]) {
                attribs.push(i);
            }
        }

        var prefixAndAttribs = [],
            copyright = '';

        if (this._first) {
            copyright = this._getAttributionHTML(lang);
        }

        if (this.options.prefix) {
            prefixAndAttribs.push(this.options.prefix);
        }
        if (attribs.length) {
            prefixAndAttribs.push(attribs.join(', '));
        }

        this._container.innerHTML = copyright + prefixAndAttribs.join(' | ');
    },
    _getData: function(lang) {
        return {
            'osm': this._osm,
            'work_on': this.t('work_on'),
            'lang': lang || this._map.getLang(),
            'copyright_apilink': this._getLink('copyright_apilink'),
            'copyright_license': this._getLink('copyright_license'),
            'copyright_logo': this._getLink('copyright_logo'),
            'license_agreement': this.t('license_agreement'),
            'API_2GIS': this.t('API_2GIS')
        };
    },
    _getAttributionHTML: function(lang) {
        return DG.dust('DGAttribution/copyright', this._getData(lang));
    },
    _renderTranslation: function(e) {
        this._update(e.lang);
    }
});

DG.Map.addInitHook(function() {
    if (!this._copyright) {
        DG.control.attribution().addTo(this);
    }
});

DG.Control.Attribution.Dictionary.ru = {
    license_agreement: ' ',
    work_on: ' ',
    API_2GIS: 'API 2'
};

DG.Control.Attribution.Dictionary.it = {
	license_agreement : 'Accordo di licenza',
    work_on: ' ',
	API_2GIS: '2GIS API'
};

DG.Control.Attribution.Dictionary.cs = {
	license_agreement: 'Licenn smlouva',
	work_on: 'Pracuje na',
    API_2GIS: 'API 2GIS'
};

DG.Control.Attribution.Dictionary.en = {
    license_agreement: 'License agreement',
    work_on: 'Uses',
    API_2GIS: '2GIS API'
};

DG.Control.Attribution.Dictionary.es = {
	license_agreement : 'Acuerdo de licencia',
    work_on: ' ',
	API_2GIS: '2GIS API'
};

DG.Control.Location = DG.RoundControl.extend({

    statics: {
        Dictionary: {}
    },

    options: {
        iconClass: 'locate',
        position: DG.Browser.mobile ? 'bottomright' : 'topleft',
        drawCircle: true,
        follow: true,  // follow with zoom and pan the user's location
        stopFollowingOnDrag: false, // if follow is true, stop following when map is dragged
        metric: true,
        onLocationError: function(/*err*/) {
            // this event is called in case of any location error
            // that is not a time out error.
            // console.log(err.message);
        },
        onLocationOutsideMapBounds: function(/*context*/) {
            // this event is repeatedly called when the location changes
            // console.log(context.t('outsideMapBoundsMsg'));
        },
        locateOptions: {}
    },

    initialize: function(options) {
        DG.Util.setOptions(this, options);

        if (!navigator.geolocation) {
            this._disable = true;
            return;
        }

        this._event = undefined;

        this._locateOptions = {
            watch: true,  // if you overwrite this, visualization cannot be updated
            setView: true,
            maximumAge: Infinity,
            maxZoom: Infinity
        };
        DG.extend(this._locateOptions, this.options.locateOptions);

        this._resetVariables();

        this.on({
            'click': this._handleLocate,
            'add': this._initLocate
        });
    },

    _initLocate: function() {
        this._layer = new DG.LayerGroup();
        this._layer.addTo(this._map);

        // event hooks
        this._map.on({
            'locationfound': this._onLocationFound,
            'locationerror': this._onLocationError
        }, this);
    },

    _handleLocate: function() {
        if (this._active && (!this._event ||
            (this._map.getBounds().contains(this._event.latlng) ||
            this._isOutsideMapBounds()))) {
            this._stopLocate();
        } else {
            this._locateOnNextLocationFound = true;

            if (!this._active) {
                this._map.locate(this._locateOptions);
            }

            this._active = true;

            if (this.options.follow) {
                this._startFollowing();
            }

            this._clearError();

            if (this._event) {
                this._visualizeLocation();
            } else {
                this.setState('requesting');
            }
        }
    },

    _onLocationFound: function(e) {
        // no need to do anything if the location has not changed
        if (this._event &&
            (this._event.latlng.lat === e.latlng.lat &&
             this._event.latlng.lng === e.latlng.lng &&
             this._event.accuracy === e.accuracy)) {
            return;
        }

        if (!this._active) {
            return;
        }

        this._event = e;

        if (this.options.follow && this._following) {
            this._locateOnNextLocationFound = true;
        }

        this._visualizeLocation();
    },

    _startFollowing: function() {
        this._following = true;
        if (this.options.stopFollowingOnDrag) {
            this._map.on('dragstart', this._stopFollowing);
        }
    },

    _stopFollowing: function() {
        this._following = false;
        if (this.options.stopFollowingOnDrag) {
            this._map.off('dragstart', this._stopFollowing);
        }
        this._visualizeLocation();
    },

    _isOutsideMapBounds: function() {
        if (this._event === undefined) {
            return false;
        }
        return this._map.options.maxBounds &&
            !this._map.options.maxBounds.contains(this._event.latlng);
    },

    _visualizeLocation: function() {
        if (this._event.accuracy === undefined) {
            this._event.accuracy = 0;
        }

        var radius = this._event.accuracy;

        if (this._locateOnNextLocationFound) {
            if (this._isOutsideMapBounds()) {
                this.options.onLocationOutsideMapBounds(this);
            } else if (this._locateOptions.setView) {
                var zoom = this._map.projectDetector.getProject().maxZoom || DG.config.projectLeaveMaxZoom;
                zoom = Math.min(this._locateOptions.maxZoom, zoom);
                this._map.setView(this._event.latlng, zoom);
            }
            this._locateOnNextLocationFound = false;
        }

        // circle with the radius of the location's accuracy
        var style = {
            clickable: false,
            color: '#FFF',
            fillColor: '#FFF',
            fillOpacity: 0.4,
            weight: 0,
            opacity: 0.3
        };
        if (this.options.drawCircle) {
            if (!this._circle) {
                this._circle = DG.circle(this._event.latlng, radius, style)
                    .addTo(this._layer);
            } else {
                this._circle.setLatLng(this._event.latlng).setRadius(radius);
            }
        }

        var markerClass = 'dg-location__pin';

        markerClass += this._following ? (' ' + markerClass + 'state_following') : '';
        // small inner marker
        var m = {
            icon: DG.divIcon({
                className: markerClass,
                iconSize: [20, 20]
            })
        };

        if (!this._marker) {
            this._marker = DG.marker(this._event.latlng, m)
                .bindLabel(this.t('you_are_here'))
                .addTo(this._layer);
        } else {
            this._marker.setLatLng(this._event.latlng);
        }

        DG.DomEvent.on(this._marker, 'click', function() {
            this._map.fireEvent('dgLocateClick');
        }, this);

        if (!this._container) {
            return;
        }

        this.setState('active');
    },

    _resetVariables: function() {
        this._active = false;
        this._following = false;
    },


    _stopLocate: function() {
        this._map.stopLocate();
        this._map.off('dragstart', this._stopFollowing);

        this.setState();
        this._resetVariables();

        this._layer.clearLayers();
        this._marker = undefined;
        this._circle = undefined;
        this._event = undefined;
    },

    _onLocationError: function(err) {
        // ignore time out error if the location is watched
        if (err.code === 3 && this._locateOptions.watch) {
            return;
        }

        this._stopLocate();
        this._error = DG.DomUtil.create('div', 'dg-label dg-label_name_location-error', this._container);
        this._errorText = DG.DomUtil.create('div', 'dg-label__content', this._error);
        this._errorText.innerHTML = this.t('cant_find');

        var self = this;
        setTimeout(function() {
            self._clearError();
        }, 3000);

        //show location error
        this.options.onLocationError(err);
    },

    _clearError: function() {
        if (this._error) {
            this._container.removeChild(this._error);
            this._error = undefined;
            this._errorText = undefined;
        }
    },

    _renderTranslation: function() {
        if (this._link) {
            this._link.title = this.t('button_title');
        }
        if (this._marker) {
            this._marker.bindLabel(this.t('you_are_here'));
        }
    }
});

DG.control.location = function(options) {
    return new DG.Control.Location(options);
};

DG.Map.addInitHook(function() {
    if (this.options.locationControl) {
        this.locationControl = DG.control.location(this.options.locationControl);
        this.addControl(this.locationControl);
    }
});

DG.Control.Location.Dictionary.ru = {
	 cant_find : '    ',
	 you_are_here : ' ',
	 button_title : '   '
};
DG.Control.Location.Dictionary.it = {
	 cant_find : 'Non siamo riusciti a localizzarti',
	 you_are_here : 'Voi siete qui',
	 button_title : 'Trova la tua posizione sulla mappa'
};
DG.Control.Location.Dictionary.cs = {
	 cant_find : 'Nepodailo se nm urit Vai polohu',
	 you_are_here : 'Jste tady',
	 button_title : 'Urit Vai polohu na map'
};
DG.Control.Location.Dictionary.en = {
	 cant_find : 'We can\'t find you',
	 you_are_here : 'You are here',
	 button_title : 'Show your location'
};
DG.Control.Location.Dictionary.es = {
	 cant_find : 'No pudimos encontrarte',
	 you_are_here : 'T ests aqu',
	 button_title : 'Encontrarte en el mapa'
};
// Inspired by Sindre Sorhus screenfull
/*global Element */
DG.Screenfull = DG.Class.extend({
    _apiMap: [
        [
            'requestFullscreen',
            'exitFullscreen',
            'fullscreenElement',
            'fullscreenEnabled',
            'fullscreenchange',
            'fullscreenerror'
        ],
        [
            'webkitRequestFullscreen',
            'webkitExitFullscreen',
            'webkitFullscreenElement',
            'webkitFullscreenEnabled',
            'webkitfullscreenchange',
            'webkitfullscreenerror'

        ],
        [
            'mozRequestFullScreen',
            'mozCancelFullScreen',
            'mozFullScreenElement',
            'mozFullScreenEnabled',
            'mozfullscreenchange',
            'mozfullscreenerror'
        ],
        [
            'msRequestFullscreen',
            'msExitFullscreen',
            'msFullscreenElement',
            'msFullscreenEnabled',
            'MSFullscreenChange',
            'MSFullscreenError'
        ]
    ],

    initialize: function() {
        this.api = this._api();
    },

    request: function(elem) {
        var request = this.api.requestFullscreen;

        elem = elem || document.documentElement;
        elem[request](Element.ALLOW_KEYBOARD_INPUT);
    },

    exit: function() {
        document[this.api.exitFullscreen]();
    },

    isFullscreen: function() {
        return !!document[this.api.fullscreenElement];
    },

    isAvailable: function() {
        return Boolean(this.api);
    },

    _api: function() {
        var api = {},
            apiMap = this._apiMap;

        apiMap.forEach(function(val) {
            if (val && val[1] in document) {
                val.forEach(function(method, i) {
                    api[apiMap[0][i]] = method;
                });
            }
        });

        return api.requestFullscreen ? api : false;
    }
});

DG.screenfull = new DG.Screenfull();

DG.Control.Fullscreen = DG.RoundControl.extend({

    statics: {
        Dictionary: {}
    },

    options: {
        position: 'topright',
        iconClass: 'fullscreen'
    },

    initialize: function(options) {
        DG.Util.setOptions(this, options);
        this._isFullscreen = false;
        this.on('click', this._toggleFullscreen);
    },

    _toggleFullscreen: function() {
        if (!this._isFullscreen) {
            this._toggle(true, 'request', 'on', 'requestfullscreen');
        } else {
            this._toggle(false, 'exit', 'on', 'cancelfullscreen');
        }

        this._renderTranslation();
        this._map.invalidateSize();
    },

    _renderTranslation: function() {
        this._link.title = this.t(this._isFullscreen ? 'title_min' : 'title_max');
    },

    _toggle: function(isEnabled, method, list, event) {
        var container = this._map._container;

        this._isFullscreen = isEnabled;
        this.setState(isEnabled ? 'active' : '');

        DG.screenfull[method](container);
        DG.DomEvent[list](document, DG.screenfull.api.fullscreenchange, this._onFullScreenStateChange, this);
        this._map.fire(event);
    },

    _onFullScreenStateChange: function() {
        if (!DG.screenfull.isFullscreen()) {
            this._toggle(false, 'exit', 'on', 'cancelfullscreen');
        }
    }
});

DG.control.fullscreen = function(options) {
    return new DG.Control.Fullscreen(options);
};

DG.Map.mergeOptions({
    fullscreenControl: true
});

DG.Map.addInitHook(function() {
    if (this.options.fullscreenControl) {
        this.fullscreenControl = DG.control.fullscreen(this.options.fullscreenControl);

        if (DG.screenfull.isAvailable()) {
            this.addControl(this.fullscreenControl);
        }
    }
});

DG.Control.Fullscreen.Dictionary.ru = {
    title_max : '',
    title_min : ''
};

DG.Control.Fullscreen.Dictionary.it = {
    title_max : 'Espandi',
    title_min : 'Ripristina'
};

DG.Control.Fullscreen.Dictionary.cs = {
     title_max : 'Rozbalit',
     title_min : 'Obnovit'
};

DG.Control.Fullscreen.Dictionary.en = {
    title_max : 'Expand',
    title_min : 'Restore'
};

DG.Control.Fullscreen.Dictionary.es = {
    title_max : 'Maximizar',
    title_min : 'Restaurar'
};

DG.Meta = {};

DG.Meta.Layer = DG.Layer.extend({

    options: {
        tileSize: 256,

        minZoom: 0,
        maxZoom: 19,
        zoomOffset: 0,
        eventBubbling: 'transparent'
        // maxNativeZoom: <Number>,
        // detectRetina: <Number>,
        // zoomReverse: <Number>
        // attribution: <String>,
        // zIndex: <Number>,
        // bounds: <LatLngBounds>
    },

    initialize: function(source, options) { // (String, Object)
        DG.TileLayer.prototype.initialize.call(this, null, options);
        delete this._url;

        this._currentTile = false;
        this._currentTileData = false;
        this._dispatchMouseEvents = true;

        this._origin = DG.Meta.origin(source, {
            dataFilter: this.options.dataFilter
        });
    },

    getOrigin: function() { // () -> Object
        return this._origin;
    },

    onAdd: function(map) {
        this._resetView();

        map.metaLayers.push(this);

        map.on('rulerstart', this._disableDispatchMouseEvents, this);
        map.on('rulerend', this._enableDispatchMouseEvents, this);
    },

    onRemove: function(map) {
        this._tileZoom = null;

        var index = map.metaLayers.indexOf(this);
        if (index !== -1) {
            map.metaLayers.splice(index, 1);
        }

        map.off('rulerstart', this._disableDispatchMouseEvents, this);
        map.off('rulerend', this._enableDispatchMouseEvents, this);
    },

    getEvents: function() {
        return {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
        };
    },

    _removeAllTiles: DG.GridLayer.prototype._removeAllTiles,
    _getZoomForUrl: DG.TileLayer.prototype._getZoomForUrl,
    getTileSize: DG.TileLayer.prototype.getTileSize,
    _isValidTile: DG.GridLayer.prototype._isValidTile,
    _wrapCoords: DG.GridLayer.prototype._wrapCoords,
    _resetView: DG.GridLayer.prototype._resetView,
    _resetGrid: DG.GridLayer.prototype._resetGrid,
    _invalidateAll: DG.GridLayer.prototype._invalidateAll,
    _pxBoundsToTileRange: DG.GridLayer.prototype._pxBoundsToTileRange,

    // Fix for https://github.com/Leaflet/Leaflet/compare/0726f12bbf33fcb18fe8bb541d5e3212bb1f5ab2...c263f2d8b1bd962b60474376cc4816a688052513#diff-f1e6be67599c594731fff6191c710420L579
    _onMoveEnd: function() {
        if (!this._map || this._map._animatingZoom) { return; }

        this._resetView();
    },

    _enableDispatchMouseEvents: function() {
        this._dispatchMouseEvents = true;
    },

    _disableDispatchMouseEvents: function() {
        this._dispatchMouseEvents = false;
    },

    mapEvents: {
        mousemove: function(event) {
            var tileSize = this.getTileSize(),
                layerPoint = this._map.mouseEventToLayerPoint(event.originalEvent),
                tileOriginPoint = this._map.getPixelOrigin().add(layerPoint),
                tileCoord = tileOriginPoint.unscaleBy(tileSize).floor(),
                mouseTileOffset,
                tileKey,
                hoveredObject,
                zoom = this._map.getZoom();

            if (zoom > (this.options.maxZoom + this.options.zoomOffset) ||
                zoom < (this.options.minZoom - this.options.zoomOffset) ||
                !this._isValidTile(tileCoord)) {
                return;
            }

            this._wrapCoords(tileCoord);

            tileCoord.z = this._getZoomForUrl();
            tileCoord.key = tileSize.x + 'x' + tileSize.y;
            tileKey = this._origin.getTileKey(tileCoord);

            if (tileKey !== this._currentTile) {
                this._currentTile = tileKey;
                this._currentTileData = false;
            }

            if (this._currentTileData === false) {
                this._currentTileData = this._origin.getTileData(tileCoord);
            } else {
                mouseTileOffset = DG.point(tileOriginPoint.x % tileSize.x, tileOriginPoint.y % tileSize.y);
                hoveredObject = this._getHoveredObject(tileCoord, mouseTileOffset);

                if (this._hoveredEntity !== hoveredObject) {
                    this._fireMouseEvent('mouseout', event);

                    this._hoveredEntity = hoveredObject;
                    this._fireMouseEvent('mouseover', event);
                }

                this._fireMouseEvent('mousemove', event);
            }
        },
        mouseout: function(event) {
            this._fireMouseEvent('mouseout', event);
            this._hoveredEntity = null;
            this._currentTile = false;
        },

        click: function(event) {
            this._mouseDown = false;
            this._fireMouseEvent('click', event);
        },

        dblclick: function(event) {
            this._fireMouseEvent('dblclick', event);
        },

        mousedown: function(event) {
            this._mouseDown = true;
            this._fireMouseEvent('mousedown', event);
        },

        contextmenu: function(event) {
            this._fireMouseEvent('contextmenu', event);
        }
    },

    _fireMouseEvent: function(type, mouseEvent) {
        if (!this._hoveredEntity || !this._dispatchMouseEvents) {
            return;
        }
        this.fire(type, {
            meta: this._hoveredEntity,
            latlng: this._map.mouseEventToLatLng(mouseEvent.originalEvent)
        });
        var isDragging = type === 'mousedown' || (this._mouseDown && type === 'mousemove');
        if (this.options.eventBubbling === 'layer' && !isDragging) {
            DG.DomEvent.stop(mouseEvent);
        }
    },

    _getHoveredObject: function(coords, mouseTileOffset) {
        for (var i = 0; i < this._currentTileData.length; i++) {
            if (DG.PolyUtil.inside(mouseTileOffset, this._currentTileData[i].geometry, this._pointReduceHelper)) {
                return this._currentTileData[i];
            }
        }

        return null;
    },

    _pointReduceHelper: function(point) {
        return [point.x, point.y];
    },

    _setView: function(center, zoom, noPrune, noUpdate) {
        var tileZoom = Math.round(zoom),
            tileZoomChanged = this._tileZoom !== tileZoom;

        if (!noUpdate && tileZoomChanged) {
            this._tileZoom = tileZoom;
            this._resetGrid();
        }
    }
});

DG.Meta.layer = function(source, options) {
    return new DG.Meta.Layer(source, options);
};

DG.Meta.Origin = DG.Class.extend({

    options: {
        subdomains: '0123',
        dataFilter: null
    },

    _url: false,

    initialize: function(url, options) { // (String, Object)
        this._url = url;
        this._requests = {};

        this._tileStorage = {};

        options = DG.setOptions(this, options);

        if (typeof options.subdomains === 'string') {
            options.subdomains = options.subdomains.split('');
        }
    },

    getTileData: function(coord) { // (Object) -> Object
        var tileKey = this.getTileKey(coord),
            self = this;

        if (typeof this._tileStorage[tileKey] === 'undefined' && typeof this._requests[tileKey] === 'undefined') {
            this._tileStorage[tileKey] = false;
            this._requests[tileKey] = this._requestData(coord).then(function(data) {
                self.setTileData(tileKey, self.options.dataFilter ? self.options.dataFilter(data, coord) : data);
                delete self._requests[tileKey];
            });
            return false;
        }

        return this._tileStorage[tileKey];
    },

    setTileData: function(key, data) { // (Object/String, Object) -> Object
        if (typeof key !== 'string') {
            key = this.getTileKey(key);
        }

        data.forEach(function(entity) {
            if (entity.geometry.constructor !== Object) {
                entity.geometry = DG.Wkt.toGeoJSON(entity.geometry);
            }
            if (!this._tileStorage[key]) {
                this._tileStorage[key] = [];
            }
            this._tileStorage[key].push(entity);
        }, this);

        return this;
    },

    flush: function() { // () -> Object
        this._tileStorage = {};
        Object.keys(this._requests).forEach(function(tileKey) {
            if (this[tileKey].abort) {
                this[tileKey].abort();
            }
        }, this._requests);

        return this;
    },

    setURL: function(url, flush) { // (String, Boolean) -> Object
        this._url = url;
        if (flush) {
            this.flush();
        }

        return this;
    },

    getTileKey: function(coord) { // (Object)-> String
        return [coord.x, coord.y, coord.z, coord.key].join(':');
    },

    _requestData: function(key) { // (String)
        if (this._url) {
            return this._performRequest(key);
        } else {
            return Promise.resolve([]);
        }
    },

    _performRequest: function(coords) { // (Object) -> Promise
        return DG.ajax(this._prepareURL(coords), {
            type: 'get',
            dataType: 'json'
        });
    },

    _prepareURL: function(coords) { // (Object) -> String
        return DG.Util.template(this._url, {
            x: coords.x,
            y: coords.y,
            z: coords.z,
            s: this._getSubdomain(coords)
        });
    },

    _getSubdomain: DG.TileLayer.prototype._getSubdomain

});

DG.Meta.origin = function(source, options) {
    return new DG.Meta.Origin(source, options);
};

DG.Map.mergeOptions({
    poi: !DG.Browser.mobile
});

DG.Poi = DG.Handler.extend({

    options: {
        disableLabel: false
    },

    initialize: function(map, options) { // (Object)
        this._map = map;
        DG.Util.setOptions(this, options);

        var url = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaPoiMetaServer : DG.config.poiMetaServer);

        this._metaLayer = DG.Meta.layer(url, {
            minZoom: DG.config.poiLayerMinZoom,
            maxNativeZoom: 19,
            detectRetina: DG.config.detectRetina,
            eventBubbling: 'layer',
            dataFilter: DG.bind(this._processData, this)
        });
    },

    addHooks: function() {
        this._map.addLayer(this._metaLayer);
        if (!this.options.disableLabel) {
            this._labelHelper = DG.label();
        }
        this._metaLayer.on(this._layerEventsListeners, this);
    },

    removeHooks: function() {
        this._map.removeLayer(this._metaLayer);
        if (!this.options.disableLabel) {
            this._map.removeLayer(this._labelHelper);
            this._labelHelper = null;
        }
        this._metaLayer.off(this._layerEventsListeners, this);
    },

    getMetaLayer : function() {
        return this._metaLayer;
    },

    _processData : function(data, coord) {
        var tileOriginPoint = coord.scaleBy(this._metaLayer.getTileSize());
        var polygonLngLatToPoints = DG.bind(this._polygonLngLatToPoints, this, tileOriginPoint);

        if (data.responseText === '') {
            return [];
        }

        return data.result.poi
            .map(function(item) {
                return {
                    id: item.id,
                    hint: item.links[0].name,
                    linked: item.links[0],
                    geometry: DG.Wkt.toGeoJSON(item.hover)
                };
            })
            .filter(function(item) {
                return item.geometry.type == 'Polygon' ||
                    item.geometry.type == 'MultiPolygon';
            })
            .map(function(item) {
                var geoJson = item.geometry;

                if (geoJson.type == 'Polygon') {
                    geoJson.coordinates = polygonLngLatToPoints(geoJson.coordinates);
                } else if (geoJson.type == 'MultiPolygon') {
                    geoJson.coordinates = geoJson.coordinates.map(polygonLngLatToPoints);
                }

                return item;
            });
    },

    _polygonLngLatToPoints: function(originPoint, polygon) {
        var map = this._map;

        return polygon.map(function(contour) {
            return contour.map(function(lngLat) {
                return map
                    .project([lngLat[1], lngLat[0]]).round()
                    .subtract(originPoint);
            });
        });
    },

    _layerEventsListeners : {
        mouseover: function(e) { // (Object)
            this._setCursor('pointer');
            if (e.meta.hint && e.meta.hint.length && !this.options.disableLabel) {
                this._labelHelper
                    .setPosition(e.latlng)
                    .setContent(e.meta.hint)
                    .setZIndexOffset(300);
                this._map.addLayer(this._labelHelper);
            }
            this._map.fire('poihover', {
                latlng: e.latlng,
                meta: e.meta
            });
        },

        mouseout: function(e) {
            this._setCursor('');
            if (!this.options.disableLabel) {
                this._map.removeLayer(this._labelHelper);
            }
            this._map.fire('poileave', {
                latlng: e.latlng,
                meta: e.meta
            });
        },

        mousemove: function(e) { // (Object)
            if (!this.options.disableLabel) {
                this._labelHelper.setPosition(e.latlng);
            }
        }
    },

    _setCursor: function(cursor) { // (String)
        this._map.getContainer().style.cursor = cursor;
    }

});

DG.Map.addInitHook('addHandler', 'poi', DG.Poi);

DG.Map.mergeOptions({
    geoclicker: false
});

DG.Geoclicker = DG.Handler.extend({
    clickCount: 0,
    pendingClick: 0,
    timeout: 250, // should be equal to 'delay' value in DoubleTap event

    initialize: function(map, options) { // (Object)
        this._map = map;
        this._controller = new DG.Geoclicker.Controller(map, options);
    },

    addHooks: function() {
        this._toggleEvents(true);

        this._map
            .on('rulerstart', this._pause, this)
            .on('rulerend', this._unpause, this);
    },

    removeHooks: function() {
        this._toggleEvents();

        this._map
            .off('rulerstart', this._pause, this)
            .off('rulerend', this._unpause, this);
    },

    _checkOpenPopup: function() {
        if (DG.Browser.mobile && this._map._popup &&
            (this._map._popup.options.closeOnClick ||
            this._map.options.closePopupOnClick)) {
            this.popupWasOpen = true;
        }
    },

    _pause: function() {
        this._toggleEvents();
    },

    _unpause: function() {
        // Reenable event handling only in case geoclicker is enabled
        if (this.enabled()) {
            this._toggleEvents(true);
        }
    },

    _toggleEvents: function(flag) {
        this._map[flag ? 'on' : 'off'](this._mapEventsListeners, this);
        if (this._map.poi) {
            this._map.poi.getMetaLayer()[flag ? 'on' : 'off']('click', this._onMetaClick, this);
        }
    },

    getController: function() {
        return this._controller;
    },

    _onMetaClick: function(e) {
        this.clickCount = 0;
        clearTimeout(this.pendingClick);
        this.popupWasOpen = false;

        this._mapEventsListeners.click.call(this, e);
    },

    _mapEventsListeners: {
        langchange: function() {
            this._controller.reinvokeHandler();
        },

        popupclose: function(e) { // (Object)
            this._controller.handlePopupClose(e.popup);
        },

        click: function(e) { // (Object)
            if (this.clickCount === 0) {
                this.clickCount = 1;
                this._singleClick(e);
            } else {
                this.clickCount = 0;
                clearTimeout(this.pendingClick);
                this.popupWasOpen = false;
            }
        },

        dblclick: function() {
            if (DG.Browser.ielt9) {
                this.clickCount = 0;
                this.popupWasOpen = false;
                clearTimeout(this.pendingClick);
            }
        }
    },

    _singleClick: function(e) { // (Object)
        var self = this;

        clearTimeout(this.pendingClick);

        this.pendingClick = setTimeout(function() {
            if (e.meta) {
                self._checkOpenPopup();
                self._map.closePopup();
            }

            //  DGPopup's '_close' method is the only place where .popupWasOpen is modified
            //  It signals geoclicker that popup was open before user do a 'click' on map
            //  Multistage behavior is needed as this processing occurs after popup was already closed
            if (!self.popupWasOpen) {
                var zoom = self._map.getZoom();
                self._controller.handleClick(e.latlng, zoom, e.meta);
            }

            self.clickCount = 0;
            self.popupWasOpen = false;
        }, this.timeout);
    }
});

DG.Map.addInitHook('addHandler', 'geoclicker', DG.Geoclicker);

DG.Geoclicker.clampHelper = function(el, lineClamp) {
    var measure, text, lineWidth,
        lineStart, lineCount, wordStart,
        line, lineText, wasNewLine,
        ce = document.createElement.bind(document),
        ctn = document.createTextNode.bind(document);

    // measurement element is made a child of the clamped element to get it's style
    measure = ce('span');

    (function(s) {
        s.position = 'absolute'; // prevent page reflow
        s.whiteSpace = 'pre'; // cross-browser width results
        s.visibility = 'hidden'; // prevent drawing
        s.margin = '0 18px 8px 0';
    })(measure.style);

    // make sure the element belongs to the document
    if (!el.ownerDocument || el.ownerDocument !== document) {
        return;
    }
    // reset to safe starting values
    lineStart = wordStart = 0;
    lineCount = 1;
    wasNewLine = false;
    lineWidth = el.clientWidth;
    // get all the text, remove any line changes
    text = (el.textContent || el.innerText).replace(/\n/g, ' ');
    // remove all content
    while (el.firstChild !== null) {
        el.removeChild(el.firstChild);
    }
    // add measurement element within so it inherits styles
    el.appendChild(measure);
    // http://ejohn.org/blog/search-and-dont-replace/
    text.replace(/ |-/g, function(m, pos) {
        // ignore any further processing if we have total lines
        if (lineCount === lineClamp) {
            return;
        }
        // create a text node and place it in the measurement element
        measure.appendChild(ctn(text.substr(lineStart, pos - lineStart)));
        // have we exceeded allowed line width?
        if (lineWidth < measure.clientWidth) {
            if (wasNewLine) {
                // we have a long word so it gets a line of it's own
                lineText = text.substr(lineStart, pos + 1 - lineStart);
                // next line start position
                lineStart = pos + 1;
            } else {
                // grab the text until this word
                lineText = text.substr(lineStart, wordStart - lineStart);
                // next line start position
                lineStart = wordStart;
            }
            // create a line element
            line = ce('span');
            // add text to the line element
            line.appendChild(ctn(lineText));
            // add the line element to the container
            el.appendChild(line);
            line.className = 'dg-map-geoclicker__clamped-line';
            // yes, we created a new line
            wasNewLine = true;
            lineCount++;
        } else {
            // did not create a new line
            wasNewLine = false;
        }
        // remember last word start position
        wordStart = pos + 1;
        // clear measurement element
        measure.removeChild(measure.firstChild);
    });
    // remove the measurement element from the container
    el.removeChild(measure);
    // create the last line element
    line = ce('span');
    // give styles required for text-overflow to kick in
    line.className = 'dg-map-geoclicker__clamped-line dg-map-geoclicker__clamped-line_last';
    // add all remaining text to the line element
    line.appendChild(ctn(text.substr(lineStart)));
    // add the line element to the container
    el.appendChild(line);
};

DG.Geoclicker.Provider = {};

DG.Geoclicker.Provider.CatalogApi = DG.Class.extend({
    initialize: function(map) { // (Object)
        this._map = map;

        var apiUrl = DG.config.protocol +
            DG.config.webApiServer + '/' +
            DG.config.webApiVersion + '/';

        this._urlGeoSearch = apiUrl + 'geo/search';
        this._urlGeoGet = apiUrl + 'geo/get';
        this._urlDetails = apiUrl + 'catalog/branch/get';
        this._urlFirmsInHouse = apiUrl + 'catalog/branch/list';

        this._key = DG.config.geoclickerCatalogApiKey;
        this._geoFields = DG.config.geoAdditionalFields;
        this._firmInfoFields = DG.config.firmInfoFields;
    },

    getLocations: function(options) { // (Object)
        // Callback will receive array of found results or void if errors occurred or nothing was found.
        var zoom = options.zoom,
            latlng = options.latlng,
            beforeRequest = options.beforeRequest || function() {},
            types = this.getTypesByZoom(zoom),
            q = latlng.lng + ',' + latlng.lat;

        if (!types) {
            return Promise.reject('no type');
        }

        beforeRequest();

        return this.geoSearch(q, types, zoom).then(DG.bind(function(result) {
            return this._filterResponse(result, types);
        }, this));
    },

    firmsInHouse: function(houseId, parameters) { // (String, Function, Number)
        parameters = parameters || {};

        /* eslint-disable camelcase */
        var params = {
            building_id: houseId,
            page: parameters.page || 1
        };
        /* eslint-enable camelcase */

        return this._performRequest(params, this._urlFirmsInHouse);
    },

    getFirmInfo: function(firmId) {
        return this._performRequest({
            type: 'filial',
            id: firmId,
            fields: this._firmInfoFields
        }, this._urlDetails);
    },

    geoSearch: function(q, types, zoomlevel) { // (String, String, Number)
        /* eslint-disable camelcase */
        var params = {
            point: q,
            type: types,
            zoom_level: zoomlevel,
            fields: this._geoFields
        };
        /* eslint-enable camelcase */

        return this._performRequest(params, this._urlGeoSearch);
    },

    geoGet: function(id) {
        var params = {
            id: id,
            fields: this._geoFields
        };

        return this._performRequest(params, this._urlGeoGet);
    },

    cancelLastRequest: function() {
        if (this._lastRequest) {
            this._lastRequest.abort();
        }
    },

    getTypesByZoom: function(zoom) { // (Number) -> String|Null
        var types = {
                'adm_div.settlement':   8,
                'adm_div.city':         8,
                'adm_div.division':     11,
                'adm_div.district':     12,
                'street':               14,
                'building':             14,
                'adm_div.place':        15,
                'poi':                  15,
                'attraction':           17
            },
            selectedTypes = [];

        Object.keys(types).forEach(function(type) {
            if (zoom >= types[type]) {
                selectedTypes.push(type);
            }
        });

        if (selectedTypes.length) {
            return selectedTypes.join(',');
        } else {
            return null;
        }
    },

    _performRequest: function(params, url) { // (Object, String, Function, Function)
        var data = DG.extend({key: this._key}, params);
        var type = 'get';

        this.cancelLastRequest();

        if (!DG.ajax.corsSupport) {
            type = data.format = 'jsonp';
        }

        this._lastRequest = DG.ajax(url, {
            type: type,
            data: data,
            timeout: this._timeoutMs
        });

        return this._lastRequest;
    },

    _filterResponse: function(response, allowedTypes) { // (Object, Array) -> Boolean|Object
        var result = {}, i, item, found, data, type;

        if (this._isNotFound(response)) {
            return false;
        }

        data = response.result.items;

        for (i = data.length - 1; i >= 0; i--) {
            item = data[i];

            type = item.type;
            if (item.subtype) {
                type += '.' + item.subtype;
            }

            if (allowedTypes && allowedTypes.indexOf(type) === -1) {
                continue;
            }

            result[type] = item;
            found = true;
        }

        if (found) {
            return result;
        } else {
            return false;
        }
    },

    _isNotFound: function(response) { // (Object) -> Boolean
        return !response ||
               !!response.meta && !!response.meta.error ||
               !response.result ||
               !response.result.items ||
               !response.result.items.length;
    }

});

DG.Geoclicker.Handler = {};

DG.Geoclicker.Handler.Default = DG.Class.extend({

    includes: DG.Locale,

    statics: {
        Dictionary: {}
    },

    _eventHandlers: {},

    initialize: function(controller, view, map) { // (Object, Object, Object)
        this._controller = controller;
        this._view = view;
        this._map = map;
    },

    handle: function() { // () -> Promise
        return Promise.resolve({
            tmpl: 'popupHeader',
            data: {'title': this.t('we_have_not')}
        });
    },

    addClickEvent: function() {
        this._view._popup.on('click', this._runEventHandlers, this);
        this._map.once('popupclose', this._removeClickEvent, this);
    },

    _removeClickEvent: function() {
        this._view._popup.off('click', this._runEventHandlers, this);
    },

    _addEventHandler: function(el, handler) { // (String, Function)
        this._eventHandlers[el] = handler;
    },

    _runEventHandlers: function(e) {
        var target = e.originalEvent.target;

        for (var eventClass in this._eventHandlers) {
            if (this._eventHandlers.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                DG.DomEvent.preventDefault(e.originalEvent);
                this._eventHandlers[eventClass].call(this, target);
                return;
            }
        }
    },

    _clearEventHandlers: function() {
        this._eventHandlers = {};
    },

    _getDirectionsUrl: function(name) {
        return DG.Util.template(DG.config.ppnotLink, {
            'domain': this._map.projectDetector.getProject().domain,
            'projectCode': this._map.projectDetector.getProject().code,
            'center': this._map.getCenter().lng + ',' + this._map.getCenter().lat,
            'zoom': this._map.getZoom(),
            'name': encodeURIComponent(name),
            'rsType': this._map.projectDetector.getProject().transport ? 'bus' : 'car',
            'point': this._popup._latlng.lng + ',' + this._popup._latlng.lat
        });
    },

    _getDrilldown: function(object) {
        var admDivs = [],
            result;

        if (object.adm_div) {
            admDivs = object.adm_div
                .reduce(function(admDivs, admDiv) {
                    if (admDiv.name) {
                        admDivs.push(admDiv.name);
                    }

                    return admDivs;
                }, [])
                .reverse();
        }

        if (admDivs.length && object.address && object.address.postcode) {
            admDivs.push(object.address.postcode);
        }

        result = admDivs.join(', ');

        return result;
    }

});


DG.Geoclicker.Handler.HandlerExample = DG.Geoclicker.Handler.Default.extend({

    handle: function(results, type) { // (Object, String) -> Promise
        return Promise.resolve({
            tmpl: type + ':<br/>' + results[type].id
        });
    }
});

DG.Geoclicker.Handler.ApiError = DG.Geoclicker.Handler.Default.extend({
    handle: function() { // () -> Promise
        var header = this._view.render({
            tmpl: 'popupHeader',
            data: {
                title: this.t('apiErrorTitle')
            }
        });

        return Promise.resolve({
            header: header,
            tmpl: this.t('apiErrorBody')
        });
    }
});

DG.Geoclicker.Handler.CityArea = DG.Geoclicker.Handler.Default.extend({

    _polylineStyleDefault : {
        fillColor: '#ff9387',
        color: '#ff9387',
        noClip: true,
        opacity: 1
    },

    _polylineStyles : {
        11 : {
            fillOpacity: 0.18,
            weight: 1
        },
        12 : {
            fillOpacity: 0.12,
            weight: 1
        },
        13 : {
            fillOpacity: 0.08,
            weight: 2
        },
        18 : {
            fillOpacity: 0,
            weight: 3
        }
    },

    handle: function(results, type) { // (Object, String) -> Promise
        if (!results[type]) {
            return false;
        }

        if (!this._stylesInited) {
            this._initStyles();
        }

        // remove previous geometry see https://github.com/2gis/mapsapi/issues/213
        if (this._geometry) {
            this._map.removeLayer(this._geometry);
        }

        this._popup = this._view.getPopup();

        this._geometryZoomStyle = this._getPolyStyleNum();
        this._geometry = DG.Wkt.geoJsonLayer(results[type].geometry.selection, {
            style: this._polylineStyles[this._geometryZoomStyle],
            interactive: false
        }).addTo(this._map);

        this._map
            .on('zoomend', this._updateGeometry, this)
            .once('popupclose', this._clearPopup, this);

        return Promise.resolve(this._fillCityAreaObject(results, type));
    },

    _fillCityAreaObject: function(results, type) {
        var data = {
            name: this.t('noname'),
            drilldown: '',
            purpose: this.t(type),
            type: type.split('.').join('_')
        };

        data.drilldown = this._getDrilldown(results[type]);

        if (results[type].name) {
            data.name = results[type].name;
        }

        return {
            tmpl: 'cityarea',
            data: data,
            header: this._view.render({
                tmpl: 'popupHeader',
                data: {'title': data.name}
            })
        };
    },

    _initStyles : function() {
        this._stylesInited = true;

        Object.keys(this._polylineStyles).forEach(function(zoom) {
            DG.extend(this._polylineStyles[zoom], this._polylineStyleDefault);
        }, this);
    },

    _getPolyStyleNum: function() {
        var mapZoom = this._map.getZoom();

        return Object.keys(this._polylineStyles).filter(function(zoom) {
            return mapZoom <= zoom;
        })[0] || false;
    },

    _updateGeometry: function() {
        var newStyle = this._getPolyStyleNum();

        if (newStyle && newStyle !== this._geometryZoomStyle) {
            this._geometryZoomStyle = newStyle;
            this._geometry.setStyle(this._polylineStyles[newStyle]);
        }
    },

    _clearPopup: function() {
        this._map
                .removeLayer(this._geometry)
                .off('zoomend', this._updateGeometry, this);
    }

});

/*global FirmCard */
DG.Geoclicker.Handler.House = DG.Geoclicker.Handler.Default.extend({

    _firmsOnPage: 20,
    _scrollThrottleInterval: 400,
    _scrollHeightReserve: 60,

    options: {
        'showBooklet': true,
        'showPhotos': true,
        'showRouteSearch': true
    },

    handle: function(results) { // (Object) -> Promise
        if (!results.building) {
            return false;
        }

        // initialization setup
        this.firmCard = null;
        this._page = 1;
        this._houseObject = null;
        this._firmList = null;
        this._firmListObject = null;
        this._firmCardObject = null;
        this._onScroll = false;
        this._isFirmlistOpen = false;

        this._id = results.building.id;
        this._totalPages = 1;
        this._api = this._controller.getCatalogApi();
        this._popup = this._view.getPopup();
        this._initedPopupClose = false;
        this._directionsUrl = this._getDirectionsUrl(results.building.name);
        this._firmListLoader = this._view.initLoader(true);

        this._houseObject = this._fillHouseObject(results.building);

        return Promise.resolve(this._houseObject);
    },

    _isRouteSearchAllowed: function() { //() -> Boolean
        var project = this._controller.getMap().projectDetector.getProject();
        return project.transport || project.roads;
    },

    _firmCardSetup: function() { //() -> Object
        return {
            render: this._view.renderTemplate,
            lang: this._map.getLang(),
            domain: this._controller.getMap().projectDetector.getProject().domain,
            ajax: DG.bind(this._api.getFirmInfo, this._api),
            timezoneOffset: this._controller.getMap().projectDetector.getProject().timeOffset,
            map: this._map,
            popup: this._popup,
            isMobile: DG.Browser.mobile,
            showEntrance: DG.Entrance,
            gotoUrl: this._directionsUrl,
            onFirmReady: DG.bind(this._onFirmReady, this),
            onToggle: DG.bind(this._popup.resize, this._popup),
            showBooklet: this.options.showBooklet,
            showPhotos: this.options.showPhotos,
            showRouteSearch: this.options.showRouteSearch && this._isRouteSearchAllowed(),
            t: DG.bind(this.t, this)
        };
    },

    // init single firm card in case of poi
    _fillFirmCardObject: function(firmId) {
        var options = this._firmCardSetup();

        this.firmCard = new FirmCard(firmId, options);
        this._initPopupClose();
        return this.firmCard.getContainer();
    },

    _firmListSetup: function() {
        var options = this._firmCardSetup();

        DG.extend(options, {
            backBtn: DG.bind(this._showHousePopup, this),
            onFirmClick: DG.bind(this._onFirmListClick, this),
            onShowLess: DG.bind(this._showHousePopup, this),
            pasteLoader: DG.bind(this._pasteLoader, this)
        });

        return {
            firmCard: options,
            firmlistItemTmpl: 'firmlistItem',
            onListReady: DG.bind(this._renderFirmList, this)
        };
    },

    _initShortFirmList: function(firms) { //(Object) -> DOMElement
        var options = this._firmListSetup();

        this._shortFirmList = new FirmCard.List(firms, options);

        return this._shortFirmList.renderList();
    },

    _initFirmList: function(res) { //(Object) -> Promise
        if (!res) { return false; }

        var results = res.result.items,
            options = this._firmListSetup();

        options.firmCard.backBtn = DG.bind(this._showListPopup, this);

        this._shortFirmList._toggleEventHandlers(true);

        this._firmList = new FirmCard.List(results, options);

        this._firmListObject = this._fillFirmListObject(this._firmList.renderList());
        this._clearAndRenderPopup(this._firmListObject);
    },

    _fillFirmListObject: function(firmList) { //(DOMElement) -> Object
        var self = this;

        return {
            tmpl: firmList,
            header: this._header,
            footer: this._view.render({
                tmpl: 'popupFooterBtns',
                data: {
                    btns: [
                        {
                            name: 'back',
                            label: this.t('back_button'),
                            icon: true
                        }
                    ]
                }
            }),
            afterRender: function() {
                self._initPopupClose();

                if (self._totalPages > 1 && self._firmListLoader) {
                    // "this" here is self._firmListObject
                    this.tmpl.parentNode.appendChild(self._firmListLoader);
                }
            }
        };
    },

    _onFirmReady: function(firmContentObject) {
        var self = this;
        firmContentObject.afterRender = function() {
            var headerTitle = self._popup._popupStructure.header.firstChild;
            if (!DG.Browser.ielt9) {
                if (headerTitle.offsetHeight > 72) { //TODO: magic number
                    DG.DomUtil.addClass(headerTitle, 'dg-popup__header-teaser');
                    if (!DG.Browser.webkit) {
                        DG.Geoclicker.clampHelper(headerTitle, 3);
                    }
                }
            }
        };
        this._clearAndRenderPopup(firmContentObject);
    },

    _showHousePopup: function() {
        this._popup.off('scroll', this._onScroll);
        this._clearAndRenderPopup(this._houseObject);
        this._shortFirmList._toggleEventHandlers();
    },

    _onFirmListClick: function() {
        this._popup.off('scroll', this._onScroll);
    },

    _pasteLoader: function() {
        var loaderWrapper  = DG.DomUtil.create('div', 'dg-map-geoclicker__preloader-wrapper'),
            loader = this._view.initLoader();

        loaderWrapper.insertBefore(loader, loaderWrapper.firstChild);
        loaderWrapper.style.height = this._popup._contentNode.offsetHeight - 1 + 'px'; // MAGIC
        loaderWrapper.style.width = this._popup._contentNode.offsetWidth + 'px';
        this._clearAndRenderPopup({tmpl: loaderWrapper});
    },

    _initPopupClose: function() {
        if (this._initedPopupClose) { return; }

        this._controller.getMap().once('popupclose', DG.bind(this._onPopupClose, this));
        this._initedPopupClose = true;
    },

    _showListPopup: function() {
        var firmList = this._firmListObject;

        this._pasteLoader();

        if (!firmList) {
            firmList = this._api.firmsInHouse(this._id).then(DG.bind(this._initFirmList, this));
        } else {
            this._clearAndRenderPopup(firmList);
            this._firmList._toggleEventHandlers();
        }

        if (!this._onScroll) {
            this._onScroll = DG.Util.throttle(this._handlePopupScroll, this._scrollThrottleInterval, this);
        }

        this._popup.on('scroll', this._onScroll);
    },

    _renderFirmList: function() {
        if (!this._isFirmlistOpen) {
            this._popup.resize();
            this._isFirmlistOpen = true;
        }
    },

    _onPopupClose: function() {
        this._initedPopupClose = false;
        if (this._firmList) {
            this._firmList.clearList();
            this._firmList = null;
            this._popup.off('scroll', this._onScroll);
        }
        this._firmId = null;
        if (this.firmCard) {
            this.firmCard._toggleEventHandlers(true);
            this.firmCard = null;
        }
        this._firmListLoader = null;
        this._page = 1;
        this._clearEventHandlers();
    },

    _initShowMore: function() {
        var link = this._popup.findElement('.dg-popup__button_name_all');

        if (link) {
            this._addEventHandler('dg-popup__button_name_all', DG.bind(this._showListPopup, this));
        }
    },

    _clearAndRenderPopup: function(popupObject) {
        this._clearEventHandlers();
        this._popup.clear('header', 'footer');
        this._view.renderPopup(popupObject);
    },

    _appendFirmList: function(res) { // (Object)
        this._firmList.addFirms(res.result.items);
        this._popup._updateScrollPosition();
    },

    _handlePopupScroll: function(e) {
        var scroller = e.originalEvent.target || e.target._scroller;

        DG.DomEvent.stop(e);

        if (this._totalPages <= 1) { return; }
        if (scroller && scroller.scrollHeight <= scroller.scrollTop + scroller.offsetHeight + this._scrollHeightReserve) {
            this._handlePaging();
        }
    },

    _handlePaging: function() {
        this._page++;

        if (this._totalPages && this._page <= this._totalPages) {
            this._api.firmsInHouse(this._id, {page: this._page}).then(DG.bind(this._appendFirmList, this));
        }

        if (this._page === this._totalPages) {
            var loader = this._firmListLoader;

            if (loader && loader.parentNode) {
                loader.parentNode.removeChild(loader);
            }

            this._popup.off('scroll', this._onScroll);
        }
    }
});

DG.Geoclicker.Handler.House.include({
    _getAddressString: function(house) {
        if (!house.address || !house.address.components) {
            return '';
        }

        return house.address.components
            .filter(function(component) {
                return component.type === 'street_number';
            })
            .map(function(component) {
                return component.street + ', ' + component.number;
            })
            .join(' / ');
    },

    _fillBody: function(house) { // // (Object) -> (DOMElement)
        var data = {},
            wrapper = DG.DomUtil.create('div', 'dg-building-callout__body'),
            filials = house.links && house.links.branches;

        var drilldown = this._getDrilldown(house);

        if (house.building_name) {
            data.address = {
                header: this._getAddressString(house),
                drilldown: drilldown
            };
        } else if (drilldown) {
            data.address = {
                drilldown: drilldown
            };
        }

        data.purpose = house.purpose_name +
            (house.floors ? ', ' + this.t('n_floors', house.floors.ground_count) : '');

        if (filials && filials.count > 0) {
            this._totalPages = Math.ceil(house.links.branches.count / this._firmsOnPage);
        }

        if (house.links && house.links.attractions && house.links.attractions.length) {
            data.attractions = house.links.attractions.reduce(function(attractions, attraction) {
                if (attraction.name) {
                    attractions.push(attraction.name);
                }

                return attractions;
            }, []);
        }

        wrapper.innerHTML = this._view.render({
            tmpl: 'house',
            data: data
        });

        if (filials && filials.items) {
            wrapper.appendChild(this._initShortFirmList(filials.items));
        }

        return wrapper;
    },

    _fillHeader: function(house) { // (Object) -> (HTMLString)
        var header = {};

        if (house.building_name) {
            header.title = house.building_name;
        } else if (house.address && house.address.components) {
            header.title = this._getAddressString(house);
        } else {
            header.title = house.purpose_name;
        }

        this._header = this._view.render({
            tmpl: 'popupHeader',
            data: header
        });

        return this._header;
    },

    _fillFooter: function(house) { // (Object) -> (HTMLString)
        var btns = [];
        var houseFilials = house.links && house.links.branches;

        // Decide if we need to display 'more organisations' button
        if (
            houseFilials &&
            houseFilials.items &&
            houseFilials.items.length &&
            houseFilials.count > houseFilials.items.length
        ) {
            btns.push(this._getShowAllData(houseFilials.count));
        }

        if (this._isRouteSearchAllowed()) {
            btns.push({
                name: 'goto',
                label: this.t('go_to'),
                icon: true,
                href: this._directionsUrl
            });
        }

        return this._view.render({
            tmpl: 'popupFooterBtns',
            data: {'btns': btns}
        });
    },

    _getShowAllData: function(filialsCount) {
        return {
            name: 'all',
            label: this.t('show_organization_in_building', filialsCount)
        };
    },

    _fillHouseObject: function(house) { // (Object) -> (Object)
        var self = this;

        return {
            header: this._fillHeader(house),
            tmpl: this._fillBody(house),
            footer: this._fillFooter(house),
            afterRender: function() {
                self._initShowMore();
                self._initPopupClose();
            }
        };
    }
});

DG.Geoclicker.Handler.Poi = DG.Geoclicker.Handler.House.extend({

    handle: function(results) { // (Object) -> Promise
        if (!results.poi) {
            return false;
        }

        // initialization setup
        this.firmCard = null;
        this._page = 1;
        this._houseObject = null;
        this._firmList = null;
        this._firmListObject = null;
        this._firmCardObject = null;
        this._onScroll = false;
        this._isFirmlistOpen = false;

        this._id = results.poi.reference.id;
        this._totalPages = 1;
        this._api = this._controller.getCatalogApi();
        this._popup = this._view.getPopup();
        this._initedPopupClose = false;
        this._directionsUrl = this._getDirectionsUrl(results.poi.reference.name);
        this._firmListLoader = this._view.initLoader(true);

        // If the POI refers to a building (e.g. galleries in Santiago),
        // show a building callout
        if (results.poi.reference.type === 'building') {
            var self = this;

            return self._api.geoGet(results.poi.reference.id)
                .then(function(result) {
                    self._houseObject = self._fillHouseObject(result.result.items[0]);
                    return Promise.resolve(self._houseObject);
                });
        }

        // Otherwise, show a firm callout
        if (results.poi.reference.type === 'branch') {
            this._fillFirmCardObject(results.poi.reference.id);
            return true;
        }

        return false;
    }

});

DG.Geoclicker.Handler.Sight = DG.Geoclicker.Handler.Default.extend({

    handle: function(results) { // (Object, String) -> Promise
        if (!results.attraction) {
            return false;
        }

        this._popup = this._view.getPopup();
        this._initedPopupClose = false;

        return Promise.resolve(this._fillSightObject(results));
    },

    _fillSightObject: function(results) { // (Object) -> Object
        var attraction = results.attraction,
            data = {},
            self = this,
            footer = {
                btns: [
                    {
                        name: 'goto',
                        label: this.t('go_to'),
                        icon: true
                    }
                ]
            };

        if (attraction.name) {
            data.buildingName = attraction.name;
            data.purpose = attraction.subtype_name;
        } else {
            data.buildingName = attraction.subtype_name;
        }

        data.description = attraction.description;

        data.drillDown = this._getDrilldown(attraction);

        if (this._checkDescFieldHeight(data.description)) {
            data.showMoreText = this.t('show_more_about_sight');
        }

        footer.btns[0].href = this._getDirectionsUrl(data.buildingName);

        return {
            tmpl: 'sight',
            data: data,
            header: this._view.render({
                tmpl: 'popupHeader',
                data: {'title': data.buildingName}
            }),
            footer: this._view.render({
                tmpl: 'popupFooterBtns',
                data: footer
            }),
            afterRender: function() {
                if (self._needShowMore) {
                    self._initShowMore();
                }
                self._initPopupClose();
            }
        };
    },

    _initPopupClose: function() {
        if (this._initedPopupClose) {
            return;
        }

        this._controller.getMap().once('popupclose', DG.bind(this._clearPopup, this));
        this._initedPopupClose = true;
    },

    _clearPopup: function() {
        this._initedPopupClose = false;
        this._clearEventHandlers();
    },

    _showMoreText: function() {
        this._desc.style.maxHeight = '100%';
        this._link.parentNode.removeChild(this._link);
        this._popup.resize();
    },

    _initShowMore: function() {
        this._link = this._popup.findElement('.dg-map-geoclicker__show-more-sights-link');
        this._desc = this._popup.findElement('.dg-map-geoclicker__sight-description');

        if (this._link && this._desc) {
            this._addEventHandler('dg-map-geoclicker__show-more-sights-link', DG.bind(this._showMoreText, this));
        }
    },

    _checkDescFieldHeight: function(desc) {
        var el = DG.DomUtil.create('div', ''),
            height;

        el.style.visibility = 'hidden';
        el.innerHTML = desc;

        this._popup._contentNode.appendChild(el);
        height = el.offsetHeight;
        this._popup._contentNode.removeChild(el);
        this._needShowMore = (height > 40);

        return this._needShowMore;
    }
});

DG.Geoclicker.View = DG.Class.extend({

    initialize: function(map, options) { // (Object, Object)
        this._map = map;
        this._popup = DG.popup({
            maxHeight: 300,
            minHeight: 50,
            maxWidth: 385,
            minWidth: 310,
            sprawling: true,
            closeOnClick: true
        });

        if (options) {
            DG.Util.setOptions(this, options);
        }
    },

    initLoader: function(isSmall) {
        var loader = document.createElement('div');
        loader.innerHTML = DG.dust('DGGeoclicker/loader', {
            small: isSmall,
            anim: this._detectCssAnimation()
        });

        return loader.firstChild;
    },

    showPopup: function(latlng, content) { // (Object)
        this._popup
            .setContent(content)
            .setLatLng(latlng)
            .openOn(this._map);
    },

    render: function(options) { // (Object) -> String
        var html,
            data = {};

        options = options || {};
        options.tmpl = options.tmpl || '';

        if (options.data) {
            html = this.renderTemplate(options.tmpl, options.data);
        } else {
            html = options.tmpl;
        }

        if (options.beforeRender) {
            options.beforeRender();
        }

        if (options.popup) {
            if (options.header) {
                data.header = options.header;
            }
            if (options.footer) {
                data.footer = options.footer;
            }
            data.body = html;
            this._popup.setContent(data);
        }
        if (options.afterRender) {
            options.afterRender();
        }

        return html;
    },

    renderTemplate: function(name, data) {
        return DG.dust('DGGeoclicker/' + name, data);
    },

    renderPopup: function(options) { // (Object) -> String
        options.popup = true;
        return this.render(options);
    },

    getPopup: function() { // () -> Object
        return this._popup;
    },

    _detectCssAnimation: function() {
        var animation = false,
            domPrefixes = 'Webkit Moz O ms Khtml'.split(' '),
            elm = document.createElement('div');

        if (elm.style.animationName) { animation = true; }

        if (animation === false) {
            for (var i = 0; i < domPrefixes.length; i++) {
                if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
                    animation = true;
                    break;
                }
            }
        }
        return animation;
    }
});

DG.Geoclicker.Controller = DG.Class.extend({

    options: {
        // if handler worked successfully, it should return rendering object that will be processed in View , otherwise it should return false
        // default handler always should return rendering object
        'handlersSequence': {
            'poi': DG.Geoclicker.Handler.Poi,
            'attraction': DG.Geoclicker.Handler.Sight,
            'building': DG.Geoclicker.Handler.House,
            'street': DG.Geoclicker.Handler.CityArea,
            'adm_div.place': DG.Geoclicker.Handler.CityArea,
            'adm_div.district': DG.Geoclicker.Handler.CityArea,
            'adm_div.division': DG.Geoclicker.Handler.CityArea,
            'adm_div.settlement': DG.Geoclicker.Handler.CityArea,
            'adm_div.city': DG.Geoclicker.Handler.CityArea,

            'default': DG.Geoclicker.Handler.Default,

            'apiError': DG.Geoclicker.Handler.ApiError

//            station_platform
//            project
//            station
//            crossbroad
//            metro
        }
    },

    initialize: function(map, options) { // (Object, Object)
        this._options = options;
        this._handlers = {};
        this._catalogApi = new DG.Geoclicker.Provider.CatalogApi(map);
        this._map = map;
        this._view = new DG.Geoclicker.View(map);

        this._renderHandlerResult = DG.bind(this._renderHandlerResult, this);
        this._lastHandleClickArguments = null;
    },

    handlePopupClose: function(popup) { // (Object)
        if (popup === this._view.getPopup()) {
            this._lastHandleClickArguments = null;
            this._catalogApi.cancelLastRequest();
        }
    },

    handleClick: function(latlng, zoom, meta) { // (Object, Number, Object)
        var self = this,
            args = Array.prototype.slice.call(arguments, 0);

        function beforeRequest() {
            var loader = self._view.initLoader();
            self._view._popup.clear();
            self._view.showPopup(latlng, loader);
            self._lastHandleClickArguments = args;
        }

        if (meta && meta.linked && meta.linked.type != 'sight' && meta.linked.type != 'attraction') {
            if (meta.linked.type != 'branch' && meta.linked.type != 'building') {
                return;
            }

            beforeRequest();
            self.handleResponse({
                poi: {
                    reference: meta.linked
                }
            });
        } else {
            this._catalogApi.getLocations({
                latlng: latlng,
                zoom: zoom,
                beforeRequest: beforeRequest
            }).then(function(result) {
                self.handleResponse(result);
            }, function(error) {
                self.handleResponse(error);
            });
        }
    },

    handleResponse: function(result) { // (Object)
        var type;

        if (!result) {
            this._runHandler('default');
            return;
        }

        if (result === 'no type') {
            return;
        }

        if (result === 'aborted') {
            this._runHandler('apiError');
            return;
        }

        type = this.findHandler(result);

        while (type) {
            if (this._runHandler(type, result)) {
                return;
            }
            delete result[type];

            type = this.findHandler(result);
        }
        this._runHandler('default');
    },

    findHandler: function(result) { // (Object) -> String|Null
        for (var i in this.options.handlersSequence) {
            if (result[i]) {
                return i;
            }
        }

        return null;
    },

    getCatalogApi: function() { // () -> Object
        return this._catalogApi;
    },

    getMap: function() {
        return this._map;
    },

    reinvokeHandler: function() {
        if (this._lastHandleClickArguments) {
            this.handleClick.apply(this, this._lastHandleClickArguments);
        }
    },

    _runHandler: function(type, data) { // (String, Object) -> Boolean
        data = data || {};
        this._initHandlerOnce(type);
        this._handlers[type].addClickEvent();

        var handlerResult = this._handlers[type].handle(data, type);

        return handlerResult && handlerResult.then ?
            handlerResult.then(this._renderHandlerResult) :
            handlerResult;
    },

    _renderHandlerResult: function(result) {
        this._view.renderPopup(result);
    },

    _initHandlerOnce: function(type) { // (String)
        if (!this._handlers[type]) {
            this._handlers[type] = new this.options.handlersSequence[type](this, this._view, this._map, this._options);
        }
    }
});

DG.Geoclicker.Handler.Default.Dictionary.it = DG.extend({
    apiErrorTitle: 'Oh oh, c\'&nbsp;un&nbsp;errore',
    apiErrorBody: 'I nostri server si rifiutano di rispondere. Stiamo facendo del nostro meglio per convincerli a&nbsp;comportarsi bene. Ritorna tra qualche minuto.',
    we_have_not : 'Non disponiamo ancora di informazioni su questo posto',
    noname : 'Nome non indicato',
    'adm_div.place' : 'Luogo',
    'adm_div.division' : 'Zona',
    'adm_div.settlement' : 'Comune',
    street : 'Via',
    'adm_div.district' : 'Municipalit',
    'adm_div.city' : 'itt',
    go_to : 'Come arrivare',
    show_organization_in_building : ['{n} azienda in tutto', '{n} aziende in tutto'],
    show_more_about_sight : 'Maggiori informazioni',
    back_button: 'Indietro',
    n_floors : ['{n} piano', '{n} piani']
}, DG.Dictionary.it);

DG.Geoclicker.Handler.Default.Dictionary.ru = DG.extend({
    apiErrorTitle: ' ',
    apiErrorBody: '   .     ,   .  &nbsp; &nbsp; .',
    we_have_not : '      ',
    noname: ' ',
    'adm_div.place': '',
    'adm_div.division': '',
    'adm_div.settlement': ' ',
    street: '',
    'adm_div.district': '',
    'adm_div.city': '',
    go_to: ' ',
    show_organization_in_building: [' {n} ', ' {n} ', ' {n} '],
    show_more_about_sight: '',
    back_button: '',
    n_floors: ['{n} ', '{n} ', '{n} ']
}, DG.Dictionary.ru);

DG.Geoclicker.Handler.Default.Dictionary.en = DG.extend({
    apiErrorTitle: 'Oops! Error detected.',
    apiErrorBody: 'Our servers are not responding. We are doing our best to straighten them out. Please return to us in a few minutes.',
    we_have_not: 'We haven\'t collected info about this place yet',
    noname : 'No name',
    'adm_div.place' : 'Place',
    'adm_div.division' : 'Area',
    'adm_div.settlement' : 'Village',
    street : 'Street',
    'adm_div.district' : 'District',
    'adm_div.city' : 'City',
    go_to : 'Directions to here',
    show_organization_in_building : ['{n} organization total', '{n} organizations total'],
    back_button : 'Back',
    show_more_about_sight : 'More information',
    n_floors : ['{n} floor', '{n} floors']
}, DG.Dictionary.en);

DG.Geoclicker.Handler.Default.Dictionary.cs = DG.extend({
    apiErrorTitle: 'Chybika se&nbsp;vloudila',
    apiErrorBody: 'Nae servery odmtaj reagovat. Ji nyn vynakldme veker sil, abychom je pivedli k rozumu. Zkuste akci opakovat za nkolik minut.',
    we_have_not : 'O tomto mst zatm nemme informace',
    noname : 'Bez nzvu',
    'adm_div.place' : 'Msto',
    'adm_div.division' : 'Sprvn obvod',
    'adm_div.settlement' : 'Obec',
    street : 'Ulice',
    'adm_div.district' : 'Mstsk st',
    'adm_div.city' : 'Msto',
    go_to : 'Cesta sem',
    show_organization_in_building : ['Celkem {n} organizace', 'Celkem {n} organizace', 'Celkem {n} organizac'],
    back_button : 'Zpt',
    show_more_about_sight : 'Vce',
    n_floors : ['{n} patro', '{n} patra', '{n} pater']
}, DG.Dictionary.cs);

DG.Geoclicker.Handler.Default.Dictionary.es = DG.extend({
    apiErrorTitle: 'Vaya, ha ocurrido un error',
    apiErrorBody: 'Nuestros servidores se niegan a responder. Ya nos estamos esforzando por hacerlos entrar en razn. Vuelva con nosotrospasados unos minutos.',
    we_have_not : 'Todava no hemos recopilado la informacin sobre este lugar',
    noname : 'Sin nombre',
    'adm_div.place' : 'Lugar',
    'adm_div.division' : 'Comuna',
    'adm_div.settlement' : 'Poblacin',
    street : 'Calle',
    'adm_div.district' : 'Comuna',
    'adm_div.city' : 'Ciudad',
    go_to : 'Ir para all',
    show_organization_in_building : ['Total {n} organizacin', 'Total {n} organizaciones', 'Total {n} organizaciones'],
    show_more_about_sight : 'Read more',
    back_button: 'Atrs',
    n_floors : ['{n} piso', '{n} pisos']
}, DG.Dictionary.es);

var FirmCard = function (firm, options) {
    this._setOptions(options);
    this._firmContentObject = {};
    this._schedule = new FirmCard.Schedule({
        localLang: this.options.lang,
        dict: this.dict
    });

    this.render(firm);
};

FirmCard.prototype = {

    render: function (firmId) {
        if (!firmId) { return; }

        if (firmId !== this._firmId) {
            this._firmContentObject = {};
            this._renderCardById(firmId);
        } else {
            this._toggleEventHandlers();
        }

        return this._firmContentObject;
    },

    getSchedule: function () {
        return this._schedule;
    },

    getContainer: function () {
        return this._container;
    },

    _renderCardById: function (firmId) {
        var self = this;

        this.options.ajax(firmId).then(function (res) {
            if (!res) { return false; }
            var data = res.result.items;
            if (data !== 'undefined') {
                self._firmData = data[0];

                // Support for old WebAPI format.
                // TODO: remove this call after WebAPI release
                self._convertWebsite();

                self._firmId = firmId;
                self._renderFirmCard();
                self._toggleEventHandlers();
            }
        }, function (error) {
            self._renderError();
        });
    },

    _createFirmContainer: function () {
        var firm = document.createElement('div');
        firm.setAttribute('id', 'dg-map-firm-full-' + this._firmId);
        firm.setAttribute('class', 'dg-map-firm-full');

        return firm;
    },

    _getPaymentTypes: function (data) {
        var result = [],
            groupName = 'general_payment_type';

        if (!data.attribute_groups) {
            return result;
        }

        data.attribute_groups.forEach(function (group) {
            if (group.name) {
                return;
            }

            group.attributes.forEach(function (attr) {
                if (attr.tag.substring(0, groupName.length) === groupName) {
                    result.push(attr.name);
                }
            });
        });

        return result;
    },

    _groupRubrics: function (data) {
        var result = {
            primary: [],
            additional: []
        };

        if (!data.rubrics || !data.rubrics.length) {
            return result;
        }

        data.rubrics.forEach(function (rubric) {
            result[rubric.kind].push(rubric);
        });

        return result;
    },

    // Support for old WebAPI format.
    // TODO: remove this function after WebAPI release
    _convertWebsite: function () {
        if (!this._firmData.contact_groups) {
            return;
        }

        this._firmData.contact_groups.forEach(function (group) {
            if (!group.contacts) {
                return;
            }

            group.contacts.forEach(function (contact) {
                if (contact.type != 'website') {
                    return;
                }

                if (!contact.url) {
                    contact.url = contact.value;
                }
            });
        });
    },

    _renderFirmCard: function () {
        var firmCardBody, schedule, forecast, links, btns, paymentTypes, rubrics,
            data = this._firmData,
            container = this._container = this._createFirmContainer();

        schedule = this._schedule.transform(data.schedule, {
            zoneOffset: this.options.timezoneOffset,
            apiLang: this.options.lang,
            localLang: this.options.lang
        });

        forecast = this._schedule.forecast(schedule);

        paymentTypes = this._getPaymentTypes(data);
        rubrics = this._groupRubrics(data);

        firmCardBody = this._buildFirmCardBody(
            this._getConfigFirmCardBody(data, schedule, forecast, paymentTypes, rubrics)
        );

        links = this._fillHeaderLinks();
        btns = this._fillFooterButtons();

        //fill object for view render
        this._firmContentObject.header = this.options.render('firmCardHeader', {'firmName': data.name, 'links': links});
        container.innerHTML = firmCardBody;
        this._firmContentObject.tmpl = container;
        if (btns.length) {
            this._footerContainer = document.createElement('div');

            this._footerContainer.innerHTML = this.options.render('popupFooterBtns', {'btns': btns});
            this._firmContentObject.footer = this._footerContainer;
        }

        if (this.options.onFirmReady) {
            this.options.onFirmReady(this._firmContentObject);
        }
    },

    _renderError: function() {
        this._firmContentObject.header = this.options.render('popupHeader', {
            title: this.options.t('apiErrorTitle')
        });

        this._firmContentObject.tmpl = this.options.t('apiErrorBody');

        if (this.options.onFirmReady) {
            this.options.onFirmReady(this._firmContentObject);
        }
    },

    _getConfigFirmCardBody: function (data, schedule, forecast, attributes, rubrics) {
        return [
            {
                tmpl: 'firmCardAddr',
                data: {
                    address: data.address_name,
                    comment: data.address_comment
                }
            },
            {
                tmpl: 'firmCardContacts',
                data: {
                    groups: data.contact_groups
                }
            },
            {
                tmpl: 'firmCardSchedule',
                data: {
                    schedule: schedule,
                    forecast: forecast
                }
            },
            {
                tmpl: 'frimCardPayments',
                data: {
                    payments: attributes
                }
            },
            {
                tmpl: 'firmCardRubric',
                data: {
                    rubrics: rubrics
                }
            }
        ];
    },

    _buildFirmCardBody: function (parts) {
        var self = this;
        return parts.reduce(function (body, item) {
            var html = self.options.render(item.tmpl, item.data);
            return body + html;
        }, '');
    },

    _fillFooterButtons: function () {
        var btns = [];

        if (this.options.backBtn) {
            btns.push({ name: 'firm-card-back',
                        label: this.dict.t(this.options.lang, 'btnBack'),
                        icon: true
            });
        }

        if (this.options.showRouteSearch) {
            btns.push({ name: 'goto',
                        label: this.dict.t(this.options.lang, 'btnFindWay'),
                        icon: true,
                        href: this.options.gotoUrl
            });
        }

        if (
            this._firmData.links &&
                this._firmData.links.entrances &&
                this.options.showEntrance
        ) {
            btns.push({ name: 'show-entrance',
                        label: this.dict.t(this.options.lang, 'btnEntrance'),
                        icon: true
            });
        }

        return btns;
    },

    _fillHeaderLinks: function () {
        var links = [],
            reviewData = this._firmData.reviews,
            booklet,
            link;

        if (this._firmData.external_content) {
            this._firmData.external_content.forEach(function (el) {
                if (el && el.type == 'booklet') {
                    booklet = el;
                }
            });
        }

        if (reviewData && reviewData.is_reviewable) {
            links.push({
                name: 'flamp_stars',
                width: reviewData.rating * 20
            });
            links.push({
                name: 'flamp_reviews',
                label: this.dict.t(this.options.lang, 'linkReviews', reviewData.review_count ? reviewData.review_count : 0),
                href: FirmCard.DataHelper.getFlampUrl(this._firmId)
            });
        }

        // Retrieve photo data from external content block
        var photos;
        var externalContent = this._firmData.external_content;

        for (var i = 0; i < externalContent.length; i++) {
            if (
                externalContent[i].type == 'photo_album' &&
                externalContent[i].subtype == 'common'
            ) {
                photos = externalContent[i];
                break;
            }
        }

        if (!this.options.isMobile && photos && photos.count && this.options.showPhotos) {
            link = L.Util.template(DG.config.photosLink, {
                'id': this._firmId,
                'domain': this.options.domain
            });

            links.push({name: 'photos',
                href: link,
                label: this.dict.t(this.options.lang, 'linkPhoto', photos.count)
            });
        }

        if (!this.options.isMobile && booklet && booklet.url && this.options.showBooklet) {
            links.push({
                name: 'booklet',
                href:  booklet.url,
                label: this.dict.t(this.options.lang, 'linkBooklet')
            });
        }


        return links;
    },

    _events: {
        'dg-popup__button_name_firm-card-back': function() {
            this.options.backBtn();
            this._toggleEventHandlers(true);
        },
        'dg-popup__button_name_show-entrance': function() {
            var ent = new this.options.showEntrance({'vectors': this._firmData.links.entrances[0].geometry.vectors});
            ent.addTo(this.options.map);
            ent.fitBounds();
            this._toggleEventHandlers(true);
        },
        'dg-schedule__today': function() {
            this._onToggleSchedule();
        }
    },

    _toggleEventHandlers: function (flag) {
        this.options.popup[flag ? 'off' : 'on']('click', this._onClick, this);
        this.options.map[flag ? 'off' : 'on']('popupclose', this._onClose, this);
    },

    _onClick: function (e) {
        var target = e.originalEvent.target;

        for (var eventClass in this._events) {
            if (this._events.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                DG.DomEvent.preventDefault(e.originalEvent);
                this._events[eventClass].call(this, target);
                return;
            }
        }
    },

    _onClose: function (e) {
        this._toggleEventHandlers(true);
    },

    _onToggleSchedule: function () {
        var schedule = this._container.querySelector('.dg-schedule__table'),
            forecast = this._container.querySelector('.dg-schedule__now'),
            target = this._container.querySelector('.dg-schedule__today'),
            showClass = ' dg-schedule__today_shown_true';

        if (!schedule) { return; }

        if (schedule.style.display === 'block') {
            schedule.style.display = 'none';
            forecast.style.display = 'block';
            target.className = target.className.replace(showClass, '');
        } else {
            forecast.style.display = 'none';
            schedule.style.display = 'block';
            target.className += showClass;
        }

        if (this.options.onToggle) {
            this.options.onToggle();
        }
    },

    _setOptions: function (options) {
        var option,
            options = options || {};

        this.options = options;
        options.lang = options.lang || 'ru';

        for (option in options) {
            if (options.hasOwnProperty(option)) {
                this.options[option] = options[option];
            }
        }
    },

    _hasTouch: function () {
        return (('ontouchstart' in window) ||
                (navigator.maxTouchPoints > 0) ||
                (navigator.msMaxTouchPoints > 0));
    }
};

FirmCard.DataHelper = {
	payMethods : [
		'americanexpress',
		'cash',
		'dinersclub',
		'goldcrown',
		'internet',
		'mastercard',
		'noncash',
		'visa'
	],

	_msgs : {},

	getFlampUrl : function (id) {
	    return DG.config.flampUrl.concat(id, '?', DG.config.flampGoogleAnalytics);
	},

	msg : function (msg) {
		if (this._msgs.hasOwnProperty(msg)) {
			return this._msgs[msg];
		}
		console && console.log("Cant't find translation for '" + msg + "'.");
		return msg.toString().replace('_', ' ');
	},

	getProjectTime: function (timezoneOffset, time) {
        var now, utc;

        if (time) {
            now = new Date(time);
        } else {
            now = new Date();
        }

        if (timezoneOffset) {
            utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            return new Date(utc + (60000 * timezoneOffset));
        } else {
            return now;
        }
    }
};

/* global
    FirmCard: false
*/
(function () {
    FirmCard.List = function (firms, options) {
        this._firms = {}; // {'firmID': firmDomObj}
        this._setOptions(options);

        this._container = options && options.container || document.createElement('ul');
        this._container.setAttribute('class', 'dg-building-callout__list');

        this._eventHandlersInited = false;
        this._firmCard = this._createFirm();
        this.renderList(firms);
    };

    FirmCard.List.prototype = {

        renderList: function (firms) {
            if (firms) {
                this._toggleEventHandlers();
                this.addFirms(firms);
            }
            if (this.options.onListReady) {
                this.options.onListReady(this._container);
            }

            return this._container;
        },

        _processFirms: function (firms, action) {
            if (!firms) { return; }
            var method = '_' + action + 'Firm';
            if (this._isArray(firms)) {
                for (var i = 0, l = firms.length; i < l; i++) {
                    this[method](firms[i]);
                }
            } else {
                this[method](firms);
            }

        },

        addFirms: function(firms) {
            this._processFirms(firms, 'add');
        },

        removeFirms: function(firms) {
            this._processFirms(firms, 'remove');
        },

        setLang: function (newLang) {
            this.options.firmCard.lang = newLang;
        },

        getLang: function () {
            return this.options.firmCard.lang;
        },

        getContainer: function () {
            return this._container;
        },

        clearList : function () {
            this._firms = {};
            this._toggleEventHandlers(true);
            this._clearContainer();
        },

        _removeFirm: function (id) {
            if (!this._firms[id]) { return false; }
            this._container.removeChild(this._firms[id]);
            delete this._firms[id];
        },

        _addFirm: function (firmData) {
            var tmpl = this.options.firmlistItemTmpl,
                domFirm, firm, content;

            firm = {
                name: firmData.name,
                id: firmData.id.split('_').slice(0, 1)
            };

            if (!(firm.id in this._firms)) {

                domFirm = this._createListItem();

                content = tmpl ? this.options.firmCard.render(tmpl, {'firm': firm}) : firm.name;

                domFirm.insertAdjacentHTML('beforeend', content);

                this._firms[firm.id] = domFirm;
                this._container.appendChild(domFirm);
            }
        },

        _createListItem: function () {
            var item = document.createElement('li');
            item.setAttribute('class', 'dg-building-callout__list-item');

            return item;
        },

        _isArray: function (obj) {
            return {}.toString.call(obj) === '[object Array]';
        },

        _createFirm: function (firmData) {
            return new FirmCard(firmData, this.options.firmCard);
        },

        _isEmptyObj: function (obj) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    return false;
                }
            }

            return true;
        },

        _events: {
            'dg-popup__link': function(target) {
                var s = this._firmCard.render(target.id);

                this.options.firmCard[this._isEmptyObj(s) ? 'pasteLoader' : 'onFirmReady'](s);

                this.options.firmCard.onFirmClick && this.options.firmCard.onFirmClick();

                this._toggleEventHandlers(true);
            },
            'dg-building-callout__list-item': function(target) {
                target = target.children[0];

                this._events['dg-popup__link'].call(this, target);
            },
            'dg-popup__button_name_back': function() {
                this.options.firmCard.onShowLess();

                this._toggleEventHandlers(true);
            }
        },

        _toggleEventHandlers : function (flag) {
            this.options.firmCard.popup[flag ? 'off' : 'on']('click', this._onClick, this);
        },

        _onClick: function (e) {
            var target = e.originalEvent.target;

            for (var eventClass in this._events) {
                if (this._events.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                    DG.DomEvent.preventDefault(e.originalEvent);
                    this._events[eventClass].call(this, target);
                    return;
                }
            }
        },

        _clearContainer: function () {
            var container = this._container;

            while (container.hasChildNodes()) {
                container.removeChild(container.firstChild);
            }
        },

        _setOptions: function (options) {
            options || (options = {});
            this.options = options;
            this.options.firmCard || (this.options.firmCard = {});

            if (!options.firmCard.lang) {
                this.options.firmCard.lang = 'ru';
            }

            for (var option in options) {
                if (options.hasOwnProperty(option)) {
                    this.options[option] = options[option];
                }
            }
        }
    };
})();

/*global
    FirmCard:false
*/
FirmCard.Schedule = function (options) {
    options = options || {};

    this.localLang = options.localLang || 'ru';
    this.dict = options.dict;
    return this;
};

FirmCard.Schedule.prototype = {

    setLang: function (lang) {
        this.localLang = lang || 'ru';
        return this;
    },

    transform: function (model, params) {
        if (!model) {
            return;
        }
        params = params || {};

        function bind(fn, obj) { // (Function, Object) -> Function
            var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
            return function () {
                return fn.apply(obj, args || arguments);
            };
        }

        var todayKey, // Mon, Tue ...
            today, //   -   
            from, //      
            to, //      
            zoneOffset = params.zoneOffset || 0,
            schedule = {}, // -,   
            now = params.now || FirmCard.DataHelper.getProjectTime(zoneOffset).getTime(), // Current timestamp in milliseconds
            weekKeys = [], //   ,       . 0 -      (  Mon)
            weekKeysLocal = [],
            weekFullKeysLocal = [],
            weekKeysShort =  [ 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun' ],
            weekKeysFull = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'],
            localLang = params.localLang || this.localLang,
            localWorkingDays = params.localWorkingDays || [0, 1, 1, 1, 1, 1, 0],
            firstdayOffset = params.firstdayOffset || 1,
            minHoursToDisplayClosure = params.minHoursToDisplayClosure || 4,
            t = bind(this.dict.t, this.dict);


        function capitaliseFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function getHours(str) {
            return str.substr(0, 2);
        }

        function getMinutes(str) {
            return str.substr(3, 2);
        }

        //         (25:00 -> 01:00)
        function formatTime(str) {
            var hours = +getHours(str) % 24 + '';

            if (hours.length === 1) {
                hours = '0' + hours;
            }

            return hours + ':' + getMinutes(str);
        }

        //  int      ( 0-6)
        function dayNum(n) {
            return n % 7;
        }


        /* jshint ignore:start */
        //    
        //   Underscore.js http://underscorejs.org/#last
        function getArrayLast(arr, n) {
            if ( arr == null ) return void 0;
            if (   n == null ) return arr[ arr.length - 1 ];
            return slice.call( arr, Math.max(arr.length - n , 0) );
        }


        //    
        //   Underscore.js http://underscorejs.org/#isEqual
        //     ,    Shedule.js
        function isEqual(obj1, obj2) {
            if ( obj1 === obj2 ) return true;
            if ( ! ( obj1 instanceof Object ) || ! ( obj2 instanceof Object ) ) return false;
            if ( obj1.constructor !== obj2.constructor ) return false;
            for ( var prop in obj1 ) {
                if ( ! obj1.hasOwnProperty( prop ) ) continue;
                if ( ! obj2.hasOwnProperty( prop ) ) return false;
                if ( obj1[ prop ] === obj2[ prop ] ) continue;
                if ( typeof( obj1[ prop ] ) !== "object" ) return false;
                if ( ! isEqual( obj1[ prop ],  obj2[ prop ] ) ) return false;
            }
            for ( prop in obj2 ) {
            if ( obj2.hasOwnProperty( prop ) && ! obj1.hasOwnProperty( prop ) ) return false;
            }

            return true;
        }

        // Generate an integer Array containing an arithmetic progression. A port of
        // the native Python `range()` function. See
        // [the Python documentation](http://docs.python.org/library/functions.html#range).
        function range(start, stop, step) {
        if (arguments.length <= 1) {
            stop = start || 0;
            start = 0;
        }
        step = arguments[2] || 1;

        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(length);
        while(idx < length) {
            range[idx++] = start;
            start += step;
        }

        return range;
        }


        //     
        //  Underscore.js http://underscorejs.org/#defaults
        function fillDefaults(obj) {
         var args = Array.prototype.slice.call(arguments, 1);
         args.forEach(function(source) {
            if (source) {
                for (var prop in source) {
                    if (obj[prop] === void 0) obj[prop] = source[prop];
                }
            }
        });
        return obj;
        }

        //    
        //  Underscore.js http://underscorejs.org/#sortBy
        function sortBy(obj, iterator){
            return pluck(obj.map( function(value, index, list) {
                return {
                        value: value,
                        index: index,
                        criteria: iterator.call(this, value, index, list)
                        };
                }).sort(function(left, right) {
                        var a = left.criteria;
                        var b = right.criteria;
                        if (a !== b) {
                        if (a > b || a === void 0) return 1;
                        if (a < b || b === void 0) return -1;
                        }
                return left.index - right.index;
                }), 'value');
        }

        /* jshint ignore:end */

        function pluck(arr, key){
            var i, rv = [];
            for (i = 0; i < arr.length; ++i) {
            rv[i] = arr[i][key];
            }
            return rv;
        }


        //          (string)
        //  ,  API    
        function getSortedTimePoints(day) {
            var points = [],
                from, to,
                deltaHours, deltaMinutes;

            if (!day || !day.working_hours) {
                return [];
            }

            for (var i = 0 ; i < day.working_hours.length ; i++) {
                from = day.working_hours[i].from;
                to = day.working_hours[i].to;

                deltaHours = getHours(to) - getHours(from);
                deltaMinutes = getMinutes(to) - getMinutes(from);
                if (deltaHours < 0 || (deltaHours === 0 && deltaMinutes <= 0)) { //  ""    "" -    
                    to = (+getHours(to) + 24) + ':' + getMinutes(to); // (01:00 -> 25:00)
                }

                points[i * 2] = {
                    time: from,
                    type: 'open'
                };
                points[i * 2 + 1] = {
                    time: to,
                    type: day.working_hours.length - 1 === i ? 'close' : 'lunch'
                };
            }

            return points;
        }

        //   timestamp  ,   ,     
        // ,  ,        ()    
        function getTimeStamps(model) {
            var timestamps = [],
                out = [],
                timePoints,
                num = weekKeys.indexOf(todayKey); //     (  )


            //       
            var j; //      weekKeys
            for (var i = 0 ; i < 7 ; i++) {
                j = dayNum(num + i);
                timePoints = getSortedTimePoints(model[weekKeys[j]]);
                //        timestamp
                timePoints.forEach(
                    /* jshint -W083 */
                    function (point) {
                    // now - !     timestamp      
                    //      ,   ,  ,    now
                    var tsp = new Date(now);
                    tsp.setDate(tsp.getDate()+i);
                    tsp.setHours(getHours(point.time));
                    tsp.setMinutes(getMinutes(point.time));
                    var ts = tsp.getTime();



                    timestamps.push({
                        ts: ts,
                        type: point.type
                    });

                    if (timestamps[timestamps.length - 1] && timestamps[timestamps.length - 2]) {
                        //     (    -   24:00   00:00)
                        if (timestamps[timestamps.length - 1].ts === timestamps[timestamps.length - 2].ts) {
                            timestamps.pop();
                            timestamps.pop();
                        }
                    }

                    if (timestamps[timestamps.length - 1] && timestamps[timestamps.length - 2]) {
                        //     ,      (  ([0])    !)
                        if (timestamps[timestamps.length - 1].ts <= now && timestamps[timestamps.length - 2].ts <= now) {
                            timestamps[timestamps.length - 1].ts += (7 * 24 * 60 * 60 * 1000);
                            timestamps[timestamps.length - 2].ts += (7 * 24 * 60 * 60 * 1000);
                        }
                    }
                }
                /* jshint +W083 */
                );
            }

            //   ,      
            timestamps = sortBy(timestamps, function (timestamp) { return timestamp.ts; });

            //     
            i = 0;
            while (i < timestamps.length) {
                if (timestamps[i + 1] && timestamps[i].ts === timestamps[i + 1].ts) {
                    i++;
                } else {
                    out.push(timestamps[i].ts);
                }
                i++;
            }

            //   -
            if (out.length === 2 && (out[1] - out[0]) === (7 * 24 * 60 * 60 * 1000)) {
                return [];
            }

            return timestamps;
        }

        function whenOpenInverse(h, d, num) {
            if (d === 1 && h > minHoursToDisplayClosure ) {
                return t(localLang, 'tommorow');
            } else if (d > 1) {
                /* jshint -W015 */
                switch (num) {
                    case 0: return t(localLang, 'nextSun');
                    case 1: return t(localLang, 'nextMon');
                    case 2: return t(localLang, 'nextTue');
                    case 3: return t(localLang, 'nextWed');
                    case 4: return t(localLang, 'nextThu');
                    case 5: return t(localLang, 'nextFri');
                    case 6: return t(localLang, 'nextSat');
                }
                /* jshint +W015 */
            }

            return;
        }


        //    ,       , 
        // @param timestampEnd  @param dateStart
        function dayInterval(timestampEnd, dateStart) {

            var oneDay = 1000 * 60 * 60 * 24,
                dateEnd = new Date(timestampEnd.ts);

            var diff;

            diff = Math.round((dateEnd - dateStart) / oneDay);

            if( timestampEnd.type==='open' && dateEnd.getHours() < 1 )
                { diff ++; }

            return diff;
        }


        //         
        function setTodayString(today) {

            var timePoints,
                periods = [],
                timestamps;

            schedule.now = {};

            // Timestamps  
            timestamps = getTimeStamps(model);

            if (!timestamps.length) {
                schedule.always = true; //   
                schedule.now.open = true;
            }


            for (var i = 0 ; i < timestamps.length ; i++) {
                //    i-1  i //       1
                if (now >= (timestamps[i - 1] && timestamps[i - 1].ts || 0) && now < timestamps[i].ts) {
                    var h = Math.floor((timestamps[i].ts - now) / (1000 * 60 * 60)), //     timestamp
                        m = Math.floor((timestamps[i].ts - now) / (1000 * 60) - h * 60), //   ( )   timestamp
                        dayNow = new Date(now),

                        //      
                        nowIsOpen = timestamps[i].type !== 'open';

                        //var d = dayOfYear(dayTs) - dayOfYear(dayNow);
                        //var d = dayInterval(dayTs, dayNow, nowIsOpen);
                        var d = dayInterval(timestamps[i], dayNow);



                    //     5
                    m = Math.floor(m / 10) * 10 ? Math.floor(m / 10) * 10 : 5;

                    schedule.now.open = nowIsOpen;
                    schedule.now.lunch = !!(timestamps[i - 1] && timestamps[i - 1].type === 'lunch' || getArrayLast(timestamps).type === 'lunch');

                    schedule.will = {
                        willType: timestamps[i].type,
                        d: d,
                        h: h,
                        m: m
                    };

                    //    
                    var willWhen = new Date(timestamps[i].ts);
                    schedule.will.when = whenOpenInverse(h, d, willWhen.getDay());


                    var willTill = new Date(timestamps[i].ts),
                        strHours = willTill.getHours(),
                        strMinutes = willTill.getMinutes();

                    if (strHours < 10) { strHours = '0' + strHours; }
                    if (strMinutes < 10) { strMinutes = '0' + strMinutes; }

                    schedule.will.till = strHours+':'+strMinutes;
                }
            }

            if (!today) {
                return; //     -  
            }

            timePoints = pluck(getSortedTimePoints(today), 'time');

            //      
            for (i = 2 ; i < timePoints.length ; i = i + 2) {
                periods.push({ from: timePoints[i - 1], to: timePoints[i] });
            }

            from = formatTime(timePoints[0]);
            to = formatTime(timePoints[timePoints.length - 1]);

            if (from === to) { // 
                schedule.today = {
                    alltime: true,
                    alltimeStr: t(localLang, 'worksAroundTheClock'),
                    from: '00:00',
                    to: '24:00'
                };
            } else { //  from  to
                schedule.today = {
                    from: from,
                    to: to
                };
            }

            if (periods.length > 0) { //   
                schedule.lunch = periods;
                schedule.lunchStr = t(localLang, 'lunch');
            }
        }

        //  --  
        function makeTable() {
            var column = [],
                hasLunch = false;

            for (var j = 0 ; j < 7 ; j++) {
                var dayKey = weekKeys[j],
                    lunchMaxLength = 0;

                column[j] = {};

                if (model[dayKey]) {
                    var day = model[dayKey],
                        timePoints = pluck(getSortedTimePoints(day), 'time'),
                        lunch = []; //   ( )  

                    //      
                    for (var i = 2 ; i < timePoints.length ; i = i + 2) {
                        hasLunch = true;
                        lunch.push({ from: timePoints[i - 1], to: timePoints[i] });
                    }
                    lunchMaxLength = Math.max(timePoints.length / 2, lunchMaxLength);

                    column[j] = {
                        from: formatTime(timePoints[0]),
                        to: formatTime(timePoints[timePoints.length - 1]),
                        lunch: lunch
                    };
                }

                if (dayKey === todayKey) { //    
                    column[j].active = true;
                }

                column[j].key = weekKeysLocal[j];
            }

            //     lunch
            column.forEach( function (col) {
                if (col.lunch) {
                    fillDefaults(col.lunch, range(1, lunchMaxLength));
                }
            });

            return {
                table: column,
                hasLunch: hasLunch
            };
        }

        //      model,   day
        function makeSimpleString(day, model) {
            var points,
                out = {
                    dayList: [],
                    lunch: []
                },
                lunchesTime = [];

            if (day && day.working_hours && day.working_hours.length) {
                points = pluck(getSortedTimePoints(day), 'time');
                points.forEach( function (point, key) {
                    if (key === 0) {
                        out.from = formatTime(point);
                    } else if (key === points.length - 1) {
                        out.to = formatTime(point);
                    } else {
                        lunchesTime.push(formatTime(point));
                    }
                });
                for (var i = 0; i < lunchesTime.length; i += 2) {
                    out.lunch.push({
                        from: lunchesTime[i],
                        to: lunchesTime[i + 1],
                        lunchStr: capitaliseFirstLetter(t(localLang, 'lunch'))
                    });
                }

                if (out.from == '00:00' && out.to == '00:00') {
                    out.to = '24:00';
                }

                if (day.round_the_clock) {
                    out.alltime = true;
                    out.alltimeStr = t(localLang, 'worksAroundTheClock');
                }
            } else { // 
                out.holiday = true;
            }

            //      
            var groupWorkingDays = [0, 0, 0, 0, 0, 0, 0]; //       
            var flow = 0;

            weekKeys.forEach( function (dayKey, numKey) { // 'Mon', 0
                if (isEqual(model[dayKey], day) || (!model[dayKey] && day === null)) {
                    out.dayList.push(weekFullKeysLocal[numKey]);
                    groupWorkingDays[dayNum(numKey + firstdayOffset)] = 1;
                    flow++;
                } else {
                    if (flow > 2) { //  2  
                        var lastDay = out.dayList.pop();

                        for (var i = 1 ; i < flow - 1 ; i++) {
                            out.dayList.pop();
                        }

                        out.dayList[out.dayList.length - 1] += '  ' + lastDay;
                    }

                    flow = 0;
                }
            });

            //         ,     ""
            out.budni = isEqual(localWorkingDays, groupWorkingDays);
            //    -   ,     ""
            out.everyday = ( Math.min.apply(Math, groupWorkingDays) === 1 );

            if ( out.holiday ) { out.holidayStr = t(localLang, 'restDay', out.dayList.length).slice(2); }

            //        
            out.dayList = out.dayList.join(', ');
            out.dayList = out.dayList.charAt(0).toUpperCase() + out.dayList.slice(1);


            return out;
        }

        //   simple      days
        function makeAdvancedString(days, model) {
            var out = [];

            for (var i = days.length - 1 ; i >= 0 ; i--) {
                out.push(makeSimpleString(days[i], model));
            }

            return out;
        }

        //    , 1 - .      0

        for (var i = 0 ; i < 7 ; i++) {
            weekKeys[i] = weekKeysShort[i];
            weekKeysLocal[i] = this.dict.t(localLang, weekKeysShort[i].toLowerCase());
            weekFullKeysLocal[i] = this.dict.t(localLang, weekKeysFull[i]);
        }

        //     (     )
        todayKey = weekKeysShort[(new Date(now).getDay()-firstdayOffset) % 7];
        today = model[todayKey]; //   -   
        setTodayString(today); //     - ,     

        //         
        var apiDifferentDays = [], //     
            apiScheduleDaysCount = 0, //      
            apiDifferentDaysCount = 0, //      
            differentWorkingHoursCount = []; //      

        Object.keys(model).forEach( function(day) {
            if (model[day] && model[day].working_hours) { //    ,     - 
                apiScheduleDaysCount++;
                if (!isEqual(model[day], getArrayLast(apiDifferentDays))) {
                    apiDifferentDays.push(model[day]);
                }
            }
        });

        apiDifferentDaysCount = apiDifferentDays.length;
        //       ,       -  (  )
        if (apiScheduleDaysCount < 7) {
            apiDifferentDaysCount++;
        }

        //    2,     -  
        if (apiDifferentDaysCount > 2) {
            schedule.week = makeTable(model);
        } else { // ,     

            // ,   
            if (apiDifferentDaysCount === 1) {
                schedule.week = {
                    evently: [makeSimpleString(model[weekKeys[0]], model)]
                };
            } else { //  ,     
                //           
                for (i = 0 ; i < apiDifferentDaysCount ; i++) {
                    differentWorkingHoursCount[i] = 0;

                    if (apiDifferentDays[i]) {
                        var points = pluck(getSortedTimePoints(apiDifferentDays[i]), 'time');

                        for (var j = 0 ; j < points.length ; j = j + 2) {
                            var hours = (getHours(points[j + 1]) + getMinutes(points[j + 1]) / 60) - (getHours(points[j]) + getMinutes(points[j]) / 60);
                            differentWorkingHoursCount[i] += hours;
                        }
                    } else { // 
                        apiDifferentDays[i] = null;
                    }
                }

                var apiSortedDifferentDays = sortBy(apiDifferentDays, function (day, key) {
                    return differentWorkingHoursCount[key];
                });

                schedule.week = {
                    evently: makeAdvancedString(apiSortedDifferentDays, model)
                };
            }
        }

        schedule.comment = model.comment;
        if (schedule.week && schedule.week.evently && schedule.week.evently.length === 1) {
            schedule.everyday = schedule.week.evently[0].everyday;
        }
        return schedule;
    },

    forecast: function (schedule, params) {
        var interval = '',
        open,
        today = {},
        nowText,
        maxHours = params && params.maxHours || 1;

        if (!schedule) {
            return {};
        }

        if (schedule.always) { //   -     
            return {
                today: {
                    text: this.dict.t(this.localLang, 'aroundTheClock')
                },
                open: true
            };
        }

        //   -      
        if (schedule.will && schedule.will.h < maxHours) {
            if (schedule.will.h) {
                interval += this.dict.t(this.localLang, 'nHours', schedule.will.h) + ' ';
            }

            if (schedule.will.m) {
                interval += this.dict.t(this.localLang, 'nMins', schedule.will.m);
            }
        }

        //   
        if (schedule.today) {
            today.text = this.dict.t(this.localLang, 'today');
            if (schedule.everyday) {
                today.text = this.dict.t(this.localLang, 'everyday');
            }
            today.from = schedule.today.from;
            today.to = schedule.today.to;
            today.lunch = schedule.lunch;
            if (today.lunch) {
                today.lunchStr = this.dict.t(this.localLang, 'lunch');
            }
        } else {
            today.text = this.dict.t(this.localLang, 'todayIsRestDay');
        }

        //    
        if (schedule.always) { //  ,   ""   
            today.text = this.dict.t(this.localLang, 'aroundTheClock');
            open = true;
        } else if (schedule.now) {
            open = schedule.now.open;
            if (open) { // 
                if (schedule.will && schedule.will.willType === 'lunch') {
                    //  -   
                    if (schedule.will && schedule.will.h < maxHours) {
                        //  maxHours     
                        nowText = this.dict.t(this.localLang, '_in') + ' ' + this.dict.t(this.localLang, 'nMins', interval) + this.dict.t(this.localLang, 'isClosingOnDinner');
                    } else {
                        //  maxHours     
                        nowText = this.dict.t(this.localLang, 'isOpen');
                    }

                } else {
                    //   
                    if (schedule.will.h < maxHours) {
                        //  maxHours   
                        nowText = this.dict.t(this.localLang, 'closeIn') + this.dict.t(this.localLang, 'nMins', interval);
                    } else {
                        //  maxHours   
                        nowText = this.dict.t(this.localLang, 'isOpen');
                    }
                }
            } else { // 
                if (schedule.will && schedule.will.when) {
                    //   
                    nowText = this.dict.t(this.localLang, 'open') + schedule.will.when;
                } else {
                    //  
                    if (schedule.now && schedule.now.lunch) {
                        //  
                        if (schedule.will.h < maxHours) {
                            //  maxHours    
                            nowText = this.dict.t(this.localLang, 'Lunch') + this.dict.t(this.localLang, 'openIn') + this.dict.t(this.localLang, 'nMins', interval);
                        } else {
                            //  maxHours    
                            nowText = this.dict.t(this.localLang, 'Lunch') + this.dict.t(this.localLang, 'openAt') + schedule.will.till;
                        }
                    } else {
                        //  
                        if (schedule.will && schedule.will.h < maxHours) {
                            //  maxHours   
                            nowText = this.dict.t(this.localLang, 'openIn') + this.dict.t(this.localLang, 'nMins', interval);
                        } else {
                            //  maxHours   
                            nowText = this.dict.t(this.localLang, 'openAt') + schedule.will.till;
                        }
                    }
                }
            }
        }

        return {
            today: today,
            now: nowText,
            open: open,
            week: schedule.week,
            comment: schedule.comment,
            everyday: schedule.everyday
        };
    }
};

/*global
    FirmCard:false
*/
// FirmCard.dictionary = {};

FirmCard.prototype.dict = {

    t: function (lang, msg, argument) { // (String, Number) -> String
        var result,
            msgIsset = false,
            dictionaryMsg,
            exp;

        if (typeof this[lang] === 'undefined') {
            lang = 'ru';
        }
        dictionaryMsg = this[lang][msg];
        msgIsset = typeof dictionaryMsg !== 'undefined';
        if (!msgIsset) {
            return msg;
        }
        result = msgIsset ? dictionaryMsg : msg;

        if (argument !== undefined) {
            argument = parseInt(argument, 10);
            argument = isNaN(argument) ? 0 : argument;
            exp = this[lang].pluralRules(argument);
            result = argument + ' ' + dictionaryMsg[exp];
        }
        return result ? result : msg;
    },

    ru: {
        pluralRules: function (n) { // (Number)
            if (n % 10 === 1 && n % 100 !== 11) { // 1, 21
                return 0;
            }
            if ((n % 10 >= 2 && n % 10 <= 4 && (n % 10) % 1 === 0) && (n % 100 < 12 || n % 100 > 14)) { // 2, 3
                return 1;
            }

            if ((n % 10 === 0) || (n % 10 >= 5 && n % 10 <= 9 && (n % 10) % 1 === 0) || (n % 100 >= 11 && (n % 100) <= 14 && (n % 100) % 1 === 0)) { // 13, 17
                return 2;
            }
        },

        btnBack: '',
        btnFindWay: ' ',
        btnEntrance: ' ',
        linkReviews: ['', '', ''],
        linkPhoto: ['', '', ''],
        linkBooklet: '',
        tommorow: '',
        afterTommorow: '',
        afterWeek: ' ',
        nextSun: ' ',
        nextMon: ' ',
        nextTue: ' ',
        nextWed: ' ',
        nextThu: ' ',
        nextFri: ' ',
        nextSat: ' ',
        willOpen: '',
        willClose: '',
        isOpen: '',
        openTill: '  ',
        closeIn: '  ',
        openAt: '  ',
        openIn: '  ',
        open: ' ',
        nHours: ['', '', ''],
        nMins: ['', '', ''],
        lunch: '',
        Lunch: '. ',
        workingDays: ' ',
        weekdays: ' ',
        restDay: ['', '',''],
        reviewsOnFlamp: '  ',
        writeReviewOnFlamp: '   ',
        payment: '',
        everyday: ' c',
        worksAroundTheClock: ' ',
        aroundTheClock: '',
        knowMore: ' ',
        toClose: ' ',
        monday: '',
        tuesday: '',
        wednesday: '',
        thursday: '',
        friday: '',
        saturday: '',
        sunday: '',
        mon: '',
        tue: '',
        wed: '',
        thu: '',
        fri: '',
        sat: '',
        sun: '',
        toLunch: ' ',
        today: '',
        lessThenHour: ' ',
        youCouldLate: '   ',
        workingTime: ' ',
        showAllOrgInRubric: '   ',
        todayIsRestDay: ' ',
        internet: '  ',
        noncash: ' ',
        goldcrown: ' ',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: ' ',
        americanexpress: 'American Express',
        hour : '',
        less: '',
        _in : '',
        isClosingOnDinner : '   '
    },

    it: {
        pluralRules: function (n) { // (Number)
            if (n === 1) { // 1
                return 0;
            } else {
                return 1; //0, 2, 3, 4 ..
            }
        },

        btnBack: 'Indietro',
        btnFindWay: 'Come arrivare ',
        btnEntrance: 'Trova l\'ingresso',
        linkReviews: ['recensione', 'recensioni'],
        linkPhoto: ['fotografia', 'fotografie'],
        linkBooklet: 'Sull\'azienda',
        tommorow: 'domani',
        afterTommorow: 'dopodomani',
        afterWeek: 'tra una settimana',
        nextSun: 'la domenica',
        nextMon: 'il lunedi',
        nextTue: 'il marted',
        nextWed: 'il mercoled',
        nextThu: 'il giovedi',
        nextFri: 'il venerd',
        nextSat: 'il sabato',
        willOpen: 'apre',
        willClose: 'ciuso',
        isOpen: 'Aperto',
        openTill: 'Aperto fino alle ',
        closeIn: 'Chiude tra ',
        openAt: 'Apre alle ',
        openIn: 'Apre tra ',
        open: 'Apre ',
        nHours: ['ora', 'ore'],
        nMins: ['minuto', 'minuti'],
        lunch: 'pausa pranzo',
        Lunch: 'Pausa pranzo. ',
        workingDays: 'Giorni feriali',
        weekdays: 'Giorni feriali',
        restDay: ['chiusura','chiusura'],
        reviewsOnFlamp: 'Recensioni su Flamp',
        writeReviewOnFlamp: 'Scrivi una recensione su Flamp',
        payment: 'pagamento',
        everyday: 'Ogni giorno dalole',
        worksAroundTheClock: 'Operativo 24 ore su 24',
        aroundTheClock: '24 ore su 24',
        knowMore: 'ulteriori informazioni',
        toClose: 'fino alla chiusura',
        monday: 'lunedi',
        tuesday: 'marted',
        wednesday: 'mercoled',
        thursday: 'giovedi',
        friday: 'venerd',
        saturday: 'sabato',
        sunday: 'domenica',
        mon: 'lun',
        tue: 'mar',
        wed: 'mer',
        thu: 'gio',
        fri: 'ven',
        sat: 'sab',
        sun: 'dom',
        toLunch: 'fino alla pausa pranzo',
        today: 'Oggi',
        lessThenHour: 'meno di un\'ora',
        youCouldLate: 'affrettarsi, chiusura imminente',
        workingTime: 'orario di lavoro',
        showAllOrgInRubric: 'Visualizza tutte le aziende della categoria',
        todayIsRestDay: 'oggi chiuso',
        internet: 'Pagamento on-line',
        noncash: 'Pagamento non in contanti',
        goldcrown: 'Zolotaja Korona',
        dinersclub: 'Diners Club',
        mastercard: 'MasterCard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Pagamento in contanti',
        americanexpress: 'American Express',
        hour : 'un\'ora',
        less: 'meno di',
        _in : 'Tra',
        isClosingOnDinner : 'chiude per pausa pranzo'
    },

    en: {
        pluralRules: function (n) { // (Number)
            if (n === 1) { // 1
                return 0;
            } else {
                return 1; //0, 2, 3, 4 ..
            }
        },

        btnBack: 'Back',
        btnFindWay: 'Get here',
        btnEntrance: 'Find entrance',
        linkReviews: ['review', 'reviews'],
        linkPhoto: ['photo', 'photos'],
        linkBooklet: 'About company',
        tommorow: 'tomorrow',
        afterTommorow: 'the day after tomorrow',
        afterWeek: 'in a week',
        nextSun: 'on Sunday',
        nextMon: 'on Monday',
        nextTue: 'on Tuesday',
        nextWed: 'on Wednesday',
        nextThu: 'on Thursday',
        nextFri: 'on Friday',
        nextSat: 'on Saturday',
        willOpen: 'opens ',
        willClose: 'closes',
        isOpen: 'Open',
        openTill: 'Open till ',
        closeIn: 'Closes in ',
        openAt: 'Opens at ',
        openIn: 'Opens in ',
        open: 'Opens ',
        nHours: ['hour', 'hours'],
        nMins: ['minute', 'minutes'],
        lunch: 'lunch break',
        Lunch: 'Lunch break. ',
        workingDays: 'Working days',
        weekdays: 'Weekdays',
        restDay: ['day off','days off'],
        reviewsOnFlamp: 'Reviews on Flamp',
        writeReviewOnFlamp: 'Write a review on Flamp',
        payment: 'payment',
        everyday: 'Daily from',
        worksAroundTheClock: 'Open 24 hours',
        aroundTheClock: '24h',
        knowMore: 'see also',
        toClose: 'until closing',
        monday: 'Monday',
        tuesday: 'Tuesday',
        wednesday: 'Wednesday',
        thursday: 'Thursday',
        friday: 'Friday',
        saturday: 'Saturday',
        sunday: 'Sunday',
        mon: 'Mon',
        tue: 'Tue',
        wed: 'Wed',
        thu: 'Thu',
        fri: 'Fri',
        sat: 'Sat',
        sun: 'Sun',
        toLunch: 'until lunch',
        today: 'Today',
        lessThenHour: 'less then one hour',
        youCouldLate: 'you might be late',
        workingTime: 'working hours',
        showAllOrgInRubric: 'Show all organizations in the category',
        todayIsRestDay: 'closed today',
        internet: 'Online',
        noncash: ' No-cash',
        goldcrown: 'Golden Crown',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Cash',
        americanexpress: 'American Express',
        hour : 'hour',
        less: 'less',
        _in : 'In',
        isClosingOnDinner : 'will be closing for lunch'
    },

    cs: {
        pluralRules: function (n) { // (Number)
            return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2;
        },

        btnBack: 'Zpt',
        btnFindWay: 'Jet sem',
        btnEntrance: 'Hledat vstup',
        linkReviews: ['recenze', 'recenze', 'recenz'],
        linkPhoto: ['fotografie', 'fotografie', 'fotografi'],
        linkBooklet: 'Letk',
        tommorow: 'ztra',
        afterTommorow: 'pozt',
        afterWeek: 'za tden',
        nextSun: 'v nedli',
        nextMon: 'v pondl',
        nextTue: 'v ter',
        nextWed: 've stedu',
        nextThu: 've tvrtek',
        nextFri: 'v ptek',
        nextSat: 'v sobotu',
        willOpen: 'oteve se',
        willClose: 'zave se',
        isOpen: 'Oteveno',
        openTill: 'Oteveno do ',
        closeIn: 'Zave se za ',
        openAt: 'Oteve se v ',
        openIn: 'Oteve se za ',
        open: 'Oteve se ',
        nHours: [ 'hodinu' , 'hodiny' , 'hodin' ],
        nMins: [ 'minutu' , 'minuty' , 'minut' ],
        lunch: 'poledn pestvka',
        Lunch: 'Poledn pestvka. ',
        workingDays: 'Vedn dny',
        weekdays: 'Vedn dny',
        restDay: ['zaveno', 'zaveno'],
        reviewsOnFlamp: 'Recenze na Flampu',
        writeReviewOnFlamp: 'Napsat recenzi na Flampu',
        payment: 'platba',
        everyday: 'Denn od ',
        worksAroundTheClock: 'Pracuje nonstop',
        aroundTheClock: 'Nonstop',
        knowMore: 'dozvdt se vce',
        toClose: 'do uzaven',
        monday: 'pondl',
        tuesday: 'ter',
        wednesday: 'steda',
        thursday: 'tvrtek',
        friday: 'ptek',
        saturday: 'sobota',
        sunday: 'nedle',
        mon: 'po',
        tue: 't',
        wed: 'st',
        thu: 't',
        fri: 'p',
        sat: 'so',
        sun: 'ne',
        toLunch: 'do poledn pestvky',
        today: 'Dnes',
        lessThenHour: 'mn ne hodinu',
        youCouldLate: 'nemuste to stihnout',
        workingTime: 'pracovn doba',
        showAllOrgInRubric: 'Zobrazit vechny organizace v rubrice',
        todayIsRestDay: 'Dnes je zaveno',
        internet: 'Platba prostednictvm Internetu',
        noncash: 'Bezhotovostn platba',
        goldcrown: 'Zolotaja Korona',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Platba hotov',
        americanexpress: 'American Express',
        hour : 'hodinu',
        less: 'mn',
        _in : 'Za',
        isClosingOnDinner : 'zan poledn pestvka'
    },

    es: {
        pluralRules: function (n) { // (Number)
          return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2;
        },

        btnBack: 'Atrs',
        btnFindWay: 'Ir para all',
        btnEntrance: 'Buscar acceso',
        linkReviews: ['comentario', 'comentarios', 'comentarios'],
        linkPhoto: ['foto', 'fotos', 'fotos'],
        linkBooklet: 'Folleto',
        tommorow: 'maana',
        afterTommorow: 'pasado maana',
        afterWeek: 'en una semana ms',
        nextSun: 'el domingo',
        nextMon: 'el lunes',
        nextTue: 'el martes',
        nextWed: 'el mircoles',
        nextThu: 'el jueves',
        nextFri: 'el viernes',
        nextSat: 'el sbado',
        willOpen: 'se abrir',
        willClose: 'se cerrar',
        isOpen: 'Abierto',
        openTill: 'Abierto hasta ',
        closeIn: 'Se cerrar dentro de ',
        openAt: 'Se abrir el ',
        openIn: 'Se abrir dentro de ',
        open: 'Se abrir ',
        nHours: ['hora', 'horas', 'horas'],
        nMins: ['minuto', 'minutos', 'minutos'],
        lunch: 'hora de colacin',
        Lunch: 'Hora de colacin. ',
        workingDays: 'Das laborables',
        weekdays: 'Das laborables',
        restDay: ['cerrado','cerrado'],
        reviewsOnFlamp: 'Comentarios en Flamp',
        writeReviewOnFlamp: 'Escribir un comentario en Flamp',
        payment: 'pago',
        everyday: 'Cada da desde',
        worksAroundTheClock: 'Abierto las 24 horas',
        aroundTheClock: '24 horas',
        knowMore: 'para saber ms',
        toClose: 'hasta el cierre',
        monday: 'lunes',
        tuesday: 'martes',
        wednesday: 'mircoles',
        thursday: 'jueves',
        friday: 'viernes',
        saturday: 'sbado',
        sunday: 'domingo',
        mon: 'lun',
        tue: 'mar',
        wed: 'mi',
        thu: 'jue',
        fri: 'vie',
        sat: 'sb',
        sun: 'dom',
        toLunch: 'antes de la hora de colacin',
        today: 'Hoy',
        lessThenHour: 'menos de una hora',
        youCouldLate: 'puede ser que no alcanzas a llegar',
        workingTime: 'horario de trabajo',
        showAllOrgInRubric: 'Mostrar todas las empresas de la categora',
        todayIsRestDay: 'Hoy cerrado',
        internet: 'Pago por Internet',
        noncash: 'Pago sin efectivo',
        goldcrown: 'Zolotaya Korona',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Pago en efectivo',
        americanexpress: 'American Express',
        hour : 'hora',
        less: 'menos de',
        _in : 'Dentro de',
        isClosingOnDinner : 'se cierra por hora de colacin'
    }
};

DG.Traffic = DG.TileLayer.extend({
    options: {
        period: 0,
        disableLabel: false
    },

    statics: {
        Dictionary: {}
    },

    initialize: function(options) {
        this._tileUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaTrafficTileServer : DG.config.trafficTileServer);
        this._metaUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaTrafficMetaServer : DG.config.trafficMetaServer);
        this._timeUrl = DG.config.protocol + DG.config.trafficTimestampServer;
        this._updateInterval = DG.config.trafficLayerUpdateInterval;

        this._layersOptions = {
            errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
            subdomains: '012345679',
            maxNativeZoom: 18,
            detectRetina: true,
            minZoom: DG.config.trafficLayerMinZoom
        };

        options = DG.setOptions(this, DG.extend(options || {}, this._layersOptions));
        options.timestampString = options.period ? '' : ('?' +  (new Date()).getTime());
        this._metaLayer = DG.Meta.layer(null, {
            detectRetina: options.detectRetina,
            maxNativeZoom: options.maxNativeZoom,
            dataFilter: DG.bind(this._processData, this),
            minZoom: options.minZoom
        });
        this._isDg = true;
        this._onTimer = DG.bind(this._onTimer, this);
        DG.TileLayer.prototype.initialize.call(this, this._tileUrl, options);
    },

    // #setTime(day [0-6], time[0-23]) ????

    onAdd: function(map) {
        this._updateLayerProject();

        map
            .addLayer(this._metaLayer)
            .on('projectchange projectleave', this._onMapProjectChange, this);

        if (!this.options.disableLabel) {
            this._metaLayer.on(this._layerEventsListeners, this);
            this._labelHelper = DG.label();
        }

        if (this._updateInterval) {
            this._updateTimer = setInterval(this._onTimer, this._updateInterval);
        }

        DG.TileLayer.prototype.onAdd.call(this, map);
    },

    onRemove: function(map) {
        clearInterval(this._updateTimer);

        map
            .removeLayer(this._metaLayer)
            .off('projectchange projectleave', this._onMapProjectChange, this);

        if (!this.options.disableLabel) {
            this._metaLayer.off(this._layerEventsListeners, this);
            this._map.removeLayer(this._labelHelper);
            this._labelHelper = null;
        }

        DG.TileLayer.prototype.onRemove.call(this, map);
    },

    update: function() {
        var self = this;
        this._getTimestampString().then(
            function(response) {
                self.options.timestampString = '?' + response;
            },
            function() {
                self.options.timestampString = '?' + (new Date()).getTime();
            }).then(
            function() {
                self.fire('update', {timestamp: self.options.timestampString});
                self._layerEventsListeners.mouseout.call(self);
                self._metaLayer.getOrigin().setURL(self._prepareMetaURL(), self);
                self.redraw();
            }
        );
    },

    getSubdomain: function() {
        return this._layersOptions.subdomains[
            Math.floor(Math.random() * this._layersOptions.subdomains.length)
        ];
    },

    _getTimestampString: function() {
        return DG.ajax(
            DG.Util.template(
                this._timeUrl,
                DG.extend({
                    s : this.getSubdomain(),
                    projectCode: this._map.projectDetector.getProject().code
                }, this.options || {})),
            {type: 'get'}
        );
    },

    _onTimer: function() {
        if (this.options.period === 0) {
            this.update();
        }
    },

    _processData: function(trafficData, coord) {
        var tileOriginPoint = coord.scaleBy(this.getTileSize());
        var polygonLngLatToPoints = DG.bind(this._polygonLngLatToPoints, this, tileOriginPoint);
        var hints = {};

        if (!DG.Util.isArray(trafficData)) {    // TODO remove
            return [];
        }

        trafficData[1].forEach(function(item) {
            this[item.graph_id] = item.speed_text;
        }, hints);

        return trafficData[0]
            .map(function(item) {
                return {
                    id: item.graph_id,
                    speed: hints[item.graph_id],
                    geometry: DG.Wkt.toGeoJSON(item.geometry[0].object[0])
                };
            })
            .filter(function(item) {
                return item.geometry.type == 'Polygon' ||
                    item.geometry.type == 'MultiPolygon';
            })
            .map(function(item) {
                var geoJson = item.geometry;

                if (geoJson.type == 'Polygon') {
                    geoJson.coordinates = polygonLngLatToPoints(geoJson.coordinates);
                } else if (geoJson.type == 'MultiPolygon') {
                    geoJson.coordinates = geoJson.coordinates.map(polygonLngLatToPoints);
                }

                return item;
            });
    },

    _polygonLngLatToPoints: function(originPoint, polygon) {
        var map = this._map;

        return polygon.map(function(contour) {
            return contour.map(function(lngLat) {
                return map
                    .project([lngLat[1], lngLat[0]]).round()
                    .subtract(originPoint);
            });
        });
    },

    _prepareMetaURL: function() {
        return DG.Util.template(this._metaUrl, DG.extend({
            x: '{x}',
            y: '{y}',
            z: '{z}',
            s: '{s}'
        }, this.options));
    },

    _updateLayerProject: function() {
        var project = this._map.projectDetector.getProject();
        DG.setOptions(this, project && project.traffic ? {
            projectCode: project.code,
            bounds: project.latLngBounds,
            minZoom: Math.max(project.minZoom, this._layersOptions.minZoom),
            maxZoom: project.maxZoom
        } : {
            maxZoom: 0,
            minZoom: 0
        });
        this._metaLayer.getOrigin().setURL(this._prepareMetaURL());
    },

    _onMapProjectChange: function() {
        this._updateLayerProject();
        this.redraw();
    },

    _layerEventsListeners: {
        mouseover: function(e) { // (Object)
            this._setCursor('pointer');
            if (this._labelHelper && e.meta.speed) {
                this._labelHelper
                    .setPosition(e.latlng)
                    .setContent(e.meta.speed + ' ' + this.t('speed_unit_km_h'))
                    .addTo(this._map);
            }
        },
        mouseout: function() {
            this._setCursor('');
            if (this._labelHelper) {
                this._map.removeLayer(this._labelHelper);
            }
        },
        mousemove: function(e) {
            if (this._labelHelper) {
                this._labelHelper.setPosition(e.latlng);
            }
        }
    },

    _setCursor: function(cursor) { // (String)
        this._map.getContainer().style.cursor = cursor;
    }

});

DG.Traffic.include(DG.Locale);

DG.traffic = function(options) { // (Object)
    return new DG.Traffic(options);
};

DG.Traffic.Dictionary.ru = {
    speed_unit_km_h: '/'
};
DG.Traffic.Dictionary.it = {
    speed_unit_km_h: 'km/h'
};
DG.Traffic.Dictionary.cs = {
    speed_unit_km_h: 'km/h'
};
DG.Traffic.Dictionary.es = {
    speed_unit_km_h: 'km/h'
};
DG.Traffic.Dictionary.en = {
    speed_unit_km_h: 'km/h'
};
DG.Control.Traffic = DG.RoundControl.extend({
    options: {
        position: 'topright',
        iconClass: 'traffic'
    },

    statics: {
        Dictionary: {}
    },

    initialize: function(options) {
        this._trafficClass = 'dg-traffic-control';
        this._controlHideClass = 'dg-control-round_is-hidden_true';

        DG.setOptions(this, options);
        DG.extend(this, {
            _active: false,
            _trafficLayer: null
        }).on(this._controlEvents, this);
    },

    _controlEvents: {
        add: function() {
            this._trafficLayer = DG.traffic();
            this._map.on('zoomend projectchange projectleave', this._updateControlVisibility, this);
        },
        click: function() {
            this._active = !this._active;

            if (this._active) {
                this.setState('active');
                this._showTraffic();
            } else {
                this.setState('');
                this._hideTraffic();
            }
        },
        remove: function() {
            this.off(this._controlEvents, this);
            this._map.off('zoomend projectchange projectleave', this._updateControlVisibility, this);
            if (this._active) {
                this._map.removeLayer(this._trafficLayer);
                this._active = false;
            }
            this._trafficLayer = null;
        }
    },

    _showTraffic: function() { // ()
        this._updateTrafficScore();
        this._map.addLayer(this._trafficLayer);
    },

    _hideTraffic: function() { // ()
        this._handleDom('remove');
        this._map.removeLayer(this._trafficLayer);
    },

    _handleDom: function(method, score) {
        var a = this._link;

        a.innerHTML = score || '';
        DG.DomUtil[method + 'Class'](a, this._trafficClass);
        DG.DomUtil[method + 'Class'](a, this._trafficClass + '_color_' + this._scoreRate);
    },

    _getTrafficColor: function(score) { // (Number) -> String
        var result = 'green';

        if (score > 7) {
            result = 'red';
        } else if (score > 4) {
            result = 'yellow';
        }

        return result;
    },

    _updateControlVisibility: function() {
        var project = this._map.projectDetector.getProject(),
            projectHasTraffic = project && project.traffic,
            method = ((this._map.getZoom() < DG.config.trafficLayerMinZoom) ||
            (!projectHasTraffic)) ? 'addClass' : 'removeClass';

        DG.DomUtil[method](this._container, this._controlHideClass);
        if (this._active && projectHasTraffic) {
            this._updateTrafficScore();
        }
    },

    _updateTrafficScore: function() {
        var self = this;

        this._getTrafficScore().then(function(score) {
            score = parseInt(score, 10); // sometimes webapi returns something like '5,+'

            self._scoreRate = self._getTrafficColor(score);
            self._handleDom('add', score);
        });
    },

    _getTrafficScore: function() { // () -> Promise
        var url = DG.Util.template(
            DG.config.protocol + DG.config.trafficScoreServer,
            {
                s: this._trafficLayer.getSubdomain(),
                projectCode: this._map.projectDetector.getProject().code
            }
        );

        return DG.ajax(url, {type: 'get'});
    },

    _renderTranslation: function() { // ()
        this._link.title = this.t('button_title');
    }
});

DG.control.traffic = function(options) {
    return new DG.Control.Traffic(options);
};

DG.Map.mergeOptions({
    trafficControl: false
});

DG.Map.addInitHook(function() {
    if (this.options.trafficControl) {
        this.trafficControl = DG.control.traffic(this.options.trafficControl);
        this.addControl(this.trafficControl);
    }
});

DG.Control.Traffic.Dictionary.ru = {
	button_title: ''
};

DG.Control.Traffic.Dictionary.it = {
	button_title: 'Colonna'
};

DG.Control.Traffic.Dictionary.cs = {
	button_title: 'Zcpy'
};

DG.Control.Traffic.Dictionary.es = {
	button_title: 'Taco'
};

DG.Control.Traffic.Dictionary.en = {
	button_title: 'Traffic'
};

DG.Ruler = DG.Layer.extend({

    options: {
        editable: true
    },

    includes: [DG.Locale],

    statics: {
        Dictionary: {}
    },

    initialize: function(latlngs, options) { // (Array, Object)
        DG.Util.setOptions(this, options);

        this._layers = {
            back : null,
            middle : null,
            front : null,
            mouse : null
        };
        this._points = [];

        this._layersContainer = DG.featureGroup();
        Object.keys(this._layers).forEach(function(name) {
            this._layersContainer.addLayer(this._layers[name] = DG.featureGroup());
        }, this);

        this._reset();

        if (DG.Browser.mobile) {
            delete this._lineMouseEvents.mouseover;
            delete this._lineMouseEvents.mouseout;
            delete this._lineMouseEvents.mousemove;
        } else {
            delete this._lineMouseEvents.click;
        }

        if (latlngs && latlngs.length) {
            this.setLatLngs(latlngs);
        }
    },

    onAdd: function(map) { // (Map)
        this._map = map.on('langchange', this._updateDistance, this);

        //  Pane for ruler Markers
        if (!this._map.getPane('rulerMarkerPane')) {
            this._map.createPane('rulerMarkerPane');
        }

        //  Main ruler pane (svg objects and runner)
        if (!this._map.getPane('rulerPane')) {
            this._map.createPane('rulerPane');
        }

        this._layersContainer.addTo(this._map);

        if (this._points.length) {
            this._layers.mouse.fire('layeradd');
            this._updateDistance();
        }

        this._layers.mouse.on(this._lineMouseEvents, this);
    },

    onRemove: function(map) { // (Map)
        map
            .off('langchange', this._updateDistance, this)
            .removeLayer(this._layersContainer);

        this._layers.mouse.off(this._lineMouseEvents, this);
        this._reset();
    },

    getTotalDistance: function() { // () -> Number
        return this._calcDistance();
    },

    spliceLatLngs: function(index) { // (Number, Number, args ...) -> Array
        var oldLength = this._points.length,
            mutationStart = index >= 0 ? Math.min(index, oldLength) : oldLength - index,
            removed = Array.prototype.splice.apply(this._points, arguments).map(function(point) {
                this._layers.mouse.removeLayer(point);
                return point.off().getLatLng();
            }, this),
            length = this._points.length;

        if (length) {
            for (var i = mutationStart; i < length; i++) {
                if (!(this._points[i] instanceof DG.Ruler.LayeredMarker)) {
                    this._points[i] = this._createPoint(this._points[i], this.options.iconStyles.large)
                        .on(this._pointEvents, this)
                        .once('add', this._addCloseHandler, this)
                        .addTo(this._layers.mouse, this._layers);
                }
                if (i && !this._points[i - 1]._legs) {
                    this._addLegs(this._points[i - 1]);
                }
                this._points[i].setPointStyle(this.options.iconStyles[i && i < length - 1 ? 'small' : 'large']);
                this._points[i]._pos = i;
            }
            this._removeLegs(this._points[length - 1]);
            if (oldLength > 0 && oldLength < length) {
                this._points[oldLength - 1].collapse();
            }
            if (this._points[mutationStart]) {
                this._updateLegs(this._points[mutationStart]);
            }
            if (mutationStart > 1) {
                this._points[mutationStart - 1].setPointStyle(this.options.iconStyles.small);
            }
            this._updateDistance();
            this._normalizeRulerPoints();
        }
        if (DG.Browser.touch && this._lineMarkerHelper) {
            this._lineMarkerHelper.collapse();
        }
        this._fireChangeEvent();
        return removed;
    },

    addLatLng: function(latlng) { // (LatLng) -> Ruler
        var lastPoint = this._points[this._points.length - 1] || null;
        latlng = DG.latLng(latlng);

        if (lastPoint) {
            latlng = this._normalizeLatLng(latlng, lastPoint.getLatLng());
        }

        this.spliceLatLngs(this._points.length, 0, latlng);
        return this;
    },

    getLatLngs: function() { // () -> Array
        return this._points.map(function(point) {
            return point.getLatLng();
        });
    },

    setLatLngs: function(latlngs) { // (Array) -> Ruler
        var args = latlngs.slice();
        args.unshift(0, this._points.length);
        this.spliceLatLngs.apply(this, args);
        return this;
    },

    _reset: function() { // ()
        DG.extend(this, {
            _lineMarkerHelper: null,
            _morphingNow: false
        });
    },

    _lineMouseEvents: {
        click: function(event) {
            var target = event.layer;
            if (target instanceof DG.Marker && target._pos !== this._points.length - 1) {
                if (this._lineMarkerHelper) {
                    this._lineMarkerHelper.collapse();
                }
                target.setText(this._getFormatedDistance(target));
                this._lineMarkerHelper = target;
            } else if (target instanceof DG.Path && this.options.editable) {
                var latlng = event.latlng,
                    insertPos = target._point._pos + 1;
                this.spliceLatLngs(insertPos, 0, latlng);
            }
        },
        mouseover: function(event) { // (MouseEvent)
            var target = event.layer;

            target._hovered = true;
            if (this._morphingNow) {
                return;
            }
            if (target instanceof DG.Marker && target._pos !== this._points.length - 1) {
                target.setText(this._getFormatedDistance(target));
            } else if (target instanceof DG.Path && !this._lineMarkerHelper) {
                var point = target._point;

                this._lineMarkerHelper = this._addRunningLabel(
                    this._nearestPoint(point._legs.middle, event.latlng),
                    point
                );
            }
        },
        mouseout: function(event) { // (MouseEvent)
            var target = event.layer,
                originalEv = event.originalEvent;

            target._hovered = false;
            if (this._morphingNow || target._pos === this._points.length - 1) {
                return;
            }
            if (target instanceof DG.Marker) {
                // collapse only when we move out from label container (if browser support relatedTarget)
                if (!originalEv.relatedTarget ||
                    (originalEv.relatedTarget !== target.querySelector('container') &&
                    originalEv.relatedTarget.parentNode !== target.querySelector('container'))) {
                    target.collapse();
                }
            } else {
                this._removeRunningLabel();
            }
        },
        mousemove: function(event) { // (MouseEvent)
            if (this._morphingNow || !this._lineMarkerHelper) {
                return;
            }

            var point = event.layer._point,
                latlng = this._nearestPoint(point._legs.middle, event.latlng);

            this._lineMarkerHelper
                    .setLatLng(latlng)
                    .setText(this._getFormatedDistance(point, point.getLatLng().distanceTo(latlng)));
        },
        layeradd: function() { // ()
            Object.keys(this._layers).forEach(function(name) {
                this._layers[name].bringToFront();
            }, this);
        }
    },

    _fireChangeEvent: function() {
        this.fire('changed', {latlngs : this.getLatLngs()});
    },

    _addRunningLabel: function(latlng, previousPoint) { // (LatLng, Ruler.LayeredMarker)
        var point = this._createPoint(latlng).addTo(this._layers.mouse, this._layers);
        var pane = this._map.getPane('rulerPane');
        pane.insertBefore(point._icon, pane.lastElementChild);
        return point.setText(this._getFormatedDistance(previousPoint, previousPoint.getLatLng().distanceTo(latlng)));
    },

    _removeRunningLabel: function() { // ()
        if (this._lineMarkerHelper) {
            this._layers.mouse.removeLayer(this._lineMarkerHelper);
            this._lineMarkerHelper = null;
        }
    },

    _insertPointInLine: function(event) { // (MouseEvent)
        var latlng = this._lineMarkerHelper.getLatLng(),
            insertPos = event.target._point._pos + 1,
            point;

        if (L.Browser.ie) {
            var path = event.originalEvent.target || event.originalEvent.srcElement,
                parent = path.parentNode;
            parent.appendChild(path); // IE click event leaking problem solution: we reappend mousedown event target element
        }

        L.DomEvent.stopPropagation(event.originalEvent);

        this.spliceLatLngs(insertPos, 0, latlng);
        point = this._points[insertPos];
        point.setText(this._getFormatedDistance(point));

        setTimeout(function() {
            if (document.createEvent) {
                var e = document.createEvent('MouseEvents');
                e.initMouseEvent('mouseup', false, false, document.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 1, point._icon);
                document.dispatchEvent(e);

                e = document.createEvent('MouseEvents');
                e.initMouseEvent('mousedown', false, false, document.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 1, point._icon);
                point._icon.dispatchEvent(e);
            } else {
                point._icon.fireEvent('onMouseUp', DG.extend(document.createEventObject(), {
                    button: 1,
                    bubbles: false,
                    cancelable: false
                }));
                point._icon.fireEvent('onMouseDown', DG.extend(document.createEventObject(), {
                    button: 1,
                    bubbles: false,
                    cancelable: false
                }));
            }
        }, 0);

        this._removeRunningLabel();

        this._updateLegs(point);
    },

    // Find the point on given polyline which is closest to given latlng
    _nearestPoint: function(polyline, latlng) { // (Polyline, LatLng) -> LatLng
        var self = this;

        // Convert everything to pixel coordinates
        var point = this._project(latlng);
        var linePoints = polyline.getLatLngs().map(function(latlng) {
            return self._project(latlng);
        });

        // First look for closest polyline segment
        var minDistance;
        var closestSegmentIndex;
        for (var i = 0; i < linePoints.length - 1; i++) {
            var distance = DG.LineUtil.pointToSegmentDistance(
                point,
                linePoints[i],
                linePoints[i + 1]
            );

            if (minDistance === undefined || distance < minDistance) {
                minDistance = distance;
                closestSegmentIndex = i;
            }
        }

        // Then look for closest point on that segment
        var closestPoint = DG.LineUtil.closestPointOnSegment(
            point,
            linePoints[closestSegmentIndex],
            linePoints[closestSegmentIndex + 1]
        );

        // Convert back to LatLng
        return this._unproject(closestPoint);
    },

    _addCloseHandler: function(event) { // (Event)
        event.target
                .on('click', this._deletePoint, this)
                .querySelector('remove-link').style.display = 'inline-block';
    },

    _createPoint: function(latlng, style) { // (LatLng, Object) -> Ruler.LayeredMarker
        var pointStyle = style ? style : this.options.iconStyles.large,
            layers = {};
        Object.keys(pointStyle).forEach(function(layer) {
            layers[layer] = DG.circleMarker(latlng, pointStyle[layer]);
        });

        return DG.Ruler.layeredMarker(latlng, {
            layers : layers,
            draggable : this.options.editable
        });
    },

    // Moves curr LatLng to correct world if necessary so that ruler section
    // between curr and base can be plotted correctly. Returns a new LatLng
    // object.
    _normalizeLatLng: function(curr, base) { // (LatLng, LatLng) -> LatLng
        var diff = (curr.lng < base.lng) ? 360 : -360;

        var newLng = curr.lng;
        while (Math.abs(newLng - base.lng) > 180) {
            newLng += diff;
        }

        return DG.latLng(curr.lat, newLng);
    },

    // Rearranges ruler points between worlds based on point param so that all
    // ruler sections can be plotted correctly.
    _normalizeRulerPoints: function(point) { // (Ruler.LayeredMarker)
        point = point || this._points[0];

        var self = this;
        var position = point._pos;
        var changedPoints = [];
        var i, currPoint, prevPoint, latlng, normalized;

        // Check points to the right
        for (i = position + 1; i < this._points.length; i++) {
            currPoint = this._points[i];
            prevPoint = this._points[i - 1];

            latlng = currPoint.getLatLng();
            normalized = this._normalizeLatLng(latlng, prevPoint.getLatLng());

            if (!normalized.equals(latlng)) {
                currPoint.setLatLng(normalized);
                changedPoints.push(i);
            }
        }

        // Check points to the left
        for (i = position - 1; i >= 0; i--) {
            currPoint = this._points[i];
            prevPoint = this._points[i + 1];

            latlng = currPoint.getLatLng();
            normalized = this._normalizeLatLng(latlng, prevPoint.getLatLng());

            if (!normalized.equals(latlng)) {
                currPoint.setLatLng(normalized);
                changedPoints.push(i);
            }
        }

        // Update legs of all points that changed position
        changedPoints.sort().reduce(function(previous, current) {
            var skipPrevious = previous && previous === current - 1;

            self._updateLegs(self._points[current], skipPrevious);

            return current;
        }, null);
    },

    _pointEvents: {
        drag: function(event) { // (Event)
            var point = event.target;

            this._normalizeRulerPoints(point);

            if (!DG.Browser.touch && point !== this._points[this._points.length - 1]) {
                point.setText(this._getFormatedDistance(point));
            }

            this._updateLegs(point);
            this._updateDistance();
        },
        dragend: function(event) { // (Event)
            var point = event.target;
            this._morphingNow = false;
            if (!point._hovered && point !== this._points[this._points.length - 1]) {
                point.collapse();
            }
            this._fireChangeEvent();
        },
        dragstart: function() { // ()
            if (DG.Browser.touch && this._lineMarkerHelper) {
                this._lineMarkerHelper.collapse();
            }
            this._morphingNow = true;
        }
    },

    _deletePoint: function(event) { // (MouseEvent)
        var originalEvent = event.originalEvent,
            target = originalEvent.target  || originalEvent.srcElement;

        if (target.className !== 'dg-ruler__label-remove-link' &&
            target.className !== 'dg-ruler__remove-link-overlay') {
            return;
        }
        DG.DomEvent.stop(event.originalEvent);
        this.spliceLatLngs(event.target._pos, 1);
    },

    _degToRad: function(deg) {
        return (Math.PI / 180) * deg;
    },

    _radToDeg: function(rad) {
        return (180 / Math.PI) * rad;
    },

    // Map-independent project method
    _project: function(latlng) {
        if (this._map) {
            return this._map.project(latlng);
        }

        return DG.CRS.EPSG3857.latLngToPoint(latlng, 1);
    },

    // Map-independent unproject method
    _unproject: function(point) {
        if (this._map) {
            return this._map.unproject(point);
        }

        return DG.CRS.EPSG3857.pointToLatLng(point, 1);
    },

    // Calculates the size of angle point1-point-point2
    _calcAngle: function(point, point1, point2) { // (LatLng, LatLng, LatLng) -> Number
        point1 = this._normalizeLatLng(point1, point);
        point2 = this._normalizeLatLng(point2, point);

        point = this._project(point);
        point1 = this._project(point1);
        point2 = this._project(point2);

        var x1 = point1.x - point.x;
        var x2 = point2.x - point.x;
        var y1 = point1.y - point.y;
        var y2 = point2.y - point.y;

        var dotProduct = x1 * x2 + y1 * y2;
        var mag1 = Math.sqrt(x1 * x1 + y1 * y1);
        var mag2 = Math.sqrt(x2 * x2 + y2 * y2);

        return Math.acos(dotProduct / (mag1 * mag2));
    },

    // Calculates the midpoint on the great circle between two LatLngs
    _calcMidPoint: function(latlng1, latlng2) { // (LatLng, LatLng) -> LatLng
        var lon1 = this._degToRad(latlng1.lng);
        var lat1 = this._degToRad(latlng1.lat);

        var lon2 = this._degToRad(latlng2.lng);
        var lat2 = this._degToRad(latlng2.lat);

        // Based on formulae from
        // http://williams.best.vwh.net/avform.htm#Intermediate
        var d = Math.acos(Math.sin(lat1) * Math.sin(lat2) +
            Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));

        // Split the arc in half
        var f = 0.5;

        var A = Math.sin((1 - f) * d) / Math.sin(d);
        var B = Math.sin(f * d) / Math.sin(d);

        var x = A * Math.cos(lat1) * Math.cos(lon1) +
            B * Math.cos(lat2) * Math.cos(lon2);

        var y = A * Math.cos(lat1) * Math.sin(lon1) +
            B * Math.cos(lat2) * Math.sin(lon2);

        var z = A * Math.sin(lat1) + B * Math.sin(lat2);

        var lat = Math.atan2(z, Math.sqrt(x * x + y * y));
        var lon = Math.atan2(y, x);

        return DG.latLng(this._radToDeg(lat), this._radToDeg(lon));
    },

    // Adaptive sampling algorithm based on
    // http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf
    _adaptiveSample: function(left, right, depth, middle) { // (LatLng, LatLng, Number[, LatLng]) -> LatLng[]
        if (depth > 9) {
            // Max recursion depth reached
            return [];
        }

        middle = middle || this._calcMidPoint(left, right);

        var leftMiddle = this._calcMidPoint(left, middle);
        var rightMiddle = this._calcMidPoint(middle, right);

        var angle1 = this._calcAngle(leftMiddle, middle, left);
        var angle2 = this._calcAngle(middle, left, right);
        var angle3 = this._calcAngle(rightMiddle, middle, right);

        // left --- leftMiddle --- middle --- rightMiddle --- right
        //            angle1       angle2       angle3

        var minAngle = 3.1;
        if (angle1 > minAngle && angle2 > minAngle && angle3 > minAngle) {
            // This section is straight enough, no intermediate points needed.
            return [];
        } else {
            // Angles are too small. Recursively sample halves of this section.
            var result = [];
            result = result.concat(this._adaptiveSample(left, middle, depth + 1, leftMiddle));
            result.push(middle);
            result = result.concat(this._adaptiveSample(middle, right, depth + 1, rightMiddle));

            return result;
        }
    },

    // Calculates the great circle arc between two LatLngs.
    _calcGreatCircle: function(latlng1, latlng2) { // (LatLng, LatLng) -> LatLng[]
        latlng2 = this._normalizeLatLng(latlng2, latlng1);

        // Special case: points are close to each other (within 1 degree)
        if (latlng1.equals(latlng2, 1)) {
            return [latlng1, latlng2];
        }

        // Special case: the great circle crosses a pole
        if (Math.abs(latlng2.lng - latlng1.lng) == 180) {
            // North or south pole?
            var latitude = (latlng1.lat + latlng2.lat > 0) ? 90 : -90;

            return [
                latlng1,
                DG.latLng(latitude, latlng1.lng),
                DG.latLng(latitude, latlng2.lng),
                latlng2
            ];
        }

        var result = [];

        result.push(latlng1);
        result = result.concat(this._adaptiveSample(latlng1, latlng2, 0));
        result.push(latlng2);

        // Make sure the arc doesn't jump between worlds
        for (var i = 1; i < result.length; i++) {
            result[i] = this._normalizeLatLng(result[i], result[i - 1]);
        }

        return result;
    },

    _addLegs: function(point) {
        var pathStyles = this.options.pathStyles;

        var greatCirclePoints = this._calcGreatCircle(
            point.getLatLng(),
            this._points[point._pos + 1].getLatLng()
        );

        point._legs = {};
        Object.keys(pathStyles).forEach(function(layer) {
            point._legs[layer] = DG.polyline(greatCirclePoints, pathStyles[layer]).addTo(this._layers[layer]);
        }, this);

        point._legs.mouse._point = point.once('remove', this._clearRemovingPointLegs, this);

        if (this.options.editable && !DG.Browser.mobile) {
            point._legs.mouse.on('mousedown', this._insertPointInLine, this);
        }

        if (this._map) {
            this._layers.mouse.addLayer(point._legs.mouse);
        }
    },

    _clearRemovingPointLegs: function(event) { // (Event)
        this._removeLegs(event.target);
    },

    _removeLegs: function(point) { // (Ruler.LayeredMarker)
        if (point._legs) {
            Object.keys(point._legs).forEach(function(layer) {
                this._layers[layer].removeLayer(point._legs[layer]);
            }, this);
            point._legs = null;
        }
    },

    _updateLegs: function(point, skipPrevious) { // (Ruler.LayeredMarker, Boolean)
        var latlng = point.getLatLng(),
            previousPoint = this._points[point._pos - 1],
            nextPoint = this._points[point._pos + 1],
            self = this,
            newPoints;

        if (previousPoint && !skipPrevious) {
            newPoints = self._calcGreatCircle(previousPoint.getLatLng(), latlng);

            Object.keys(previousPoint._legs).forEach(function(layer) {
                previousPoint._legs[layer].setLatLngs(newPoints);
            });
        }

        if (nextPoint) {
            newPoints = self._calcGreatCircle(latlng, nextPoint.getLatLng());

            Object.keys(point._legs).forEach(function(layer) {
                point._legs[layer].setLatLngs(newPoints);
            });
        }
    },

    _calcDistance: function(finishPoint, tail) { // (Ruler.LayeredMarker, Number) -> Number
        var distance = tail ? tail : 0,
            calcTo = finishPoint ? finishPoint._pos : this._points.length - 1;

        for (var i = 0; i < calcTo; i++) {
            distance += this._points[i].getLatLng().distanceTo(this._points[i + 1].getLatLng());
        }

        return distance;
    },

    _getFormatedDistance: function() { // () -> String
        var distance = this._calcDistance.apply(this, arguments),
            units = 'm';

        if (distance > 1000) {
            distance /= 1000;
            units = 'km';
            if (distance > 1000) {
                distance = distance.toFixed();
                distance = distance.slice(0, -3) + ' ' + distance.slice(-3);
            } else {
                distance = distance.toFixed(2).split('.').join(this.t('delimiter'));
            }
        } else {
            distance = Math.round(distance);
        }

        return [distance || 0, ' ', this.t(units)].join('');
    },

    _updateDistance: function() { // ()
        if (this._map && this._points.length) {
            this._points[this._points.length - 1].setText(this._getFormatedDistance());
        }
    }
});

DG.ruler = function(latlngs, options) { // (Array, Object)
    return new DG.Ruler(latlngs, options);
};

DG.Ruler.LayeredMarker = DG.Marker.extend({
    options: {
        draggable: false,
        keyboard: false,
        riseOnHover: true,
        pane: 'rulerMarkerPane',
        iconHTML: [
            '<img class="dg-ruler__label-spacer" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" width="26" height="26" />',
            '<div class="dg-ruler__label-container">',
            '    <div class="dg-ruler__point"></div>',
            '    <span class="dg-ruler__label-distance">0 </span>',
            '    <span class="dg-ruler__label-remove-link"></span>',
            '    <div class="dg-ruler__remove-link-overlay"></div>',
            '</div>'
        ].join('\n')
    },

    statics: {
        domClass : 'dg-ruler__label'
    },

    addTo : function(map, layers) {
        Object.keys(this._layers).forEach(function(name) {
            layers[name].addLayer(this._layers[name]);
        }, this);

        this._viewport = layers;
        return DG.Marker.prototype.addTo.call(this.on('move', this._onMove), map);
    },

    onRemove : function(map) {
        Object.keys(this._layers).forEach(function(name) {
            this._viewport[name].removeLayer(this._layers[name]);
        }, this);
        this.off('move', this._onMove);
        this._viewport = null;
        this._style = null;
        return DG.Marker.prototype.onRemove.call(this, map);
    },

    setText : function(text) {
        if (this._iconCollapsed) {
            this.expand();
        }
        this._iconNodes.label.innerHTML = text;
        return this;
    },

    setPointStyle : function(style) {
        if (this._style !== style) {
            Object.keys(this._style = style).forEach(function(name) {
                this._layers[name].setStyle(style[name]);
            }, this);
        }
        return this;
    },

    expand : function() {
        this._iconCollapsed = false;
        this._iconNodes.container.style.display = 'block';
        this._iconNodes.spacer.style.display = 'none';
        return this;
    },

    collapse : function() {
        this._iconCollapsed = true;
        this._iconNodes.container.style.display = 'none';
        this._iconNodes.spacer.style.display = 'block';
        return this;
    },

    querySelector : function(selector) {
        return this._icon.querySelector('.' + DG.Ruler.LayeredMarker.domClass + '-' + selector);
    },

    _onMove : function(event) {
        var latlng = event.latlng;
        Object.keys(this._layers).forEach(function(name) {
            this._layers[name].setLatLng(latlng);
        }, this);
    },

    _initIcon : function() {
        DG.Marker.prototype._initIcon.call(this);
        this._iconCollapsed = true;
        this._icon.style.width = '';
        this._iconNodes = {
            label : this.querySelector('distance'),
            spacer : this.querySelector('spacer'),
            container : this.querySelector('container')
        };
    },

    // don't change icon zIndex
    _setPos: function(pos) {
        L.DomUtil.setPosition(this._icon, pos);

        if (this._shadow) {
            L.DomUtil.setPosition(this._shadow, pos);
        }
    },

    _afterInit : function() {
        this._layers = this.options.layers || null;
        this.options.icon = DG.divIcon({
            className: DG.Ruler.LayeredMarker.domClass,
            iconSize: [26, 26],
            iconAnchor: [13, 13],
            html: this.options.iconHTML
        });
    }

});

DG.Ruler.LayeredMarker.addInitHook('_afterInit');

DG.Ruler.layeredMarker = function(latlng, options) {
    return new DG.Ruler.LayeredMarker(latlng, options);
};

var rulerRenderer = DG.svg({pane: 'rulerPane'});
var hoverRenderer = DG.svg({pane: 'rulerPane'});

DG.Ruler.mergeOptions({
    pathStyles: {
        back: {
            color: '#fff',
            opacity: 1,
            weight: 12,
            pointerEvents: 'none',
            noClip: true,
            renderer: rulerRenderer,
            smoothFactor: 0
        },
        middle: {
            color: '#0da5d5',
            opacity: 1,
            weight: 4,
            pointerEvents: 'none',
            noClip: true,
            renderer: rulerRenderer,
            smoothFactor: 0
        },
        mouse: {
            color: '#fff',
            opacity: DG.Browser.vml ? 0.1 : 0,
            weight: DG.Browser.touch ? 40 : 20,
            pointerEvents: 'painted',
            noClip: true,
            renderer: hoverRenderer,
            smoothFactor: 0
        }
    },
    iconStyles: {
        large: {
            back: {
                color: '#fff',
                opacity: 1,
                fillColor: '#fff',
                fillOpacity: 1,
                weight: 1,
                radius: 13,
                renderer: rulerRenderer
            },
            middle: {
                color: '#0da5d5',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 1,
                radius: 9,
                renderer: rulerRenderer
            },
            front: {
                color: '#fff',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 4,
                radius: 5,
                renderer: rulerRenderer
            }
        },
        small: {
            back: {
                color: '#fff',
                opacity: 1,
                fillColor: '#fff',
                fillOpacity: 1,
                weight: 1,
                radius: 9,
                renderer: rulerRenderer
            },
            middle: {
                color: '#0da5d5',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 1,
                radius: 5,
                renderer: rulerRenderer
            },
            front: {
                color: '#fff',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 4,
                radius: 2,
                renderer: rulerRenderer
            }
        }
    }
});

DG.Ruler.Dictionary.ru = {
	km : '',
	m : '',
	delimiter : ','
};

DG.Ruler.Dictionary.it = {
	km : 'km',
	m : 'm',
	delimiter : ','
};
DG.Ruler.Dictionary.cs = {
	km: 'km',
	m: 'm',
	delimiter: ','
};
DG.Ruler.Dictionary.es = {
	km : 'km',
	m : 'm',
	delimiter : ','
};
DG.Ruler.Dictionary.en = {
	km : 'km',
	m : 'm',
	delimiter : '.'
};

DG.Control.Ruler = DG.RoundControl.extend({

    options: {
        position: 'topright',
        iconClass: 'ruler'
    },

    statics: {
        Dictionary: {}
    },

    initialize: function(options) {
        DG.setOptions(this, options);
        DG.extend(this, {
            _active: false,
            _drawingHelper: null,
            _geoclickerNeedRestore: false
        }).on(this._controlEvents, this);
    },

    _controlEvents: {
        add: function() {
            this._drawingHelper = DG.ruler([]);
        },
        click: function() {
            this._active = !this._active;

            if (this._active) {
                this.setState('active');
                this._startDrawing();
            } else {
                this.setState('');
                this._finishDrawing();
            }
        },
        remove: function() {
            this.off(this._controlEvents, this);
            if (this._active) {
                this._map.removeLayer(this._drawingHelper);
                this._active = false;
            }
            this._drawingHelper = null;
        }
    },

    _startDrawing: function() { // ()
        this._map
            .addLayer(this._drawingHelper)
            .on('click', this._handleMapClick, this);

        this._map.fire('rulerstart');
    },

    _finishDrawing: function() { // ()
        this._map
            .off('click', this._handleMapClick, this)
            .removeLayer(this._drawingHelper);

        this._drawingHelper.setLatLngs([]);

        this._map.fire('rulerend');
    },

    _handleMapClick: function(event) { // (MouseEvents)
        this._drawingHelper.addLatLng(event.latlng);
    },

    _renderTranslation: function() { // ()
        this._link.title = this.t('button_title');
    }
});

DG.control.ruler = function(options) {
    return new DG.Control.Ruler(options);
};

DG.Map.mergeOptions({
    rulerControl: false
});

DG.Map.addInitHook(function() {
    if (this.options.rulerControl) {
        this.rulerControl = DG.control.ruler(this.options.rulerControl);
        this.addControl(this.rulerControl);
    }
});

DG.Control.Ruler.Dictionary.ru = {
	button_title: ''
};
DG.Control.Ruler.Dictionary.it = {
	button_title : 'Righello'
};
DG.Control.Ruler.Dictionary.cs = {
	button_title: 'Pravtko'
};
DG.Control.Ruler.Dictionary.es = {
	button_title : 'Regla'
};

DG.Control.Ruler.Dictionary.en = {
	button_title : 'Ruler'
};
(function(dust){dust.register("DGAttribution\/copyright",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-attribution__copyright\"><ul class=\"dg-attribution__links\"><li class=\"dg-attribution__link-item\">").x(ctx.get(["osm"], false),ctx,{"block":body_1},{}).w("<a href=\"").f(ctx.get(["copyright_apilink"], false),ctx,"h").w("\" target=\"_blank\" class=\"dg-attribution__link\">").nx(ctx.get(["osm"], false),ctx,{"block":body_2},{}).f(ctx.get(["API_2GIS"], false),ctx,"h").w("</a></li><li class=\"dg-attribution__link-item\"><a href=\"").f(ctx.get(["copyright_license"], false),ctx,"h").w("\" target=\"_blank\" class=\"dg-attribution__link\">").f(ctx.get(["license_agreement"], false),ctx,"h").w("</a></li></ul><a href=\"").f(ctx.get(["copyright_logo"], false),ctx,"h").w("\" target=\"_blank\" class=\"dg-attribution__logo-url\"></a></div>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w(" <a href=\"http://www.openstreetmap.org/copyright\" target=\"_blank\" class=\"dg-attribution__link\">OpenStreetMap contributors</a>, ");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.f(ctx.get(["work_on"], false),ctx,"h").w(" ");}body_2.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/cityarea",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_").f(ctx.get(["type"], false),ctx,"h").w("\">").f(ctx.get(["purpose"], false),ctx,"h").w("</div>").s(ctx.get(["drilldown"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__drilldown\">").f(ctx.get(["drilldown"], false),ctx,"h").w("</div>");}body_1.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmCardAddr",body_0);function body_0(chk,ctx){return chk.w("<address class=\"dg-firm-card__address dg-firm-card__icon\">").f(ctx.get(["address"], false),ctx,"h").s(ctx.get(["comment"], false),ctx,{"block":body_1},{}).w("</address>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<span class=\"dg-firm-card__comment\">&mdash; ").f(ctx.getPath(true, []),ctx,"h").w("</span>");}body_1.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmCardContacts",body_0);function body_0(chk,ctx){return chk.s(ctx.get(["groups"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.s(ctx.get(["contacts"], false),ctx,{"block":body_2},{});}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.h("select",ctx,{"block":body_3},{"key":ctx.get(["type"], false),"type":"string"},"h");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.h("eq",ctx,{"block":body_4},{"value":"phone","type":"string"},"h").h("eq",ctx,{"block":body_6},{"value":"fax","type":"string"},"h").h("eq",ctx,{"block":body_8},{"value":"website","type":"string"},"h").h("eq",ctx,{"block":body_9},{"value":"email","type":"string"},"h");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<div class=\"dg-firm-card__phone dg-firm-card__icon\"><span class=\"dg-firm-card__phone-num\">").f(ctx.get(["text"], false),ctx,"h").s(ctx.get(["comment"], false),ctx,{"block":body_5},{}).w("</span></div>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<span class=\"dg-firm-card__comment\" title=\"").f(ctx.getPath(true, []),ctx,"h").w("\">&mdash;&nbsp;&nbsp;").f(ctx.getPath(true, []),ctx,"h").w("</span>");}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<div class=\"dg-firm-card__phone dg-firm-card__icon\"><span class=\"dg-firm-card__phone-num\">").f(ctx.get(["text"], false),ctx,"h").s(ctx.get(["comment"], false),ctx,{"block":body_7},{}).w("</span></div>");}body_6.__dustBody=!0;function body_7(chk,ctx){return chk.w("<span class=\"dg-firm-card__comment\" title=\"").f(ctx.getPath(true, []),ctx,"h").w("\">&mdash;&nbsp;&nbsp;").f(ctx.getPath(true, []),ctx,"h").w("</span>");}body_7.__dustBody=!0;function body_8(chk,ctx){return chk.w("<div class=\"dg-firm-card__link dg-firm-card__site dg-firm-card__icon\"><a href=\"").f(ctx.get(["url"], false),ctx,"h").w("\" target=\"_blank\" class=\"dg-link_scheme_dark dg-firm-card__sitelink\">").f(ctx.get(["text"], false),ctx,"h").w("</a></div>");}body_8.__dustBody=!0;function body_9(chk,ctx){return chk.w("<div class=\"dg-firm-card__link dg-firm-card__email dg-firm-card__icon\"><a href=\"mailto:").f(ctx.get(["value"], false),ctx,"h").w("\">").f(ctx.get(["value"], false),ctx,"h").w("</a></div>");}body_9.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmCardHeader",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-popup__header-title dg-popup__header-title_for_firmcard\" title=\"").f(ctx.get(["firmName"], false),ctx,"h").w("\">").f(ctx.get(["firmName"], false),ctx,"h").w("</div>").x(ctx.get(["links"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<div class=\"dg-popup__header-links\">").s(ctx.get(["links"], false),ctx,{"block":body_2},{}).w("</div>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.h("eq",ctx,{"else":body_3,"block":body_6},{"key":body_7,"value":"flamp_stars","type":"string"},"h");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<a class=\"dg-popup__header-link dg-popup__link dg-popup__link_type_").f(ctx.get(["name"], false),ctx,"h").w("\"").x(ctx.get(["href"], false),ctx,{"else":body_4,"block":body_5},{}).w(">").f(ctx.get(["label"], false),ctx,"h").w("</a>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("href=\"javascript:void(0)\"");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("href=").f(ctx.get(["href"], false),ctx,"h").w(" target=\"_blank\"");}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<div class=\"dg-popup__rating\"><div class=\"dg-popup__rating-stars\" style=\"width: ").f(ctx.get(["width"], false),ctx,"h").w("%\"></div></div>");}body_6.__dustBody=!0;function body_7(chk,ctx){return chk.f(ctx.get(["name"], false),ctx,"h");}body_7.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmCardRubric",body_0);function body_0(chk,ctx){return chk.s(ctx.get(["rubrics"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<section class=\"dg-firm-card__rubrics\">").x(ctx.get(["primary"], false),ctx,{"block":body_2},{}).x(ctx.get(["additional"], false),ctx,{"block":body_4},{}).w("</section>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<ul class=\"dg-firm-card__rubrics-list dg-firm-card__rubrics-list_type_primary\">").s(ctx.get(["primary"], false),ctx,{"block":body_3},{}).w("</ul>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<li class=\"dg-firm-card__rubrics-list-item\">").f(ctx.get(["name"], false),ctx,"h").w("</li>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<ul class=\"dg-firm-card__rubrics-list dg-firm-card__rubrics-list_type_additional\">").s(ctx.get(["additional"], false),ctx,{"block":body_5},{}).w("</ul>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<li class=\"dg-firm-card__rubrics-list-item\">").f(ctx.get(["name"], false),ctx,"h").w("</li>");}body_5.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmCardSchedule",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-firm-card__schedule dg-schedule dg-schedule_open_").x(ctx.getPath(false, ["forecast","open"]),ctx,{"else":body_1,"block":body_2},{}).w(" dg-schedule_works-everyday_").x(ctx.getPath(false, ["schedule","everyday"]),ctx,{"else":body_3,"block":body_4},{}).w("\">").x(ctx.get(["schedule"], false),ctx,{"block":body_5},{}).w("</div>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("false");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("true");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("false");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("true");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.x(ctx.getPath(false, ["forecast","today"]),ctx,{"block":body_6},{}).s(ctx.getPath(false, ["forecast","now"]),ctx,{"block":body_10},{}).nx(ctx.getPath(false, ["schedule","everyday"]),ctx,{"block":body_12},{});}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<div class=\"dg-schedule__today\"><div class=\"dg-schedule__today-inner\">").f(ctx.getPath(false, ["forecast","today","text"]),ctx,"h").w("&nbsp;").x(ctx.getPath(false, ["forecast","today","from"]),ctx,{"block":body_7},{}).x(ctx.getPath(false, ["schedule","lunch"]),ctx,{"block":body_8},{}).w("</div></div>");}body_6.__dustBody=!0;function body_7(chk,ctx){return chk.f(ctx.getPath(false, ["forecast","today","from"]),ctx,"h").w("&ndash;").f(ctx.getPath(false, ["forecast","today","to"]),ctx,"h");}body_7.__dustBody=!0;function body_8(chk,ctx){return chk.w(",&nbsp;").f(ctx.getPath(false, ["forecast","today","lunchStr"]),ctx,"h").w("&nbsp;").s(ctx.getPath(false, ["schedule","lunch"]),ctx,{"block":body_9},{});}body_8.__dustBody=!0;function body_9(chk,ctx){return chk.f(ctx.get(["from"], false),ctx,"h").w("&ndash;").f(ctx.get(["to"], false),ctx,"h");}body_9.__dustBody=!0;function body_10(chk,ctx){return chk.w("<div class=\"dg-schedule__now\"><span class=\"dg-schedule__now-text\">").f(ctx.getPath(true, []),ctx,"h").s(ctx.getPath(false, ["schedule","comment"]),ctx,{"block":body_11},{}).w("</span></div>");}body_10.__dustBody=!0;function body_11(chk,ctx){return chk.w(", ").f(ctx.getPath(true, []),ctx,"h");}body_11.__dustBody=!0;function body_12(chk,ctx){return chk.x(ctx.getPath(false, ["schedule","week"]),ctx,{"block":body_13},{});}body_12.__dustBody=!0;function body_13(chk,ctx){return chk.x(ctx.getPath(false, ["schedule","week","evently"]),ctx,{"block":body_14},{}).x(ctx.getPath(false, ["schedule","week","table"]),ctx,{"block":body_22},{});}body_13.__dustBody=!0;function body_14(chk,ctx){return chk.w("<div class=\"dg-schedule__table\">").s(ctx.getPath(false, ["schedule","week","evently"]),ctx,{"block":body_15},{}).w("</div>");}body_14.__dustBody=!0;function body_15(chk,ctx){return chk.w("<div class=\"dg-schedule__string\">").x(ctx.get(["alltime"], false),ctx,{"block":body_16},{}).x(ctx.get(["everyday"], false),ctx,{"else":body_17,"block":body_18},{}).x(ctx.get(["holiday"], false),ctx,{"else":body_19,"block":body_21},{}).w("</div>");}body_15.__dustBody=!0;function body_16(chk,ctx){return chk.f(ctx.get(["alltimeStr"], false),ctx,"h");}body_16.__dustBody=!0;function body_17(chk,ctx){return chk.f(ctx.get(["dayList"], false),ctx,"h");}body_17.__dustBody=!0;function body_18(chk,ctx){return chk.f(ctx.getPath(false, ["forecast","today","text"]),ctx,"h");}body_18.__dustBody=!0;function body_19(chk,ctx){return chk.w("<span class=\"schedule__string-time\">&nbsp;").f(ctx.get(["from"], false),ctx,"h").w("&ndash;").f(ctx.get(["to"], false),ctx,"h").w("</span>").s(ctx.get(["lunch"], false),ctx,{"block":body_20},{});}body_19.__dustBody=!0;function body_20(chk,ctx){return chk.w("<p>").f(ctx.get(["lunchStr"], false),ctx,"h").w("&mdash;<span class=\"schedule__string-time\">").f(ctx.get(["from"], false),ctx,"h").w("&ndash;").f(ctx.get(["to"], false),ctx,"h").w("</span></p>");}body_20.__dustBody=!0;function body_21(chk,ctx){return chk.w("&nbsp;&mdash;<span class=\"schedule__string-time\">&nbsp;").f(ctx.get(["holidayStr"], false),ctx,"h").w("</span>");}body_21.__dustBody=!0;function body_22(chk,ctx){return chk.w("<div><div class=\"dg-schedule__table\"><div class=\"dg-schedule__tc dg-schedule__tc_pre\"><div class=\"dg-schedule__day-name\">&nbsp;</div><div class=\"dg-schedule__table-clock dg-schedule__td\"></div>").x(ctx.getPath(false, ["schedule","week","hasLunch"]),ctx,{"block":body_23},{}).w("</div>").s(ctx.getPath(false, ["schedule","week","table"]),ctx,{"block":body_24},{}).w("</div>  </div>");}body_22.__dustBody=!0;function body_23(chk,ctx){return chk.w("<div class=\"dg-schedule__table-lunch dg-schedule__td\"></div>");}body_23.__dustBody=!0;function body_24(chk,ctx){return chk.h("if",ctx,{"block":body_25},{"cond":body_26},"h").w("<div class=\"dg-schedule__tc").x(ctx.get(["active"], false),ctx,{"block":body_27},{}).w("\"><div class=\"dg-schedule__day-name\">").f(ctx.get(["key"], false),ctx,"h").w("</div><div class=\"dg-schedule__td\">").x(ctx.get(["from"], false),ctx,{"else":body_28,"block":body_29},{}).w("</div>").s(ctx.get(["lunch"], false),ctx,{"block":body_30},{}).w("</div> ").h("if",ctx,{"block":body_33},{"cond":body_34},"h");}body_24.__dustBody=!0;function body_25(chk,ctx){return chk.w("<span class=\"dg-schedule__table-cell-group\">");}body_25.__dustBody=!0;function body_26(chk,ctx){return chk.w("(").f(ctx.get(["$idx"], false),ctx,"h").w(" == ").f(ctx.get(["$len"], false),ctx,"h").w(" - 2)");}body_26.__dustBody=!0;function body_27(chk,ctx){return chk.w(" dg-schedule__tc_active_true");}body_27.__dustBody=!0;function body_28(chk,ctx){return chk.w("&ndash;");}body_28.__dustBody=!0;function body_29(chk,ctx){return chk.f(ctx.get(["from"], false),ctx,"h").w(" ").f(ctx.get(["to"], false),ctx,"h");}body_29.__dustBody=!0;function body_30(chk,ctx){return chk.w("<div class=\"dg-schedule__td\">").x(ctx.get(["from"], false),ctx,{"else":body_31,"block":body_32},{}).w("</div>");}body_30.__dustBody=!0;function body_31(chk,ctx){return chk.w("&ndash;");}body_31.__dustBody=!0;function body_32(chk,ctx){return chk.f(ctx.get(["from"], false),ctx,"h").w(" ").f(ctx.get(["to"], false),ctx,"h");}body_32.__dustBody=!0;function body_33(chk,ctx){return chk.w("</span>");}body_33.__dustBody=!0;function body_34(chk,ctx){return chk.w("(").f(ctx.get(["$idx"], false),ctx,"h").w(" == ").f(ctx.get(["$len"], false),ctx,"h").w(")");}body_34.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmlistItem",body_0);function body_0(chk,ctx){return chk.w("<a id=\"").f(ctx.getPath(false, ["firm","id"]),ctx,"h").w("\" class=\"dg-popup__link\" href=\"#\">").f(ctx.getPath(false, ["firm","name"]),ctx,"h").w("</a>");}body_0.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/frimCardPayments",body_0);function body_0(chk,ctx){return chk.x(ctx.get(["payments"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<section class=\"dg-firm-card__aa\"><ul class=\"dg-firm-card__aa-list\">").s(ctx.get(["payments"], false),ctx,{"block":body_2},{}).w("</ul></section>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<li class=\"dg-firm-card__aa-list-item\">").f(ctx.getPath(true, []),ctx,"h").w("</li>");}body_2.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/house",body_0);function body_0(chk,ctx){return chk.s(ctx.get(["address"], false),ctx,{"block":body_1},{}).s(ctx.get(["purpose"], false),ctx,{"block":body_4},{}).s(ctx.get(["attractions"], false),ctx,{"block":body_5},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<address class=\"dg-map-geoclicker__address\">").s(ctx.getPath(false, ["address","header"]),ctx,{"block":body_2},{}).s(ctx.getPath(false, ["address","drilldown"]),ctx,{"block":body_3},{}).w("</address>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__address-header\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__address-drilldown\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__purpose\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_sight\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_5.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/loader",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-preloader dg-preloader_scheme_regular dg-preloader_animation_").x(ctx.get(["anim"], false),ctx,{"else":body_1,"block":body_2},{}).x(ctx.get(["small"], false),ctx,{"block":body_3},{}).w("\"></div>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("false");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("true");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w(" dg-preloader_size_small");}body_3.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/popupFooter",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-popup__footer-title\"><a class=\"dg-popup__show-less-house-link\" href=\"javascript:void(0)\">").f(ctx.get(["hideFirmsText"], false),ctx,"h").w("</a></div>");}body_0.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/popupFooterBtns",body_0);function body_0(chk,ctx){return chk.x(ctx.get(["btns"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<footer class=\"dg-popup__footer-buttons\">").s(ctx.get(["btns"], false),ctx,{"block":body_2},{}).w("</footer>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<div class=\"dg-popup__footer-button-wrapper\"><a class=\"dg-popup__button_name_").f(ctx.get(["name"], false),ctx,"h").w(" dg-popup__footer-button").x(ctx.get(["icon"], false),ctx,{"block":body_3},{}).w("\"").x(ctx.get(["href"], false),ctx,{"else":body_4,"block":body_5},{}).w(">").f(ctx.get(["label"], false),ctx,"h").w("</a></div>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w(" dg-popup__footer-icon-button");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("href=\"javascript:void(0)\"");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("href=").f(ctx.get(["href"], false),ctx,"h").w(" target=\"_blank\"");}body_5.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/popupHeader",body_0);function body_0(chk,ctx){return chk.s(ctx.get(["title"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<div class=\"dg-popup__header-title\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_1.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/sight",body_0);function body_0(chk,ctx){return chk.s(ctx.get(["purpose"], false),ctx,{"block":body_1},{}).s(ctx.get(["address"], false),ctx,{"block":body_2},{}).s(ctx.get(["description"], false),ctx,{"block":body_5},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_sight\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<address class=\"dg-map-geoclicker__address\">").s(ctx.getPath(false, ["address","header"]),ctx,{"block":body_3},{}).s(ctx.getPath(false, ["address","drilldown"]),ctx,{"block":body_4},{}).w("</address>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__address-header\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__address-drilldown\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__sight-description\">").f(ctx.getPath(true, []),ctx,"h").w("</div>").s(ctx.get(["showMoreText"], false),ctx,{"block":body_6},{});}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<a class=\"dg-map-geoclicker__show-more-sights-link\" href=\"javascript:void(0)\">").f(ctx.getPath(true, []),ctx,"h").w("</a>");}body_6.__dustBody=!0;return body_0}(dust));DG.fallbackProjectsList = JSON.parse('[{"name":"Cyprus","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"road_network":true},"domain":"com.cy","bounds":"POLYGON((32.646616 34.47507,32.357465 34.559162,32.137711 34.848336,32.109708 35.28792,32.401464 35.311411,32.865147 35.531039,33.443449 35.516132,34.753746 35.822229,34.748536 35.609787,34.334347 35.229161,34.221031 34.869272,33.100897 34.396654,32.646616 34.47507))","zoom_level":{"min":9,"max":19},"code":"cyprus","country_code":"cy","id":"173","type":"region","time_zone":{"name":"Asia/Nicosia","offset":180}},{"name":"Dubai. Sharjah. Ajman","flags":{"metro":true,"2gis_reviews":false,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"ae","bounds":"POLYGON((55.680597 24.772487,54.879687 24.763288,54.86679 25.507556,55.672568 25.51707,55.680597 24.772487))","zoom_level":{"min":9,"max":18},"code":"dubai","country_code":"ae","id":"99","type":"region","time_zone":{"name":"Asia/Dubai","offset":240}},{"name":"Praha","flags":{"metro":true,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":true},"domain":"cz","bounds":"POLYGON((14.219495 49.934897,14.215528 50.17879,14.713797 50.181086,14.715245 49.937173,14.219495 49.934897))","zoom_level":{"min":10,"max":18},"code":"praha","country_code":"cz","id":"92","type":"region","time_zone":{"name":"Europe/Prague","offset":120}},{"name":"Santiago","flags":{"metro":true,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":true},"domain":"cl","bounds":"POLYGON((-70.483526 -33.665691,-70.857156 -33.660641,-70.849333 -33.293335,-70.477276 -33.298315,-70.483526 -33.665691))","zoom_level":{"min":9,"max":19},"code":"santiago","country_code":"cl","id":"101","type":"region","time_zone":{"name":"America/Santiago","offset":-240}},{"name":"Venezia e Padova","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":false},"domain":"it","bounds":"POLYGON((11.381405 45.733677,12.61199 45.701369,12.572035 45.071337,11.355023 45.102946,11.381405 45.733677))","zoom_level":{"min":9,"max":18},"code":"padova","country_code":"it","id":"66","type":"region","time_zone":{"name":"Europe/Rome","offset":120}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((91.144335 53.893079,91.817626 53.901599,91.826689 53.577496,91.158554 53.569076,91.144335 53.893079))","zoom_level":{"min":9,"max":18},"code":"abakan","country_code":"ru","id":"69","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"","flags":{"metro":true,"2gis_reviews":false,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"kz","bounds":"POLYGON((76.72599 43.469093,77.1084 43.462692,77.096182 43.108051,76.715991 43.114387,76.72599 43.469093))","zoom_level":{"min":9,"max":18},"code":"almaty","country_code":"kz","id":"67","type":"region","time_zone":{"name":"Asia/Almaty","offset":360}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((52.206024 54.949956,52.478673 54.946945,52.473188 54.796869,52.20155 54.799862,52.206024 54.949956))","zoom_level":{"min":9,"max":18},"code":"almetevsk","country_code":"ru","id":"108","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((40.8594 44.729852,40.876282 45.249444,41.322578 45.241236,41.301688 44.721791,40.8594 44.729852))","zoom_level":{"min":9,"max":18},"code":"armawir","country_code":"ru","id":"106","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.467082 64.829966,41.321175 64.812571,41.276671 64.284305,39.458118 64.301293,39.467082 64.829966))","zoom_level":{"min":9,"max":18},"code":"arkhangelsk","country_code":"ru","id":"49","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":true},"domain":"kz","bounds":"POLYGON((71.18796 51.371885,71.882791 51.35684,71.856572 50.934375,71.168047 50.949196,71.18796 51.371885))","zoom_level":{"min":9,"max":18},"code":"astana","country_code":"kz","id":"68","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((47.863046 46.503348,48.172299 46.511418,48.185812 46.249257,47.878034 46.241258,47.863046 46.503348))","zoom_level":{"min":9,"max":18},"code":"astrakhan","country_code":"ru","id":"8","type":"region","time_zone":{"name":"Europe/Astrakhan","offset":240}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((84.087935 53.472209,84.065362 53.158598,83.445791 53.172941,83.463815 53.486716,84.087935 53.472209))","zoom_level":{"min":9,"max":18},"code":"barnaul","country_code":"ru","id":"4","type":"region","time_zone":{"name":"Asia/Barnaul","offset":420}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((36.419278 50.695,36.719872 50.701271,36.729779 50.495879,36.430487 50.489654,36.419278 50.695))","zoom_level":{"min":9,"max":18},"code":"belgorod","country_code":"ru","id":"46","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((85.467428 52.646705,85.492485 51.91455,84.608614 51.899905,84.568894 52.63167,85.467428 52.646705))","zoom_level":{"min":9,"max":18},"code":"biysk","country_code":"ru","id":"20","type":"region","time_zone":{"name":"Asia/Barnaul","offset":420}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"kg","bounds":"POLYGON((74.4117 43.079799,74.961984 43.081306,74.962352 42.560778,74.416615 42.559297,74.4117 43.079799))","zoom_level":{"min":9,"max":18},"code":"bishkek","country_code":"kg","id":"112","type":"region","time_zone":{"name":"Asia/Bishkek","offset":360}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((127.345035 50.596534,127.754667 50.601634,127.764413 50.228495,127.357983 50.223461,127.345035 50.596534))","zoom_level":{"min":9,"max":18},"code":"blagoveshensk","country_code":"ru","id":"52","type":"region","time_zone":{"name":"Asia/Yakutsk","offset":540}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((101.089619 56.502645,102.059766 56.482523,102.016041 55.92995,101.059727 55.949659,101.089619 56.502645))","zoom_level":{"min":9,"max":18},"code":"bratsk","country_code":"ru","id":"51","type":"region","time_zone":{"name":"Asia/Irkutsk","offset":480}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((34.115433 53.143963,34.122949 53.431556,34.604425 53.426058,34.593689 53.138522,34.115433 53.143963))","zoom_level":{"min":9,"max":18},"code":"bryansk","country_code":"ru","id":"62","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":" ","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((31.131394 58.678746,31.505415 58.683631,31.514694 58.465262,31.142992 58.460419,31.131394 58.678746))","zoom_level":{"min":9,"max":18},"code":"v_novgorod","country_code":"ru","id":"77","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((132.300602 42.803446,131.558591 42.822446,131.592018 43.61615,132.343685 43.596619,132.300602 42.803446))","zoom_level":{"min":9,"max":18},"code":"vladivostok","country_code":"ru","id":"25","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((40.178443 56.46782,40.695168 56.461839,40.676114 56.02824,40.165193 56.034124,40.178443 56.46782))","zoom_level":{"min":9,"max":18},"code":"vladimir","country_code":"ru","id":"59","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((43.982875 48.314123,43.970587 48.922097,44.93003 48.92667,44.930866 48.3186,43.982875 48.314123))","zoom_level":{"min":9,"max":18},"code":"volgograd","country_code":"ru","id":"33","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.611585 59.337288,40.07794 59.334267,40.072156 59.150523,38.986034 59.105979,38.426083 59.179531,38.063961 59.066342,37.680388 59.063007,37.674991 59.20788,37.98548 59.312602,38.873687 59.226731,39.610251 59.262879,39.611585 59.337288))","zoom_level":{"min":9,"max":18},"code":"vologda","country_code":"ru","id":"78","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.607251 51.475591,38.991243 51.477162,38.991159 51.910994,39.613084 51.909398,39.607251 51.475591))","zoom_level":{"min":9,"max":18},"code":"voronezh","country_code":"ru","id":"31","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"-","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((86.458369 51.25739,85.514346 51.249215,85.48461 52.148049,87.909246 52.154279,87.891399 51.255249,86.458369 51.25739))","zoom_level":{"min":9,"max":18},"code":"gornoaltaysk","country_code":"ru","id":"27","type":"region","time_zone":{"name":"Asia/Barnaul","offset":420}},{"name":"","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"ua","bounds":"POLYGON((34.749305 48.687967,35.296754 48.67835,35.281569 48.341385,34.737733 48.35089,34.749305 48.687967))","zoom_level":{"min":9,"max":18},"code":"dnepropetrovsk","country_code":"ua","id":"105","type":"region","time_zone":{"name":"Europe/Kiev","offset":180}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":true},"domain":"ua","bounds":"POLYGON((37.510512 48.182783,38.240528 48.189925,38.246188 47.802815,37.521609 47.795769,37.510512 48.182783))","zoom_level":{"min":9,"max":18},"code":"donetsk","country_code":"ua","id":"79","type":"region","time_zone":{"name":"Europe/Kiev","offset":180}},{"name":"","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((59.714357 57.010251,60.919831 57.036097,60.943224 56.611802,59.751258 56.586369,59.714357 57.010251))","zoom_level":{"min":9,"max":18},"code":"ekaterinburg","country_code":"ru","id":"9","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((40.806886 57.089556,41.189405 57.083456,41.177466 56.879061,40.796997 56.885115,40.806886 57.089556))","zoom_level":{"min":9,"max":18},"code":"ivanovo","country_code":"ru","id":"65","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":false,"road_network":true},"domain":"ru","bounds":"POLYGON((52.95169 57.057889,53.495625 57.04823,53.470393 56.667543,52.931947 56.677063,52.95169 57.057889))","zoom_level":{"min":9,"max":18},"code":"izhevsk","country_code":"ru","id":"41","type":"region","time_zone":{"name":"Europe/Samara","offset":240}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((103.618853 52.641505,104.97019 52.64955,104.970807 51.718225,103.647397 51.710443,103.618853 52.641505))","zoom_level":{"min":9,"max":18},"code":"irkutsk","country_code":"ru","id":"11","type":"region","time_zone":{"name":"Asia/Irkutsk","offset":480}},{"name":"-","flags":{"metro":false,"2gis_reviews":false,"public_transport":false,"flamp":false,"road_network":true},"domain":"kg","bounds":"POLYGON((76.019309 42.160297,76.018908 42.513716,76.300436 42.70127,77.394521 42.913214,78.474487 42.855105,78.677523 42.274735,77.488299 41.915294,76.583726 41.973638,76.019309 42.160297))","zoom_level":{"min":9,"max":18},"code":"issyk_kul","country_code":"kg","id":"195","type":"region","time_zone":{"name":"Asia/Bishkek","offset":360}},{"name":"-","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((47.588902 56.761482,48.153297 56.748478,48.133249 56.507529,47.572432 56.520416,47.588902 56.761482))","zoom_level":{"min":9,"max":18},"code":"yoshkarola","country_code":"ru","id":"70","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"  ","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((42.596866 44.289522,43.518711 44.305202,43.530679 43.823418,42.616267 43.807998,42.596866 44.289522))","zoom_level":{"min":9,"max":18},"code":"minvody","country_code":"ru","id":"89","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((48.29118 55.977651,49.519957 55.998533,49.535477 55.587187,48.319555 55.566624,48.29118 55.977651))","zoom_level":{"min":9,"max":18},"code":"kazan","country_code":"ru","id":"21","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((19.839261 55.044274,19.83187 55.297838,21.137338 55.253862,21.134927 54.539492,19.853783 54.534137,19.839261 55.044274))","zoom_level":{"min":9,"max":18},"code":"kaliningrad","country_code":"ru","id":"40","type":"region","time_zone":{"name":"Europe/Kaliningrad","offset":120}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((35.894818 54.755461,36.455305 54.768523,36.482233 54.33388,35.927655 54.321024,35.894818 54.755461))","zoom_level":{"min":9,"max":18},"code":"kaluga","country_code":"ru","id":"61","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"-","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((61.715751 56.571122,62.254705 56.57552,62.260467 56.279794,61.725677 56.275445,61.715751 56.571122))","zoom_level":{"min":9,"max":18},"code":"k_uralskiy","country_code":"ru","id":"109","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":true},"domain":"kz","bounds":"POLYGON((73.394974 50.132623,73.41063 49.658415,72.880917 49.64993,72.860052 50.123995,73.394974 50.132623))","zoom_level":{"min":9,"max":18},"code":"karaganda","country_code":"kz","id":"84","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((86.326511 55.27068,86.327501 55.212118,85.914901 55.209146,85.906046 55.53142,86.322012 55.534428,86.326511 55.27068))","zoom_level":{"min":9,"max":18},"code":"kemerovo","country_code":"ru","id":"5","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((49.036766 58.786454,49.936128 58.797004,49.947791 58.410879,49.058277 58.400486,49.036766 58.786454))","zoom_level":{"min":9,"max":18},"code":"kirov","country_code":"ru","id":"58","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":true,"2gis_reviews":false,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"ua","bounds":"POLYGON((30.210468 50.619492,31.021354 50.636093,31.039177 50.206516,30.235576 50.190165,30.210468 50.619492))","zoom_level":{"min":9,"max":18},"code":"kiev","country_code":"ua","id":"107","type":"region","time_zone":{"name":"Europe/Kiev","offset":180}},{"name":"--","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((136.792391 50.721413,137.258493 50.713313,137.233696 50.189815,136.772704 50.197767,136.792391 50.721413))","zoom_level":{"min":9,"max":18},"code":"komsomolsk","country_code":"ru","id":"94","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((40.721432 57.682077,40.733014 57.924383,41.151865 57.917978,41.137488 57.675732,40.721432 57.682077))","zoom_level":{"min":9,"max":18},"code":"kostroma","country_code":"ru","id":"34","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((38.650083 45.265382,39.378568 45.26529,39.376448 44.943556,38.65204 44.943646,38.650083 45.265382))","zoom_level":{"min":9,"max":18},"code":"krasnodar","country_code":"ru","id":"23","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((92.125881 56.306626,93.59929 56.308263,93.591657 55.813004,92.137966 55.811406,92.132089 56.075066,91.790143 56.047857,91.015607 56.224372,90.301064 56.186943,90.290658 56.334408,90.986978 56.328622,91.482301 56.198958,92.125881 56.306626))","zoom_level":{"min":9,"max":18},"code":"krasnoyarsk","country_code":"ru","id":"7","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((65.163165 55.530326,65.573707 55.522454,65.557277 55.260162,65.13751 55.268215,65.163165 55.530326))","zoom_level":{"min":9,"max":18},"code":"kurgan","country_code":"ru","id":"10","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((35.889369 51.829944,36.419838 51.842787,36.435346 51.569517,35.908055 51.556799,35.889369 51.829944))","zoom_level":{"min":9,"max":18},"code":"kursk","country_code":"ru","id":"73","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"-","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((85.750103 54.768861,86.495701 54.774252,86.502903 54.184679,85.767947 54.179404,85.750103 54.768861))","zoom_level":{"min":9,"max":18},"code":"lenkuz","country_code":"ru","id":"86","type":"region","time_zone":{"name":"Asia/Novokuznetsk","offset":420}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.376422 52.719879,39.82336 52.717618,39.819113 52.490547,39.37448 52.49279,39.376422 52.719879))","zoom_level":{"min":9,"max":18},"code":"lipetsk","country_code":"ru","id":"56","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((59.504226 53.910884,59.464288 53.229865,58.523119 53.245612,58.547823 53.927025,59.504226 53.910884))","zoom_level":{"min":9,"max":18},"code":"magnitogorsk","country_code":"ru","id":"26","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((47.20145 43.164765,47.748162 43.160885,47.727392 42.692228,47.185086 42.703864,47.20145 43.164765))","zoom_level":{"min":9,"max":18},"code":"makhachkala","country_code":"ru","id":"113","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"  ","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((59.545758 55.280232,60.258434 55.263275,60.228055 54.888197,59.522002 54.90492,59.545758 55.280232))","zoom_level":{"min":9,"max":18},"code":"miass","country_code":"ru","id":"87","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((36.751702 56.216166,39.120953 56.236539,39.117281 55.026003,36.819893 55.006528,36.751702 56.216166))","zoom_level":{"min":9,"max":18},"code":"moscow","country_code":"ru","id":"32","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((33.225325 69.064731,33.222252 68.761176,32.705233 68.761065,32.701158 69.064619,33.225325 69.064731))","zoom_level":{"min":9,"max":18},"code":"murmansk","country_code":"ru","id":"96","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":" ","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((51.717261 55.865183,52.62818 55.856503,52.614937 55.536675,51.711425 55.545252,51.717261 55.865183))","zoom_level":{"min":9,"max":18},"code":"nabchelny","country_code":"ru","id":"29","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((132.750811 42.90212,133.241339 42.910709,133.248191 42.668281,132.759571 42.659764,132.750811 42.90212))","zoom_level":{"min":10,"max":18},"code":"nahodka","country_code":"ru","id":"82","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((75.931826 61.190935,77.028582 61.178947,77.007766 60.851181,75.922257 60.863009,75.931826 61.190935))","zoom_level":{"min":9,"max":18},"code":"nizhnevartovsk","country_code":"ru","id":"12","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":" ","flags":{"metro":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((43.297073 56.468016,44.247071 56.477411,44.254811 56.081492,43.937458 56.079169,44.025486 55.810553,43.902612 55.345696,43.771932 55.344281,43.791023 55.501205,43.71237 55.595942,43.848289 55.751737,43.757035 55.891333,43.839433 55.98491,43.811741 56.078023,43.31457 56.072236,43.297073 56.468016))","zoom_level":{"min":9,"max":18},"code":"n_novgorod","country_code":"ru","id":"19","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":" ","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((59.788601 58.091707,60.347887 58.078228,60.317394 57.749299,59.763185 57.762607,59.788601 58.091707))","zoom_level":{"min":9,"max":18},"code":"ntagil","country_code":"ru","id":"45","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((86.517836 53.497554,86.510624 54.121371,87.463657 54.121473,87.456823 53.497654,86.517836 53.497554))","zoom_level":{"min":9,"max":18},"code":"novokuznetsk","country_code":"ru","id":"6","type":"region","time_zone":{"name":"Asia/Novokuznetsk","offset":420}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((36.968059 44.305963,36.936306 45.204638,38.650344 45.222751,38.655728 44.32352,36.968059 44.305963))","zoom_level":{"min":9,"max":18},"code":"novorossiysk","country_code":"ru","id":"74","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((85.088133 54.816411,84.910658 54.751737,85.011185 54.637544,84.810533 54.546933,84.674093 54.541496,84.351643 54.752476,84.256032 54.653791,84.093196 54.728848,84.066363 54.614937,83.763786 54.3856,83.998623 54.175215,83.553128 54.109112,83.48778 53.979297,83.349582 53.933688,83.292679 54.085893,83.049376 53.969325,82.76229 54.012318,82.645574 54.14543,82.661704 54.35505,82.470375 54.420101,81.542805 53.909614,81.613035 54.021479,81.137057 54.109871,80.95166 54.375446,81.069744 54.449125,81.349135 54.442051,81.553585 54.533401,81.533405 54.612019,81.719479 54.657871,81.535705 54.795751,81.569753 54.873304,81.486161 54.938744,81.360969 54.937569,81.472002 55.050177,81.397608 55.101903,81.477305 55.251991,81.330338 55.319242,82.154603 55.51402,81.553507 56.235201,82.774176 56.409006,82.862728 56.535243,83.095518 56.54937,83.285825 56.445179,83.064804 56.230587,83.211845 56.209412,83.12927 56.120556,83.301553 56.095779,83.230086 56.013203,83.403008 55.896203,83.211507 55.729573,83.501531 55.706658,83.597281 55.578084,83.74695 55.537542,83.972523 55.555768,84.000495 55.408305,84.660798 55.479568,84.725026 55.446609,84.652652 55.380482,84.916854 55.324764,84.815445 55.227775,84.927023 55.163725,84.837145 54.997021,85.088133 54.816411))","zoom_level":{"min":9,"max":18},"code":"novosibirsk","country_code":"ru","id":"1","type":"region","time_zone":{"name":"Asia/Novosibirsk","offset":420}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((88.529535 69.242435,86.000942 69.246318,85.986318 69.559455,88.551918 69.555507,88.529535 69.242435))","zoom_level":{"min":9,"max":18},"code":"norilsk","country_code":"ru","id":"76","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((74.30478 63.879187,76.263372 63.875343,76.226155 63.018251,74.325265 63.021954,74.30478 63.879187))","zoom_level":{"min":9,"max":18},"code":"noyabrsk","country_code":"ru","id":"103","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":true},"domain":"ua","bounds":"POLYGON((30.512168 46.64901,30.896079 46.656702,30.911286 46.261025,30.530141 46.253438,30.512168 46.64901))","zoom_level":{"min":9,"max":18},"code":"odessa","country_code":"ua","id":"14","type":"region","time_zone":{"name":"Europe/Kiev","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((72.9275 54.78532,72.844079 55.404999,73.75247 55.41764,73.771665 54.796804,72.9275 54.78532))","zoom_level":{"min":9,"max":18},"code":"omsk","country_code":"ru","id":"2","type":"region","time_zone":{"name":"Asia/Omsk","offset":360}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((54.932518 51.663479,54.920411 51.927322,55.487422 51.935975,55.496231 51.672052,54.932518 51.663479))","zoom_level":{"min":9,"max":18},"code":"orenburg","country_code":"ru","id":"48","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((35.870923 53.103739,36.315298 53.092181,36.295963 52.838995,35.85417 52.850448,35.870923 53.103739))","zoom_level":{"min":9,"max":18},"code":"orel","country_code":"ru","id":"71","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":true},"domain":"kz","bounds":"POLYGON((76.677763 52.439519,77.2347 52.430303,77.213446 52.005015,76.661799 52.014092,76.677763 52.439519))","zoom_level":{"min":9,"max":18},"code":"pavlodar","country_code":"kz","id":"111","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((44.79682 53.065926,44.795477 53.349082,45.35881 53.348717,45.356452 53.065566,44.79682 53.065926))","zoom_level":{"min":9,"max":18},"code":"penza","country_code":"ru","id":"42","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((55.631623 57.685995,55.610475 58.236816,56.038646 58.240755,56.070906 58.590357,56.301913 58.876445,56.176262 59.052952,56.215606 59.220063,56.368563 59.29783,56.363531 59.565159,57.204268 59.566549,57.20242 59.210676,56.878146 59.210772,56.758428 59.023927,56.856102 58.769966,56.697725 58.516546,56.66204 57.69294,55.631623 57.685995))","zoom_level":{"min":9,"max":18},"code":"perm","country_code":"ru","id":"16","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((34.102722 61.959477,34.70885 61.953295,34.694352 61.691472,34.093364 61.697587,34.102722 61.959477))","zoom_level":{"min":9,"max":18},"code":"petrozavodsk","country_code":"ru","id":"80","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"-","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((158.195687 53.346954,159.025519 53.349662,159.02523 52.858368,158.204799 52.855708,158.195687 53.346954))","zoom_level":{"min":9,"max":18},"code":"p_kamchatskiy","country_code":"ru","id":"95","type":"region","time_zone":{"name":"Asia/Kamchatka","offset":720}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((28.168619 57.889106,28.491531 57.885724,28.484999 57.727138,28.1635 57.7305,28.168619 57.889106))","zoom_level":{"min":9,"max":18},"code":"pskov","country_code":"ru","id":"90","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"--","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.358722 47.368152,39.924838 47.364983,39.919436 47.053314,39.356627 47.05645,39.358722 47.368152))","zoom_level":{"min":9,"max":18},"code":"rostov","country_code":"ru","id":"24","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.40589 54.882191,40.082101 54.878236,40.072595 54.486578,39.402002 54.490668,39.40589 54.882191))","zoom_level":{"min":9,"max":18},"code":"ryazan","country_code":"ru","id":"44","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((50.524471 53.044185,49.796735 53.03905,49.777726 53.708125,50.516995 53.713386,50.524471 53.044185))","zoom_level":{"min":9,"max":18},"code":"samara","country_code":"ru","id":"18","type":"region","time_zone":{"name":"Europe/Samara","offset":240}},{"name":"-","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((29.41089 60.259339,30.98445 60.292561,31.031377 59.5092,29.494307 59.477002,29.41089 60.259339))","zoom_level":{"min":9,"max":18},"code":"spb","country_code":"ru","id":"38","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((44.867017 54.301903,45.511721 54.300891,45.507836 53.984632,44.868027 53.985633,44.867017 54.301903))","zoom_level":{"min":9,"max":18},"code":"saransk","country_code":"ru","id":"85","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((46.304971 51.353163,45.730611 51.358153,45.7361 51.699809,46.314773 51.694758,46.304971 51.353163))","zoom_level":{"min":9,"max":18},"code":"saratov","country_code":"ru","id":"43","type":"region","time_zone":{"name":"Europe/Saratov","offset":240}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((31.755002 54.885154,32.265103 54.889311,32.268673 54.692002,31.761048 54.687875,31.755002 54.885154))","zoom_level":{"min":9,"max":18},"code":"smolensk","country_code":"ru","id":"63","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((40.464281 43.36325,38.937514 43.372607,38.93648 44.354812,40.488511 44.345131,40.464281 43.36325))","zoom_level":{"min":9,"max":18},"code":"sochi","country_code":"ru","id":"30","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((41.679025 44.89293,41.658117 45.252393,42.307255 45.269558,42.324115 44.909882,41.679025 44.89293))","zoom_level":{"min":9,"max":18},"code":"stavropol","country_code":"ru","id":"57","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":" ","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((37.748371 51.246862,37.744862 51.375661,37.979312 51.377938,37.982166 51.249129,37.748371 51.246862))","zoom_level":{"min":10,"max":18},"code":"staroskol","country_code":"ru","id":"60","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((55.805672 53.734238,56.123975 53.736987,56.13283 53.305583,55.817744 53.302876,55.805672 53.734238))","zoom_level":{"min":9,"max":18},"code":"sterlitamak","country_code":"ru","id":"54","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((72.38176 61.388553,73.781358 61.408288,73.797164 60.996565,72.41568 60.977161,72.38176 61.388553))","zoom_level":{"min":9,"max":18},"code":"surgut","country_code":"ru","id":"39","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((50.431525 61.921812,51.275081 61.92271,51.271963 61.571227,50.437968 61.570342,50.431525 61.921812))","zoom_level":{"min":9,"max":18},"code":"syktyvkar","country_code":"ru","id":"72","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((41.268899 52.567826,41.283161 52.841816,41.602492 52.835242,41.58624 52.561316,41.268899 52.567826))","zoom_level":{"min":9,"max":18},"code":"tambov","country_code":"ru","id":"81","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((35.531082 56.998794,36.290293 57.017546,36.3143 56.68411,35.561787 56.665594,35.531082 56.998794))","zoom_level":{"min":9,"max":18},"code":"tver","country_code":"ru","id":"47","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((68.027461 58.334051,68.627747 58.337205,68.630591 58.064257,68.03489 58.061137,68.027461 58.334051))","zoom_level":{"min":9,"max":18},"code":"tobolsk","country_code":"ru","id":"97","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((48.961827 53.69702,49.777726 53.708125,49.796735 53.03905,48.992064 53.028186,48.807098 53.101486,48.629384 53.081652,48.633662 52.958002,48.265666 52.950101,48.246726 53.247566,48.982979 53.253459,48.961827 53.69702))","zoom_level":{"min":9,"max":18},"code":"togliatti","country_code":"ru","id":"22","type":"region","time_zone":{"name":"Europe/Samara","offset":240}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((84.768656 56.588195,85.235419 56.595694,85.246532 56.355458,84.782704 56.348026,84.768656 56.588195))","zoom_level":{"min":9,"max":18},"code":"tomsk","country_code":"ru","id":"3","type":"region","time_zone":{"name":"Asia/Tomsk","offset":420}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((38.421585 53.908416,37.429616 53.899539,37.414045 54.309532,38.415847 54.318543,38.421585 53.908416))","zoom_level":{"min":9,"max":18},"code":"tula","country_code":"ru","id":"36","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((66.690851 57.236046,66.609235 56.397678,65.213221 56.430463,65.263355 57.26989,66.690851 57.236046))","zoom_level":{"min":9,"max":18},"code":"tyumen","country_code":"ru","id":"13","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"-","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((107.376889 52.056483,107.990789 52.042492,107.96757 51.691351,107.358424 51.705168,107.376889 52.056483))","zoom_level":{"min":9,"max":18},"code":"ulanude","country_code":"ru","id":"37","type":"region","time_zone":{"name":"Asia/Irkutsk","offset":480}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((48.031111 54.455092,48.869524 54.472913,48.888501 54.122688,48.056193 54.105046,48.031111 54.455092))","zoom_level":{"min":9,"max":18},"code":"ulyanovsk","country_code":"ru","id":"55","type":"region","time_zone":{"name":"Europe/Ulyanovsk","offset":240}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":true},"domain":"kz","bounds":"POLYGON((51.526154 51.284431,51.567598 51.109229,51.255488 51.110327,51.256457 51.285243,51.526154 51.284431))","zoom_level":{"min":9,"max":18},"code":"uralsk","country_code":"kz","id":"162","type":"region","time_zone":{"name":"Asia/Oral","offset":300}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((131.762993 43.708079,131.749241 43.961672,132.129905 43.971877,132.142052 43.718194,131.762993 43.708079))","zoom_level":{"min":9,"max":18},"code":"ussuriysk","country_code":"ru","id":"83","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"-","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":true},"domain":"kz","bounds":"POLYGON((82.444837 49.862906,82.450724 50.059192,82.805717 50.054212,82.798391 49.857959,82.444837 49.862906))","zoom_level":{"min":9,"max":18},"code":"ustkam","country_code":"kz","id":"91","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((55.719915 54.687507,55.71509 54.952485,56.304345 54.957284,56.312416 54.48324,55.729992 54.478524,55.72565 54.618066,55.165043 54.541368,54.408439 54.558827,53.452049 54.41283,53.371336 54.536212,53.565234 54.66441,53.848363 54.584263,55.059533 54.760159,55.719915 54.687507))","zoom_level":{"min":9,"max":18},"code":"ufa","country_code":"ru","id":"17","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((135.259151 48.629372,135.257422 48.288578,134.874409 48.288797,134.873526 48.629594,135.259151 48.629372))","zoom_level":{"min":9,"max":18},"code":"khabarovsk","country_code":"ru","id":"35","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"","flags":{"metro":true,"2gis_reviews":false,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"ua","bounds":"POLYGON((36.031103 50.115121,36.467033 50.125456,36.481687 49.845767,36.048271 49.835534,36.031103 50.115121))","zoom_level":{"min":9,"max":18},"code":"kharkov","country_code":"ua","id":"110","type":"region","time_zone":{"name":"Europe/Kiev","offset":180}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((47.00778 56.342026,47.60576 56.33089,47.58216 55.980845,46.989585 55.991836,47.00778 56.342026))","zoom_level":{"min":9,"max":18},"code":"cheboksary","country_code":"ru","id":"53","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((61.185486 55.312905,61.734408 55.319826,61.74458 54.997301,61.200066 54.990462,61.185486 55.312905))","zoom_level":{"min":9,"max":18},"code":"chelyabinsk","country_code":"ru","id":"15","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((113.113845 52.186114,113.639184 52.175527,113.624543 51.926502,113.102113 51.936995,113.113845 52.186114))","zoom_level":{"min":9,"max":18},"code":"chita","country_code":"ru","id":"64","type":"region","time_zone":{"name":"Asia/Chita","offset":540}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":true},"domain":"kz","bounds":"POLYGON((69.416245 42.43852,69.802137 42.436468,69.799675 42.242484,69.414967 42.244521,69.416245 42.43852))","zoom_level":{"min":9,"max":18},"code":"shymkent","country_code":"kz","id":"161","type":"region","time_zone":{"name":"Asia/Almaty","offset":360}},{"name":"-","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((142.47294 47.515634,142.971757 47.50814,142.937954 46.583209,142.44768 46.590465,142.47294 47.515634))","zoom_level":{"min":9,"max":18},"code":"yuzhnosakhalinsk","country_code":"ru","id":"88","type":"region","time_zone":{"name":"Asia/Sakhalin","offset":660}},{"name":"","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((129.532344 62.180335,129.533901 62.268614,129.994959 62.266076,129.979868 61.800501,129.525802 61.80299,129.532344 62.180335))","zoom_level":{"min":9,"max":18},"code":"yakutsk","country_code":"ru","id":"50","type":"region","time_zone":{"name":"Asia/Yakutsk","offset":540}},{"name":"","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.722892 57.776199,40.012883 57.774213,40.005807 57.519309,39.717841 57.521275,39.722892 57.776199))","zoom_level":{"min":9,"max":18},"code":"yaroslavl","country_code":"ru","id":"28","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}}]');DG.config = {"host":null,"port":3000,"defaultSkin":"dark","defaultLang":"ru","trafficLayerMinZoom":10,"trafficLayerUpdateInterval":300000,"ppnotLink":"http://2gis.{domain}/{projectCode}/center/{center}/zoom/{zoom}/routeTab/rsType/{rsType}/to/{point}{name}","photosLink":"http://2gis.{domain}/photos/{id}","poiLayerMinZoom":11,"detectRetina":false,"webApiKey":"ruregt3044","webApiVersion":"2.0","regionListFields":"items.bounds,items.zoom_level,items.time_zone,items.code,items.flags,items.country_code,items.domain,items.default_pos","firmInfoFields":"items.reviews,items.links,items.external_content","geoAdditionalFields":"items.geometry.selection,items.links,items.adm_div,items.address,items.floors,items.description","geoclickerCatalogApiKey":"ruregt3044","projectLeaveMaxZoom":13,"flampUrl":"http://flamp.ru/r/","flampGoogleAnalytics":"utm_source=api2gis&utm_medium=api&utm_campaign=geoclicker","gaCode":"UA-38243181-2","protocol":"https:","baseUrl":"//maps.api.2gis.ru/2.0","tileServer":"//tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1","retinaTileServer":"//rtile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1","previewTileServer":"//tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1&size=64","previewRetinaTileServer":"//rtile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1&size=64","trafficTileServer":"//traffic{s}.maps.2gis.com/{projectCode}/traffic/{z}/{x}/{y}/speed/{period}/{timestampString}","retinaTrafficTileServer":"//traffic{s}.maps.2gis.com/{projectCode}/traffic/{z}/{x}/{y}/speed/{period}/{timestampString}","trafficMetaServer":"//meta{s}.maps.2gis.com/{projectCode}/meta/{z}/{x}/{y}/graph_speed/{period}/{timestampString}","retinaTrafficMetaServer":"//meta{s}.maps.2gis.com/{projectCode}/meta/{z}/{x}/{y}/graph_speed/{period}/{timestampString}","trafficTimestampServer":"//traffic{s}.maps.2gis.com/{projectCode}/meta/speed/time/","trafficScoreServer":"//traffic{s}.maps.2gis.com/{projectCode}/meta/score/0/","poiMetaServer":"//tile{s}.maps.2gis.com/?x={x}&y={y}&z={z}&v=1&type=poi","retinaPoiMetaServer":"//rtile{s}.maps.2gis.com/?x={x}&y={y}&z={z}&v=1&type=poi","webApiServer":"//catalog.api.2gis.ru","analytics":"//maps.api.2gis.ru/analytics/track-user.png","googleAnalytics":"//www.google-analytics.com/analytics.js","loadProjectListTimeout":5000};_dereq_("../../../dist/css/styles.full.dark.css");


}).call(this,_dereq_('_process'))

},{"../../../dist/css/styles.full.dark.css":1,"../../../vendors/baron":9,"_process":8,"dustjs-helpers":4,"dustjs-linkedin":5,"html5shiv":6,"leaflet":7}],3:[function(_dereq_,module,exports){
'use strict';
// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.

var styleElementsInsertedAtTop = [];

var insertStyleElement = function(styleElement, options) {
    var head = document.head || document.getElementsByTagName('head')[0];
    var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];

    options = options || {};
    options.insertAt = options.insertAt || 'bottom';

    if (options.insertAt === 'top') {
        if (!lastStyleElementInsertedAtTop) {
            head.insertBefore(styleElement, head.firstChild);
        } else if (lastStyleElementInsertedAtTop.nextSibling) {
            head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
        } else {
            head.appendChild(styleElement);
        }
        styleElementsInsertedAtTop.push(styleElement);
    } else if (options.insertAt === 'bottom') {
        head.appendChild(styleElement);
    } else {
        throw new Error('Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.');
    }
};

module.exports = {
    // Create a <link> tag with optional data attributes
    createLink: function(href, attributes) {
        var head = document.head || document.getElementsByTagName('head')[0];
        var link = document.createElement('link');

        link.href = href;
        link.rel = 'stylesheet';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            link.setAttribute('data-' + key, value);
        }

        head.appendChild(link);
    },
    // Create a <style> tag with optional data attributes
    createStyle: function(cssText, attributes, extraOptions) {
        extraOptions = extraOptions || {};

        var style = document.createElement('style');
        style.type = 'text/css';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            style.setAttribute('data-' + key, value);
        }

        if (style.sheet) { // for jsdom and IE9+
            style.innerHTML = cssText;
            style.sheet.cssText = cssText;
            insertStyleElement(style, { insertAt: extraOptions.insertAt });
        } else if (style.styleSheet) { // for IE8 and below
            insertStyleElement(style, { insertAt: extraOptions.insertAt });
            style.styleSheet.cssText = cssText;
        } else { // for Chrome, Firefox, and Safari
            style.appendChild(document.createTextNode(cssText));
            insertStyleElement(style, { insertAt: extraOptions.insertAt });
        }
    }
};

},{}],4:[function(_dereq_,module,exports){
(function(root, factory) {
  if (typeof define === 'function' && define.amd && define.amd.dust === true) {
    define(['dust.core'], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(_dereq_('dustjs-linkedin'));
  } else {
    factory(root.dust);
  }
}(this, function(dust) {

function log(helper, msg, level) {
  level = level || "INFO";
  helper = helper ? '{@' + helper + '}: ' : '';
  dust.log(helper + msg, level);
}

var _deprecatedCache = {};
function _deprecated(target) {
  if(_deprecatedCache[target]) { return; }
  log(target, "Deprecation warning: " + target + " is deprecated and will be removed in a future version of dustjs-helpers", "WARN");
  log(null, "For help and a deprecation timeline, see https://github.com/linkedin/dustjs-helpers/wiki/Deprecated-Features#" + target.replace(/\W+/g, ""), "WARN");
  _deprecatedCache[target] = true;
}

function isSelect(context) {
  return context.stack.tail &&
         context.stack.tail.head &&
         typeof context.stack.tail.head.__select__ !== "undefined";
}

function getSelectState(context) {
  return isSelect(context) && context.get('__select__');
}

/**
 * Adds a special __select__ key behind the head of the context stack. Used to maintain the state
 * of {@select} blocks
 * @param context {Context} add state to this Context
 * @param opts {Object} add these properties to the state (`key` and `type`)
 */
function addSelectState(context, opts) {
  var head = context.stack.head,
      newContext = context.rebase(),
      key;

  if(context.stack && context.stack.tail) {
    newContext.stack = context.stack.tail;
  }

  var state = {
    isPending: false,
    isResolved: false,
    isDeferredComplete: false,
    deferreds: []
  };

  for(key in opts) {
    state[key] = opts[key];
  }

  return newContext
  .push({ "__select__": state })
  .push(head, context.stack.index, context.stack.of);
}

/**
 * After a {@select} or {@math} block is complete, they invoke this function
 */
function resolveSelectDeferreds(state) {
  var x, len;
  state.isDeferredPending = true;
  if(state.deferreds.length) {
    state.isDeferredComplete = true;
    for(x=0, len=state.deferreds.length; x<len; x++) {
      state.deferreds[x]();
    }
  }
  state.isDeferredPending = false;
}

/**
 * Used by {@contextDump}
 */
function jsonFilter(key, value) {
  if (typeof value === "function") {
    return value.toString()
      .replace(/(^\s+|\s+$)/mg, '')
      .replace(/\n/mg, '')
      .replace(/,\s*/mg, ', ')
      .replace(/\)\{/mg, ') {');
  }
  return value;
}

/**
 * Generate a truth test helper
 */
function truthTest(name, test) {
  return function(chunk, context, bodies, params) {
    return filter(chunk, context, bodies, params, name, test);
  };
}

/**
 * This function is invoked by truth test helpers
 */
function filter(chunk, context, bodies, params, helperName, test) {
  var body = bodies.block,
      skip = bodies['else'],
      selectState = getSelectState(context) || {},
      willResolve, key, value, type;

  // Once one truth test in a select passes, short-circuit the rest of the tests
  if (selectState.isResolved && !selectState.isDeferredPending) {
    return chunk;
  }

  // First check for a key on the helper itself, then look for a key on the {@select}
  if (params.hasOwnProperty('key')) {
    key = params.key;
  } else if (selectState.hasOwnProperty('key')) {
    key = selectState.key;
  } else {
    log(helperName, "No key specified", "WARN");
    return chunk;
  }

  type = params.type || selectState.type;

  key = coerce(context.resolve(key), type);
  value = coerce(context.resolve(params.value), type);

  if (test(key, value)) {
    // Once a truth test passes, put the select into "pending" state. Now we can render the body of
    // the truth test (which may contain truth tests) without altering the state of the select.
    if (!selectState.isPending) {
      willResolve = true;
      selectState.isPending = true;
    }
    if (body) {
      chunk = chunk.render(body, context);
    }
    if (willResolve) {
      selectState.isResolved = true;
    }
  } else if (skip) {
    chunk = chunk.render(skip, context);
  }
  return chunk;
}

function coerce(value, type) {
  if (type) {
    type = type.toLowerCase();
  }
  switch (type) {
    case 'number': return +value;
    case 'string': return String(value);
    case 'boolean':
      value = (value === 'false' ? false : value);
      return Boolean(value);
    case 'date': return new Date(value);
  }

  return value;
}

var helpers = {

  // Utility helping to resolve dust references in the given chunk
  // uses native Dust Context#resolve (available since Dust 2.6.2)
  "tap": function(input, chunk, context) {
    // deprecated for removal in 1.8
    _deprecated("tap");
    return context.resolve(input);
  },

  "sep": function(chunk, context, bodies) {
    var body = bodies.block;
    if (context.stack.index === context.stack.of - 1) {
      return chunk;
    }
    if (body) {
      return body(chunk, context);
    } else {
      return chunk;
    }
  },

  "first": function(chunk, context, bodies) {
    if (context.stack.index === 0) {
      return bodies.block(chunk, context);
    }
    return chunk;
  },

  "last": function(chunk, context, bodies) {
    if (context.stack.index === context.stack.of - 1) {
      return bodies.block(chunk, context);
    }
    return chunk;
  },

  /**
   * {@contextDump}
   * @param key {String} set to "full" to the full context stack, otherwise the current context is dumped
   * @param to {String} set to "console" to log to console, otherwise outputs to the chunk
   */
  "contextDump": function(chunk, context, bodies, params) {
    var to = context.resolve(params.to),
        key = context.resolve(params.key),
        target, output;
    switch(key) {
      case 'full':
        target = context.stack;
        break;
      default:
        target = context.stack.head;
    }
    output = JSON.stringify(target, jsonFilter, 2);
    switch(to) {
      case 'console':
        log('contextDump', output);
        break;
      default:
        output = output.replace(/</g, '\\u003c');
        chunk = chunk.write(output);
    }
    return chunk;
  },

  /**
   * {@math}
   * @param key first value
   * @param method {String} operation to perform
   * @param operand second value (not required for operations like `abs`)
   * @param round if truthy, round() the result
   */
  "math": function (chunk, context, bodies, params) {
    var key = params.key,
        method = params.method,
        operand = params.operand,
        round = params.round,
        output, state, x, len;

    if(!params.hasOwnProperty('key') || !params.method) {
      log("math", "`key` or `method` was not provided", "ERROR");
      return chunk;
    }

    key = parseFloat(context.resolve(key));
    operand = parseFloat(context.resolve(operand));

    switch(method) {
      case "mod":
        if(operand === 0) {
          log("math", "Division by 0", "ERROR");
        }
        output = key % operand;
        break;
      case "add":
        output = key + operand;
        break;
      case "subtract":
        output = key - operand;
        break;
      case "multiply":
        output = key * operand;
        break;
      case "divide":
        if(operand === 0) {
          log("math", "Division by 0", "ERROR");
        }
        output = key / operand;
        break;
      case "ceil":
      case "floor":
      case "round":
      case "abs":
        output = Math[method](key);
        break;
      case "toint":
        output = parseInt(key, 10);
        break;
      default:
        log("math", "Method `" + method + "` is not supported", "ERROR");
    }

    if (typeof output !== 'undefined') {
      if (round) {
        output = Math.round(output);
      }
      if (bodies && bodies.block) {
        context = addSelectState(context, { key: output });
        chunk = chunk.render(bodies.block, context);
        resolveSelectDeferreds(getSelectState(context));
      } else {
        chunk = chunk.write(output);
      }
    }

    return chunk;
  },

  /**
   * {@select}
   * Groups a set of truth tests and outputs the first one that passes.
   * Also contains {@any} and {@none} blocks.
   * @param key a value or reference to use as the left-hand side of comparisons
   * @param type coerce all truth test keys without an explicit type to this type
   */
  "select": function(chunk, context, bodies, params) {
    var body = bodies.block,
        state = {};

    if (params.hasOwnProperty('key')) {
      state.key = context.resolve(params.key);
    }
    if (params.hasOwnProperty('type')) {
      state.type = params.type;
    }

    if (body) {
      context = addSelectState(context, state);
      chunk = chunk.render(body, context);
      resolveSelectDeferreds(getSelectState(context));
    } else {
      log("select", "Missing body block", "WARN");
    }
    return chunk;
  },

  /**
   * Truth test helpers
   * @param key a value or reference to use as the left-hand side of comparisons
   * @param value a value or reference to use as the right-hand side of comparisons
   * @param type if specified, `key` and `value` will be forcibly cast to this type
   */
  "eq": truthTest('eq', function(left, right) {
    return left === right;
  }),
  "ne": truthTest('ne', function(left, right) {
    return left !== right;
  }),
  "lt": truthTest('lt', function(left, right) {
    return left < right;
  }),
  "lte": truthTest('lte', function(left, right) {
    return left <= right;
  }),
  "gt": truthTest('gt', function(left, right) {
    return left > right;
  }),
  "gte": truthTest('gte', function(left, right) {
    return left >= right;
  }),

  /**
   * {@any}
   * Outputs as long as at least one truth test inside a {@select} has passed.
   * Must be contained inside a {@select} block.
   * The passing truth test can be before or after the {@any} block.
   */
  "any": function(chunk, context, bodies, params) {
    var selectState = getSelectState(context);

    if(!selectState) {
      log("any", "Must be used inside a {@select} block", "ERROR");
    } else {
      if(selectState.isDeferredComplete) {
        log("any", "Must not be nested inside {@any} or {@none} block", "ERROR");
      } else {
        chunk = chunk.map(function(chunk) {
          selectState.deferreds.push(function() {
            if(selectState.isResolved) {
              chunk = chunk.render(bodies.block, context);
            }
            chunk.end();
          });
        });
      }
    }
    return chunk;
  },

  /**
   * {@none}
   * Outputs if no truth tests inside a {@select} pass.
   * Must be contained inside a {@select} block.
   * The position of the helper does not matter.
   */
  "none": function(chunk, context, bodies, params) {
    var selectState = getSelectState(context);

    if(!selectState) {
      log("none", "Must be used inside a {@select} block", "ERROR");
    } else {
      if(selectState.isDeferredComplete) {
        log("none", "Must not be nested inside {@any} or {@none} block", "ERROR");
      } else {
        chunk = chunk.map(function(chunk) {
          selectState.deferreds.push(function() {
            if(!selectState.isResolved) {
              chunk = chunk.render(bodies.block, context);
            }
            chunk.end();
          });
        });
      }
    }
    return chunk;
  },

  /**
  * {@size}
  * Write the size of the target to the chunk
  * Falsy values and true have size 0
  * Numbers are returned as-is
  * Arrays and Strings have size equal to their length
  * Objects have size equal to the number of keys they contain
  * Dust bodies are evaluated and the length of the string is returned
  * Functions are evaluated and the length of their return value is evaluated
  * @param key find the size of this value or reference
  */
  "size": function(chunk, context, bodies, params) {
    var key = params.key,
        value, k;

    key = context.resolve(params.key);
    if (!key || key === true) {
      value = 0;
    } else if(dust.isArray(key)) {
      value = key.length;
    } else if (!isNaN(parseFloat(key)) && isFinite(key)) {
      value = key;
    } else if (typeof key === "object") {
      value = 0;
      for(k in key){
        if(key.hasOwnProperty(k)){
          value++;
        }
      }
    } else {
      value = (key + '').length;
    }
    return chunk.write(value);
  }

};

for(var key in helpers) {
  dust.helpers[key] = helpers[key];
}

return dust;

}));

},{"dustjs-linkedin":5}],5:[function(_dereq_,module,exports){
(function (process){
(function (root, factory) {
  if (typeof define === 'function' && define.amd && define.amd.dust === true) {
    define('dust.core', [], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.dust = factory();
  }
}(this, function() {
  var dust = {
        "version": "2.7.5"
      },
      NONE = 'NONE', ERROR = 'ERROR', WARN = 'WARN', INFO = 'INFO', DEBUG = 'DEBUG',
      EMPTY_FUNC = function() {};

  dust.config = {
    whitespace: false,
    amd: false,
    cjs: false,
    cache: true
  };

  // Directive aliases to minify code
  dust._aliases = {
    "write": "w",
    "end": "e",
    "map": "m",
    "render": "r",
    "reference": "f",
    "section": "s",
    "exists": "x",
    "notexists": "nx",
    "block": "b",
    "partial": "p",
    "helper": "h"
  };

  (function initLogging() {
    /*global process, console*/
    var loggingLevels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, NONE: 4 },
        consoleLog,
        log;

    if (typeof console !== 'undefined' && console.log) {
      consoleLog = console.log;
      if(typeof consoleLog === 'function') {
        log = function() {
          consoleLog.apply(console, arguments);
        };
      } else {
        log = function() {
          consoleLog(Array.prototype.slice.apply(arguments).join(' '));
        };
      }
    } else {
      log = EMPTY_FUNC;
    }

    /**
     * Filters messages based on `dust.debugLevel`.
     * This default implementation will print to the console if it exists.
     * @param {String|Error} message the message to print/throw
     * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)
     * @public
     */
    dust.log = function(message, type) {
      type = type || INFO;
      if (loggingLevels[type] >= loggingLevels[dust.debugLevel]) {
        log('[DUST:' + type + ']', message);
      }
    };

    dust.debugLevel = NONE;
    if(typeof process !== 'undefined' && process.env && /\bdust\b/.test(process.env.DEBUG)) {
      dust.debugLevel = DEBUG;
    }

  }());

  dust.helpers = {};

  dust.cache = {};

  dust.register = function(name, tmpl) {
    if (!name) {
      return;
    }
    tmpl.templateName = name;
    if (dust.config.cache !== false) {
      dust.cache[name] = tmpl;
    }
  };

  dust.render = function(nameOrTemplate, context, callback) {
    var chunk = new Stub(callback).head;
    try {
      load(nameOrTemplate, chunk, context).end();
    } catch (err) {
      chunk.setError(err);
    }
  };

  dust.stream = function(nameOrTemplate, context) {
    var stream = new Stream(),
        chunk = stream.head;
    dust.nextTick(function() {
      try {
        load(nameOrTemplate, chunk, context).end();
      } catch (err) {
        chunk.setError(err);
      }
    });
    return stream;
  };

  /**
   * Extracts a template function (body_0) from whatever is passed.
   * @param nameOrTemplate {*} Could be:
   *   - the name of a template to load from cache
   *   - a CommonJS-compiled template (a function with a `template` property)
   *   - a template function
   * @param loadFromCache {Boolean} if false, don't look in the cache
   * @return {Function} a template function, if found
   */
  function getTemplate(nameOrTemplate, loadFromCache/*=true*/) {
    if(!nameOrTemplate) {
      return;
    }
    if(typeof nameOrTemplate === 'function' && nameOrTemplate.template) {
      // Sugar away CommonJS module templates
      return nameOrTemplate.template;
    }
    if(dust.isTemplateFn(nameOrTemplate)) {
      // Template functions passed directly
      return nameOrTemplate;
    }
    if(loadFromCache !== false) {
      // Try loading a template with this name from cache
      return dust.cache[nameOrTemplate];
    }
  }

  function load(nameOrTemplate, chunk, context) {
    if(!nameOrTemplate) {
      return chunk.setError(new Error('No template or template name provided to render'));
    }

    var template = getTemplate(nameOrTemplate, dust.config.cache);

    if (template) {
      return template(chunk, Context.wrap(context, template.templateName));
    } else {
      if (dust.onLoad) {
        return chunk.map(function(chunk) {
          // Alias just so it's easier to read that this would always be a name
          var name = nameOrTemplate;
          // Three possible scenarios for a successful callback:
          //   - `require(nameOrTemplate)(dust); cb()`
          //   - `src = readFile('src.dust'); cb(null, src)`
          //   - `compiledTemplate = require(nameOrTemplate)(dust); cb(null, compiledTemplate)`
          function done(err, srcOrTemplate) {
            var template;
            if (err) {
              return chunk.setError(err);
            }
            // Prefer a template that is passed via callback over the cached version.
            template = getTemplate(srcOrTemplate, false) || getTemplate(name, dust.config.cache);
            if (!template) {
              // It's a template string, compile it and register under `name`
              if(dust.compile) {
                template = dust.loadSource(dust.compile(srcOrTemplate, name));
              } else {
                return chunk.setError(new Error('Dust compiler not available'));
              }
            }
            template(chunk, Context.wrap(context, template.templateName)).end();
          }

          if(dust.onLoad.length === 3) {
            dust.onLoad(name, context.options, done);
          } else {
            dust.onLoad(name, done);
          }
        });
      }
      return chunk.setError(new Error('Template Not Found: ' + nameOrTemplate));
    }
  }

  dust.loadSource = function(source) {
    /*jshint evil:true*/
    return eval(source);
  };

  if (Array.isArray) {
    dust.isArray = Array.isArray;
  } else {
    dust.isArray = function(arr) {
      return Object.prototype.toString.call(arr) === '[object Array]';
    };
  }

  dust.nextTick = (function() {
    return function(callback) {
      setTimeout(callback, 0);
    };
  })();

  /**
   * Dust has its own rules for what is "empty"-- which is not the same as falsy.
   * Empty arrays, null, and undefined are empty
   */
  dust.isEmpty = function(value) {
    if (value === 0) {
      return false;
    }
    if (dust.isArray(value) && !value.length) {
      return true;
    }
    return !value;
  };

  dust.isEmptyObject = function(obj) {
    var key;
    if (obj === null) {
      return false;
    }
    if (obj === undefined) {
      return false;
    }
    if (obj.length > 0) {
      return false;
    }
    for (key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return false;
      }
    }
    return true;
  };

  dust.isTemplateFn = function(elem) {
    return typeof elem === 'function' &&
           elem.__dustBody;
  };

  /**
   * Decide somewhat-naively if something is a Thenable.
   * @param elem {*} object to inspect
   * @return {Boolean} is `elem` a Thenable?
   */
  dust.isThenable = function(elem) {
    return elem &&
           typeof elem === 'object' &&
           typeof elem.then === 'function';
  };

  /**
   * Decide very naively if something is a Stream.
   * @param elem {*} object to inspect
   * @return {Boolean} is `elem` a Stream?
   */
  dust.isStreamable = function(elem) {
    return elem &&
           typeof elem.on === 'function' &&
           typeof elem.pipe === 'function';
  };

  // apply the filter chain and return the output string
  dust.filter = function(string, auto, filters, context) {
    var i, len, name, filter;
    if (filters) {
      for (i = 0, len = filters.length; i < len; i++) {
        name = filters[i];
        if (!name.length) {
          continue;
        }
        filter = dust.filters[name];
        if (name === 's') {
          auto = null;
        } else if (typeof filter === 'function') {
          string = filter(string, context);
        } else {
          dust.log('Invalid filter `' + name + '`', WARN);
        }
      }
    }
    // by default always apply the h filter, unless asked to unescape with |s
    if (auto) {
      string = dust.filters[auto](string, context);
    }
    return string;
  };

  dust.filters = {
    h: function(value) { return dust.escapeHtml(value); },
    j: function(value) { return dust.escapeJs(value); },
    u: encodeURI,
    uc: encodeURIComponent,
    js: function(value) { return dust.escapeJSON(value); },
    jp: function(value) {
      if (!JSON) {dust.log('JSON is undefined; could not parse `' + value + '`', WARN);
        return value;
      } else {
        return JSON.parse(value);
      }
    }
  };

  function Context(stack, global, options, blocks, templateName) {
    if(stack !== undefined && !(stack instanceof Stack)) {
      stack = new Stack(stack);
    }
    this.stack = stack;
    this.global = global;
    this.options = options;
    this.blocks = blocks;
    this.templateName = templateName;
    this._isContext = true;
  }

  dust.makeBase = dust.context = function(global, options) {
    return new Context(undefined, global, options);
  };

  dust.isContext = function(obj) {
    return typeof obj === "object" && obj._isContext === true;
  };

  /**
   * Factory function that creates a closure scope around a Thenable-callback.
   * Returns a function that can be passed to a Thenable that will resume a
   * Context lookup once the Thenable resolves with new data, adding that new
   * data to the lookup stack.
   */
  function getWithResolvedData(ctx, cur, down) {
    return function(data) {
      return ctx.push(data)._get(cur, down);
    };
  }

  Context.wrap = function(context, name) {
    if (dust.isContext(context)) {
      return context;
    }
    return new Context(context, {}, {}, null, name);
  };

  /**
   * Public API for getting a value from the context.
   * @method get
   * @param {string|array} path The path to the value. Supported formats are:
   * 'key'
   * 'path.to.key'
   * '.path.to.key'
   * ['path', 'to', 'key']
   * ['key']
   * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the
   * current context (true), or if get should search in parent contexts as well (false).
   * @public
   * @returns {string|object}
   */
  Context.prototype.get = function(path, cur) {
    if (typeof path === 'string') {
      if (path[0] === '.') {
        cur = true;
        path = path.substr(1);
      }
      path = path.split('.');
    }
    return this._get(cur, path);
  };

  /**
   * Get a value from the context
   * @method _get
   * @param {boolean} cur Get only from the current context
   * @param {array} down An array of each step in the path
   * @private
   * @return {string | object}
   */
  Context.prototype._get = function(cur, down) {
    var ctx = this.stack || {},
        i = 1,
        value, first, len, ctxThis, fn;

    first = down[0];
    len = down.length;

    if (cur && len === 0) {
      ctxThis = ctx;
      ctx = ctx.head;
    } else {
      if (!cur) {
        // Search up the stack for the first value
        while (ctx) {
          if (ctx.isObject) {
            ctxThis = ctx.head;
            value = ctx.head[first];
            if (value !== undefined) {
              break;
            }
          }
          ctx = ctx.tail;
        }

        // Try looking in the global context if we haven't found anything yet
        if (value !== undefined) {
          ctx = value;
        } else {
          ctx = this.global && this.global[first];
        }
      } else if (ctx) {
        // if scope is limited by a leading dot, don't search up the tree
        if(ctx.head) {
          ctx = ctx.head[first];
        } else {
          // context's head is empty, value we are searching for is not defined
          ctx = undefined;
        }
      }

      while (ctx && i < len) {
        if (dust.isThenable(ctx)) {
          // Bail early by returning a Thenable for the remainder of the search tree
          return ctx.then(getWithResolvedData(this, cur, down.slice(i)));
        }
        ctxThis = ctx;
        ctx = ctx[down[i]];
        i++;
      }
    }

    if (typeof ctx === 'function') {
      fn = function() {
        try {
          return ctx.apply(ctxThis, arguments);
        } catch (err) {
          dust.log(err, ERROR);
          throw err;
        }
      };
      fn.__dustBody = !!ctx.__dustBody;
      return fn;
    } else {
      if (ctx === undefined) {
        dust.log('Cannot find reference `{' + down.join('.') + '}` in template `' + this.getTemplateName() + '`', INFO);
      }
      return ctx;
    }
  };

  Context.prototype.getPath = function(cur, down) {
    return this._get(cur, down);
  };

  Context.prototype.push = function(head, idx, len) {
    if(head === undefined) {
      dust.log("Not pushing an undefined variable onto the context", INFO);
      return this;
    }
    return this.rebase(new Stack(head, this.stack, idx, len));
  };

  Context.prototype.pop = function() {
    var head = this.current();
    this.stack = this.stack && this.stack.tail;
    return head;
  };

  Context.prototype.rebase = function(head) {
    return new Context(head, this.global, this.options, this.blocks, this.getTemplateName());
  };

  Context.prototype.clone = function() {
    var context = this.rebase();
    context.stack = this.stack;
    return context;
  };

  Context.prototype.current = function() {
    return this.stack && this.stack.head;
  };

  Context.prototype.getBlock = function(key) {
    var blocks, len, fn;

    if (typeof key === 'function') {
      key = key(new Chunk(), this).data.join('');
    }

    blocks = this.blocks;

    if (!blocks) {
      dust.log('No blocks for context `' + key + '` in template `' + this.getTemplateName() + '`', DEBUG);
      return false;
    }

    len = blocks.length;
    while (len--) {
      fn = blocks[len][key];
      if (fn) {
        return fn;
      }
    }

    dust.log('Malformed template `' + this.getTemplateName() + '` was missing one or more blocks.');
    return false;
  };

  Context.prototype.shiftBlocks = function(locals) {
    var blocks = this.blocks,
        newBlocks;

    if (locals) {
      if (!blocks) {
        newBlocks = [locals];
      } else {
        newBlocks = blocks.concat([locals]);
      }
      return new Context(this.stack, this.global, this.options, newBlocks, this.getTemplateName());
    }
    return this;
  };

  Context.prototype.resolve = function(body) {
    var chunk;

    if(typeof body !== 'function') {
      return body;
    }
    chunk = new Chunk().render(body, this);
    if(chunk instanceof Chunk) {
      return chunk.data.join(''); // ie7 perf
    }
    return chunk;
  };

  Context.prototype.getTemplateName = function() {
    return this.templateName;
  };

  function Stack(head, tail, idx, len) {
    this.tail = tail;
    this.isObject = head && typeof head === 'object';
    this.head = head;
    this.index = idx;
    this.of = len;
  }

  function Stub(callback) {
    this.head = new Chunk(this);
    this.callback = callback;
    this.out = '';
  }

  Stub.prototype.flush = function() {
    var chunk = this.head;

    while (chunk) {
      if (chunk.flushable) {
        this.out += chunk.data.join(''); //ie7 perf
      } else if (chunk.error) {
        this.callback(chunk.error);
        dust.log('Rendering failed with error `' + chunk.error + '`', ERROR);
        this.flush = EMPTY_FUNC;
        return;
      } else {
        return;
      }
      chunk = chunk.next;
      this.head = chunk;
    }
    this.callback(null, this.out);
  };

  /**
   * Creates an interface sort of like a Streams2 ReadableStream.
   */
  function Stream() {
    this.head = new Chunk(this);
  }

  Stream.prototype.flush = function() {
    var chunk = this.head;

    while(chunk) {
      if (chunk.flushable) {
        this.emit('data', chunk.data.join('')); //ie7 perf
      } else if (chunk.error) {
        this.emit('error', chunk.error);
        this.emit('end');
        dust.log('Streaming failed with error `' + chunk.error + '`', ERROR);
        this.flush = EMPTY_FUNC;
        return;
      } else {
        return;
      }
      chunk = chunk.next;
      this.head = chunk;
    }
    this.emit('end');
  };

  /**
   * Executes listeners for `type` by passing data. Note that this is different from a
   * Node stream, which can pass an arbitrary number of arguments
   * @return `true` if event had listeners, `false` otherwise
   */
  Stream.prototype.emit = function(type, data) {
    var events = this.events || {},
        handlers = events[type] || [],
        i, l;

    if (!handlers.length) {
      dust.log('Stream broadcasting, but no listeners for `' + type + '`', DEBUG);
      return false;
    }

    handlers = handlers.slice(0);
    for (i = 0, l = handlers.length; i < l; i++) {
      handlers[i](data);
    }
    return true;
  };

  Stream.prototype.on = function(type, callback) {
    var events = this.events = this.events || {},
        handlers = events[type] = events[type] || [];

    if(typeof callback !== 'function') {
      dust.log('No callback function provided for `' + type + '` event listener', WARN);
    } else {
      handlers.push(callback);
    }
    return this;
  };

  /**
   * Pipes to a WritableStream. Note that backpressure isn't implemented,
   * so we just write as fast as we can.
   * @param stream {WritableStream}
   * @return self
   */
  Stream.prototype.pipe = function(stream) {
    if(typeof stream.write !== 'function' ||
       typeof stream.end !== 'function') {
      dust.log('Incompatible stream passed to `pipe`', WARN);
      return this;
    }

    var destEnded = false;

    if(typeof stream.emit === 'function') {
      stream.emit('pipe', this);
    }

    if(typeof stream.on === 'function') {
      stream.on('error', function() {
        destEnded = true;
      });
    }

    return this
    .on('data', function(data) {
      if(destEnded) {
        return;
      }
      try {
        stream.write(data, 'utf8');
      } catch (err) {
        dust.log(err, ERROR);
      }
    })
    .on('end', function() {
      if(destEnded) {
        return;
      }
      try {
        stream.end();
        destEnded = true;
      } catch (err) {
        dust.log(err, ERROR);
      }
    });
  };

  function Chunk(root, next, taps) {
    this.root = root;
    this.next = next;
    this.data = []; //ie7 perf
    this.flushable = false;
    this.taps = taps;
  }

  Chunk.prototype.write = function(data) {
    var taps = this.taps;

    if (taps) {
      data = taps.go(data);
    }
    this.data.push(data);
    return this;
  };

  Chunk.prototype.end = function(data) {
    if (data) {
      this.write(data);
    }
    this.flushable = true;
    this.root.flush();
    return this;
  };

  Chunk.prototype.map = function(callback) {
    var cursor = new Chunk(this.root, this.next, this.taps),
        branch = new Chunk(this.root, cursor, this.taps);

    this.next = branch;
    this.flushable = true;
    try {
      callback(branch);
    } catch(err) {
      dust.log(err, ERROR);
      branch.setError(err);
    }
    return cursor;
  };

  Chunk.prototype.tap = function(tap) {
    var taps = this.taps;

    if (taps) {
      this.taps = taps.push(tap);
    } else {
      this.taps = new Tap(tap);
    }
    return this;
  };

  Chunk.prototype.untap = function() {
    this.taps = this.taps.tail;
    return this;
  };

  Chunk.prototype.render = function(body, context) {
    return body(this, context);
  };

  Chunk.prototype.reference = function(elem, context, auto, filters) {
    if (typeof elem === 'function') {
      elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);
      if (elem instanceof Chunk) {
        return elem;
      } else {
        return this.reference(elem, context, auto, filters);
      }
    }
    if (dust.isThenable(elem)) {
      return this.await(elem, context, null, auto, filters);
    } else if (dust.isStreamable(elem)) {
      return this.stream(elem, context, null, auto, filters);
    } else if (!dust.isEmpty(elem)) {
      return this.write(dust.filter(elem, auto, filters, context));
    } else {
      return this;
    }
  };

  Chunk.prototype.section = function(elem, context, bodies, params) {
    var body = bodies.block,
        skip = bodies['else'],
        chunk = this,
        i, len, head;

    if (typeof elem === 'function' && !dust.isTemplateFn(elem)) {
      try {
        elem = elem.apply(context.current(), [this, context, bodies, params]);
      } catch(err) {
        dust.log(err, ERROR);
        return this.setError(err);
      }
      // Functions that return chunks are assumed to have handled the chunk manually.
      // Make that chunk the current one and go to the next method in the chain.
      if (elem instanceof Chunk) {
        return elem;
      }
    }

    if (dust.isEmptyObject(bodies)) {
      // No bodies to render, and we've already invoked any function that was available in
      // hopes of returning a Chunk.
      return chunk;
    }

    if (!dust.isEmptyObject(params)) {
      context = context.push(params);
    }

    /*
    Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.
    When elem resolves to a value or object instead of an array, Dust sets the current context to the value
    and renders the block one time.
    */
    if (dust.isArray(elem)) {
      if (body) {
        len = elem.length;
        if (len > 0) {
          head = context.stack && context.stack.head || {};
          head.$len = len;
          for (i = 0; i < len; i++) {
            head.$idx = i;
            chunk = body(chunk, context.push(elem[i], i, len));
          }
          head.$idx = undefined;
          head.$len = undefined;
          return chunk;
        } else if (skip) {
          return skip(this, context);
        }
      }
    } else if (dust.isThenable(elem)) {
      return this.await(elem, context, bodies);
    } else if (dust.isStreamable(elem)) {
      return this.stream(elem, context, bodies);
    } else if (elem === true) {
     // true is truthy but does not change context
      if (body) {
        return body(this, context);
      }
    } else if (elem || elem === 0) {
       // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )
       // zero is truthy
       // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value
      if (body) {
        return body(this, context.push(elem));
      }
     // nonexistent, scalar false value, scalar empty string, null,
     // undefined are all falsy
    } else if (skip) {
      return skip(this, context);
    }
    dust.log('Section without corresponding key in template `' + context.getTemplateName() + '`', DEBUG);
    return this;
  };

  Chunk.prototype.exists = function(elem, context, bodies) {
    var body = bodies.block,
        skip = bodies['else'];

    if (!dust.isEmpty(elem)) {
      if (body) {
        return body(this, context);
      }
      dust.log('No block for exists check in template `' + context.getTemplateName() + '`', DEBUG);
    } else if (skip) {
      return skip(this, context);
    }
    return this;
  };

  Chunk.prototype.notexists = function(elem, context, bodies) {
    var body = bodies.block,
        skip = bodies['else'];

    if (dust.isEmpty(elem)) {
      if (body) {
        return body(this, context);
      }
      dust.log('No block for not-exists check in template `' + context.getTemplateName() + '`', DEBUG);
    } else if (skip) {
      return skip(this, context);
    }
    return this;
  };

  Chunk.prototype.block = function(elem, context, bodies) {
    var body = elem || bodies.block;

    if (body) {
      return body(this, context);
    }
    return this;
  };

  Chunk.prototype.partial = function(elem, context, partialContext, params) {
    var head;

    if(params === undefined) {
      // Compatibility for < 2.7.0 where `partialContext` did not exist
      params = partialContext;
      partialContext = context;
    }

    if (!dust.isEmptyObject(params)) {
      partialContext = partialContext.clone();
      head = partialContext.pop();
      partialContext = partialContext.push(params)
                                     .push(head);
    }

    if (dust.isTemplateFn(elem)) {
      // The eventual result of evaluating `elem` is a partial name
      // Load the partial after getting its name and end the async chunk
      return this.capture(elem, context, function(name, chunk) {
        partialContext.templateName = name;
        load(name, chunk, partialContext).end();
      });
    } else {
      partialContext.templateName = elem;
      return load(elem, this, partialContext);
    }
  };

  Chunk.prototype.helper = function(name, context, bodies, params, auto) {
    var chunk = this,
        filters = params.filters,
        ret;

    // Pre-2.7.1 compat: if auto is undefined, it's an old template. Automatically escape
    if (auto === undefined) {
      auto = 'h';
    }

    // handle invalid helpers, similar to invalid filters
    if(dust.helpers[name]) {
      try {
        ret = dust.helpers[name](chunk, context, bodies, params);
        if (ret instanceof Chunk) {
          return ret;
        }
        if(typeof filters === 'string') {
          filters = filters.split('|');
        }
        if (!dust.isEmptyObject(bodies)) {
          return chunk.section(ret, context, bodies, params);
        }
        // Helpers act slightly differently from functions in context in that they will act as
        // a reference if they are self-closing (due to grammar limitations)
        // In the Chunk.await function we check to make sure bodies is null before acting as a reference
        return chunk.reference(ret, context, auto, filters);
      } catch(err) {
        dust.log('Error in helper `' + name + '`: ' + err.message, ERROR);
        return chunk.setError(err);
      }
    } else {
      dust.log('Helper `' + name + '` does not exist', WARN);
      return chunk;
    }
  };

  /**
   * Reserve a chunk to be evaluated once a thenable is resolved or rejected
   * @param thenable {Thenable} the target thenable to await
   * @param context {Context} context to use to render the deferred chunk
   * @param bodies {Object} must contain a "body", may contain an "error"
   * @param auto {String} automatically apply this filter if the Thenable is a reference
   * @param filters {Array} apply these filters if the Thenable is a reference
   * @return {Chunk}
   */
  Chunk.prototype.await = function(thenable, context, bodies, auto, filters) {
    return this.map(function(chunk) {
      thenable.then(function(data) {
        if (bodies) {
          chunk = chunk.section(data, context, bodies);
        } else {
          // Actually a reference. Self-closing sections don't render
          chunk = chunk.reference(data, context, auto, filters);
        }
        chunk.end();
      }, function(err) {
        var errorBody = bodies && bodies.error;
        if(errorBody) {
          chunk.render(errorBody, context.push(err)).end();
        } else {
          dust.log('Unhandled promise rejection in `' + context.getTemplateName() + '`', INFO);
          chunk.end();
        }
      });
    });
  };

  /**
   * Reserve a chunk to be evaluated with the contents of a streamable.
   * Currently an error event will bomb out the stream. Once an error
   * is received, we push it to an {:error} block if one exists, and log otherwise,
   * then stop listening to the stream.
   * @param streamable {Streamable} the target streamable that will emit events
   * @param context {Context} context to use to render each thunk
   * @param bodies {Object} must contain a "body", may contain an "error"
   * @return {Chunk}
   */
  Chunk.prototype.stream = function(stream, context, bodies, auto, filters) {
    var body = bodies && bodies.block,
        errorBody = bodies && bodies.error;
    return this.map(function(chunk) {
      var ended = false;
      stream
        .on('data', function data(thunk) {
          if(ended) {
            return;
          }
          if(body) {
            // Fork a new chunk out of the blockstream so that we can flush it independently
            chunk = chunk.map(function(chunk) {
              chunk.render(body, context.push(thunk)).end();
            });
          } else if(!bodies) {
            // When actually a reference, don't fork, just write into the master async chunk
            chunk = chunk.reference(thunk, context, auto, filters);
          }
        })
        .on('error', function error(err) {
          if(ended) {
            return;
          }
          if(errorBody) {
            chunk.render(errorBody, context.push(err));
          } else {
            dust.log('Unhandled stream error in `' + context.getTemplateName() + '`', INFO);
          }
          if(!ended) {
            ended = true;
            chunk.end();
          }
        })
        .on('end', function end() {
          if(!ended) {
            ended = true;
            chunk.end();
          }
        });
    });
  };

  Chunk.prototype.capture = function(body, context, callback) {
    return this.map(function(chunk) {
      var stub = new Stub(function(err, out) {
        if (err) {
          chunk.setError(err);
        } else {
          callback(out, chunk);
        }
      });
      body(stub.head, context).end();
    });
  };

  Chunk.prototype.setError = function(err) {
    this.error = err;
    this.root.flush();
    return this;
  };

  // Chunk aliases
  for(var f in Chunk.prototype) {
    if(dust._aliases[f]) {
      Chunk.prototype[dust._aliases[f]] = Chunk.prototype[f];
    }
  }

  function Tap(head, tail) {
    this.head = head;
    this.tail = tail;
  }

  Tap.prototype.push = function(tap) {
    return new Tap(tap, this);
  };

  Tap.prototype.go = function(value) {
    var tap = this;

    while(tap) {
      value = tap.head(value);
      tap = tap.tail;
    }
    return value;
  };

  var HCHARS = /[&<>"']/,
      AMP    = /&/g,
      LT     = /</g,
      GT     = />/g,
      QUOT   = /\"/g,
      SQUOT  = /\'/g;

  dust.escapeHtml = function(s) {
    if (typeof s === "string" || (s && typeof s.toString === "function")) {
      if (typeof s !== "string") {
        s = s.toString();
      }
      if (!HCHARS.test(s)) {
        return s;
      }
      return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');
    }
    return s;
  };

  var BS = /\\/g,
      FS = /\//g,
      CR = /\r/g,
      LS = /\u2028/g,
      PS = /\u2029/g,
      NL = /\n/g,
      LF = /\f/g,
      SQ = /'/g,
      DQ = /"/g,
      TB = /\t/g;

  dust.escapeJs = function(s) {
    if (typeof s === 'string') {
      return s
        .replace(BS, '\\\\')
        .replace(FS, '\\/')
        .replace(DQ, '\\"')
        .replace(SQ, '\\\'')
        .replace(CR, '\\r')
        .replace(LS, '\\u2028')
        .replace(PS, '\\u2029')
        .replace(NL, '\\n')
        .replace(LF, '\\f')
        .replace(TB, '\\t');
    }
    return s;
  };

  dust.escapeJSON = function(o) {
    if (!JSON) {
      dust.log('JSON is undefined; could not escape `' + o + '`', WARN);
      return o;
    } else {
      return JSON.stringify(o)
        .replace(LS, '\\u2028')
        .replace(PS, '\\u2029')
        .replace(LT, '\\u003c');
    }
  };

  return dust;

}));

}).call(this,_dereq_('_process'))

},{"_process":8}],6:[function(_dereq_,module,exports){
/**
* @preserve HTML5 Shiv 3.7.3 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
*/
;(function(window, document) {
/*jshint evil:true */
  /** version */
  var version = '3.7.3-pre';

  /** Preset options */
  var options = window.html5 || {};

  /** Used to skip problem elements */
  var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

  /** Not all elements can be cloned in IE **/
  var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

  /** Detect whether the browser supports default html5 styles */
  var supportsHtml5Styles;

  /** Name of the expando, to work with multiple documents or to re-shiv one document */
  var expando = '_html5shiv';

  /** The id for the the documents expando */
  var expanID = 0;

  /** Cached data for each document */
  var expandoData = {};

  /** Detect whether the browser supports unknown elements */
  var supportsUnknownElements;

  (function() {
    try {
        var a = document.createElement('a');
        a.innerHTML = '<xyz></xyz>';
        //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
        supportsHtml5Styles = ('hidden' in a);

        supportsUnknownElements = a.childNodes.length == 1 || (function() {
          // assign a false positive if unable to shiv
          (document.createElement)('a');
          var frag = document.createDocumentFragment();
          return (
            typeof frag.cloneNode == 'undefined' ||
            typeof frag.createDocumentFragment == 'undefined' ||
            typeof frag.createElement == 'undefined'
          );
        }());
    } catch(e) {
      // assign a false positive if detection fails => unable to shiv
      supportsHtml5Styles = true;
      supportsUnknownElements = true;
    }

  }());

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a style sheet with the given CSS text and adds it to the document.
   * @private
   * @param {Document} ownerDocument The document.
   * @param {String} cssText The CSS text.
   * @returns {StyleSheet} The style element.
   */
  function addStyleSheet(ownerDocument, cssText) {
    var p = ownerDocument.createElement('p'),
        parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

    p.innerHTML = 'x<style>' + cssText + '</style>';
    return parent.insertBefore(p.lastChild, parent.firstChild);
  }

  /**
   * Returns the value of `html5.elements` as an array.
   * @private
   * @returns {Array} An array of shived element node names.
   */
  function getElements() {
    var elements = html5.elements;
    return typeof elements == 'string' ? elements.split(' ') : elements;
  }

  /**
   * Extends the built-in list of html5 elements
   * @memberOf html5
   * @param {String|Array} newElements whitespace separated list or array of new element names to shiv
   * @param {Document} ownerDocument The context document.
   */
  function addElements(newElements, ownerDocument) {
    var elements = html5.elements;
    if(typeof elements != 'string'){
      elements = elements.join(' ');
    }
    if(typeof newElements != 'string'){
      newElements = newElements.join(' ');
    }
    html5.elements = elements +' '+ newElements;
    shivDocument(ownerDocument);
  }

   /**
   * Returns the data associated to the given document
   * @private
   * @param {Document} ownerDocument The document.
   * @returns {Object} An object of data.
   */
  function getExpandoData(ownerDocument) {
    var data = expandoData[ownerDocument[expando]];
    if (!data) {
        data = {};
        expanID++;
        ownerDocument[expando] = expanID;
        expandoData[expanID] = data;
    }
    return data;
  }

  /**
   * returns a shived element for the given nodeName and document
   * @memberOf html5
   * @param {String} nodeName name of the element
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived element.
   */
  function createElement(nodeName, ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createElement(nodeName);
    }
    if (!data) {
        data = getExpandoData(ownerDocument);
    }
    var node;

    if (data.cache[nodeName]) {
        node = data.cache[nodeName].cloneNode();
    } else if (saveClones.test(nodeName)) {
        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
    } else {
        node = data.createElem(nodeName);
    }

    // Avoid adding some elements to fragments in IE < 9 because
    // * Attributes like `name` or `type` cannot be set/changed once an element
    //   is inserted into a document/fragment
    // * Link elements with `src` attributes that are inaccessible, as with
    //   a 403 response, will cause the tab/window to crash
    // * Script elements appended to fragments will execute when their `src`
    //   or `text` property is set
    return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;
  }

  /**
   * returns a shived DocumentFragment for the given document
   * @memberOf html5
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived DocumentFragment.
   */
  function createDocumentFragment(ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createDocumentFragment();
    }
    data = data || getExpandoData(ownerDocument);
    var clone = data.frag.cloneNode(),
        i = 0,
        elems = getElements(),
        l = elems.length;
    for(;i<l;i++){
        clone.createElement(elems[i]);
    }
    return clone;
  }

  /**
   * Shivs the `createElement` and `createDocumentFragment` methods of the document.
   * @private
   * @param {Document|DocumentFragment} ownerDocument The document.
   * @param {Object} data of the document.
   */
  function shivMethods(ownerDocument, data) {
    if (!data.cache) {
        data.cache = {};
        data.createElem = ownerDocument.createElement;
        data.createFrag = ownerDocument.createDocumentFragment;
        data.frag = data.createFrag();
    }


    ownerDocument.createElement = function(nodeName) {
      //abort shiv
      if (!html5.shivMethods) {
          return data.createElem(nodeName);
      }
      return createElement(nodeName, ownerDocument, data);
    };

    ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
      'var n=f.cloneNode(),c=n.createElement;' +
      'h.shivMethods&&(' +
        // unroll the `createElement` calls
        getElements().join().replace(/[\w\-:]+/g, function(nodeName) {
          data.createElem(nodeName);
          data.frag.createElement(nodeName);
          return 'c("' + nodeName + '")';
        }) +
      ');return n}'
    )(html5, data.frag);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Shivs the given document.
   * @memberOf html5
   * @param {Document} ownerDocument The document to shiv.
   * @returns {Document} The shived document.
   */
  function shivDocument(ownerDocument) {
    if (!ownerDocument) {
        ownerDocument = document;
    }
    var data = getExpandoData(ownerDocument);

    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
      data.hasCSS = !!addStyleSheet(ownerDocument,
        // corrects block display not defined in IE6/7/8/9
        'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +
        // adds styling not present in IE6/7/8/9
        'mark{background:#FF0;color:#000}' +
        // hides non-rendered elements
        'template{display:none}'
      );
    }
    if (!supportsUnknownElements) {
      shivMethods(ownerDocument, data);
    }
    return ownerDocument;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The `html5` object is exposed so that more elements can be shived and
   * existing shiving can be detected on iframes.
   * @type Object
   * @example
   *
   * // options can be changed before the script is included
   * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
   */
  var html5 = {

    /**
     * An array or space separated string of node names of the elements to shiv.
     * @memberOf html5
     * @type Array|String
     */
    'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video',

    /**
     * current version of html5shiv
     */
    'version': version,

    /**
     * A flag to indicate that the HTML5 style sheet should be inserted.
     * @memberOf html5
     * @type Boolean
     */
    'shivCSS': (options.shivCSS !== false),

    /**
     * Is equal to true if a browser supports creating unknown/HTML5 elements
     * @memberOf html5
     * @type boolean
     */
    'supportsUnknownElements': supportsUnknownElements,

    /**
     * A flag to indicate that the document's `createElement` and `createDocumentFragment`
     * methods should be overwritten.
     * @memberOf html5
     * @type Boolean
     */
    'shivMethods': (options.shivMethods !== false),

    /**
     * A string to describe the type of `html5` object ("default" or "default print").
     * @memberOf html5
     * @type String
     */
    'type': 'default',

    // shivs the document according to the specified `html5` object options
    'shivDocument': shivDocument,

    //creates a shived element
    createElement: createElement,

    //creates a shived documentFragment
    createDocumentFragment: createDocumentFragment,

    //extends list of elements
    addElements: addElements
  };

  /*--------------------------------------------------------------------------*/

  // expose html5
  window.html5 = html5;

  // shiv the document
  shivDocument(document);

  if(typeof module == 'object' && module.exports){
    module.exports = html5;
  }

}(typeof window !== "undefined" ? window : this, document));

},{}],7:[function(_dereq_,module,exports){

var L = {
	version: '1.0.1'
};

function expose() {
	var oldL = window.L;

	L.noConflict = function () {
		window.L = oldL;
		return this;
	};

	window.L = L;
}

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed
if (typeof window !== 'undefined') {
	expose();
}

/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

L.Util = {

	// @function extend(dest: Object, src?: Object): Object
	// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
	extend: function (dest) {
		var i, j, len, src;

		for (j = 1, len = arguments.length; j < len; j++) {
			src = arguments[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	},

	// @function create(proto: Object, properties?: Object): Object
	// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
	create: Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})(),

	// @function bind(fn: Function, ): Function
	// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	// Has a `L.bind()` shortcut.
	bind: function (fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	},

	// @function stamp(obj: Object): Number
	// Returns the unique ID of an object, assiging it one if it doesn't have it.
	stamp: function (obj) {
		/*eslint-disable */
		obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
		return obj._leaflet_id;
		/*eslint-enable */
	},

	// @property lastId: Number
	// Last unique ID used by [`stamp()`](#util-stamp)
	lastId: 0,

	// @function throttle(fn: Function, time: Number, context: Object): Function
	// Returns a function which executes function `fn` with the given scope `context`
	// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
	// `fn` will be called no more than one time per given amount of `time`. The arguments
	// received by the bound function will be any arguments passed when binding the
	// function, followed by any arguments passed when invoking the bound function.
	// Has an `L.bind` shortcut.
	throttle: function (fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	},

	// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
	// Returns the number `num` modulo `range` in such a way so it lies within
	// `range[0]` and `range[1]`. The returned value will be always smaller than
	// `range[1]` unless `includeMax` is set to `true`.
	wrapNum: function (x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	},

	// @function falseFn(): Function
	// Returns a function which always returns `false`.
	falseFn: function () { return false; },

	// @function formatNum(num: Number, digits?: Number): Number
	// Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	// @function trim(str: String): String
	// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	// @function splitWords(str: String): String[]
	// Trims and splits the string on whitespace and returns the array of parts.
	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	// @function setOptions(obj: Object, options: Object): Object
	// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
	setOptions: function (obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? L.Util.create(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	},

	// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
	// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
	// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
	// be appended at the end. If `uppercase` is `true`, the parameter names will
	// be uppercased (e.g. `'?A=foo&B=bar'`)
	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},

	// @function template(str: String, data: Object): String
	// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
	// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
	// `('Hello foo, bar')`. You can also specify functions instead of strings for
	// data values  they will be evaluated passing `data` as an argument.
	template: function (str, data) {
		return str.replace(L.Util.templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	templateRe: /\{ *([\w_\-]+) *\}/g,

	// @function isArray(obj): Boolean
	// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	// @function indexOf(array: Array, el: Object): Number
	// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
	indexOf: function (array, el) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === el) { return i; }
		}
		return -1;
	},

	// @property emptyImageUrl: String
	// Data URI string containing a base64-encoded empty GIF image.
	// Used as a hack to free memory from unused images on WebKit-powered
	// mobile devices (by setting image `src` to this string).
	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {
	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
	    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
	               getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };


	// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
	// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
	// `context` if given. When `immediate` is set, `fn` is called immediately if
	// the browser doesn't have native support for
	// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
	// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
	L.Util.requestAnimFrame = function (fn, context, immediate) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, L.bind(fn, context));
		}
	};

	// @function cancelAnimFrame(id: Number): undefined
	// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};
})();

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;


// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

L.Class = function () {};

L.Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = L.Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = L.Util.extend(L.Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
L.Class.include = function (props) {
	L.extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};

/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */


L.Evented = L.Class.extend({

	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = {fn: fn, ctx: context},
		    listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
		typeListeners.count++;
	},

	_off: function (type, fn, context) {
		var listeners,
		    i,
		    len;

		if (!this._events) { return; }

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = L.Util.falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) { continue; }
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = L.Util.falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object  the first argument of the listener function will contain its
	// properties. The event might can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = L.Util.extend({}, data, {type: type, target: this});

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = (this._firingCount + 1) || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(): this
	// Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = L.bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[L.stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[L.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, L.extend({layer: e.target}, e), true);
		}
	}
});

var proto = L.Evented.prototype;

// aliases; we should ditch those eventually

// @method addEventListener(): this
// Alias to [`on()`](#evented-on)
proto.addEventListener = proto.on;

// @method removeEventListener(): this
// Alias to [`off()`](#evented-off)

// @method clearAllEventListeners(): this
// Alias to [`off()`](#evented-off)
proto.removeEventListener = proto.clearAllEventListeners = proto.off;

// @method addOneTimeEventListener(): this
// Alias to [`once()`](#evented-once)
proto.addOneTimeEventListener = proto.once;

// @method fireEvent(): this
// Alias to [`fire()`](#evented-fire)
proto.fireEvent = proto.fire;

// @method hasEventListeners(): Boolean
// Alias to [`listens()`](#evented-listens)
proto.hasEventListeners = proto.listens;

L.Mixin = {Events: proto};

/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

(function () {

	var ua = navigator.userAgent.toLowerCase(),
	    doc = document.documentElement,

	    ie = 'ActiveXObject' in window,

	    webkit    = ua.indexOf('webkit') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android23 = ua.search('android [23]') !== -1,
	    chrome    = ua.indexOf('chrome') !== -1,
	    gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

	    win = navigator.platform.indexOf('Win') === 0,

	    mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
	    msPointer = !window.PointerEvent && window.MSPointerEvent,
	    pointer = window.PointerEvent || msPointer,

	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera12 = 'OTransition' in doc.style;


	var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {

		// @property ie: Boolean
		// `true` for all Internet Explorer versions (not Edge).
		ie: ie,

		// @property ielt9: Boolean
		// `true` for Internet Explorer versions less than 9.
		ielt9: ie && !document.addEventListener,

		// @property edge: Boolean
		// `true` for the Edge web browser.
		edge: 'msLaunchUri' in navigator && !('documentMode' in document),

		// @property webkit: Boolean
		// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
		webkit: webkit,

		// @property gecko: Boolean
		// `true` for gecko-based browsers like Firefox.
		gecko: gecko,

		// @property android: Boolean
		// `true` for any browser running on an Android platform.
		android: ua.indexOf('android') !== -1,

		// @property android23: Boolean
		// `true` for browsers running on Android 2 or Android 3.
		android23: android23,

		// @property chrome: Boolean
		// `true` for the Chrome browser.
		chrome: chrome,

		// @property safari: Boolean
		// `true` for the Safari browser.
		safari: !chrome && ua.indexOf('safari') !== -1,


		// @property win: Boolean
		// `true` when the browser is running in a Windows platform
		win: win,


		// @property ie3d: Boolean
		// `true` for all Internet Explorer versions supporting CSS transforms.
		ie3d: ie3d,

		// @property webkit3d: Boolean
		// `true` for webkit-based browsers supporting CSS transforms.
		webkit3d: webkit3d,

		// @property gecko3d: Boolean
		// `true` for gecko-based browsers supporting CSS transforms.
		gecko3d: gecko3d,

		// @property opera12: Boolean
		// `true` for the Opera browser supporting CSS transforms (version 12 or later).
		opera12: opera12,

		// @property any3d: Boolean
		// `true` for all browsers supporting CSS transforms.
		any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


		// @property mobile: Boolean
		// `true` for all browsers running in a mobile device.
		mobile: mobile,

		// @property mobileWebkit: Boolean
		// `true` for all webkit-based browsers in a mobile device.
		mobileWebkit: mobile && webkit,

		// @property mobileWebkit3d: Boolean
		// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
		mobileWebkit3d: mobile && webkit3d,

		// @property mobileOpera: Boolean
		// `true` for the Opera browser in a mobile device.
		mobileOpera: mobile && window.opera,

		// @property mobileGecko: Boolean
		// `true` for gecko-based browsers running in a mobile device.
		mobileGecko: mobile && gecko,


		// @property touch: Boolean
		// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
		touch: !!touch,

		// @property msPointer: Boolean
		// `true` for browsers implementing the Microsoft touch events model (notably IE10).
		msPointer: !!msPointer,

		// @property pointer: Boolean
		// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
		pointer: !!pointer,


		// @property retina: Boolean
		// `true` for browsers on a high-resolution "retina" screen.
		retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
	};

}());

/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 */

L.Point = function (x, y, round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(L.point(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new L.Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new L.Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new L.Point(x.x, x.y);
	}
	return new L.Point(x, y, round);
};

/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 */

L.Bounds = function (a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = L.point(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new L.Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(topLeft: Point, bottomRight: Point)
// Creates a Bounds object from two coordinates (usually top-left and bottom-right corners).
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the points it contains
L.bounds = function (a, b) {
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};

/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = new L.Transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts real `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts real `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};

/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */

L.DomUtil = {

	// @function get(id: String|HTMLElement): HTMLElement
	// Returns an element given its DOM id, or returns the element itself
	// if it was passed directly.
	get: function (id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	},

	// @function getStyle(el: HTMLElement, styleAttrib: String): String
	// Returns the value for a certain style attribute on an element,
	// including computed values or values set through CSS.
	getStyle: function (el, style) {

		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
	// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className || '';

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	// @function remove(el: HTMLElement)
	// Removes `el` from its parent element
	remove: function (el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	},

	// @function empty(el: HTMLElement)
	// Removes all of `el`'s children elements from `el`
	empty: function (el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	},

	// @function toFront(el: HTMLElement)
	// Makes `el` the last children of its parent, so it renders in front of the other children.
	toFront: function (el) {
		el.parentNode.appendChild(el);
	},

	// @function toBack(el: HTMLElement)
	// Makes `el` the first children of its parent, so it renders back from the other children.
	toBack: function (el) {
		var parent = el.parentNode;
		parent.insertBefore(el, parent.firstChild);
	},

	// @function hasClass(el: HTMLElement, name: String): Boolean
	// Returns `true` if the element's class attribute contains `name`.
	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil.getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	// @function addClass(el: HTMLElement, name: String)
	// Adds `name` to the element's class attribute.
	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil.getClass(el);
			L.DomUtil.setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	// @function removeClass(el: HTMLElement, name: String)
	// Removes `name` from the element's class attribute.
	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	// @function setClass(el: HTMLElement, name: String)
	// Sets the element's class.
	setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	// @function getClass(el: HTMLElement): String
	// Returns the element's class.
	getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	// @function setOpacity(el: HTMLElement, opacity: Number)
	// Set the opacity of an element (including old IE support).
	// `opacity` must be a number from `0` to `1`.
	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {
			L.DomUtil._setOpacityIE(el, value);
		}
	},

	_setOpacityIE: function (el, value) {
		var filter = false,
		    filterName = 'DXImageTransform.Microsoft.Alpha';

		// filters collection throws an error if we try to retrieve a filter that doesn't exist
		try {
			filter = el.filters.item(filterName);
		} catch (e) {
			// don't set opacity to 1 if we haven't already set an opacity,
			// it isn't needed and breaks transparent pngs.
			if (value === 1) { return; }
		}

		value = Math.round(value * 100);

		if (filter) {
			filter.Enabled = (value !== 100);
			filter.Opacity = value;
		} else {
			el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
		}
	},

	// @function testProp(props: String[]): String|false
	// Goes through the array of style names and returns the first name
	// that is a valid style name for an element. If no such name is found,
	// it returns false. Useful for vendor-prefixed styles like `transform`.
	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
	// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
	// and optionally scaled by `scale`. Does not have an effect if the
	// browser doesn't support 3D CSS transforms.
	setTransform: function (el, offset, scale) {
		var pos = offset || new L.Point(0, 0);

		el.style[L.DomUtil.TRANSFORM] =
			(L.Browser.ie3d ?
				'translate(' + pos.x + 'px,' + pos.y + 'px)' :
				'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
			(scale ? ' scale(' + scale + ')' : '');
	},

	// @function setPosition(el: HTMLElement, position: Point)
	// Sets the position of `el` to coordinates specified by `position`,
	// using CSS translate or top/left positioning depending on the browser
	// (used by Leaflet internally to position its layers).
	setPosition: function (el, point) { // (HTMLElement, Point[, Boolean])

		/*eslint-disable */
		el._leaflet_pos = point;
		/*eslint-enable */

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	// @function getPosition(el: HTMLElement): Point
	// Returns the coordinates of an element previously positioned with setPosition.
	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		return el._leaflet_pos || new L.Point(0, 0);
	}
};


(function () {
	// prefix style property names

	// @property TRANSFORM: String
	// Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
	L.DomUtil.TRANSFORM = L.DomUtil.testProp(
			['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);


	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	// @property TRANSITION: String
	// Vendor-prefixed transform style name.
	var transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(
			['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	L.DomUtil.TRANSITION_END =
			transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';

	// @function disableTextSelection()
	// Prevents the user from generating `selectstart` DOM events, usually generated
	// when the user drags the mouse through a page with text. Used internally
	// by Leaflet to override the behaviour of any click-and-drag interaction on
	// the map. Affects drag interactions on the whole document.

	// @function enableTextSelection()
	// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
	if ('onselectstart' in document) {
		L.DomUtil.disableTextSelection = function () {
			L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
		};
		L.DomUtil.enableTextSelection = function () {
			L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
		};

	} else {
		var userSelectProperty = L.DomUtil.testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		L.DomUtil.disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				this._userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		L.DomUtil.enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = this._userSelect;
				delete this._userSelect;
			}
		};
	}

	// @function disableImageDrag()
	// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
	// for `dragstart` DOM events, usually generated when the user drags an image.
	L.DomUtil.disableImageDrag = function () {
		L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function enableImageDrag()
	// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
	L.DomUtil.enableImageDrag = function () {
		L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function preventOutline(el: HTMLElement)
	// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
	// of the element `el` invisible. Used internally by Leaflet to prevent
	// focusable elements from displaying an outline when the user performs a
	// drag interaction on them.
	L.DomUtil.preventOutline = function (element) {
		while (element.tabIndex === -1) {
			element = element.parentNode;
		}
		if (!element || !element.style) { return; }
		L.DomUtil.restoreOutline();
		this._outlineElement = element;
		this._outlineStyle = element.style.outline;
		element.style.outline = 'none';
		L.DomEvent.on(window, 'keydown', L.DomUtil.restoreOutline, this);
	};

	// @function restoreOutline()
	// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
	L.DomUtil.restoreOutline = function () {
		if (!this._outlineElement) { return; }
		this._outlineElement.style.outline = this._outlineStyle;
		delete this._outlineElement;
		delete this._outlineStyle;
		L.DomEvent.off(window, 'keydown', L.DomUtil.restoreOutline, this);
	};
})();

/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 */

L.LatLng = function (lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
};

L.LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overriden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula).
	distanceTo: function (other) {
		return L.CRS.Earth.distance(this, L.latLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return L.CRS.Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return L.latLngBounds(
		        [this.lat - latAccuracy, this.lng - lngAccuracy],
		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new L.LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

L.latLng = function (a, b, c) {
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new L.LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new L.LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b, c);
};

/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var southWest = L.latLng(40.712, -74.227),
 * northEast = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(southWest, northEast);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof L.LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new L.LatLng(sw2.lat, sw2.lng);
			this._northEast = new L.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
	pad: function (bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds.
	equals: function (bounds) {
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(southWest: LatLng, northEast: LatLng)
// Creates a `LatLngBounds` object by defining south-west and north-east corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
L.latLngBounds = function (a, b) {
	if (a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};

/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection  the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:3395` and `Simple` CRS.
 */

L.Projection = {};

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	},

	bounds: L.bounds([-180, -90], [180, 90])
};

/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection  the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

L.Projection.SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new L.Point(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new L.LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return L.bounds([-d, -d], [d, d]);
	})()
};

/*
 * @class CRS
 * @aka L.CRS
 * Abstract class that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 */

L.CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return L.bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return L.latLng(lat, lng, alt);
	}
};

/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});

/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

L.CRS.Earth = L.extend({}, L.CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    a = Math.sin(lat1) * Math.sin(lat2) +
		        Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

		return this.R * Math.acos(Math.min(a, 1));
	}
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3857',
	projection: L.Projection.SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:4326',
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)
});

/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API  it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

L.Map = L.Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: L.CRS.EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = undefined
		// Minimum zoom level of the map. Overrides any `minZoom` option set on map layers.
		minZoom: undefined,

		// @option maxZoom: Number = undefined
		// Maximum zoom level of the map. Overrides any `maxZoom` option set on map layers.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back when he tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom) {
		// replaced by animation-powered implementation in Map.PanAnimation.js
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), zoom);
		return this;
	},

	// @method setZoom(zoom: Number, options: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		this.options.minZoom = zoom;

		if (this._loaded && this.getZoom() < this.options.minZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		this.options.maxZoom = zoom;

		if (this._loaded && (this.getZoom() > this.options.maxZoom)) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method invalidateSize(options: Zoom/Pan options): this
	// Checks if the map container size changed and updates the map if so 
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so 
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},


	// TODO handler.addTo
	// TODO Appropiate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/*eslint-enable */
			this._containerId = undefined;
		}

		L.DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		for (var i in this._layers) {
			this._layers[i].remove();
		}

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a children of `container`, or
	// as a children of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = L.DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);
		padding = L.point(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;

		var scale = Math.min(size.x / boundsSize.x, size.y / boundsSize.y);
		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(L.latLng(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return L.DomEvent.getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		L.DomEvent.addListener(container, 'scroll', this._onScroll, this);
		this._containerId = L.Util.stamp(container);
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(L.Browser.safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for tooltip.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		return this.fire('movestart');
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		L.Util.cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove) {
		if (!L.DomEvent) { return; }

		this._targets = {};
		this._targets[L.stamp(this._container)] = this;

		var onOff = remove ? 'off' : 'on';

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused.
		L.DomEvent[onOff](this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}

		if (L.Browser.any3d && this.options.transform3DLimit) {
			this[onOff]('moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[L.stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !L.DomEvent._isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && L.DomEvent._isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;

		if (type === 'mousedown') {
			// prevents outline when clicking on keyboard-focusable element
			L.DomUtil.preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = L.Util.extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			L.DomEvent.preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target instanceof L.Marker;
			data.containerPoint = isMarker ?
					this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = L.bounds(
		        this.project(maxBounds.getNorthEast(), zoom),
		        this.project(maxBounds.getSouthWest(), zoom)
		    ),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
L.map = function (id, options) {
	return new L.Map(id, options);
};


/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


L.Layer = L.Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',
		nonBubblingEvents: []  // Array of events that should not be bubbled to DOM parents (like the map)
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map): this
	 * Adds the layer to the given map
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[L.stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[L.stamp(targetEl)];
		return this;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && this._map.attributionControl) {
			this._map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		var id = L.stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (L.stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[L.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = L.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	}
});

/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection  more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

L.Projection.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new L.Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, point.x * d / r);
	}
};

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */

L.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3395',
	projection: L.Projection.Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.Mercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


L.GridLayer = L.Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = depends
		// If `false`, new tiles are loaded during panning, otherwise only after it (for better performance). `true` by default on mobile browsers, otherwise `false`.
		updateWhenIdle: L.Browser.mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option attribution: String = null
		// String to be shown in the attribution control, describes the layer data, e.g. " Mapbox".
		attribution: null,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level that tiles will be loaded at. By default the entire map.
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level that tiles will be loaded at.
		maxZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		L.DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = null;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overriden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof L.Point ? s : new L.Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (L.Browser.ielt9) { return; }

		L.DomUtil.setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			L.DomUtil.setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) { willPrune = true; }
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		}
	},

	_initContainer: function () {
		if (this._container) { return; }

		this._container = L.DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
			} else {
				L.DomUtil.remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = L.DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			L.Util.falseFn(level.el.offsetWidth);
		}

		this._level = level;

		return level;
	},

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			L.DomUtil.remove(this._levels[z].el);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = null;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new L.Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new L.Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = Math.round(zoom);
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale)
		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(level.el, translate, scale);
		} else {
			L.DomUtil.setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = map.getZoom();

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
		                              tileRange.getTopRight().add([margin, -margin]));

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new L.Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return L.latLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {

		var map = this._map,
		    tileSize = this.getTileSize(),

		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),

		    nw = map.unproject(nwPoint, coords.z),
		    se = map.unproject(sePoint, coords.z);

		if (!this.options.noWrap) {
			nw = map.wrapLatLng(nw);
			se = map.wrapLatLng(se);
		}

		return new L.LatLngBounds(nw, se);
	},

	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
		    coords = new L.Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		L.DomUtil.remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		L.DomUtil.addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = L.Util.falseFn;
		tile.onmousemove = L.Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (L.Browser.ielt9 && this.options.opacity < 1) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.android && !L.Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			L.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));
		}

		L.DomUtil.setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map) { return; }

		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			L.DomUtil.setOpacity(tile.el, 0);
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			L.DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (L.Browser.ielt9 || !this._map._fadeAnimated) {
				L.Util.requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(L.bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new L.Point(
			this._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new L.Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
L.gridLayer = function (options) {
	return new L.GridLayer(options);
};

/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add @2x to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


L.TileLayer = L.GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// Minimum zoom number.
		minZoom: 0,

		// @option maxZoom: Number = 18
		// Maximum zoom number.
		maxZoom: 18,

		// @option maxNativeZoom: Number = null
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: null,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean = false
		// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!L.Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));
		L.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: L.Browser.retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return L.Util.template(this._url, L.extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (L.Browser.ielt9) {
			setTimeout(L.bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	getTileSize: function () {
		var map = this._map,
		    tileSize = L.GridLayer.prototype.getTileSize.call(this),
		    zoom = this._tileZoom + this.options.zoomOffset,
		    zoomN = this.options.maxNativeZoom;

		// increase tile size when overscaling
		return zoomN !== null && zoom > zoomN ?
				tileSize.divideBy(map.getZoomScale(zoomN, zoom)).round() :
				tileSize;
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._tileZoom;

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom !== null ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;

				if (!tile.complete) {
					tile.src = L.Util.emptyImageUrl;
					L.DomUtil.remove(tile);
				}
			}
		}
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};

/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data  2012 IEM Nexrad"
 * });
 * ```
 */

L.TileLayer.WMS = L.TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = L.setOptions(this, options);

		wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToBounds(coords),
		    nw = this._crs.project(tileBounds.getNorthWest()),
		    se = this._crs.project(tileBounds.getSouthEast()),

		    bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
			    [se.y, nw.x, nw.y, se.x] :
			    [nw.x, se.y, se.x, nw.y]).join(','),

		    url = L.TileLayer.prototype.getTileUrl.call(this, coords);

		return url +
			L.Util.getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};

/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

L.ImageOverlay = L.Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option attribution: String = null
		// An optional string containing HTML to be shown on the `Attribution control`
		attribution: null,

		// @option crossOrigin: Boolean = false
		// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
		crossOrigin: false
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			L.DomUtil.addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		L.DomUtil.remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	setBounds: function (bounds) {
		this._bounds = bounds;

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	getBounds: function () {
		return this._bounds;
	},

	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var img = this._image = L.DomUtil.create('img',
				'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

		img.onselectstart = L.Util.falseFn;
		img.onmousemove = L.Util.falseFn;

		img.onload = L.bind(this.fire, this, 'load');

		if (this.options.crossOrigin) {
			img.crossOrigin = '';
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center);

		L.DomUtil.setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new L.Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		L.DomUtil.setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};

/*
 * @class Icon
 * @aka L.Icon
 * @inherits Layer
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

L.Icon = L.Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = null
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	initialize: function (options) {
		L.setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = L.point(sizeOption),
		    anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
L.icon = function (options) {
	return new L.Icon(options);
};

/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to change the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconUrl:       'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl:     'marker-shadow.png',
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		if (!L.Icon.Default.imagePath) {	// Deprecated, backwards-compatibility only
			L.Icon.Default.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `L.Icon.Default` will try to auto-detect the absolute location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right absolute path.
		return (this.options.imagePath || L.Icon.Default.imagePath) + L.Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function () {
		var el = L.DomUtil.create('div',  'leaflet-default-icon-path', document.body);
		var path = L.DomUtil.getStyle(el, 'background-image') ||
		           L.DomUtil.getStyle(el, 'backgroundImage');	// IE8

		document.body.removeChild(el);

		return path.indexOf('url') === 0 ?
			path.replace(/^url\([\"\']?/, '').replace(/marker-icon\.png[\"\']?\)$/, '') : '';
	}
});

/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

L.Marker = L.Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon class to use for rendering the marker. See [Icon documentation](#L.Icon) for details on how to customize the marker icon. If not specified, a new `L.Icon.Default` is used.
		icon: new L.Icon.Default(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// FIXME: shadowPane is no longer a valid option
		nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = L.latLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		L.DomUtil.remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			L.DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		L.DomUtil.addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (L.Handler.MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new L.Handler.MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		L.DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};

/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

L.DivIcon = L.Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = L.point(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
L.divIcon = function (options) {
	return new L.DivIcon(options);
};

/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
L.DivOverlay = L.Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
		} else {
			L.DomUtil.remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
		}
		return this;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			L.DomUtil.setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});

/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
L.Popup = L.DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when user clicks the map (set globally by
		// the Map's [closePopupOnClick](#map-closepopuponclick) option).
		autoClose: true,

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof L.Path)) {
				this._source.on('preclick', L.DomEvent.stopPropagation);
			}
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			if (!(this._source instanceof L.Path)) {
				this._source.off('preclick', L.DomEvent.stopPropagation);
			}
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = L.DomUtil.create('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-animated');

		if (this.options.closeButton) {
			var closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent
			.disableClickPropagation(wrapper)
			.disableScrollPropagation(this._contentNode)
			.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		L.DomUtil.setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }

		var map = this._map,
		    marginBottom = parseInt(L.DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,
		    containerHeight = this._container.offsetHeight + marginBottom,
		    containerWidth = this._containerWidth,
		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(L.DomUtil.getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return L.point(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
L.popup = function (options, source) {
	return new L.Popup(options, source);
};


/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
L.Map.mergeOptions({
	closePopupOnClick: true
});


// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof L.Popup)) {
			popup = new L.Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
L.Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specificed `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return this._popup.isOpen();
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		L.DomEvent.stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof L.Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});

/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor || [0, 0];
	}
});

/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offseting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
L.Tooltip = L.DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamicaly switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if (L.Browser.touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = L.DomUtil.create('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_setPosition: function (pos) {
		var map = this._map,
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(L.point(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y));
		} else if (direction === 'bottom') {
			pos = pos.subtract(L.point(tooltipWidth / 2 - offset.x, -offset.y));
		} else if (direction === 'center') {
			pos = pos.subtract(L.point(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add([offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y]);
		} else {
			direction = 'left';
			pos = pos.subtract(L.point(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y));
		}

		L.DomUtil.removeClass(container, 'leaflet-tooltip-right');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-left');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-top');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-bottom');
		L.DomUtil.addClass(container, 'leaflet-tooltip-' + direction);
		L.DomUtil.setPosition(container, pos);
	},

	_updatePosition: function () {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			L.DomUtil.setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return L.point(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
L.tooltip = function (options, source) {
	return new L.Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof L.Tooltip)) {
			tooltip = new L.Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
L.Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof L.Tooltip) {
			L.setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = L.tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove) {
		if (!remove && this._tooltipHandlersAdded) { return; }
		var onOff = remove ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		    };
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (L.Browser.touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specificed `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});

/*
 * Tooltip extension to L.Marker, adding tooltip-related methods.
 */

L.Marker.include({
	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor || [0, 0];
	}
});

/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

L.LayerGroup = L.Layer.extend({

	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i]);
		}
		return this;
	},

	// @method invoke(methodName: String, ): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i]);
		}
	},

	onRemove: function (map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i]);
		}
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});


// @factory L.layerGroup(layers: Layer[])
// Create a layer group, optionally given an initial set of layers.
L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};

/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

L.FeatureGroup = L.LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		L.LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the top of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new L.LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};

/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

L.Renderer = L.Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1
	},

	initialize: function (options) {
		L.setOptions(this, options);
		L.stamp(this);
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
	},

	onRemove: function () {
		L.DomUtil.remove(this._container);
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = L.DomUtil.getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),

		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(this._container, topLeftOffset, scale);
		} else {
			L.DomUtil.setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);
	},

	_update: function () {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});


L.Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			renderer = this._renderer = (this.options.preferCanvas && L.canvas()) || L.svg();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = (L.SVG && L.svg({pane: name})) || (L.Canvas && L.canvas({pane: name}));
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});

/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

L.Path = L.Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
		this._renderer.on('update', this._update, this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
		this._renderer.off('update', this._update, this);
	},

	getEvents: function () {
		return {
			zoomend: this._project,
			viewreset: this._reset
		};
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		L.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in children classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);
	}
});

/*
 * @namespace LineUtil
 *
 * Various utility functions for polyine points processing, used by Leaflet internally to make polylines lightning-fast.
 */

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	// @function simplify(points: Point[], tolerance: Number): Point[]
	// Dramatically reduces the number of points in a polyline while retaining
	// its shape and returns a new array of simplified points, using the
	// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
	// Used for a huge performance boost when processing/displaying Leaflet polylines for
	// each zoom level and also reducing visual noise. tolerance affects the amount of
	// simplification (lesser value means higher quality but slower and with more points).
	// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
	simplify: function (points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
	// Returns the distance between point `p` and segment `p1` to `p2`.
	pointToSegmentDistance:  function (p, p1, p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
	// Returns the closest point from a point `p` on a segment `p1` to `p2`.
	closestPointOnSegment: function (p, p1, p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},


	// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
	// Clips the segment a to b by rectangular bounds with the
	// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
	// (modifying the segment points directly!). Used by Leaflet to only show polyline
	// points that are on the screen or near, increasing performance.
	clipSegment: function (a, b, bounds, useLastCode, round) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			}

			// if a,b is outside the clip window (trivial reject)
			if (codeA & codeB) {
				return false;
			}

			// other cases
			codeOut = codeA || codeB;
			p = this._getEdgeIntersection(a, b, codeOut, bounds, round);
			newCode = this._getBitCode(p, bounds);

			if (codeOut === codeA) {
				a = p;
				codeA = newCode;
			} else {
				b = p;
				codeB = newCode;
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds, round) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new L.Point(x, y, round);
	},

	_getBitCode: function (p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};

/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[-122.68, 45.51],
 * 	[-122.43, 37.77],
 * 	[-118.2, 34.04]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[-122.68, 45.51],
 * 	 [-122.43, 37.77],
 * 	 [-118.2, 34.04]],
 * 	[[-73.91, 40.78],
 * 	 [-87.62, 41.83],
 * 	 [-96.72, 32.76]]
 * ];
 * ```
 */

L.Polyline = L.Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		L.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = L.LineUtil._sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = L.latLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new L.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = L.Polyline._flat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = L.latLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new L.Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
		    p = new L.Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof L.LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = L.LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};

L.Polyline._flat = function (latlngs) {
	// true if it's a flat array of latlngs; false if nested
	return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
};

/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

L.PolyUtil = {};

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a seperate method for it.
 */
L.PolyUtil.clipPolygon = function (points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds, round);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds, round);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};

/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
 *   [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
 *     [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
 *   ],
 *   [ // second polygon
 *     [[-109.05, 37],[-109.03, 41],[-102.05, 41],[-102.04, 37],[-109.05, 38]]
 *   ]
 * ];
 * ```
 */

L.Polygon = L.Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, j, p1, p2, f, area, x, y, center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		L.Polyline.prototype._setLatLngs.call(this, latlngs);
		if (L.Polyline._flat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new L.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	}
});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};

/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Retangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};

/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

L.CircleMarker = L.Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		L.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};

/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

L.Circle = L.CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = L.extend({}, legacyOptions, {radius: options});
		}
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new L.LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: L.Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === L.CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / L.CRS.Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1);

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
L.circle = function (latlng, options, legacyOptions) {
	return new L.Circle(latlng, options, legacyOptions);
};

/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.SVG = L.Renderer.extend({

	getEvents: function () {
		var events = L.Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = L.SVG.create('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = L.SVG.create('g');
		this._container.appendChild(this._rootGroup);
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		L.DomUtil.setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = L.SVG.create('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			L.DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			L.DomUtil.addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		L.DomUtil.remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = layer._radius,
		    r2 = layer._radiusY || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc + (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._path);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._path);
	}
});


// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:
L.extend(L.SVG, {
	// @function create(name: String): SVGElement
	// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
	// corresponding to the class name passed. For example, using 'line' will return
	// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
	create: function (name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	},

	// @function pointsToPath(rings: Point[], closed: Boolean): String
	// Generates a SVG path string for multiple rings, with each ring turning
	// into "M..L..L.." instructions
	pointsToPath: function (rings, closed) {
		var str = '',
		    i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (L.Browser.svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}
});

// @namespace Browser; @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
L.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);


// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
L.svg = function (options) {
	return L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;
};

/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

/*
 * @class SVG
 *
 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// @namespace Browser; @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

// redefine some SVG methods to handle VML syntax which is similar but with some differences
L.SVG.include(!L.Browser.vml ? {} : {

	_initContainer: function () {
		this._container = L.DomUtil.create('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		L.Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function (layer) {
		var container = layer._container = L.SVG.create('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = L.SVG.create('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		L.DomUtil.remove(container);
		layer.removeInteractiveTarget(container);
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = L.SVG.create('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = L.SVG.create('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._container);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._container);
	}
});

if (L.Browser.vml) {
	L.SVG.create = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();
}

/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.Canvas = L.Renderer.extend({

	onAdd: function () {
		L.Renderer.prototype.onAdd.call(this);

		this._layers = this._layers || {};

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		L.DomEvent
			.on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)
			.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)
			.on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		this._drawnLayers = {};

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = L.Browser.retina ? 2 : 1;

		L.DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (L.Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[L.stamp(layer)] = layer;
	},

	_addPath: L.Util.falseFn,

	_removePath: function (layer) {
		layer._removed = true;
		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		this._redrawBounds = layer._pxBounds;
		this._draw(true);
		layer._project();
		layer._update();
		this._draw();
		this._redrawBounds = null;
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (layer.options.dashArray) {
			var parts = layer.options.dashArray.split(','),
			    dashArray = [],
			    i;
			for (i = 0; i < parts.length; i++) {
				dashArray.push(Number(parts[i]));
			}
			layer.options._dashArray = dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		var padding = (layer.options.weight || 0) + 1;
		this._redrawBounds = this._redrawBounds || new L.Bounds();
		this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
		this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));

		this._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);
	},

	_redraw: function () {
		this._redrawRequest = null;

		this._draw(true); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_draw: function (clear) {
		this._clear = clear;
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);
			this._ctx.clip();
		}

		for (var id in this._layers) {
			layer = this._layers[id];
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
			if (clear && layer._removed) {
				delete layer._removed;
				delete this._layers[id];
			}
		}
		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) { return; }

		this._drawnLayers[layer._leaflet_id] = layer;

		ctx.beginPath();

		if (ctx.setLineDash) {
			ctx.setLineDash(layer.options && layer.options._dashArray || []);
		}

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = layer._radius,
		    s = (layer._radiusY || r) / r;

		this._drawnLayers[layer._leaflet_id] = layer;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var clear = this._clear,
		    options = layer.options;

		ctx.globalCompositeOperation = clear ? 'destination-out' : 'source-over';

		if (options.fill) {
			ctx.globalAlpha = clear ? 1 : options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			ctx.globalAlpha = clear ? 1 : options.opacity;

			// if clearing shape, do it with the previously drawn line width
			layer._prevWeight = ctx.lineWidth = clear ? layer._prevWeight + 1 : options.weight;

			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layers = [], layer;

		for (var id in this._layers) {
			layer = this._layers[id];
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				L.DomEvent._fakeStop(e);
				layers.push(layer);
			}
		}
		if (layers.length)  {
			this._fireEvent(layers, e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseOut(e, point);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e, point) {
		var layer = this._hoveredLayer;
		if (layer && (e.type === 'mouseout' || !layer._containsPoint(point))) {
			// if we're leaving the layer, fire mouseout
			L.DomUtil.removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function (e, point) {
		var id, layer;

		for (id in this._drawnLayers) {
			layer = this._drawnLayers[id];
			if (layer.options.interactive && layer._containsPoint(point)) {
				L.DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([layer], e, 'mouseover');
				this._hoveredLayer = layer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	// TODO _bringToFront & _bringToBack, pretty tricky

	_bringToFront: L.Util.falseFn,
	_bringToBack: L.Util.falseFn
});

// @namespace Browser; @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @namespace Canvas
// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
L.canvas = function (options) {
	return L.Browser.canvas ? new L.Canvas(options) : null;
};

L.Polyline.prototype._containsPoint = function (p, closed) {
	var i, j, k, len, len2, part,
	    w = this._clickTolerance();

	if (!this._pxBounds.contains(p)) { return false; }

	// hit detection for polylines
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			if (!closed && (j === 0)) { continue; }

			if (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
				return true;
			}
		}
	}
	return false;
};

L.Polygon.prototype._containsPoint = function (p) {
	var inside = false,
	    part, p1, p2, i, j, k, len, len2;

	if (!this._pxBounds.contains(p)) { return false; }

	// ray casting algorithm for detecting if point is in polygon
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			p1 = part[j];
			p2 = part[k];

			if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
				inside = !inside;
			}
		}
	}

	// also check if it's on polygon stroke
	return inside || L.Polyline.prototype._containsPoint.call(this, p, true);
};

L.CircleMarker.prototype._containsPoint = function (p) {
	return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
};

/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

L.GeoJSON = L.FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to include a feature or not.
	 * The default is to include all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 * Note: dynamically changing the `filter` option will have effect only on newly
	 * added data. It will _not_ re-evaluate already included features.
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 */

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): Layer
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer ): Layer
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = L.Util.extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): Layer
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:
L.extend(L.GeoJSON, {
	// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
	// Creates a `Layer` from a given GeoJSON feature. Can use a custom
	// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
	// functions if provided as options.
	geometryToLayer: function (geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry ? geometry.coordinates : null,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
		    latlng, latlngs, i, len;

		if (!coords && !geometry) {
			return null;
		}

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);
			return new L.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
			return new L.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	// @function coordsToLatLng(coords: Array): LatLng
	// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
	// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
	coordsToLatLng: function (coords) {
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
	// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
	// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
	// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	// @function latLngToCoords(latlng: LatLng): Array
	// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
	latLngToCoords: function (latlng) {
		return latlng.alt !== undefined ?
				[latlng.lng, latlng.lat, latlng.alt] :
				[latlng.lng, latlng.lat];
	},

	// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
	// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
	// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
	latLngsToCoords: function (latlngs, levelsDeep, closed) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				L.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :
				L.GeoJSON.latLngToCoords(latlngs[i]));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ?
				L.extend({}, layer.feature, {geometry: newGeometry}) :
				L.GeoJSON.asFeature(newGeometry);
	},

	// @function asFeature(geojson: Object): Object
	// Normalize GeoJSON geometries/features into GeoJSON features.
	asFeature: function (geojson) {
		if (geojson.type === 'Feature') {
			return geojson;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geojson
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
L.Polyline.prototype.toGeoJSON = function () {
	var multi = !L.Polyline._flat(this._latlngs);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'LineString',
		coordinates: coords
	});
};

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
L.Polygon.prototype.toGeoJSON = function () {
	var holes = !L.Polyline._flat(this._latlngs),
	    multi = holes && !L.Polyline._flat(this._latlngs[0]);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);

	if (!holes) {
		coords = [coords];
	}

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'Polygon',
		coordinates: coords
	});
};


// @namespace LayerGroup
L.LayerGroup.include({
	toMultiPoint: function () {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON().geometry.coordinates);
		});

		return L.GeoJSON.getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `GeometryCollection`).
	toGeoJSON: function () {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint();
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON();
				jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
			}
		});

		if (isGeometryCollection) {
			return L.GeoJSON.getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
L.geoJSON = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};
// Backward compatibility.
L.geoJson = L.geoJSON;

/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.



var eventsKey = '_leaflet_events';

L.DomEvent = {

	// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Adds a listener function (`fn`) to a particular DOM event type of the
	// element `el`. You can optionally specify the context of the listener
	// (object the `this` keyword will point to). You can also pass several
	// space-separated types (e.g. `'click dblclick'`).

	// @alternative
	// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
	// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	on: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._on(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(obj, types[i], fn, context);
			}
		}

		return this;
	},

	// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Removes a previously added listener function. If no function is specified,
	// it will remove all the listeners of that particular DOM event from the element.
	// Note that if you passed a custom context to on, you must pass the same
	// context to `off` in order to remove the listener.

	// @alternative
	// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
	// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	off: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._off(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(obj, types[i], fn, context);
			}
		}

		return this;
	},

	_on: function (obj, type, fn, context) {
		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.addPointerListener(obj, type, handler, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);

		} else if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (L.DomEvent._isExternalTarget(obj, e)) {
						originalHandler(e);
					}
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && L.Browser.android) {
					handler = function (e) {
						return L.DomEvent._filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;

		return this;
	},

	_off: function (obj, type, fn, context) {

		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;

		return this;
	},

	// @function stopPropagation(ev: DOMEvent): this
	// Stop the given event from propagation to parent elements. Used inside the listener functions:
	// ```js
	// L.DomEvent.on(div, 'click', function (ev) {
	// 	L.DomEvent.stopPropagation(ev);
	// });
	// ```
	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else if (e.originalEvent) {  // In case of Leaflet event.
			e.originalEvent._stopped = true;
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	// @function disableScrollPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
	disableScrollPropagation: function (el) {
		return L.DomEvent.on(el, 'mousewheel', L.DomEvent.stopPropagation);
	},

	// @function disableClickPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
	// `'mousedown'` and `'touchstart'` events (plus browser variants).
	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		L.DomEvent.on(el, L.Draggable.START.join(' '), stop);

		return L.DomEvent.on(el, {
			click: L.DomEvent._fakeStop,
			dblclick: stop
		});
	},

	// @function preventDefault(ev: DOMEvent): this
	// Prevents the default action of the DOM Event `ev` from happening (such as
	// following a link in the href of the a element, or doing a POST request
	// with page reload when a `<form>` is submitted).
	// Use it inside listener functions.
	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	// @function stop(ev): this
	// Does `stopPropagation` and `preventDefault` at the same time.
	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
	// Gets normalized mouse position from a DOM event relative to the
	// `container` or to the whole page if not specified.
	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
	// and Firefox scrolls device pixels, not CSS pixels
	_wheelPxFactor: (L.Browser.win && L.Browser.chrome) ? 2 :
	                L.Browser.gecko ? window.devicePixelRatio :
	                1,

	// @function getWheelDelta(ev: DOMEvent): Number
	// Gets normalized wheel delta from a mousewheel DOM event, in vertical
	// pixels scrolled (negative if scrolling down).
	// Events from pointing devices without precise scrolling are mapped to
	// a best guess of 60 pixels.
	getWheelDelta: function (e) {
		return (L.Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / L.DomEvent._wheelPxFactor : // Pixels
		       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		       0;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_isExternalTarget: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		    elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		handler(e);
	}
};

// @function addListener(): this
// Alias to [`L.DomEvent.on`](#domevent-on)
L.DomEvent.addListener = L.DomEvent.on;

// @function removeListener(): this
// Alias to [`L.DomEvent.off`](#domevent-off)
L.DomEvent.removeListener = L.DomEvent.off;

/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

L.Draggable = L.Evented.extend({

	options: {
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline: Boolean)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		L.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		L.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (L.DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (L.Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches) || !this._enabled) { return; }
		L.Draggable._dragging = true;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			L.DomUtil.preventOutline(this._element);
		}

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);

		L.DomEvent
			.on(document, L.Draggable.MOVE[e.type], this._onMove, this)
			.on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		L.DomUtil.setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		L.DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
				.off(document, L.Draggable.MOVE[i], this._onMove, this)
				.off(document, L.Draggable.END[i], this._onUp, this);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		L.Draggable._dragging = false;
	}
});

/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});

/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !L.Browser.android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second.
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				down: this._onDown,
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		L.DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-grab');
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDown: function () {
		this._map._stop();
	},

	_onDragStart: function () {
		var map = this._map;

		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = L.latLngBounds(this._map.options.maxBounds);

			this._offsetLimit = L.bounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,

		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);

/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

L.Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);

/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);

/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

L.PosAnimation = L.Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		L.DomUtil.setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});

/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	}
});

/*
 * Extends L.Map to handle zoom animations.
 */

// @namespace Map
// @section Animation Options
L.Map.mergeOptions({
	// @option zoomAnimation: Boolean = true
	// Whether the map zoom animation is enabled. By default it's enabled
	// in all browsers that support CSS3 Transitions except Android.
	zoomAnimation: true,

	// @option zoomAnimationThreshold: Number = 4
	// Won't animate zoom if the zoom difference exceeds this value.
	zoomAnimationThreshold: 4
});

var zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera;

if (zoomAnimated) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {

			this._createAnimProxy();

			L.DomEvent.on(this._proxy, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!zoomAnimated ? {} : {

	_createAnimProxy: function () {

		var proxy = this._proxy = L.DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = L.DomUtil.TRANSFORM,
			    transform = proxy.style[prop];

			L.DomUtil.setTransform(proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			L.DomUtil.setTransform(proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		L.Util.requestAnimFrame(function () {
			this
			    ._moveStart(true)
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired on every frame of a zoom animation
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		L.Util.requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @namespace Map
// @section Methods for modifying map state
L.Map.include({

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !L.Browser.any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = L.latLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = (to.distanceTo(from)) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
			    // thus triggering an infinite loop in flyTo
			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = L.Util.requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	}
});

/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last, touch,
		    doubleTap = false,
		    delay = 250;

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				count = L.DomEvent._pointersCount;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd() {
			if (doubleTap && !touch.cancelBubble) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = {},
					    prop, i;

					for (i in touch) {
						prop = touch[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}

		var pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend;

		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;
		obj[pre + 'dblclick' + id] = handler;

		obj.addEventListener(touchstart, onTouchStart, false);
		obj.addEventListener(touchend, onTouchEnd, false);

		// On some platforms (notably, chrome on win10 + touchscreen + mouse),
		// the browser doesn't fire touchend/pointerup events but does fire
		// native dblclicks. See #4127.
		if (!L.Browser.edge) {
			obj.addEventListener('dblclick', handler, false);
		}

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_',
		    touchstart = obj[pre + this._touchstart + id],
		    touchend = obj[pre + this._touchend + id],
		    dblclick = obj[pre + 'dblclick' + id];

		obj.removeEventListener(this._touchstart, touchstart, false);
		obj.removeEventListener(this._touchend, touchend, false);
		if (!L.Browser.edge) {
			obj.removeEventListener('dblclick', dblclick, false);
		}

		return this;
	}
});

/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	POINTER_DOWN:   L.Browser.msPointer ? 'MSPointerDown'   : 'pointerdown',
	POINTER_MOVE:   L.Browser.msPointer ? 'MSPointerMove'   : 'pointermove',
	POINTER_UP:     L.Browser.msPointer ? 'MSPointerUp'     : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
	TAG_WHITE_LIST: ['INPUT', 'SELECT', 'OPTION'],

	_pointers: {},
	_pointersCount: 0,

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		if (type === 'touchstart') {
			this._addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			this._addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			this._addPointerEnd(obj, handler, id);
		}

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(this.POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(this.POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(this.POINTER_UP, handler, false);
			obj.removeEventListener(this.POINTER_CANCEL, handler, false);
		}

		return this;
	},

	_addPointerStart: function (obj, handler, id) {
		var onDown = L.bind(function (e) {
			if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				// In IE11, some touch events needs to fire for form controls, or
				// the controls will stop working. We keep a whitelist of tag names that
				// need these events. For other target tags, we prevent default on the event.
				if (this.TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
					L.DomEvent.preventDefault(e);
				} else {
					return;
				}
			}

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(this.POINTER_DOWN, onDown, false);

		// need to keep track of what pointers and how many are active to provide e.touches emulation
		if (!this._pointerDocListener) {
			var pointerUp = L.bind(this._globalPointerUp, this);

			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_DOWN, L.bind(this._globalPointerDown, this), true);
			document.documentElement.addEventListener(this.POINTER_MOVE, L.bind(this._globalPointerMove, this), true);
			document.documentElement.addEventListener(this.POINTER_UP, pointerUp, true);
			document.documentElement.addEventListener(this.POINTER_CANCEL, pointerUp, true);

			this._pointerDocListener = true;
		}
	},

	_globalPointerDown: function (e) {
		this._pointers[e.pointerId] = e;
		this._pointersCount++;
	},

	_globalPointerMove: function (e) {
		if (this._pointers[e.pointerId]) {
			this._pointers[e.pointerId] = e;
		}
	},

	_globalPointerUp: function (e) {
		delete this._pointers[e.pointerId];
		this._pointersCount--;
	},

	_handlePointer: function (e, handler) {
		e.touches = [];
		for (var i in this._pointers) {
			e.touches.push(this._pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	},

	_addPointerMove: function (obj, handler, id) {
		var onMove = L.bind(function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(this.POINTER_MOVE, onMove, false);
	},

	_addPointerEnd: function (obj, handler, id) {
		var onUp = L.bind(function (e) {
			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(this.POINTER_UP, onUp, false);
		obj.addEventListener(this.POINTER_CANCEL, onUp, false);
	}
});

/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: L.Browser.touch && !L.Browser.android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;


		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true);
			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);

		var moveFn = L.bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);

		L.DomEvent.preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);

/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		L.DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}

/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_resetState: function () {
		this._moved = false;
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		this._resetState();

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		L.DomEvent.on(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);
			L.DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new L.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		L.DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			L.DomUtil.remove(this._box);
			L.DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent.off(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		setTimeout(L.bind(this._resetState, this), 0);

		var bounds = new L.LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);

/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
L.Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		L.DomEvent.on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		L.DomEvent.off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			offset = this._panKeys[key];
			if (e.shiftKey) {
				offset = L.point(offset).multiplyBy(3);
			}

			map.panBy(offset);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27) {
			map.closePopup();

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);

/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch).
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		L.DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function (e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});

/*
 * @class Control
 * @aka L.Control
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		L.DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		L.DomUtil.remove(this._controlContainer);
	}
});

/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

L.Control.Zoom = L.Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '-'
		// The text set on the 'zoom out' button.
		zoomOutText: '-',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		L.DomEvent
		    .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
		    .on(link, 'click', L.DomEvent.stop)
		    .on(link, 'click', fn, this)
		    .on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
		    className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};

/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

L.Control.Attribution = L.Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		if (L.DomEvent) {
			L.DomEvent.disableClickPropagation(this._container);
		}

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new L.Control.Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};

/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

L.Control.Scale = L.Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
L.control.scale = function (options) {
	return new L.Control.Scale(options);
};

/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control.html)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */


L.Control.Layers = L.Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		return this._container;
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(L.stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
		this._form.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._form.clientHeight) {
			L.DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
			this._form.style.height = acceptableHeight + 'px';
		} else {
			L.DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		L.DomEvent.disableClickPropagation(container);
		if (!L.Browser.touch) {
			L.DomEvent.disableScrollPropagation(container);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent.on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}

			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this.expand, this);
			} else {
				L.DomEvent.on(link, 'focus', this.expand, this);
			}

			// work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this.collapse, this);
			// TODO keyboard accessibility
		} else {
			this.expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && L.stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		layer.on('add remove', this._onLayerChange, this);

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) { return this; }

		L.DomUtil.empty(this._baseLayersList);
		L.DomUtil.empty(this._overlaysList);

		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(L.stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input, layer, hasLayer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			hasLayer = this._map.hasLayer(layer);

			if (input.checked && !hasLayer) {
				addedLayers.push(layer);

			} else if (!input.checked && hasLayer) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			this._map.removeLayer(removedLayers[i]);
		}
		for (i = 0; i < addedLayers.length; i++) {
			this._map.addLayer(addedLayers[i]);
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};

/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

// @namespace Map

L.Map.include({
	// @section Geolocation methods
	_defaultLocateOptions: {
		timeout: 10000,
		watch: false
		// setView: false
		// maxZoom: <Number>
		// maximumAge: 0
		// enableHighAccuracy: false
	},

	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = L.extend({}, this._defaultLocateOptions, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
		    onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	}
});

},{}],8:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],9:[function(_dereq_,module,exports){
(function(window, undefined) {
    'use strict';

    if (!window) return; // Server side

var
    _baron = window.baron, // Stored baron value for noConflict usage
    $ = window.jQuery, // Trying to use jQuery
    origin = {
        v: { // Vertical
            x: 'Y', pos: 'top', crossPos: 'left', size: 'height', crossSize: 'width',
            client: 'clientHeight', crossClient: 'clientWidth', offset: 'offsetHeight', crossOffset: 'offsetWidth', offsetPos: 'offsetTop',
            scroll: 'scrollTop', scrollSize: 'scrollHeight'
        },
        h: { // Horizontal
            x: 'X', pos: 'left', crossPos: 'top', size: 'width', crossSize: 'height',
            client: 'clientWidth', crossClient: 'clientHeight', offset: 'offsetWidth', crossOffset: 'offsetHeight', offsetPos: 'offsetLeft',
            scroll: 'scrollLeft', scrollSize: 'scrollWidth'
        }
    },

    each = function(obj, iterator) {
        var i = 0;

        if (obj.length === undefined || obj === window) obj = [obj];

        while (obj[i]) {
            iterator.call(this, obj[i], i);
            i++;
        }
    },

    baron = function(params) { // this - window or jQuery instance
        var jQueryMode = false,//(this && this[0] && this[0].nodeType),
            roots,
            $;

        params = params || {};
        $ = params.$ || window.jQuery;

        if (jQueryMode) {
            params.root = roots = this;
        } else {
            roots = $(params.root || params.scroller);
        }

        return new baron.fn.constructor(roots, params, $);
    };

    baron.fn = {
        constructor: function(roots, input, $) {
            var params = validate(input);

            params.$ = $;
            each.call(this, roots, function(root, i) {
                var localParams = clone(params);

                if (params.root && params.scroller) {
                    localParams.scroller = params.$(params.scroller, root);
                    if (!localParams.scroller.length) {
                        localParams.scroller = root;
                    }
                } else {
                    localParams.scroller = root;
                }

                localParams.root = root;
                this[i] = init(localParams);
                this.length = i + 1;
            });

            this.params = params;
        },

        dispose: function() {
            var params = this.params;

            each(this, function(item) {
                item.dispose(params);
            });
            this.params = null;
        },

        update: function() {
            var i = 0;

            while (this[i]) {
                this[i].update.apply(this[i], arguments);
                i++;
            }
        },

        baron: function(params) {
            params.root = [];
            params.scroller = this.params.scroller;

            each.call(this, this, function(elem) {
                params.root.push(elem.root);
            });
            params.direction = (this.params.direction == 'v') ? 'h' : 'v';
            params._chain = true;

            return baron(params);
        }
    };

    function manageEvents(item, eventManager, mode) {
        item._eventHandlers = item._eventHandlers || [ // Creating new functions for one baron item only one time
            {
                // onScroll:
                element: item.scroller,

                handler: function(e) {
                    item.scroll(e);
                },

                type: 'scroll'
            }, {
                // onMouseDown:
                element: item.bar,

                handler: function(e) {
                    e.preventDefault ? e.preventDefault() : e.returnValue = false; // Text selection disabling in Opera... and all other browsers?
                    item.selection(); // Disable text selection in ie8
                    item.drag.now = 1; // Save private byte
                },

                type: 'touchstart mousedown'
            }, {
                // onMouseUp:
                element: document,

                handler: function() {
                    item.selection(1); // Enable text selection
                    item.drag.now = 0;
                },

                type: 'mouseup blur touchend'
            }, {
                // onCoordinateReset:
                element: item.bar,

                handler: function(e) {
                    if (e.button != 2) { // Not RM
                        item._pos0(e);
                    }
                },

                type: 'touchstart mousedown'
            }, {
                // onMouseMove:
                element: document,

                handler: function(e) {
                    if (item.drag.now) {
                        item.drag(e);
                    }
                },

                type: 'mousemove touchmove'
            }, {
                // onResize:
                element: window,

                handler: function() {
                    item.update();
                },

                type: 'resize'
            }, {
                // sizeChange:
                element: item.root,

                handler: function() {
                    item.update();
                },

                type: 'sizeChange'
            }
        ];

        each(item._eventHandlers, function(event) {
            if (event.element) {
                eventManager(event.element, event.type, event.handler, mode);
            }
        });

        // if (item.scroller) {
        //     event(item.scroller, 'scroll', item._eventHandlers.onScroll, mode);
        // }
        // if (item.bar) {
        //     event(item.bar, 'touchstart mousedown', item._eventHandlers.onMouseDown, mode);
        // }
        // event(document, 'mouseup blur touchend', item._eventHandlers.onMouseUp, mode);
        // event(document, 'touchstart mousedown', item._eventHandlers.onCoordinateReset, mode);
        // event(document, 'mousemove touchmove', item._eventHandlers.onMouseMove, mode);
        // event(window, 'resize', item._eventHandlers.onResize, mode);
        // if (item.root) {
        //     event(item.root, 'sizeChange', item._eventHandlers.onResize, mode); // Custon event for alternate baron update mechanism
        // }
    }

    function manageAttr(node, direction, mode) {
        var attrName = 'data-baron-' + direction;

        if (mode == 'on') {
            node.setAttribute(attrName, 'inited');
        } else if (mode == 'off') {
            node.removeAttribute(attrName);
        } else {
            return node.getAttribute(attrName);
        }
    }

    function init(params) {
        if (manageAttr(params.root, params.direction)) return;

        var out = new item.prototype.constructor(params); // __proto__ of returning object is baron.prototype

        manageEvents(out, params.event, 'on');

        manageAttr(out.root, params.direction, 'on');

        out.update();

        return out;
    }

    function clone(input) {
        var output = {};

        input = input || {};

        for (var key in input) {
            if (input.hasOwnProperty(key)) {
                output[key] = input[key];
            }
        }

        return output;
    }

    function validate(input) {
        var output = clone(input);

        output.direction = output.direction || 'v';

        var event = input.event || function(elem, event, func, mode) {
            output.$(elem)[mode || 'on'](event, func);
        };

        output.event = function(elems, e, func, mode) {
            each(elems, function(elem) {
                event(elem, e, func, mode);
            });
        };

        return output;
    }

    function fire(eventName) {
        /* jshint validthis:true */
        if (this.events && this.events[eventName]) {
            for (var i = 0 ; i < this.events[eventName].length ; i++) {
                var args = Array.prototype.slice.call( arguments, 1 );

                this.events[eventName][i].apply(this, args);
            }
        }
    }

    var item = {};

    item.prototype = {
        constructor: function(params) {
            var $,
                barPos,
                scrollerPos0,
                track,
                resizePauseTimer,
                scrollPauseTimer,
                pause,
                scrollLastFire,
                resizeLastFire;

            resizeLastFire = scrollLastFire = new Date().getTime();

            $ = this.$ = params.$;
            this.event = params.event;
            this.events = {};

            function getNode(sel, context) {
                return $(sel, context)[0]; // Can be undefined
            }

            // DOM elements
            this.root = params.root; // Always html node, not just selector
            this.scroller = getNode(params.scroller); // (params.scroller) ? getNode(params.scroller, this.root) : this.root;
            this.bar = getNode(params.bar, this.root);
            track = this.track = getNode(params.track, this.root);
            if (!this.track && this.bar) {
                track = this.bar.parentNode;
            }
            this.clipper = this.scroller.parentNode;

            // Parameters
            this.direction = params.direction;
            this.origin = origin[this.direction];
            this.barOnCls = params.barOnCls;
            this.barTopLimit = 0;
            pause = params.pause * 1000 || 0;

            // Updating height or width of bar
            function setBarSize(size) {
                /* jshint validthis:true */
                var barMinSize = this.barMinSize || 20;

                if (size > 0 && size < barMinSize) {
                    size = barMinSize;
                }

                if (this.bar) {
                    $(this.bar).css(this.origin.size, parseInt(size, 10) + 'px');
                }
            }

            // Updating top or left bar position
            function posBar(pos) {
                /* jshint validthis:true */
                if (this.bar) {
                    $(this.bar).css(this.origin.pos, +pos + 'px');
                }
            }

            // Free path for bar
            function k() {
                /* jshint validthis:true */
                return track[this.origin.client] - this.barTopLimit - this.bar[this.origin.offset];
            }

            // Relative content top position to bar top position
            function relToPos(r) {
                /* jshint validthis:true */
                return r * k.call(this) + this.barTopLimit;
            }

            // Bar position to relative content position
            function posToRel(t) {
                /* jshint validthis:true */
                return (t - this.barTopLimit) / k.call(this);
            }

            // Cursor position in main direction in px // Now with iOs support
            this.cursor = function(e) {
                return e['client' + this.origin.x] || (((e.originalEvent || e).touches || {})[0] || {})['page' + this.origin.x];
            };

            // Text selection pos preventing
            function dontPosSelect() {
                return false;
            }

            this.pos = function(x) { // Absolute scroller position in px
                var ie = 'page' + this.origin.x + 'Offset',
                    key = (this.scroller[ie]) ? ie : this.origin.scroll;

                if (x !== undefined) this.scroller[key] = x;

                return this.scroller[key];
            };

            this.rpos = function(r) { // Relative scroller position (0..1)
                var free = this.scroller[this.origin.scrollSize] - this.scroller[this.origin.client],
                    x;

                if (r) x = this.pos(r * free);
                else x = this.pos();

                return x / (free || 1);
            };

            // Switch on the bar by adding user-defined CSS classname to scroller
            this.barOn = function(dispose) {
                if (this.barOnCls) {
                    if (dispose || this.scroller[this.origin.client] >= this.scroller[this.origin.scrollSize]) {
                        $(this.root).removeClass(this.barOnCls);
                    } else {
                        $(this.root).addClass(this.barOnCls);
                    }
                }
            };

            this._pos0 = function(e) {
                scrollerPos0 = this.cursor(e) - barPos;
            };

            this.drag = function(e) {
                this.scroller[this.origin.scroll] = posToRel.call(this, this.cursor(e) - scrollerPos0) * (this.scroller[this.origin.scrollSize] - this.scroller[this.origin.client]);
            };

            // Text selection preventing on drag
            this.selection = function(enable) {
                this.event(document, 'selectpos selectstart', dontPosSelect, enable ? 'off' : 'on');
            };

            // onResize & DOM modified handler
            this.resize = function() {
                var self = this,
                    delay = 0;

                if (new Date().getTime() - resizeLastFire < pause) {
                    clearTimeout(resizePauseTimer);
                    delay = pause;
                }

                function upd() {
                    var delta = self.scroller[self.origin.crossOffset] - self.scroller[self.origin.crossClient];

                    if (params.freeze && !self.clipper.style[self.origin.crossSize]) { // Sould fire only once
                        $(self.clipper).css(self.origin.crossSize, self.clipper[self.origin.crossClient] - delta + 'px');
                    }
                    $(self.scroller).css(self.origin.crossSize, self.clipper[self.origin.crossClient] + delta + 'px');

                    Array.prototype.unshift.call(arguments, 'resize');
                    fire.apply(self, arguments);

                    resizeLastFire = new Date().getTime();
                }

                if (delay) {
                    resizePauseTimer = setTimeout(upd, delay);
                } else {
                    upd();
                }
            };

            // onScroll handler
            this.scroll = function() {
                var oldBarSize, newBarSize,
                    delay = 0,
                    self = this;

                if (new Date().getTime() - scrollLastFire < pause) {
                    clearTimeout(scrollPauseTimer);
                    delay = pause;
                }

                function upd() {
                    if (self.bar) {
                        newBarSize = (track[self.origin.client] - self.barTopLimit) * self.scroller[self.origin.client] / self.scroller[self.origin.scrollSize];

                        // Positioning bar
                        if (oldBarSize != newBarSize) {
                            setBarSize.call(self, newBarSize);
                            oldBarSize = newBarSize;
                        }

                        barPos = relToPos.call(self, self.rpos());

                        posBar.call(self, barPos);
                    }

                    Array.prototype.unshift.call( arguments, 'scroll' );
                    fire.apply(self, arguments);

                    scrollLastFire = new Date().getTime();
                }

                if (delay) {
                    scrollPauseTimer = setTimeout(upd, delay);
                } else {
                    upd();
                }

            };

            return this;
        },

        update: function(params) {
            fire.call(this, 'upd', params); //    

            this.resize(1);
            this.barOn();
            this.scroll();

            return this;
        },

        dispose: function(params) {
            manageEvents(this, this.event, 'off');
            manageAttr(this.root, params.direction, 'off');
            $(this.scroller).css(this.origin.crossSize, '');
            this.barOn(true);
            fire.call(this, 'dispose');
        },

        on: function(eventName, func, arg) {
            var names = eventName.split(' ');

            for (var i = 0 ; i < names.length ; i++) {
                if (names[i] == 'init') {
                    func.call(this, arg);
                } else {
                    this.events[names[i]] = this.events[names[i]] || [];

                    this.events[names[i]].push(function(userArg) {
                        func.call(this, userArg || arg);
                    });
                }
            }
        }
    };

    baron.fn.constructor.prototype = baron.fn;
    item.prototype.constructor.prototype = item.prototype;

    // Use when you need "baron" global var for another purposes
    baron.noConflict = function() {
        window.baron = _baron; // Restoring original value of "baron" global var
        return baron;
    };

    baron.version = '0.6.6';

    if ($ && $.fn) { // Adding baron to jQuery as plugin
        $.fn.baron = baron;
    }
    window.baron = baron; // Use noConflict method if you need window.baron var for another purposes

    var fix = function(userParams) {
        var elements, viewPortSize,
            params = { // Default params
                outside: '',
                before: '',
                after: '',
                past: '',
                future: '',
                radius: 0,
                minView: 0
            },
            topFixHeights = [], // inline style for element
            topRealHeights = [], // real offset position when not fixed
            headerTops = [],
            scroller = this.scroller,
            eventManager = this.event,
            $ = this.$,
            self = this;

        function fixElement(i, pos) {
            if (viewPortSize < (params.minView || 0)) { // No headers fixing when no enought space for viewport
                pos = undefined;
            }

            if (pos !== undefined) {
                pos += 'px';
                this.$(elements[i]).css(this.origin.pos, pos).addClass(params.outside);
            } else {
                this.$(elements[i]).css(this.origin.pos, '').removeClass(params.outside);
            }
        }

        function bubbleWheel(e) {
            try {
                i = document.createEvent('WheelEvent'); // i - for extra byte
                // evt.initWebKitWheelEvent(deltaX, deltaY, window, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
                i.initWebKitWheelEvent(e.originalEvent.wheelDeltaX, e.originalEvent.wheelDeltaY);
                scroller.dispatchEvent(i);
                e.preventDefault();
            } catch (e) {}
        }

        function init(_params) {
            var pos;

            for (var key in _params) {
                params[key] = _params[key];
            }

            elements = this.$(params.elements, this.scroller);

            if (elements) {
                viewPortSize = this.scroller[this.origin.client];
                for (var i = 0 ; i < elements.length ; i++) {
                    // Variable header heights
                    pos = {};
                    pos[this.origin.size] = elements[i][this.origin.offset];
                    if (elements[i].parentNode !== this.scroller) {
                        this.$(elements[i].parentNode).css(pos);
                    }
                    pos = {};
                    pos[this.origin.crossSize] = elements[i].parentNode[this.origin.crossClient];
                    this.$(elements[i]).css(pos);

                    // Between fixed headers
                    viewPortSize -= elements[i][this.origin.offset];

                    headerTops[i] = elements[i].parentNode[this.origin.offsetPos]; // No paddings for parentNode

                    // Summary elements height above current
                    topFixHeights[i] = (topFixHeights[i - 1] || 0); // Not zero because of negative margins
                    topRealHeights[i] = (topRealHeights[i - 1] || Math.min(headerTops[i], 0));

                    if (elements[i - 1]) {
                        topFixHeights[i] += elements[i - 1][this.origin.offset];
                        topRealHeights[i] += elements[i - 1][this.origin.offset];
                    }

                    if ( !(i == 0 && headerTops[i] == 0)/* && force */) {
                        this.event(elements[i], 'mousewheel', bubbleWheel, 'off');
                        this.event(elements[i], 'mousewheel', bubbleWheel);
                    }
                }

                if (params.limiter && elements[0]) { // Bottom edge of first header as top limit for track
                    if (this.track && this.track != this.scroller) {
                        pos = {};
                        pos[this.origin.pos] = elements[0].parentNode[this.origin.offset];
                        this.$(this.track).css(pos);
                    } else {
                        this.barTopLimit = elements[0].parentNode[this.origin.offset];
                    }
                    // this.barTopLimit = elements[0].parentNode[this.origin.offset];
                    this.scroll();
                }

                if (params.limiter === false) { // undefined (in second fix instance) should have no influence on bar limit
                    this.barTopLimit = 0;
                }
            }

            var event = {
                element: elements,

                handler: function() {
                    var parent = $(this)[0].parentNode,
                        top = parent.offsetTop,
                        num;

                    // finding num -> elements[num] === this
                    for (var i = 0 ; i < elements.length ; i++ ) {
                        if (elements[i] === this) num = i;
                    }

                    var pos = top - topFixHeights[num];

                    if (params.scroll) { // User defined callback
                        params.scroll({
                            x1: self.scroller.scrollTop,
                            x2: pos
                        });
                    } else {
                        self.scroller.scrollTop = pos;
                    }
                },

                type: 'click'
            };

            if (params.clickable) {
                this._eventHandlers.push(event); // For auto-dispose
                eventManager(event.element, event.type, event.handler, 'off');
                eventManager(event.element, event.type, event.handler, 'on');
            }
        }

        this.on('init', init, userParams);

        this.on('init scroll', function() {
            var fixState, hTop,
                fixFlag = []; // 1 - past, 2 - future, 3 - current (not fixed)

            if (elements) {
                var change;

                // fixFlag update
                for (var i = 0 ; i < elements.length ; i++) {
                    fixState = 0;
                    if (headerTops[i] - this.pos() < topRealHeights[i] + params.radius) {
                        // Header trying to go up
                        fixState = 1;
                        hTop = topFixHeights[i];
                    } else if (headerTops[i] - this.pos() > topRealHeights[i] + viewPortSize - params.radius) {
                        // Header trying to go down
                        fixState = 2;
                        hTop = topFixHeights[i] + viewPortSize;
                    } else {
                        // Header in viewport
                        fixState = 3;
                        hTop = undefined;
                    }
                    if (fixState != fixFlag[i]) {
                        fixElement.call(this, i, hTop);
                        fixFlag[i] = fixState;
                        change = true;
                    }
                }

                // Adding positioning classes (on last top and first bottom header)
                if (change) { // At leats one change in elements flag structure occured
                    for (i = 0 ; i < elements.length ; i++) {
                        if (fixFlag[i] == 1 && params.past) {
                            this.$(elements[i]).addClass(params.past).removeClass(params.future);
                        }

                        if (fixFlag[i] == 2 && params.future) {
                            this.$(elements[i]).addClass(params.future).removeClass(params.past);
                        }

                        if (fixFlag[i] == 3 && (params.future || params.past)) {
                            this.$(elements[i]).removeClass(params.past).removeClass(params.future);
                        }

                        if (fixFlag[i] != fixFlag[i + 1] && fixFlag[i] == 1 && params.before) {
                            this.$(elements[i]).addClass(params.before).removeClass(params.after); // Last top fixed header
                        } else if (fixFlag[i] != fixFlag[i - 1] && fixFlag[i] == 2 && params.after) {
                            this.$(elements[i]).addClass(params.after).removeClass(params.before); // First bottom fixed header
                        } else {
                            this.$(elements[i]).removeClass(params.before).removeClass(params.after);
                        }
                    }
                }
            }
        });

        this.on('resize upd', function(updParams) {
            init.call(this, updParams && updParams.fix);
        });
    };

    baron.fn.fix = function(params) {
        var i = 0;

        while (this[i]) {
            fix.call(this[i], params);
            i++;
        }

        return this;
    };

    var controls = function(params) {
        var forward, backward, track, screen,
            self = this; // AAAAAA!!!!!11

        screen = params.screen || 0.9;

        if (params.forward) {
            forward = this.$(params.forward, this.clipper);

            this.event(forward, 'click', function() {
                var y = self.pos() - params.delta || 30;

                self.pos(y);
            });
        }

        if (params.backward) {
            backward = this.$(params.backward, this.clipper);

            this.event(backward, 'click', function() {
                var y = self.pos() + params.delta || 30;

                self.pos(y);
            });
        }

        if (params.track) {
            if (params.track === true) {
                track = this.track;
            } else {
                track = this.$(params.track, this.clipper)[0];
            }

            if (track) {
                this.event(track, 'mousedown', function(e) {
                    var x = e['offset' + self.origin.x],
                        xBar = self.bar[self.origin.offsetPos],
                        sign = 0;

                    if (x < xBar) {
                        sign = -1;
                    } else if (x > xBar + self.bar[self.origin.offset]) {
                        sign = 1;
                    }

                    var y = self.pos() + sign * screen * self.scroller[self.origin.client];
                    self.pos(y);
                });
            }
        }

    };

    baron.fn.controls = function(params) {
        var i = 0;

        while (this[i]) {
            controls.call(this[i], params);
            i++;
        }

        return this;
    };

    var pull = function(params) {
        var block = this.$(params.block),
            size = params.size || this.origin.size,
            limit = params.limit || 80,
            onExpand = params.onExpand,
            elements = params.elements || [],
            inProgress = params.inProgress || '',
            self = this,
            _insistence = 0,
            _zeroXCount = 0,
            _interval,
            _timer,
            _x = 0,
            _onExpandCalled,
            _waiting = params.waiting || 500,
            _on;

        function getSize() {
            return self.scroller[self.origin.scroll] + self.scroller[self.origin.offset];
        }

        // Scroller content height
        function getContentSize() {
            return self.scroller[self.origin.scrollSize];
        }

        // Scroller height
        function getScrollerSize() {
            return self.scroller[self.origin.client];
        }

        function step(x, force) {
            var k = x * 0.0005;

            return Math.floor(force - k * (x + 550));
        }

        function toggle(on) {
            _on = on;

            if (on) {
                update(); // First time with no delay
                _interval = setInterval(update, 200);
            } else {
                clearInterval(_interval);
            }
        }

        function update() {
            var pos = {},
                height = getSize(),
                scrollHeight = getContentSize(),
                dx,
                op4,
                scrollInProgress = _insistence == 1;

            op4 = 0; //  
            if (_insistence > 0) {
                op4 = 40;
            }
            //if (_insistence > -1) {
                dx = step(_x, op4);
                if (height >= scrollHeight - _x && _insistence > -1) {
                    if (scrollInProgress) {
                        _x += dx;
                    }
                } else {
                    _x = 0;
                }

                if (_x < 0) _x = 0;

                pos[size] = _x + 'px';
                if (getScrollerSize() <= getContentSize()) {
                    self.$(block).css(pos);
                    for (var i = 0 ; i < elements.length ; i++) {
                        self.$(elements[i].self).css(elements[i].property, Math.min(_x / limit * 100, 100) + '%');
                    }
                }

                if (inProgress && _x) {
                    self.$(self.root).addClass(inProgress);
                }

                if (_x == 0) {
                    if (params.onCollapse) {
                        params.onCollapse();
                    }
                }

                _insistence = 0;
                _timer = setTimeout(function() {
                    _insistence = -1;
                }, _waiting);
            //}

            if (onExpand && _x > limit && !_onExpandCalled) {
                onExpand();
                _onExpandCalled = true;
            }

            if (_x == 0) {
                _zeroXCount++;
            } else {
                _zeroXCount = 0;

            }
            if (_zeroXCount > 1) {
                toggle(false);
                _onExpandCalled = false;
                if (inProgress) {
                    self.$(self.root).removeClass(inProgress);
                }
            }
        }

        this.on('init', function() {
            toggle(true);
        });

        this.on('dispose', function() {
            toggle(false);
        });

        this.event(this.scroller, 'mousewheel DOMMouseScroll', function(e) {
            var down = e.wheelDelta < 0 || (e.originalEvent && e.originalEvent.wheelDelta < 0) || e.detail > 0;

            if (down) {
                _insistence = 1;
                clearTimeout(_timer);
                if (!_on && getSize() >= getContentSize()) {
                    toggle(true);
                }
            }
            //  else {
            //     toggle(false);
            // }
        });
    };

    baron.fn.pull = function(params) {
        var i = 0;

        while (this[i]) {
            pull.call(this[i], params);
            i++;
        }

        return this;
    };
})(window);

},{}]},{},[2])(2)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2Nzcy9zdHlsZXMuZnVsbC5kYXJrLmNzcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvcG9seWZpbGxzL2VzNS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvcG9seWZpbGxzL3Byb21pc2UuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDb3JlL3NyYy9ER0NvcmUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDb3JlL3NyYy9ER3RoZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDb3JlL3NyYy9ER3BsdWdpbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0FqYXgvc3JjL0RHQWpheC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1drdC9ER1drdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1Byb2plY3REZXRlY3Rvci9zcmMvREdQcm9qZWN0RGV0ZWN0b3IuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdNZXRyaWMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdWZXJ0ZXhUcmFuc2Zvcm0uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdBcnJvd1BhdGhUcmFuc2Zvcm0uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdBcnJvd1RpcFRyYW5zZm9ybS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0VudHJhbmNlL3NyYy9ER0NvbXBsZXhQYXRoLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHRW50cmFuY2Uvc3JjL0RHUmVuZGVyZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdCZXppZXJDdXJ2ZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdBbmltYXRpb24uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdFbnRyYW5jZS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0VudHJhbmNlL3NyYy9ER0VudHJhbmNlQXJyb3cuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdFbnRyYW5jZUFycm93U2hhcGUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMYWJlbC9zcmMvREdMYWJlbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xhYmVsL3NyYy9NYXJrZXIuREdMYWJlbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xhYmVsL3NyYy9QYXRoLkRHTGFiZWwuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMYWJlbC9zcmMvRW50cmFuY2UuREdMYWJlbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1BvcHVwL3NraW4vYmFzaWMvc2tpbi5jb25maWcuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdQb3B1cC9zcmMvREdQb3B1cC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xvY2FsZS9zcmMvREdEaWN0aW9uYXJ5LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYWxlL3NyYy9ER0xvY2FsZS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1JvdW5kQ29udHJvbC9zcmMvREdSb3VuZENvbnRyb2wuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDdXN0b21pemF0aW9uL3NraW4vYmFzaWMvc2tpbi5jb25maWcuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDdXN0b21pemF0aW9uL3NyYy9ER0N1c3RvbWl6YXRpb24uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDdXN0b21pemF0aW9uL3NyYy9ER01hcC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0N1c3RvbWl6YXRpb24vc3JjL0RHTWFwLkJhc2VMYXllci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0N1c3RvbWl6YXRpb24vc3JjL0RHTWFwLlRpbGVzQ2hlY2suanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDdXN0b21pemF0aW9uL3NyYy9ER01hcC5EcmFnLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHQ3VzdG9taXphdGlvbi9zcmMvREdQb2x5VXRpbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0N1c3RvbWl6YXRpb24vc3JjL0RHTW9iaWxlSW1wcm92ZS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1pvb21Db250cm9sL3NyYy9ER1pvb21Db250cm9sLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHWm9vbUNvbnRyb2wvbGFuZy9ydS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1pvb21Db250cm9sL2xhbmcvaXQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdab29tQ29udHJvbC9sYW5nL2NzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHWm9vbUNvbnRyb2wvbGFuZy9lbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1pvb21Db250cm9sL2xhbmcvZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdEdXN0L3NyYy9ER0R1c3QuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdBdHRyaWJ1dGlvbi9zcmMvREdBdHRyaWJ1dGlvbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0F0dHJpYnV0aW9uL2xhbmcvcnUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdBdHRyaWJ1dGlvbi9sYW5nL2l0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHQXR0cmlidXRpb24vbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0F0dHJpYnV0aW9uL2xhbmcvZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdBdHRyaWJ1dGlvbi9sYW5nL2VzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYXRpb24vc3JjL0RHTG9jYXRpb24uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMb2NhdGlvbi9sYW5nL3J1LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYXRpb24vbGFuZy9pdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xvY2F0aW9uL2xhbmcvY3MuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMb2NhdGlvbi9sYW5nL2VuLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYXRpb24vbGFuZy9lcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vc3JjL0RHU2NyZWVuZnVsbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vc3JjL0RHRnVsbFNjcmVlbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vbGFuZy9ydS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vbGFuZy9pdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vbGFuZy9lbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vbGFuZy9lcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER01ldGEvc3JjL0RHTWV0YS5MYXllci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER01ldGEvc3JjL0RHTWV0YS5PcmlnaW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdQb2kvc3JjL0RHUG9pLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvREdHZW9jbGlja2VyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvQ2xhbXBIZWxwZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9wcm92aWRlci9Qcm92aWRlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvc3JjL3Byb3ZpZGVyL0NhdGFsb2dBcGkuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL0hhbmRsZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL0RlZmF1bHQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL0FwaUVycm9yLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvaGFuZGxlci9DaXR5QXJlYS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvc3JjL2hhbmRsZXIvSG91c2UuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL0hvdXNlLlZpZXcuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL1BPSS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvc3JjL2hhbmRsZXIvU2lnaHQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9WaWV3LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvQ29udHJvbGxlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvbGFuZy9pdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvbGFuZy9ydS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvbGFuZy9lbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvbGFuZy9lcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvZmlybWNhcmQvc3JjL0Zpcm1DYXJkLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvdmVuZG9ycy9maXJtY2FyZC9zcmMvRmlybUNhcmQuRGF0YUhlbHBlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvZmlybWNhcmQvc3JjL0Zpcm1MaXN0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvdmVuZG9ycy9maXJtY2FyZC9zcmMvU2NoZWR1bGUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy92ZW5kb3JzL2Zpcm1jYXJkL3NyYy9EaWN0aW9uYXJ5LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9zcmMvREdUcmFmZmljLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9sYW5nL3J1LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9sYW5nL2l0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9sYW5nL2NzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9sYW5nL2VzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9sYW5nL2VuLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpY0NvbnRyb2wvc3JjL0NvbnRyb2wuVHJhZmZpYy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWNDb250cm9sL2xhbmcvcnUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdUcmFmZmljQ29udHJvbC9sYW5nL2l0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpY0NvbnRyb2wvbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWNDb250cm9sL2xhbmcvZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdUcmFmZmljQ29udHJvbC9sYW5nL2VuLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXIvc3JjL1J1bGVyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXIvc3JjL0xheWVyZWRNYXJrZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlci9zcmMvR2VvbWV0cnlTdHlsZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlci9sYW5nL3J1LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXIvbGFuZy9pdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyL2xhbmcvY3MuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlci9sYW5nL2VzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXIvbGFuZy9lbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyQ29udHJvbC9zcmMvQ29udHJvbC5SdWxlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyQ29udHJvbC9sYW5nL3J1LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXJDb250cm9sL2xhbmcvaXQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlckNvbnRyb2wvbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyQ29udHJvbC9sYW5nL2VzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXJDb250cm9sL2xhbmcvZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9jb3B5cmlnaHQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9jaXR5YXJlYS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2Zpcm1DYXJkQWRkci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2Zpcm1DYXJkQ29udGFjdHMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9maXJtQ2FyZEhlYWRlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2Zpcm1DYXJkUnVicmljLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvZmlybUNhcmRTY2hlZHVsZS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2Zpcm1saXN0SXRlbS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2ZyaW1DYXJkUGF5bWVudHMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9ob3VzZS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2xvYWRlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3BvcHVwRm9vdGVyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvcG9wdXBGb290ZXJCdG5zLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvcG9wdXBIZWFkZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2R1c3Rqcy1oZWxwZXJzL2xpYi9kdXN0LWhlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvZHVzdGpzLWxpbmtlZGluL2xpYi9kdXN0LmpzIiwibm9kZV9tb2R1bGVzL2h0bWw1c2hpdi9kaXN0L2h0bWw1c2hpdi5qcyIsIm5vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwidmVuZG9ycy9iYXJvbi9iYXJvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDblRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDemNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JGQTtBQUNBO0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN0tBO0FBQ0E7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BPQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdEZBO0FBQ0E7QUFDQTtBQ0ZBO0FBQ0E7QUFDQTtBQ0ZBO0FBQ0E7QUFDQTtBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FDRkE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDemNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdm5DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgY3NzID0gXCIubGVhZmxldC1pbWFnZS1sYXllciwubGVhZmxldC1sYXllciwubGVhZmxldC1tYXAtcGFuZSBjYW52YXMsLmxlYWZsZXQtbWFwLXBhbmUgc3ZnLC5sZWFmbGV0LW1hcmtlci1pY29uLC5sZWFmbGV0LW1hcmtlci1zaGFkb3csLmxlYWZsZXQtcGFuZSwubGVhZmxldC10aWxlLC5sZWFmbGV0LXRpbGUtY29udGFpbmVyLC5sZWFmbGV0LXpvb20tYm94e3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MH0ubGVhZmxldC1jb250YWluZXJ7b3ZlcmZsb3c6aGlkZGVufS5sZWFmbGV0LW1hcmtlci1pY29uLC5sZWFmbGV0LW1hcmtlci1zaGFkb3csLmxlYWZsZXQtdGlsZXstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7LXdlYmtpdC11c2VyLWRyYWc6bm9uZX0ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZXtpbWFnZS1yZW5kZXJpbmc6LXdlYmtpdC1vcHRpbWl6ZS1jb250cmFzdH0ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZS1jb250YWluZXJ7d2lkdGg6MTYwMHB4O2hlaWdodDoxNjAwcHg7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjAgMH0ubGVhZmxldC1tYXJrZXItaWNvbiwubGVhZmxldC1tYXJrZXItc2hhZG93e2Rpc3BsYXk6YmxvY2t9LmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW1hcmtlci1wYW5lIGltZywubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZywubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtdGlsZS1wYW5lIGltZywubGVhZmxldC1jb250YWluZXIgaW1nLmxlYWZsZXQtaW1hZ2UtbGF5ZXJ7bWF4LXdpZHRoOm5vbmUhaW1wb3J0YW50fS5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLXpvb217LW1zLXRvdWNoLWFjdGlvbjpwYW4teCBwYW4teTt0b3VjaC1hY3Rpb246cGFuLXggcGFuLXl9LmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZ3stbXMtdG91Y2gtYWN0aW9uOnBpbmNoLXpvb219LmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZy5sZWFmbGV0LXRvdWNoLWRyYWd7LW1zLXRvdWNoLWFjdGlvbjpub25lO3RvdWNoLWFjdGlvbjpub25lfS5sZWFmbGV0LXRpbGV7LXdlYmtpdC1maWx0ZXI6aW5oZXJpdDtmaWx0ZXI6aW5oZXJpdDt2aXNpYmlsaXR5OmhpZGRlbn0ubGVhZmxldC10aWxlLWxvYWRlZHt2aXNpYmlsaXR5OmluaGVyaXR9LmxlYWZsZXQtem9vbS1ib3h7d2lkdGg6MDtoZWlnaHQ6MDstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7ei1pbmRleDo4MDB9LmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2Z3stbW96LXVzZXItc2VsZWN0Om5vbmV9LmxlYWZsZXQtcGFuZXt6LWluZGV4OjQwMH0ubGVhZmxldC10aWxlLXBhbmV7ei1pbmRleDoyMDB9LmxlYWZsZXQtb3ZlcmxheS1wYW5le3otaW5kZXg6NDAwfS5sZWFmbGV0LXNoYWRvdy1wYW5le3otaW5kZXg6NTAwfS5sZWFmbGV0LW1hcmtlci1wYW5le3otaW5kZXg6NjAwfS5sZWFmbGV0LXRvb2x0aXAtcGFuZXt6LWluZGV4OjY1MH0ubGVhZmxldC1wb3B1cC1wYW5le3otaW5kZXg6NzAwfS5sZWFmbGV0LW1hcC1wYW5lIGNhbnZhc3t6LWluZGV4OjEwMH0ubGVhZmxldC1tYXAtcGFuZSBzdmd7ei1pbmRleDoyMDB9LmxlYWZsZXQtdm1sLXNoYXBle3dpZHRoOjFweDtoZWlnaHQ6MXB4fS5sdm1se2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlfS5sZWFmbGV0LWNvbnRyb2x7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDo4MDA7cG9pbnRlci1ldmVudHM6dmlzaWJsZVBhaW50ZWQ7cG9pbnRlci1ldmVudHM6YXV0b30ubGVhZmxldC1ib3R0b20sLmxlYWZsZXQtdG9we3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTAwMDtwb2ludGVyLWV2ZW50czpub25lfS5sZWFmbGV0LXRvcHt0b3A6MH0ubGVhZmxldC1yaWdodHtyaWdodDowfS5sZWFmbGV0LWJvdHRvbXtib3R0b206MH0ubGVhZmxldC1sZWZ0e2xlZnQ6MH0ubGVhZmxldC1jb250cm9se2Zsb2F0OmxlZnQ7Y2xlYXI6Ym90aH0ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9se2Zsb2F0OnJpZ2h0fS5sZWFmbGV0LXRvcCAubGVhZmxldC1jb250cm9se21hcmdpbi10b3A6MTBweH0ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbHttYXJnaW4tYm90dG9tOjEwcHh9LmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9se21hcmdpbi1sZWZ0OjEwcHh9LmxlYWZsZXQtcmlnaHQgLmxlYWZsZXQtY29udHJvbHttYXJnaW4tcmlnaHQ6MTBweH0ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtdGlsZXt3aWxsLWNoYW5nZTpvcGFjaXR5fS5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC1wb3B1cHtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjJzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjJzIGxpbmVhcn0ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXB7b3BhY2l0eToxfS5sZWFmbGV0LXpvb20tYW5pbWF0ZWR7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjAgMDstbXMtdHJhbnNmb3JtLW9yaWdpbjowIDA7dHJhbnNmb3JtLW9yaWdpbjowIDB9LmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWR7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtOy13ZWJraXQtdHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuMjVzIGN1YmljLWJlemllcigwLDAsLjI1LDEpO3RyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gLjI1cyBjdWJpYy1iZXppZXIoMCwwLC4yNSwxKTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuMjVzIGN1YmljLWJlemllcigwLDAsLjI1LDEpO3RyYW5zaXRpb246dHJhbnNmb3JtIC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwuMjUsMSksLXdlYmtpdC10cmFuc2Zvcm0gLjI1cyBjdWJpYy1iZXppZXIoMCwwLC4yNSwxKX0ubGVhZmxldC1wYW4tYW5pbSAubGVhZmxldC10aWxlLC5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC10aWxley13ZWJraXQtdHJhbnNpdGlvbjpub25lO3RyYW5zaXRpb246bm9uZX0ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtem9vbS1oaWRle3Zpc2liaWxpdHk6aGlkZGVufS5sZWFmbGV0LWludGVyYWN0aXZle2N1cnNvcjpwb2ludGVyfS5sZWFmbGV0LWdyYWJ7Y3Vyc29yOi13ZWJraXQtZ3JhYjtjdXJzb3I6LW1vei1ncmFifS5sZWFmbGV0LWNyb3NzaGFpciwubGVhZmxldC1jcm9zc2hhaXIgLmxlYWZsZXQtaW50ZXJhY3RpdmV7Y3Vyc29yOmNyb3NzaGFpcn0ubGVhZmxldC1jb250cm9sLC5sZWFmbGV0LXBvcHVwLXBhbmV7Y3Vyc29yOmF1dG99LmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYiwubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1ncmFiIC5sZWFmbGV0LWludGVyYWN0aXZlLC5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LW1hcmtlci1kcmFnZ2FibGV7Y3Vyc29yOm1vdmU7Y3Vyc29yOi13ZWJraXQtZ3JhYmJpbmc7Y3Vyc29yOi1tb3otZ3JhYmJpbmd9LmxlYWZsZXQtaW1hZ2UtbGF5ZXIsLmxlYWZsZXQtbWFya2VyLWljb24sLmxlYWZsZXQtbWFya2VyLXNoYWRvdywubGVhZmxldC1wYW5lPnN2ZyBwYXRoLC5sZWFmbGV0LXRpbGUtY29udGFpbmVye3BvaW50ZXItZXZlbnRzOm5vbmV9LmxlYWZsZXQtaW1hZ2UtbGF5ZXIubGVhZmxldC1pbnRlcmFjdGl2ZSwubGVhZmxldC1tYXJrZXItaWNvbi5sZWFmbGV0LWludGVyYWN0aXZlLC5sZWFmbGV0LXBhbmU+c3ZnIHBhdGgubGVhZmxldC1pbnRlcmFjdGl2ZXtwb2ludGVyLWV2ZW50czp2aXNpYmxlUGFpbnRlZDtwb2ludGVyLWV2ZW50czphdXRvfS5sZWFmbGV0LWNvbnRhaW5lcntvdXRsaW5lOjB9LmxlYWZsZXQtY29udGFpbmVyIGF7Y29sb3I6IzAwNzhBOH0ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LWFjdGl2ZXtvdXRsaW5lOm9yYW5nZSBzb2xpZCAycHh9LmxlYWZsZXQtem9vbS1ib3h7Ym9yZGVyOjJweCBkb3R0ZWQgIzM4ZjtiYWNrZ3JvdW5kOnJnYmEoMjU1LDI1NSwyNTUsLjUpfS5sZWFmbGV0LWNvbnRhaW5lcntmb250OjEycHgvMS41IFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsQXJpYWwsSGVsdmV0aWNhLHNhbnMtc2VyaWZ9LmxlYWZsZXQtYmFyey13ZWJraXQtYm94LXNoYWRvdzowIDFweCA1cHggcmdiYSgwLDAsMCwuNjUpO2JveC1zaGFkb3c6MCAxcHggNXB4IHJnYmEoMCwwLDAsLjY1KTtib3JkZXItcmFkaXVzOjRweH0ubGVhZmxldC1iYXIgYSwubGVhZmxldC1iYXIgYTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2NjYzt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2xpbmUtaGVpZ2h0OjI2cHg7ZGlzcGxheTpibG9jazt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LWRlY29yYXRpb246bm9uZTtjb2xvcjojMDAwfS5sZWFmbGV0LWJhciBhLC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjUwJSA1MCU7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2Rpc3BsYXk6YmxvY2t9LmxlYWZsZXQtYmFyIGE6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZjRmNGY0fS5sZWFmbGV0LWJhciBhOmZpcnN0LWNoaWxke2JvcmRlci10b3AtbGVmdC1yYWRpdXM6NHB4O2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjRweH0ubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxke2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6NHB4O2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjRweDtib3JkZXItYm90dG9tOm5vbmV9LmxlYWZsZXQtYmFyIGEubGVhZmxldC1kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdDtiYWNrZ3JvdW5kLWNvbG9yOiNmNGY0ZjQ7Y29sb3I6I2JiYn0ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYXt3aWR0aDozMHB4O2hlaWdodDozMHB4O2xpbmUtaGVpZ2h0OjMwcHh9LmxlYWZsZXQtY29udHJvbC16b29tLWluLC5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXR7Zm9udDo3MDAgMThweCAnTHVjaWRhIENvbnNvbGUnLE1vbmFjbyxtb25vc3BhY2U7dGV4dC1pbmRlbnQ6MXB4fS5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXR7Zm9udC1zaXplOjIwcHh9LmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC16b29tLWlue2ZvbnQtc2l6ZToyMnB4fS5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXR7Zm9udC1zaXplOjI0cHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnN7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDVweCByZ2JhKDAsMCwwLC40KTtib3gtc2hhZG93OjAgMXB4IDVweCByZ2JhKDAsMCwwLC40KTtiYWNrZ3JvdW5kOiNmZmY7Ym9yZGVyLXJhZGl1czo1cHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xle2JhY2tncm91bmQtaW1hZ2U6dXJsKGRpc3QvY3NzL2ltYWdlcy9sYXllcnMucG5nKTt3aWR0aDozNnB4O2hlaWdodDozNnB4fS5sZWFmbGV0LXJldGluYSAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGlzdC9jc3MvaW1hZ2VzL2xheWVycy0yeC5wbmcpO2JhY2tncm91bmQtc2l6ZToyNnB4IDI2cHh9LmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xle3dpZHRoOjQ0cHg7aGVpZ2h0OjQ0cHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnMgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtbGlzdCwubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGV7ZGlzcGxheTpub25lfS5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWxpc3R7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZHtwYWRkaW5nOjZweCAxMHB4IDZweCA2cHg7Y29sb3I6IzMzMztiYWNrZ3JvdW5kOiNmZmZ9LmxlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFye292ZXJmbG93LXk6c2Nyb2xsO3BhZGRpbmctcmlnaHQ6NXB4fS5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9ye21hcmdpbi10b3A6MnB4O3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDoxcHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnMgbGFiZWx7ZGlzcGxheTpibG9ja30ubGVhZmxldC1jb250cm9sLWxheWVycy1zZXBhcmF0b3J7aGVpZ2h0OjA7Ym9yZGVyLXRvcDoxcHggc29saWQgI2RkZDttYXJnaW46NXB4IC0xMHB4IDVweCAtNnB4fS5sZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoe2JhY2tncm91bmQtaW1hZ2U6dXJsKGRpc3QvY3NzL2ltYWdlcy9tYXJrZXItaWNvbi5wbmcpfS5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9ue2JhY2tncm91bmQ6I2ZmZjtiYWNrZ3JvdW5kOnJnYmEoMjU1LDI1NSwyNTUsLjcpO21hcmdpbjowfS5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5le3BhZGRpbmc6MCA1cHg7Y29sb3I6IzMzM30ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGF7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBhOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9LmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtc2NhbGV7Zm9udC1zaXplOjExcHh9LmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9sLXNjYWxle21hcmdpbi1sZWZ0OjVweH0ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbC1zY2FsZXttYXJnaW4tYm90dG9tOjVweH0ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmV7Ym9yZGVyOjJweCBzb2xpZCAjNzc3O2JvcmRlci10b3A6bm9uZTtsaW5lLWhlaWdodDoxLjE7cGFkZGluZzoycHggNXB4IDFweDtmb250LXNpemU6MTFweDt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtiYWNrZ3JvdW5kOiNmZmY7YmFja2dyb3VuZDpyZ2JhKDI1NSwyNTUsMjU1LC41KX0ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmU6bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLXRvcDoycHggc29saWQgIzc3Nztib3JkZXItYm90dG9tOm5vbmU7bWFyZ2luLXRvcDotMnB4fS5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZTpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b206MnB4IHNvbGlkICM3Nzd9LmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyLC5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnN7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfS5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciwubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWxheWVyc3tib3JkZXI6MnB4IHNvbGlkIHJnYmEoMCwwLDAsLjIpO2JhY2tncm91bmQtY2xpcDpwYWRkaW5nLWJveH0ubGVhZmxldC1wb3B1cHtwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmNlbnRlcn0ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXJ7dGV4dC1hbGlnbjpsZWZ0fS5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJ7d2lkdGg6NDBweDtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTttYXJnaW4tbGVmdDotMjBweDtvdmVyZmxvdzpoaWRkZW47cG9pbnRlci1ldmVudHM6bm9uZX0ubGVhZmxldC1wb3B1cC10aXB7d2lkdGg6MTdweDtoZWlnaHQ6MTdweDtwYWRkaW5nOjFweDttYXJnaW46LTEwcHggYXV0byAwOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7LW1zLXRyYW5zZm9ybTpyb3RhdGUoNDVkZWcpO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciwubGVhZmxldC1wb3B1cC10aXB7YmFja2dyb3VuZDojZmZmO2NvbG9yOiMzMzM7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE0cHggcmdiYSgwLDAsMCwuNCk7Ym94LXNoYWRvdzowIDNweCAxNHB4IHJnYmEoMCwwLDAsLjQpfS5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9ue2JvcmRlcjpub25lO2ZvbnQ6MTZweC8xNHB4IFRhaG9tYSxWZXJkYW5hLHNhbnMtc2VyaWY7Y29sb3I6I2MzYzNjMzt0ZXh0LWRlY29yYXRpb246bm9uZTtiYWNrZ3JvdW5kOjAgMH0ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbjpob3Zlcntjb2xvcjojOTk5fS5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcnt6b29tOjF9LmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwe3dpZHRoOjI0cHg7bWFyZ2luOjAgYXV0bzstbXMtZmlsdGVyOlxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0wLjcwNzEwNjc4LCBNMTI9MC43MDcxMDY3OCwgTTIxPS0wLjcwNzEwNjc4LCBNMjI9MC43MDcxMDY3OClcXFwiO2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0uNzA3MTA2NzgsIE0xMj0uNzA3MTA2NzgsIE0yMT0tLjcwNzEwNjc4LCBNMjI9LjcwNzEwNjc4KX0ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC10aXAtY29udGFpbmVye21hcmdpbi10b3A6LTFweH0ubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLWxheWVycywubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLXpvb20sLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyLC5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcHtib3JkZXI6MXB4IHNvbGlkICM5OTl9LmxlYWZsZXQtZGl2LWljb257YmFja2dyb3VuZDojZmZmO2JvcmRlcjoxcHggc29saWQgIzY2Nn0ubGVhZmxldC10b29sdGlwe3Bvc2l0aW9uOmFic29sdXRlO3BhZGRpbmc6NnB4O2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNmZmY7Ym9yZGVyLXJhZGl1czozcHg7Y29sb3I6IzIyMjt3aGl0ZS1zcGFjZTpub3dyYXA7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3BvaW50ZXItZXZlbnRzOm5vbmU7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC40KTtib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC40KX0ubGVhZmxldC10b29sdGlwLmxlYWZsZXQtY2xpY2thYmxle2N1cnNvcjpwb2ludGVyO3BvaW50ZXItZXZlbnRzOmF1dG99LmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlLC5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3BvaW50ZXItZXZlbnRzOm5vbmU7Ym9yZGVyOjZweCBzb2xpZCB0cmFuc3BhcmVudDtiYWNrZ3JvdW5kOjAgMDtjb250ZW50OlxcXCJcXFwifS5sZWFmbGV0LXRvb2x0aXAtYm90dG9te21hcmdpbi10b3A6NnB4fS5sZWFmbGV0LXRvb2x0aXAtdG9we21hcmdpbi10b3A6LTZweH0ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3Jle2xlZnQ6NTAlO21hcmdpbi1sZWZ0Oi02cHh9LmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3Jle2JvdHRvbTowO21hcmdpbi1ib3R0b206LTEycHg7Ym9yZGVyLXRvcC1jb2xvcjojZmZmfS5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZXt0b3A6MDttYXJnaW4tdG9wOi0xMnB4O21hcmdpbi1sZWZ0Oi02cHg7Ym9yZGVyLWJvdHRvbS1jb2xvcjojZmZmfS5sZWFmbGV0LXRvb2x0aXAtbGVmdHttYXJnaW4tbGVmdDotNnB4fS5sZWFmbGV0LXRvb2x0aXAtcmlnaHR7bWFyZ2luLWxlZnQ6NnB4fS5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmV7dG9wOjUwJTttYXJnaW4tdG9wOi02cHh9LmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZXtyaWdodDowO21hcmdpbi1yaWdodDotMTJweDtib3JkZXItbGVmdC1jb2xvcjojZmZmfS5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3Jle2xlZnQ6MDttYXJnaW4tbGVmdDotMTJweDtib3JkZXItcmlnaHQtY29sb3I6I2ZmZn1bY2xhc3NePWRnLV0sW2NsYXNzXj1kZy1dOmFmdGVyLFtjbGFzc149ZGctXTpiZWZvcmV7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7bWFyZ2luOjA7cGFkZGluZzowO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO2ZvbnQtd2VpZ2h0OmluaGVyaXQ7Zm9udC1zdHlsZTppbmhlcml0O2ZvbnQtc2l6ZToxZW07Zm9udC1mYW1pbHk6aW5oZXJpdDtsaW5lLWhlaWdodDoxLjJ9W2NsYXNzXj1kZy1dPltjbGFzc149ZGctXTpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH1bY2xhc3NePWRnLV0gYWJicixbY2xhc3NePWRnLV0gZmllbGRzZXQsW2NsYXNzXj1kZy1dIGltZ3tib3JkZXI6MH1bY2xhc3NePWRnLV0gYmxvY2txdW90ZSxbY2xhc3NePWRnLV0gcXtxdW90ZXM6bm9uZX1bY2xhc3NePWRnLV0gYmxvY2txdW90ZTphZnRlcixbY2xhc3NePWRnLV0gYmxvY2txdW90ZTpiZWZvcmUsW2NsYXNzXj1kZy1dIHE6YWZ0ZXIsW2NsYXNzXj1kZy1dIHE6YmVmb3Jle2NvbnRlbnQ6Jyc7Y29udGVudDpub25lfVtjbGFzc149ZGctXSBvbCxbY2xhc3NePWRnLV0gdWx7bGlzdC1zdHlsZTpub25lfVtjbGFzc149ZGctXSB0YWJsZXtib3JkZXItc3BhY2luZzowO2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZX1bY2xhc3NePWRnLV0gY2FwdGlvbixbY2xhc3NePWRnLV0gdGh7dGV4dC1hbGlnbjpsZWZ0fVtjbGFzc149ZGctXSB0ZCxbY2xhc3NePWRnLV0gdGh7dmVydGljYWwtYWxpZ246bWlkZGxlfVtjbGFzc149ZGctXSBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsW2NsYXNzXj1kZy1dIGlucHV0OjotbW96LWZvY3VzLWlubmVye3BhZGRpbmc6MDtib3JkZXI6MH0uZGctbGFiZWx7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO21heC13aWR0aDpub25lO21heC1oZWlnaHQ6bm9uZTt3aWR0aDozMDBweDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LmRnLWxhYmVsX19jb250ZW50e2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjNweCA3cHg7bWluLXdpZHRoOjMwcHg7bWF4LXdpZHRoOjMwMHB4O3dpZHRoOmF1dG87Ym9yZGVyLXdpZHRoOjFweDtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXJhZGl1czoycHg7dmVydGljYWwtYWxpZ246dG9wO2ZvbnQtc2l6ZToxMnB4fS5sZWFmbGV0LXRvcCAuZGctbGFiZWxfbmFtZV9sb2NhdGlvbi1lcnJvcnt0b3A6NXB4fS5sZWFmbGV0LXJpZ2h0IC5kZy1sYWJlbF9uYW1lX2xvY2F0aW9uLWVycm9ye3JpZ2h0OjQwcHg7bGVmdDphdXRvO3RleHQtYWxpZ246cmlnaHR9LmxlYWZsZXQtYm90dG9tIC5kZy1sYWJlbF9uYW1lX2xvY2F0aW9uLWVycm9ye3RvcDo0cHh9LmxlYWZsZXQtbGVmdCAuZGctbGFiZWxfbmFtZV9sb2NhdGlvbi1lcnJvcntsZWZ0OjQwcHh9LmRnLWxhYmVsX19jb250ZW50e2JvcmRlci1jb2xvcjojMzIzMjMyO2JvcmRlci1jb2xvcjpyZ2JhKDUwLDUwLDUwLC44NSk7YmFja2dyb3VuZDojMzIzMjMyO2JhY2tncm91bmQ6cmdiYSg1MCw1MCw1MCwuODUpO2NvbG9yOiNmZmQyNmV9LmxlYWZsZXQtcG9wdXB7bWFyZ2luLWJvdHRvbTowfS5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJ7aGVpZ2h0OjB9LmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVye292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjA7bWluLXdpZHRoOjYwcHg7bWluLWhlaWdodDo1MHB4O2JvcmRlcjowO2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQ6MCAwOy13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZTtjb2xvcjojZTZlNmU2O2ZvbnQtc2l6ZToxNHB4Oy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IGVhc2Utb3V0IC4ycyxtYXgtaGVpZ2h0IGVhc2Utb3V0IC4ycyxoZWlnaHQgZWFzZS1vdXQgLjJzO3RyYW5zaXRpb246b3BhY2l0eSBlYXNlLW91dCAuMnMsbWF4LWhlaWdodCBlYXNlLW91dCAuMnMsaGVpZ2h0IGVhc2Utb3V0IC4yczstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7LW1zLXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7dHJhbnNmb3JtLW9yaWdpbjo1MCUgMTAwJX0ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXI6YmVmb3Jle2Zsb2F0OnJpZ2h0O3dpZHRoOjMwcHg7aGVpZ2h0OjE3cHg7Y29udGVudDonJ30ubGVhZmxldC1wb3B1cC1jb250ZW50e3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbjoxNnB4O3dpZHRoOmF1dG87bGluZS1oZWlnaHQ6MS40fS5sZWFmbGV0LXBvcHVwIGF7b3V0bGluZTowfS5sZWFmbGV0LXBvcHVwLWNvbnRlbnQgcHttYXJnaW46MH0ubGVhZmxldC1wb3B1cC1zY3JvbGxlZHtvdmVyZmxvdzp2aXNpYmxlO2JvcmRlcjowfS5sZWFmbGV0LXBvcHVwLWlubmVye3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MH0ubGVhZmxldC1wb3B1cF9zaG93X3RydWV7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgZWFzZS1pbi1vdXQgLjJzLGhlaWdodCBlYXNlLW91dCAuMnMsLXdlYmtpdC10cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzO3RyYW5zaXRpb246b3BhY2l0eSBlYXNlLWluLW91dCAuMnMsaGVpZ2h0IGVhc2Utb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzLG9wYWNpdHkgZWFzZS1pbi1vdXQgLjJzLGhlaWdodCBlYXNlLW91dCAuMnM7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzLG9wYWNpdHkgZWFzZS1pbi1vdXQgLjJzLGhlaWdodCBlYXNlLW91dCAuMnMsLXdlYmtpdC10cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEpOy1tcy10cmFuc2Zvcm06c2NhbGUoMSk7dHJhbnNmb3JtOnNjYWxlKDEpfS5sZWFmbGV0LXBvcHVwX3Nob3dfZmFsc2V7b3BhY2l0eTowIWltcG9ydGFudDstd2Via2l0LXRyYW5zaXRpb246YWxsIGVhc2UtaW4tb3V0IC4xczt0cmFuc2l0aW9uOmFsbCBlYXNlLWluLW91dCAuMXM7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMC4yKTstbXMtdHJhbnNmb3JtOnNjYWxlKDAuMik7dHJhbnNmb3JtOnNjYWxlKDAuMil9LmxlYWZsZXQtcG9wdXBfcHJlbG9hZGVyX3RydWV7d2lkdGg6Mzg0cHg7aGVpZ2h0OjUycHh9LmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6YXV0bztib3R0b206MDtsZWZ0OjUwJTttYXJnaW4tbGVmdDotMjlweDt3aWR0aDo1OHB4O2hlaWdodDo0N3B4O2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDQ3cHgpOy1tcy10cmFuc2Zvcm06dHJhbnNsYXRlWSg0N3B4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSg0N3B4KTtwb2ludGVyLWV2ZW50czpub25lfS5sZWFmbGV0LXBvcHVwLXRpcHtkaXNwbGF5Om5vbmV9LmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lcl9zdmd7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHUG9wdXBfX3BvcHVwU2hhZG93LnBuZyk7YmFja2dyb3VuZC1wb3NpdGlvbjo1MCUgOTUlO2JhY2tncm91bmQtc2l6ZTozNnB4IDEycHh9LmxlYWZsZXQtcmV0aW5hIC5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJfc3Zne2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHUG9wdXBfX3BvcHVwU2hhZG93QDJ4LnBuZyl9LmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b257cG9zaXRpb246YWJzb2x1dGU7dG9wOjNweDtyaWdodDozcHg7ei1pbmRleDoxO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjA7d2lkdGg6MzBweDtoZWlnaHQ6MzBweDt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOjE4cHg7bGluZS1oZWlnaHQ6MzBweDtjdXJzb3I6cG9pbnRlcn0ubm8tdG91Y2ggLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246aG92ZXJ7Ym9yZGVyLXJhZGl1czoycHg7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMnM7dHJhbnNpdGlvbjphbGwgLjJzfS5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uOmFjdGl2ZXtjb2xvcjojNzc3fS5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uOmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6Mjtjb250ZW50OicnfS5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoNTAsNTAsNTAsLjkpfS5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJfaW1hZ2V7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjU4JTIyJTIwaGVpZ2h0JTNEJTIyNDclMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0wJTIwMGMxMi42NDMlMjAwJTIwMjglMjA3LjExNSUyMDI4JTIwNDRoMmMwLTM2Ljg4NSUyMDE1LjM1OC00NCUyMDI4LTQ0aC01OHolMjIlMjBmaWxsJTNEJTIycmdiYSg1MCUyQzUwJTJDNTAlMkMuOSklMjIlM0UlM0MlMkZwYXRoJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIil9LmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lcl9zdmd7ZmlsbDpyZ2JhKDUwLDUwLDUwLC45KX0ubm8tdG91Y2ggLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMjIyOy13ZWJraXQtYm94LXNoYWRvdzowIDFweCAzcHggcmdiYSgwLDAsMCwuNSk7Ym94LXNoYWRvdzowIDFweCAzcHggcmdiYSgwLDAsMCwuNSl9LmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246YWZ0ZXJ7dG9wOi0zcHg7cmlnaHQ6LTVweDt3aWR0aDo0MHB4O2hlaWdodDo0MHB4fS5kZy13cmFwcGVye3Bvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmhpZGRlbn0uZGctc2Nyb2xsZXJ7aGVpZ2h0OjEwMCU7b3ZlcmZsb3cteTpzY3JvbGw7Ym9yZGVyOjB9LmRnLXNjcm9sbGVyX19iYXJ7ei1pbmRleDoxO3JpZ2h0OjA7YmFja2dyb3VuZDojOTk5fS5kZy1zY3JvbGxlcl9fYmFyX2h7Ym90dG9tOjJweDtoZWlnaHQ6OHB4fS5kZy1oZWFkZXJfX3RpdGxle3dpZHRoOjEwMCU7bWFyZ2luOjA7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2JhY2tncm91bmQ6Izk5OX0uZGctaGVhZGVyX190aXRsZV9zdGF0ZV9maXhlZHtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjF9LmRnLXNjcm9sbGVyX2hpZGRlbl90cnVle292ZXJmbG93OmF1dG99LmRnLXNjcm9sbGVyOjotd2Via2l0LXNjcm9sbGJhcnt3aWR0aDowfS5kZy1zY3JvbGxlcl9fd3JhcHBlcntwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW59LmRnLXNjcm9sbGVyX19iYXItd3JhcHBlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MThweDtyaWdodDozcHg7Ym90dG9tOjRweDt3aWR0aDo3cHg7Ym9yZGVyLXJhZGl1czo1cHh9LmRnLXNjcm9sbGVyX2hpZGRlbl90cnVlIC5kZy1zY3JvbGxlcl9fYmFyLXdyYXBwZXJ7dmlzaWJpbGl0eTpoaWRkZW59LmRnLXBvcHVwX19oZWFkZXIrLmRnLXBvcHVwX19jb250YWluZXItd3JhcHBlciAuZGctc2Nyb2xsZXJfX2Jhci13cmFwcGVye3RvcDo0cHh9LmRnLXNjcm9sbGVyX19iYXJ7cG9zaXRpb246YWJzb2x1dGU7bWluLWhlaWdodDoyMHB4O3dpZHRoOjdweDtib3JkZXItcmFkaXVzOjNweDtwb2ludGVyLWV2ZW50czphdXRvfS5zY3JvbGxlcl9fYmFyLXdyYXBwZXIgLnNjcm9sbGVyX19iYXJ7YmFja2dyb3VuZC1jb2xvcjojNjY1YjRmfS5zY3JvbGxlcl9fYmFyLXdyYXBwZXI6aG92ZXIgLnNjcm9sbGVyX19iYXJ7YmFja2dyb3VuZC1jb2xvcjojODk3YTZifS5kZy1wb3B1cF9fY29udGFpbmVye21hcmdpbjowfS5sZWFmbGV0LXBvcHVwLXNjcm9sbGVkIC5kZy1wb3B1cF9fY29udGFpbmVye3BhZGRpbmc6OHB4IDE0cHggOHB4IDB9LmRnLXBvcHVwX19oZWFkZXJ7cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZy1ib3R0b206MTJweH0ubGVhZmxldC1wb3B1cC1zY3JvbGxlZCAuZGctcG9wdXBfX2hlYWRlcjphZnRlcntwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6MTJweDtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7aGVpZ2h0OjFweDtjb250ZW50OicnfS5kZy1wb3B1cF9fZm9vdGVye3Bvc2l0aW9uOnJlbGF0aXZlO2JvdHRvbTowO292ZXJmbG93OmhpZGRlbn0ubGVhZmxldC1wb3B1cC1zY3JvbGxlZCAuZGctcG9wdXBfX2Zvb3RlcjpiZWZvcmV7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO2hlaWdodDoxcHg7Y29udGVudDonJ30uZGctcG9wdXBfaGlkZGVuX3RydWV7ZGlzcGxheTpub25lfS5sZWFmbGV0LXBvcHVwLXNjcm9sbGVkIC5kZy1wb3B1cF9fZm9vdGVyOmJlZm9yZSwubGVhZmxldC1wb3B1cC1zY3JvbGxlZCAuZGctcG9wdXBfX2hlYWRlcjphZnRlcntib3JkZXItYm90dG9tOjFweCBzb2xpZCAjNjM2MzYzO2JhY2tncm91bmQtY29sb3I6IzQ5NDk0OX0uZGctY29udHJvbC1yb3VuZHtwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjVweDt3aWR0aDozMHB4O2hlaWdodDozMHB4O2JvcmRlci1yYWRpdXM6NTAlO2N1cnNvcjpkZWZhdWx0fS5kZy1jb250cm9sLXJvdW5kX19pY29ue3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MzBweDtoZWlnaHQ6MzBweDtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOiNmMGYwZjA7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxsZWZ0IGJvdHRvbSxjb2xvci1zdG9wKDAsI2ZmZiksdG8oI2UwZTBlMCkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNmZmYgMCwjZTBlMGUwIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZmZmIDAsI2UwZTBlMCAxMDAlKTtjb2xvcjojMmIyYTI5O3RleHQtYWxpZ246Y2VudGVyO3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtc2hhZG93OjAgMXB4IDAgI2ZmZjtmb250LXNpemU6MjJweDtsaW5lLWhlaWdodDozMHB4O2N1cnNvcjpwb2ludGVyfS5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmNWY1ZjU7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxsZWZ0IGJvdHRvbSxjb2xvci1zdG9wKDAsI2ViZWJlYiksdG8oI2ZmZikpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNlYmViZWIgMCwjZmZmIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZWJlYmViIDAsI2ZmZiAxMDAlKX0uZGctY29udHJvbC1yb3VuZF9faWNvbjphY3RpdmUsLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojZWJlYmViO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AsbGVmdCBib3R0b20sY29sb3Itc3RvcCgwLCNkNmQ2ZDYpLHRvKCNmZmYpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjZDZkNmQ2IDAsI2ZmZiAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20sI2Q2ZDZkNiAwLCNmZmYgMTAwJSl9LmxlYWZsZXQtZGlzYWJsZWQgLmRnLWNvbnRyb2wtcm91bmRfX2ljb24sLmxlYWZsZXQtZGlzYWJsZWQgLmRnLWNvbnRyb2wtcm91bmRfX2ljb246YWN0aXZlLC5uby10b3VjaCAubGVhZmxldC1kaXNhYmxlZCAuZGctY29udHJvbC1yb3VuZF9faWNvbjpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOm5vbmU7Y3Vyc29yOmRlZmF1bHR9LmxlYWZsZXQtdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb246YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMTBweDtyaWdodDotMTVweDtib3R0b206LTEwcHg7bGVmdDotMTVweDtjb250ZW50OicnfS5kZy1jb250cm9sLXJvdW5kX2lzLWhpZGRlbl90cnVle2Rpc3BsYXk6bm9uZX0uZGctY29udHJvbC1yb3VuZHtiYWNrZ3JvdW5kLWNvbG9yOiMzZDNkM2Q7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDVweCAwIHJnYmEoMCwwLDAsLjMpO2JveC1zaGFkb3c6MCAzcHggNXB4IDAgcmdiYSgwLDAsMCwuMyl9LmRnLWNvbnRyb2wtcm91bmRfX2ljb257LXdlYmtpdC1ib3gtc2hhZG93OjAgMnB4IDJweCAwIHJnYmEoMCwwLDAsLjQpO2JveC1zaGFkb3c6MCAycHggMnB4IDAgcmdiYSgwLDAsMCwuNCl9Lm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uOmhvdmVyey13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDFweCAjZmZmLDAgMCAwIDFweCByZ2JhKDAsMCwwLC4zKSwwIDFweCAwIDFweCByZ2JhKDAsMCwwLC40KTtib3gtc2hhZG93Omluc2V0IDAgMXB4ICNmZmYsMCAwIDAgMXB4IHJnYmEoMCwwLDAsLjMpLDAgMXB4IDAgMXB4IHJnYmEoMCwwLDAsLjQpfS5kZy1jb250cm9sLXJvdW5kX19pY29uOmFjdGl2ZSwuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUsLm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uOmFjdGl2ZXstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IDFweCByZ2JhKDAsMCwwLC4yKSwwIDAgMCAxcHggcmdiYSgwLDAsMCwuMyksMCAtMXB4IDFweCAwICMwMDA7Ym94LXNoYWRvdzppbnNldCAwIDFweCAxcHggMXB4IHJnYmEoMCwwLDAsLjIpLDAgMCAwIDFweCByZ2JhKDAsMCwwLC4zKSwwIC0xcHggMXB4IDAgIzAwMH0ubGVhZmxldC1kaXNhYmxlZCAuZGctY29udHJvbC1yb3VuZF9faWNvbiwubGVhZmxldC1kaXNhYmxlZCAuZGctY29udHJvbC1yb3VuZF9faWNvbjphY3RpdmUsLm5vLXRvdWNoIC5sZWFmbGV0LWRpc2FibGVkIC5kZy1jb250cm9sLXJvdW5kX19pY29uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2I4YjhiODstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9LmxlYWZsZXQtY29udGFpbmVye3otaW5kZXg6MDtiYWNrZ3JvdW5kOiNmN2YzZGY7Y3Vyc29yOmRlZmF1bHR9LmxlYWZsZXQtY29udGFpbmVyOi13ZWJraXQtZnVsbC1zY3JlZW57d2lkdGg6MTAwJSFpbXBvcnRhbnQ7aGVpZ2h0OjEwMCUhaW1wb3J0YW50fS5sZWFmbGV0LWNvbnRhaW5lcjotbW96LWZ1bGwtc2NyZWVue3dpZHRoOjEwMCUhaW1wb3J0YW50O2hlaWdodDoxMDAlIWltcG9ydGFudH0ubGVhZmxldC1jb250YWluZXI6LW1zLWZ1bGxzY3JlZW57d2lkdGg6MTAwJSFpbXBvcnRhbnQ7aGVpZ2h0OjEwMCUhaW1wb3J0YW50fS5sZWFmbGV0LWNvbnRhaW5lcjpmdWxsc2NyZWVue3dpZHRoOjEwMCUhaW1wb3J0YW50O2hlaWdodDoxMDAlIWltcG9ydGFudH0ubGVhZmxldC1kcmFnZ2luZywubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1jbGlja2FibGUsLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtY29udGFpbmVye2N1cnNvcjptb3ZlfS5sZWFmbGV0LWNvbnRyb2wgYSwubGVhZmxldC1jb250cm9sIGE6Zm9jdXN7b3V0bGluZTowIWltcG9ydGFudH0ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50Oy13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZX0uZGctY3VzdG9taXphdGlvbl9fbWFya2Vye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdH0uZGctY3VzdG9taXphdGlvbl9fbWFya2VyOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtiYWNrZ3JvdW5kLWltYWdlOmluaGVyaXQ7YmFja2dyb3VuZC1zaXplOmNvbnRhaW47YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0Oy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IGVhc2UtaW4tb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7dHJhbnNpdGlvbjpvcGFjaXR5IGVhc2UtaW4tb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7dHJhbnNpdGlvbjpvcGFjaXR5IGVhc2UtaW4tb3V0IC4ycyx0cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzO3RyYW5zaXRpb246b3BhY2l0eSBlYXNlLWluLW91dCAuMnMsdHJhbnNmb3JtIGVhc2UtaW4tb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSwxKTstbXMtdHJhbnNmb3JtOnNjYWxlKDEsMSk7dHJhbnNmb3JtOnNjYWxlKDEsMSk7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjUwJSAxMDAlOy1tcy10cmFuc2Zvcm0tb3JpZ2luOjUwJSAxMDAlO3RyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCV9LmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29te2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlci5wbmcpO2JhY2tncm91bmQtc2l6ZToyMnB4IDM0cHg7d2lkdGg6MjJweDtoZWlnaHQ6MzRweDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7LW1zLXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7dHJhbnNmb3JtLW9yaWdpbjo1MCUgMTAwJTstd2Via2l0LWFuaW1hdGlvbjpkZy1jdXN0b21pemF0aW9uX19zaG93LW1hcmtlciAuMnM7YW5pbWF0aW9uOmRnLWN1c3RvbWl6YXRpb25fX3Nob3ctbWFya2VyIC4yc30ubGVhZmxldC1yZXRpbmEgLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29te2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHQ3VzdG9taXphdGlvbl9fbWFya2VyQDJ4LnBuZyl9LmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmZvY3Vze291dGxpbmU6MH0ubm8tdG91Y2ggLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmhvdmVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlckhvdmVyLnBuZyk7YmFja2dyb3VuZC1zaXplOjIycHggMzRweH0ubGVhZmxldC1yZXRpbmEgLm5vLXRvdWNoIC5kZy1jdXN0b21pemF0aW9uX19tYXJrZXJfdHlwZV9tdXNocm9vbTpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlckhvdmVyQDJ4LnBuZyl9LmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmFjdGl2ZSwubm8tdG91Y2ggLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmFjdGl2ZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoaHR0cHM6Ly9tYXBzLmFwaS4yZ2lzLnJ1LzIuMC9pbWcvREdDdXN0b21pemF0aW9uX19tYXJrZXJBY3RpdmUucG5nKTtiYWNrZ3JvdW5kLXNpemU6MjJweCAzNHB4fS5sZWFmbGV0LXJldGluYSAuZGctY3VzdG9taXphdGlvbl9fbWFya2VyX3R5cGVfbXVzaHJvb206YWN0aXZlLC5sZWFmbGV0LXJldGluYSAubm8tdG91Y2ggLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmFjdGl2ZXtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlckFjdGl2ZUAyeC5wbmcpfUAtd2Via2l0LWtleWZyYW1lcyBkZy1jdXN0b21pemF0aW9uX19zaG93LW1hcmtlcntmcm9te29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fUBrZXlmcmFtZXMgZGctY3VzdG9taXphdGlvbl9fc2hvdy1tYXJrZXJ7ZnJvbXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX0uZGctY3VzdG9taXphdGlvbl9fbWFya2VyX2FwcGVhcntiYWNrZ3JvdW5kLXBvc2l0aW9uOjk5OXB4fS5kZy1jdXN0b21pemF0aW9uX19tYXJrZXJfYXBwZWFyOmJlZm9yZXtjb250ZW50OicnfS5kZy1jdXN0b21pemF0aW9uX19tYXJrZXJfZGlzYXBwZWFye2JhY2tncm91bmQtcG9zaXRpb246OTk5cHg7cG9pbnRlci1ldmVudHM6bm9uZX0uZGctY3VzdG9taXphdGlvbl9fbWFya2VyX2Rpc2FwcGVhcjpiZWZvcmV7dmlzaWJpbGl0eTpoaWRkZW47Y29udGVudDonJztvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7LW1zLXRyYW5zZm9ybTpzY2FsZSgxLjIsMS44KTt0cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7LXdlYmtpdC1hbmltYXRpb246ZGctY3VzdG9taXphdGlvbl9fbWFya2VyLXRvLWNhbGxvdXQgLjJzO2FuaW1hdGlvbjpkZy1jdXN0b21pemF0aW9uX19tYXJrZXItdG8tY2FsbG91dCAuMnN9QC13ZWJraXQta2V5ZnJhbWVzIGRnLWN1c3RvbWl6YXRpb25fX21hcmtlci10by1jYWxsb3V0ezAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSwxKTt0cmFuc2Zvcm06c2NhbGUoMSwxKX0xMDAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7dHJhbnNmb3JtOnNjYWxlKDEuMiwxLjgpfX1Aa2V5ZnJhbWVzIGRnLWN1c3RvbWl6YXRpb25fX21hcmtlci10by1jYWxsb3V0ezAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSwxKTt0cmFuc2Zvcm06c2NhbGUoMSwxKX0xMDAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7dHJhbnNmb3JtOnNjYWxlKDEuMiwxLjgpfX0uZGctZHJhZ2dpbmctZmFsc2V7dG91Y2gtYWN0aW9uOmF1dG87LW1zLXRvdWNoLWFjdGlvbjphdXRvfS5sZWFmbGV0LWltYWdlLWxheWVyLC5sZWFmbGV0LXRpbGUtY29udGFpbmVye3BvaW50ZXItZXZlbnRzOmF1dG99LmRnLXpvb217d2lkdGg6NDBweDtoZWlnaHQ6NzRweH0uZGctem9vbV9faW57cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowfS5sZWFmbGV0LXRvdWNoIC5kZy16b29tX19pbjpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOi01cHg7cmlnaHQ6LTEwcHg7Ym90dG9tOjA7bGVmdDotMTBweDtjb250ZW50OicnfS5kZy16b29tX19pbjphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTotMXB4O2xlZnQ6MDt6LWluZGV4Oi0xO21hcmdpbjphdXRvO3dpZHRoOjEycHg7aGVpZ2h0OjJweDstd2Via2l0LWJveC1zaGFkb3c6MCAwIDNweCAycHggcmdiYSgwLDAsMCwuMyk7Ym94LXNoYWRvdzowIDAgM3B4IDJweCByZ2JhKDAsMCwwLC4zKTtjb250ZW50OicnfS5kZy16b29tX19idXR0b25fdHlwZV9pbjphZnRlciwuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YmVmb3JlLC5sZWFmbGV0LXRvdWNoIC5kZy16b29tX19idXR0b25fdHlwZV9pbjpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7bWFyZ2luOmF1dG87d2lkdGg6MTRweDtoZWlnaHQ6MnB4O2JhY2tncm91bmQtY29sb3I6IzdhN2E3YTstd2Via2l0LWJveC1zaGFkb3c6MCAxcHggI2ZmZjtib3gtc2hhZG93OjAgMXB4ICNmZmY7Y29udGVudDonJ30uZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWZ0ZXJ7d2lkdGg6MnB4O2hlaWdodDoxNHB4fS5uby10b3VjaCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46aG92ZXI6YWZ0ZXIsLm5vLXRvdWNoIC5kZy16b29tX19idXR0b25fdHlwZV9pbjpob3ZlcjpiZWZvcmV7YmFja2dyb3VuZC1jb2xvcjojNjE2MTYxfS5kZy16b29tX19idXR0b25fdHlwZV9pbjphY3RpdmU6YWZ0ZXIsLmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmFjdGl2ZTpiZWZvcmUsLm5vLXRvdWNoIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphY3RpdmU6YWZ0ZXIsLm5vLXRvdWNoIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphY3RpdmU6YmVmb3Jle2JhY2tncm91bmQtY29sb3I6IzU3NTc1N30ubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWN0aXZlOmFmdGVyLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphY3RpdmU6YmVmb3JlLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphZnRlciwubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YmVmb3JlLC5uby10b3VjaCAubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46aG92ZXI6YWZ0ZXIsLm5vLXRvdWNoIC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjpob3ZlcjpiZWZvcmV7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfS5kZy16b29tX19vdXR7cG9zaXRpb246YWJzb2x1dGU7dG9wOjQwcHg7cmlnaHQ6MDtsZWZ0OjA7bWFyZ2luOmF1dG87d2lkdGg6MjJweDtoZWlnaHQ6MjJweH0uZGctem9vbV9fb3V0OmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMXB4O3JpZ2h0OjA7bGVmdDowO21hcmdpbjphdXRvO3dpZHRoOjEycHg7aGVpZ2h0OjJweDtjb250ZW50OicnfS5kZy16b29tX19idXR0b25fdHlwZV9vdXR7d2lkdGg6MjJweDtoZWlnaHQ6MjJweH0ubGVhZmxldC10b3VjaCAuZGctem9vbV9fYnV0dG9uX3R5cGVfb3V0OmJlZm9yZXt0b3A6LTVweDtyaWdodDotMTlweDtib3R0b206LTE5cHg7bGVmdDotMTlweH0uZGctem9vbV9fYnV0dG9uX3R5cGVfb3V0OmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO21hcmdpbjphdXRvO3dpZHRoOjEwcHg7aGVpZ2h0OjJweDtiYWNrZ3JvdW5kOiM3YTdhN2E7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4ICNmZmY7Ym94LXNoYWRvdzowIDFweCAjZmZmO2NvbnRlbnQ6Jyd9Lm5vLXRvdWNoIC5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6aG92ZXI6YWZ0ZXJ7YmFja2dyb3VuZDojNjE2MTYxfS5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6YWN0aXZlOmFmdGVyLC5uby10b3VjaCAuZGctem9vbV9fYnV0dG9uX3R5cGVfb3V0OmFjdGl2ZTphZnRlcntiYWNrZ3JvdW5kOiM1NzU3NTd9LmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX291dDphY3RpdmU6YWZ0ZXIsLmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX291dDphZnRlciwubm8tdG91Y2ggLmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX291dDpob3ZlcjphZnRlcnstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9LmRnLXpvb21fX291dHstd2Via2l0LWJveC1zaGFkb3c6MCAycHggM3B4IDAgcmdiYSgwLDAsMCwuMyk7Ym94LXNoYWRvdzowIDJweCAzcHggMCByZ2JhKDAsMCwwLC4zKX0uZGctem9vbV9fb3V0OmFmdGVye2JhY2tncm91bmQtY29sb3I6IzNkM2QzZH0ubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWN0aXZlOmFmdGVyLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphY3RpdmU6YmVmb3JlLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphZnRlciwubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YmVmb3JlLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6YWN0aXZlOmFmdGVyLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6YWZ0ZXIsLm5vLXRvdWNoIC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjpob3ZlcjphZnRlciwubm8tdG91Y2ggLmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmhvdmVyOmJlZm9yZSwubm8tdG91Y2ggLmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX291dDpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLWNvbG9yOiM3MDcwNzB9LmRnLWF0dHJpYnV0aW9ue2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQhaW1wb3J0YW50fS5kZy1hdHRyaWJ1dGlvbl9fY29weXJpZ2h0e21hcmdpbjowIDU1cHggNXB4IDA7dGV4dC1hbGlnbjpyaWdodDt3aGl0ZS1zcGFjZTpub3dyYXA7Zm9udC1zaXplOjlweDtmb250LWZhbWlseTpIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZn0uZGctYXR0cmlidXRpb25fX2xpbmtze2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjowO3BhZGRpbmc6MCA1cHggMCAwfS5kZy1hdHRyaWJ1dGlvbl9fbGluay1pdGVte3BhZGRpbmc6MDtsaXN0LXN0eWxlLXR5cGU6bm9uZX0ubGVhZmxldC1jb250YWluZXIgLmRnLWF0dHJpYnV0aW9uX19saW5re2JhY2tncm91bmQ6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AscmlnaHQgdG9wLGZyb20ocmdiYSg4LDgsOCwuMykpLHRvKHJnYmEoOCw4LDgsLjMpKSkgMCA5NSUvMTBweCAxcHggcmVwZWF0LXg7YmFja2dyb3VuZDotd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LHJnYmEoOCw4LDgsLjMpLHJnYmEoOCw4LDgsLjMpIDEwMCUpIDAgOTUlLzEwcHggMXB4IHJlcGVhdC14O2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoOCw4LDgsLjMpLHJnYmEoOCw4LDgsLjMpIDEwMCUpIDAgOTUlLzEwcHggMXB4IHJlcGVhdC14O2NvbG9yOiMzMzM7dGV4dC1kZWNvcmF0aW9uOm5vbmU7Zm9udC1zaXplOjlweDtmb250LWZhbWlseTpIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZjtjdXJzb3I6cG9pbnRlcn0ubGVhZmxldC1jb250YWluZXIgLmRnLWF0dHJpYnV0aW9uX19saW5rOmhvdmVye2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AscmlnaHQgdG9wLGZyb20oIzA4MDgwOCksdG8oIzA4MDgwOCkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCwjMDgwODA4LCMwODA4MDggMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIzA4MDgwOCwjMDgwODA4IDEwMCUpO2NvbG9yOiMzMzM7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmRnLWF0dHJpYnV0aW9uX19sb2dvLXVybHtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMGhlaWdodCUzRCUyMjI0JTIyJTIwd2lkdGglM0QlMjI1NSUyMiUzRSUwQSUyMCUzQ3BhdGglMjBmaWxsJTNEJTIyJTIzYTJjMTI0JTIyJTIwZCUzRCUyMm0yNC4zOTUlMjAxMmMwLTEuNDU0NS0wLjIyMTc3LTIuNjU0NS0wLjY2NTMyLTQtMC4xNDc4NSUyMDQuMjU0NS00Ljg3OSUyMDcuODE4Mi03LjQ2NjQlMjAxMGg2Ljc2NDFjMC43MDIyOS0yJTIwMS4zNjc2LTMuOTI3MyUyMDEuMzY3Ni02bS00LjczMS05LjM0NTVjLTIuMDMzLTEuNi00LjYyLTIuNjU0NS03LjQ2Ni0yLjY1NDUtNi43Mjc2JTIwMC0xMi4xOTglMjA1LjQxODItMTIuMTk4JTIwMTJzNS40NzA0JTIwMTIlMjAxMi4xOTglMjAxMmMzLjEwNDglMjAwJTIwNS45NTA5LTEuNDU0NSUyMDguMTMxNy0zLjM0NTVoLTguNzk3di0yLjY1NDVjNS4zNTk1LTQuNTQ1NSUyMDguNzk3LTcuMzQ1NSUyMDguNzk3LTEwJTIwMC0xLjEyNzMtMC44MTMxNy0yLjY1NDUtMi42OTgzLTIuNjU0NS0xLjQ3ODUlMjAwLTIuNjk4MyUyMDEuMzQ1NS0yLjY5ODMlMjA0LjY1NDVoLTMuNDAwNWMtMC43MzkyNS00LjIxODIlMjAxLjg0ODEtNy42NzI3JTIwNi4yNDY2LTcuNjcyNyUyMDAuNjY1MzIlMjAwJTIwMS4yNTY3JTIwMC4yMTgxOCUyMDEuODg1MSUyMDAuMzI3MjclMjIlMkYlM0UlMEElMjAlM0NwYXRoJTIwZmlsbCUzRCUyMiUyMzNjNDM0NyUyMiUyMGQlM0QlMjJtMzYuNTkzJTIwOS4zNDU1aDEuMzY3NmMwLTItMC42NjUzMi01LjEyNzMtNC43MzEyLTUuMjcyNy00LjczMi0wLjIxODMtNi4xJTIwMi42MTgxLTYuMSUyMDUuOTI3MnY1LjM0NTVjMCUyMDQuNCUyMDMuNDM3NSUyMDUuMzQ1NSUyMDYuMDk4OCUyMDUuMzQ1NSUyMDEuNTUyNCUyMDAlMjAzLjQwMDUtMC44NzI3MyUyMDQuNzMxMi0ydi02LjY5MDloLTUuNDMzNXYyLjY1NDVoMi42OTgzdjIuNjU0NWMtMS4zNjc2JTIwMS4zNDU1LTUuNDMzNSUyMDEuMzQ1NS01LjQzMzUtMi42NTQ1di01LjMwOTFjMC00JTIwNS45NTA5LTQuMTQ1NSUyMDUuNjE4MyUyMDBoMS4xODI4em0xOC4yOTYlMjA2LjY1NDVjMC01LjgxODItNi45ODU5LTQuMDcyNy02Ljk4NTktNy42JTIwMC0xLjIlMjAwLjgxMzE3LTIlMjAyLjE4MDgtMiUyMDEuNDQxNSUyMDAlMjAyLjI1NDclMjAxLjAxODIlMjAyLjI1NDclMjAyLjk4MThoMi41ODc0YzAtMi0wLjY2NTMyLTUuMzQ1NS00LjczMTItNS4zNDU1LTIuNzcyMiUyMDAtNC44NzklMjAxLjQxODItNC44NzklMjA0LjMyNzMlMjAwJTIwNi4wNzI3JTIwNy4xNzA3JTIwNC4wNzI3JTIwNy4wNTk4JTIwNy42NzI3LTAuMDczOTIlMjAxLjQ1NDUtMS4xNDU4JTIwMi4wNzI3LTIuMzY1NiUyMDIuMDcyNy0xLjQ0MTUlMjAwLTIuNjk4My0wLjcyNzI3LTIuNDM5NS0zLjM4MThoLTIuNjYxM2MtMC4yNTg3NCUyMDMuMzQ1NSUyMDEuNDQxNSUyMDYlMjA1LjM1OTUlMjA2JTIwMi42OTklMjAwJTIwNC43MzItMi4xNDUlMjA0LjczMi01LjM0NWwtMC4xMTElMjAwLjYxOHptLTEyLjE5OCUyMDRoLTIuNjk4M3YtMTZoMi42OTgzdjE2eiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjU1cHg7aGVpZ2h0OjI0cHg7YmFja2dyb3VuZC1zaXplOjU1cHggMjRweDtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW46MCAzcHggMCAwfS5kZy1sb2NhdGlvbl9fcGlue2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL3Nwcml0ZS5iYXNpYy5wbmcpO2JhY2tncm91bmQtcG9zaXRpb246LTU1cHggMDtiYWNrZ3JvdW5kLXNpemU6ODdweCA3NHB4fS5sZWFmbGV0LXJldGluYSAuZGctbG9jYXRpb25fX3BpbntiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9zcHJpdGVAMnguYmFzaWMucG5nKTtiYWNrZ3JvdW5kLXBvc2l0aW9uOi01NXB4IDA7YmFja2dyb3VuZC1zaXplOjkxcHggNzEuNXB4fS5kZy1sb2NhdGlvbl9fcGluX3N0YXRlX2ZvbGxvd2luZ3tiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9zcHJpdGUuYmFzaWMucG5nKTtiYWNrZ3JvdW5kLXBvc2l0aW9uOi0yMnB4IC0yNHB4O2JhY2tncm91bmQtc2l6ZTo4N3B4IDc0cHh9LmxlYWZsZXQtcmV0aW5hIC5kZy1sb2NhdGlvbl9fcGluX3N0YXRlX2ZvbGxvd2luZ3tiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9zcHJpdGVAMnguYmFzaWMucG5nKTtiYWNrZ3JvdW5kLXBvc2l0aW9uOi0yMXB4IC0yNHB4O2JhY2tncm91bmQtc2l6ZTo5MXB4IDcxLjVweH0uZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDttYXJnaW46YXV0bztjb250ZW50OicnfS5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX2FjdGl2ZS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmFjdGl2ZTphZnRlciwuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTphZnRlciwubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6aG92ZXI6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjE4JTIyJTIwaGVpZ2h0JTNEJTIyMTglMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NnJTIwZmlsbCUzRCUyMiUyMzIzYTVkNCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE3JTJDOCUyMEglMjAxNS45MiUyMEMlMjAxNS40OCUyQzQuOTM3JTIwMTMuMDY0JTJDMi41MiUyMDEwJTJDMi4wOCUyMFYlMjAxJTIwQyUyMDEwJTJDMC40NDglMjA5LjU1MyUyQzAlMjA5JTJDMCUyMDguNDQ3JTJDMCUyMDglMkMwLjQ0OCUyMDglMkMxJTIwViUyMDIuMDglMjBDJTIwNC45MzYlMkMyLjUyJTIwMi41MiUyQzQuOTM3JTIwMi4wOCUyQzglMjBIJTIwMSUyMEMlMjAwLjQ0NyUyQzglMjAwJTJDOC40NDglMjAwJTJDOSUyMDAlMkM5LjU1MyUyMDAuNDQ3JTJDMTAlMjAxJTJDMTAlMjBIJTIwMi4wOCUyMEMlMjAyLjUyJTJDMTMuMDYzJTIwNC45MzYlMkMxNS40OCUyMDglMkMxNS45MiUyMFYlMjAxNyUyMGMlMjAwJTJDMC41NTMlMjAwLjQ0NyUyQzElMjAxJTJDMSUyMDAuNTUzJTJDMCUyMDElMkMtMC40NDclMjAxJTJDLTElMjBWJTIwMTUuOTIlMjBDJTIwMTMuMDY0JTJDMTUuNDgxJTIwMTUuNDglMkMxMy4wNjQlMjAxNS45MiUyQzEwJTIwSCUyMDE3JTIwQyUyMDE3LjU1MyUyQzEwJTIwMTglMkM5LjU1MyUyMDE4JTJDOSUyMDE4JTJDOC40NDglMjAxNy41NTMlMkM4JTIwMTclMkM4JTIweiUyME0lMjA5JTJDMTQlMjBDJTIwNi4yNCUyQzE0JTIwNCUyQzExLjc2MiUyMDQlMkM5JTIwNCUyQzYuMjM4JTIwNi4yNCUyQzQlMjA5JTJDNCUyMGMlMjAyLjc2MSUyQzAlMjA1JTJDMi4yMzglMjA1JTJDNSUyMDAlMkMyLjc2MiUyMC0yLjIzOSUyQzUlMjAtNSUyQzUlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDY2lyY2xlJTIwY3glM0QlMjI5JTIyJTIwY3klM0QlMjI5JTIyJTIwciUzRCUyMjMlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0MlMkZnJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTQlMkMxMC4wMDQlMjBDJTIwMTQlMkM5LjgzNCUyMDEzLjk5MSUyQzkuNjY3JTIwMTMuOTc1JTJDOS41MDIlMjAxMy43MjMlMkMxMi4wMjclMjAxMS41OTIlMkMxNCUyMDklMkMxNCUyMDYuNDA4JTJDMTQlMjA0LjI3NyUyQzEyLjAyNyUyMDQuMDI1JTJDOS41MDIlMjA0LjAwOSUyQzkuNjY3JTIwNCUyQzkuODM0JTIwNCUyQzEwLjAwNCUyMGMlMjAwJTJDMi43NjIlMjAyLjI0JTJDNSUyMDUlMkM1JTIwMi43NjElMkMwJTIwNSUyQy0yLjIzOCUyMDUlMkMtNSUyMHolMjBNJTIwMTAlMkMzLjA4MyUyMGMlMjAzLjA2NCUyQzAuNDM5JTIwNS40OCUyQzIuODU2JTIwNS45MiUyQzUuOTIxJTIwSCUyMDE3JTIwYyUyMDAuMzY5JTJDMCUyMDAuNjg4JTJDMC4yMDElMjAwLjg2JTJDMC40OTglMjBDJTIwMTcuOTQ3JTJDOS4zNTQlMjAxOCUyQzkuMTg0JTIwMTglMkM5JTIwMTglMkM4LjQ0OCUyMDE3LjU1MyUyQzglMjAxNyUyQzglMjBIJTIwMTUuOTIlMjBDJTIwMTUuNDglMkM0LjkzNyUyMDEzLjA2NCUyQzIuNTIlMjAxMCUyQzIuMDglMjBWJTIwMy4wODMlMjB6JTIwTSUyMDElMkM5LjAwNCUyMEglMjAyLjA4JTIwQyUyMDIuNTIlMkM1LjkzOSUyMDQuOTM2JTJDMy41MjIlMjA4JTJDMy4wODMlMjBWJTIwMi4wOCUyMEMlMjA0LjkzNiUyQzIuNTIlMjAyLjUyJTJDNC45MzclMjAyLjA4JTJDOCUyMEglMjAxJTIwQyUyMDAuNDQ3JTJDOCUyMDAlMkM4LjQ0OCUyMDAlMkM5JTIwMCUyQzkuMTg0JTIwMC4wNTMlMkM5LjM1NCUyMDAuMTQlMkM5LjUwMiUyMDAuMzEyJTJDOS4yMDUlMjAwLjYzMSUyQzkuMDA0JTIwMSUyQzkuMDA0JTIweiUyMG0lMjA4JTJDLTglMjBjJTIwMC41NTMlMkMwJTIwMSUyQzAuNDQ3JTIwMSUyQzElMjBWJTIwMSUyMEMlMjAxMCUyQzAuNDQ4JTIwOS41NTMlMkMwJTIwOSUyQzAlMjA4LjQ0NyUyQzAlMjA4JTJDMC40NDglMjA4JTJDMSUyMHYlMjAxLjAwNCUyMGMlMjAwJTJDLTAuNTUzJTIwMC40NDclMkMtMSUyMDElMkMtMSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMjY4NWFhJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwOSUyQzclMjBjJTIwMS40ODYlMkMwJTIwMi43MTclMkMxLjA4MiUyMDIuOTU1JTJDMi41JTIwQyUyMDExLjk4MiUyQzkuMzM3JTIwMTIlMkM5LjE3MSUyMDEyJTJDOSUyMDEyJTJDNy4zNDQlMjAxMC42NTYlMkM2JTIwOSUyQzYlMjA3LjM0NCUyQzYlMjA2JTJDNy4zNDQlMjA2JTJDOSUyMDYlMkM5LjE3MSUyMDYuMDE4JTJDOS4zMzclMjA2LjA0NSUyQzkuNSUyMDYuMjgzJTJDOC4wODIlMjA3LjUxNCUyQzclMjA5JTJDNyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMWM4NWFiJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIil9QC13ZWJraXQta2V5ZnJhbWVzIERHTG9jYXRpb25fX2xvY2F0ZUljb25SZXF1ZXN0aW5nQW5pbXt0b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgREdMb2NhdGlvbl9fbG9jYXRlSWNvblJlcXVlc3RpbmdBbmlte3Rvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjE4JTIyJTIwaGVpZ2h0JTNEJTIyMTglMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NnJTIwZmlsbCUzRCUyMiUyMzYxNjE2MSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE3JTJDOCUyMEglMjAxNS45MiUyMEMlMjAxNS40OCUyQzQuOTM3JTIwMTMuMDY0JTJDMi41MiUyMDEwJTJDMi4wOCUyMFYlMjAxJTIwQyUyMDEwJTJDMC40NDglMjA5LjU1MyUyQzAlMjA5JTJDMCUyMDguNDQ3JTJDMCUyMDglMkMwLjQ0OCUyMDglMkMxJTIwViUyMDIuMDglMjBDJTIwNC45MzYlMkMyLjUyJTIwMi41MiUyQzQuOTM3JTIwMi4wOCUyQzglMjBIJTIwMSUyMEMlMjAwLjQ0NyUyQzglMjAwJTJDOC40NDglMjAwJTJDOSUyMDAlMkM5LjU1MyUyMDAuNDQ3JTJDMTAlMjAxJTJDMTAlMjBIJTIwMi4wOCUyMEMlMjAyLjUyJTJDMTMuMDYzJTIwNC45MzYlMkMxNS40OCUyMDglMkMxNS45MiUyMFYlMjAxNyUyMGMlMjAwJTJDMC41NTMlMjAwLjQ0NyUyQzElMjAxJTJDMSUyMDAuNTUzJTJDMCUyMDElMkMtMC40NDclMjAxJTJDLTElMjBWJTIwMTUuOTIlMjBDJTIwMTMuMDY0JTJDMTUuNDgxJTIwMTUuNDglMkMxMy4wNjQlMjAxNS45MiUyQzEwJTIwSCUyMDE3JTIwQyUyMDE3LjU1MyUyQzEwJTIwMTglMkM5LjU1MyUyMDE4JTJDOSUyMDE4JTJDOC40NDglMjAxNy41NTMlMkM4JTIwMTclMkM4JTIweiUyME0lMjA5JTJDMTQlMjBDJTIwNi4yNCUyQzE0JTIwNCUyQzExLjc2MiUyMDQlMkM5JTIwNCUyQzYuMjM4JTIwNi4yNCUyQzQlMjA5JTJDNCUyMGMlMjAyLjc2MSUyQzAlMjA1JTJDMi4yMzglMjA1JTJDNSUyMDAlMkMyLjc2MiUyMC0yLjIzOSUyQzUlMjAtNSUyQzUlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDY2lyY2xlJTIwY3glM0QlMjI5JTIyJTIwY3klM0QlMjI5JTIyJTIwciUzRCUyMjMlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0MlMkZnJTNFJTBBJTIwJTIwJTIwJTIwJTNDZyUyMGZpbGwlM0QlMjIlMjM0NDQlMjIlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNCUyQzEwLjAwNCUyMEMlMjAxNCUyQzkuODM0JTIwMTMuOTkxJTJDOS42NjclMjAxMy45NzUlMkM5LjUwMiUyMDEzLjcyMyUyQzEyLjAyNyUyMDExLjU5MiUyQzE0JTIwOSUyQzE0JTIwNi40MDglMkMxNCUyMDQuMjc3JTJDMTIuMDI3JTIwNC4wMjUlMkM5LjUwMiUyMDQuMDA5JTJDOS42NjclMjA0JTJDOS44MzQlMjA0JTJDMTAuMDA0JTIwYyUyMDAlMkMyLjc2MiUyMDIuMjQlMkM1JTIwNSUyQzUlMjAyLjc2MSUyQzAlMjA1JTJDLTIuMjM4JTIwNSUyQy01JTIweiUyME0lMjAxMCUyQzMuMDgzJTIwYyUyMDMuMDY0JTJDMC40MzklMjA1LjQ4JTJDMi44NTYlMjA1LjkyJTJDNS45MjElMjBIJTIwMTclMjBjJTIwMC4zNjklMkMwJTIwMC42ODglMkMwLjIwMSUyMDAuODYlMkMwLjQ5OCUyMEMlMjAxNy45NDclMkM5LjM1NCUyMDE4JTJDOS4xODQlMjAxOCUyQzklMjAxOCUyQzguNDQ4JTIwMTcuNTUzJTJDOCUyMDE3JTJDOCUyMEglMjAxNS45MiUyMEMlMjAxNS40OCUyQzQuOTM3JTIwMTMuMDY0JTJDMi41MiUyMDEwJTJDMi4wOCUyMFYlMjAzLjA4MyUyMHolMjBNJTIwMSUyQzkuMDA0JTIwSCUyMDIuMDglMjBDJTIwMi41MiUyQzUuOTM5JTIwNC45MzYlMkMzLjUyMiUyMDglMkMzLjA4MyUyMFYlMjAyLjA4JTIwQyUyMDQuOTM2JTJDMi41MiUyMDIuNTIlMkM0LjkzNyUyMDIuMDglMkM4JTIwSCUyMDElMjBDJTIwMC40NDclMkM4JTIwMCUyQzguNDQ4JTIwMCUyQzklMjAwJTJDOS4xODQlMjAwLjA1MyUyQzkuMzU0JTIwMC4xNCUyQzkuNTAyJTIwMC4zMTIlMkM5LjIwNSUyMDAuNjMxJTJDOS4wMDQlMjAxJTJDOS4wMDQlMjB6JTIwbSUyMDglMkMtOCUyMGMlMjAwLjU1MyUyQzAlMjAxJTJDMC40NDclMjAxJTJDMSUyMFYlMjAxJTIwQyUyMDEwJTJDMC40NDglMjA5LjU1MyUyQzAlMjA5JTJDMCUyMDguNDQ3JTJDMCUyMDglMkMwLjQ0OCUyMDglMkMxJTIwdiUyMDEuMDA0JTIwYyUyMDAlMkMtMC41NTMlMjAwLjQ0NyUyQy0xJTIwMSUyQy0xJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQyUyRmclM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjA5JTJDNyUyMGMlMjAxLjQ4NiUyQzAlMjAyLjcxNyUyQzEuMDgyJTIwMi45NTUlMkMyLjUlMjBDJTIwMTEuOTgyJTJDOS4zMzclMjAxMiUyQzkuMTcxJTIwMTIlMkM5JTIwMTIlMkM3LjM0NCUyMDEwLjY1NiUyQzYlMjA5JTJDNiUyMDcuMzQ0JTJDNiUyMDYlMkM3LjM0NCUyMDYlMkM5JTIwNiUyQzkuMTcxJTIwNi4wMTglMkM5LjMzNyUyMDYuMDQ1JTJDOS41JTIwNi4yODMlMkM4LjA4MiUyMDcuNTE0JTJDNyUyMDklMkM3JTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0NDQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxOHB4O2hlaWdodDoxOHB4O2JhY2tncm91bmQtc2l6ZToxOHB4IDE4cHh9LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6YWN0aXZlOmFmdGVyLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTglMjIlMjBoZWlnaHQlM0QlMjIxOCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ2clMjBmaWxsJTNEJTIyJTIzNDI0MjQyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTclMkM4JTIwSCUyMDE1LjkyJTIwQyUyMDE1LjQ4JTJDNC45MzclMjAxMy4wNjQlMkMyLjUyJTIwMTAlMkMyLjA4JTIwViUyMDElMjBDJTIwMTAlMkMwLjQ0OCUyMDkuNTUzJTJDMCUyMDklMkMwJTIwOC40NDclMkMwJTIwOCUyQzAuNDQ4JTIwOCUyQzElMjBWJTIwMi4wOCUyMEMlMjA0LjkzNiUyQzIuNTIlMjAyLjUyJTJDNC45MzclMjAyLjA4JTJDOCUyMEglMjAxJTIwQyUyMDAuNDQ3JTJDOCUyMDAlMkM4LjQ0OCUyMDAlMkM5JTIwMCUyQzkuNTUzJTIwMC40NDclMkMxMCUyMDElMkMxMCUyMEglMjAyLjA4JTIwQyUyMDIuNTIlMkMxMy4wNjMlMjA0LjkzNiUyQzE1LjQ4JTIwOCUyQzE1LjkyJTIwViUyMDE3JTIwYyUyMDAlMkMwLjU1MyUyMDAuNDQ3JTJDMSUyMDElMkMxJTIwMC41NTMlMkMwJTIwMSUyQy0wLjQ0NyUyMDElMkMtMSUyMFYlMjAxNS45MiUyMEMlMjAxMy4wNjQlMkMxNS40ODElMjAxNS40OCUyQzEzLjA2NCUyMDE1LjkyJTJDMTAlMjBIJTIwMTclMjBDJTIwMTcuNTUzJTJDMTAlMjAxOCUyQzkuNTUzJTIwMTglMkM5JTIwMTglMkM4LjQ0OCUyMDE3LjU1MyUyQzglMjAxNyUyQzglMjB6JTIwTSUyMDklMkMxNCUyMEMlMjA2LjI0JTJDMTQlMjA0JTJDMTEuNzYyJTIwNCUyQzklMjA0JTJDNi4yMzglMjA2LjI0JTJDNCUyMDklMkM0JTIwYyUyMDIuNzYxJTJDMCUyMDUlMkMyLjIzOCUyMDUlMkM1JTIwMCUyQzIuNzYyJTIwLTIuMjM5JTJDNSUyMC01JTJDNSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NjaXJjbGUlMjBjeCUzRCUyMjklMjIlMjBjeSUzRCUyMjklMjIlMjByJTNEJTIyMyUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQyUyRmclM0UlMEElMjAlMjAlMjAlMjAlM0NnJTIwZmlsbCUzRCUyMiUyMzJlMmUyZSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE0JTJDMTAuMDA0JTIwQyUyMDE0JTJDOS44MzQlMjAxMy45OTElMkM5LjY2NyUyMDEzLjk3NSUyQzkuNTAyJTIwMTMuNzIzJTJDMTIuMDI3JTIwMTEuNTkyJTJDMTQlMjA5JTJDMTQlMjA2LjQwOCUyQzE0JTIwNC4yNzclMkMxMi4wMjclMjA0LjAyNSUyQzkuNTAyJTIwNC4wMDklMkM5LjY2NyUyMDQlMkM5LjgzNCUyMDQlMkMxMC4wMDQlMjBjJTIwMCUyQzIuNzYyJTIwMi4yNCUyQzUlMjA1JTJDNSUyMDIuNzYxJTJDMCUyMDUlMkMtMi4yMzglMjA1JTJDLTUlMjB6JTIwTSUyMDEwJTJDMy4wODMlMjBjJTIwMy4wNjQlMkMwLjQzOSUyMDUuNDglMkMyLjg1NiUyMDUuOTIlMkM1LjkyMSUyMEglMjAxNyUyMGMlMjAwLjM2OSUyQzAlMjAwLjY4OCUyQzAuMjAxJTIwMC44NiUyQzAuNDk4JTIwQyUyMDE3Ljk0NyUyQzkuMzU0JTIwMTglMkM5LjE4NCUyMDE4JTJDOSUyMDE4JTJDOC40NDglMjAxNy41NTMlMkM4JTIwMTclMkM4JTIwSCUyMDE1LjkyJTIwQyUyMDE1LjQ4JTJDNC45MzclMjAxMy4wNjQlMkMyLjUyJTIwMTAlMkMyLjA4JTIwViUyMDMuMDgzJTIweiUyME0lMjAxJTJDOS4wMDQlMjBIJTIwMi4wOCUyMEMlMjAyLjUyJTJDNS45MzklMjA0LjkzNiUyQzMuNTIyJTIwOCUyQzMuMDgzJTIwViUyMDIuMDglMjBDJTIwNC45MzYlMkMyLjUyJTIwMi41MiUyQzQuOTM3JTIwMi4wOCUyQzglMjBIJTIwMSUyMEMlMjAwLjQ0NyUyQzglMjAwJTJDOC40NDglMjAwJTJDOSUyMDAlMkM5LjE4NCUyMDAuMDUzJTJDOS4zNTQlMjAwLjE0JTJDOS41MDIlMjAwLjMxMiUyQzkuMjA1JTIwMC42MzElMkM5LjAwNCUyMDElMkM5LjAwNCUyMHolMjBtJTIwOCUyQy04JTIwYyUyMDAuNTUzJTJDMCUyMDElMkMwLjQ0NyUyMDElMkMxJTIwViUyMDElMjBDJTIwMTAlMkMwLjQ0OCUyMDkuNTUzJTJDMCUyMDklMkMwJTIwOC40NDclMkMwJTIwOCUyQzAuNDQ4JTIwOCUyQzElMjB2JTIwMS4wMDQlMjBjJTIwMCUyQy0wLjU1MyUyMDAuNDQ3JTJDLTElMjAxJTJDLTElMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDJTJGZyUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDklMkM3JTIwYyUyMDEuNDg2JTJDMCUyMDIuNzE3JTJDMS4wODIlMjAyLjk1NSUyQzIuNSUyMEMlMjAxMS45ODIlMkM5LjMzNyUyMDEyJTJDOS4xNzElMjAxMiUyQzklMjAxMiUyQzcuMzQ0JTIwMTAuNjU2JTJDNiUyMDklMkM2JTIwNy4zNDQlMkM2JTIwNiUyQzcuMzQ0JTIwNiUyQzklMjA2JTJDOS4xNzElMjA2LjAxOCUyQzkuMzM3JTIwNi4wNDUlMkM5LjUlMjA2LjI4MyUyQzguMDgyJTIwNy41MTQlMkM3JTIwOSUyQzclMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzJlMmUyZSUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpfS5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX3JlcXVlc3RpbmcuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTphY3RpdmU6YWZ0ZXIsLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfcmVxdWVzdGluZy5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmFmdGVyLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9yZXF1ZXN0aW5nLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6aG92ZXI6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O3dpZHRoOjI0cHg7aGVpZ2h0OjI0cHg7YmFja2dyb3VuZC1pbWFnZTp1cmwoaHR0cHM6Ly9tYXBzLmFwaS4yZ2lzLnJ1LzIuMC9pbWcvc3ByaXRlLmRhcmsucG5nKTtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgMDtiYWNrZ3JvdW5kLXNpemU6NzhweCA2NXB4Oy13ZWJraXQtYW5pbWF0aW9uOkRHTG9jYXRpb25fX2xvY2F0ZUljb25SZXF1ZXN0aW5nQW5pbSAxcyBsaW5lYXIgaW5maW5pdGU7YW5pbWF0aW9uOkRHTG9jYXRpb25fX2xvY2F0ZUljb25SZXF1ZXN0aW5nQW5pbSAxcyBsaW5lYXIgaW5maW5pdGU7aW1hZ2UtcmVuZGVyaW5nOm9wdGltaXplUXVhbGl0eX0ubGVhZmxldC1yZXRpbmEgLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfcmVxdWVzdGluZy5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmFjdGl2ZTphZnRlciwubGVhZmxldC1yZXRpbmEgLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfcmVxdWVzdGluZy5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmFmdGVyLC5sZWFmbGV0LXJldGluYSAubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfcmVxdWVzdGluZy5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmhvdmVyOmFmdGVye2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL3Nwcml0ZUAyeC5kYXJrLnBuZyk7YmFja2dyb3VuZC1wb3NpdGlvbjowIDA7YmFja2dyb3VuZC1zaXplOjc4cHggNjVweH0uZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2Z1bGxzY3JlZW46YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7bWFyZ2luOmF1dG87Y29udGVudDonJ30uZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2Z1bGxzY3JlZW46YWN0aXZlOmFmdGVyLC5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX2FjdGl2ZS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfZnVsbHNjcmVlbjphZnRlciwubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9mdWxsc2NyZWVuOmhvdmVyOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxNiUyMiUyMGhlaWdodCUzRCUyMjE2JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNiUyQzElMjBIJTIwMSUyMFYlMjA2JTIwSCUyMDMlMjBWJTIwMyUyMGglMjAzJTIweiUyMG0lMjA0JTJDMTQlMjBoJTIwNSUyMHYlMjAtNSUyMGglMjAtMiUyMHYlMjAzJTIwSCUyMDEwJTIweiUyME0lMjAxNSUyQzYlMjBWJTIwMSUyMGglMjAtNSUyMHYlMjAyJTIwaCUyMDMlMjBWJTIwNiUyMHolMjBNJTIwMSUyQzEwJTIwdiUyMDUlMjBIJTIwNiUyMFYlMjAxMyUyMEglMjAzJTIwdiUyMC0zJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMwZGE0ZDQlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxJTJDMSUyMEglMjA2JTIwViUyMDIlMjBIJTIwMSUyMHolMjBtJTIwOSUyQzAlMjBoJTIwNSUyMHYlMjAxJTIwaCUyMC01JTIweiUyMG0lMjAzJTJDOSUyMGglMjAyJTIwdiUyMDElMjBoJTIwLTIlMjB6JTIwbSUyMC0zJTJDMyUyMGglMjAzJTIwdiUyMDElMjBoJTIwLTMlMjB6JTIwbSUyMC03JTJDMCUyMGglMjAzJTIwdiUyMDElMjBIJTIwMyUyMHolMjBNJTIwMSUyQzEwJTIwaCUyMDIlMjB2JTIwMSUyMEglMjAxJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMwYTg0YWIlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxJTJDNiUyMEglMjAzJTIwViUyMDclMjBIJTIwMSUyMHolMjBtJTIwMTIlMkMwJTIwaCUyMDIlMjBWJTIwNyUyMEglMjAxMyUyMHolMjBNJTIwMSUyQzE1JTIwaCUyMDUlMjB2JTIwMSUyMEglMjAxJTIweiUyMG0lMjA5JTJDMCUyMGglMjA1JTIwdiUyMDElMjBoJTIwLTUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpfS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfZnVsbHNjcmVlbjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTYlMjIlMjBoZWlnaHQlM0QlMjIxNiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDElMkMzJTIwSCUyMDYlMjBWJTIwNCUyMEglMjAxJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA2JTJDMSUyMEglMjAxJTIwViUyMDYlMjBIJTIwMyUyMFYlMjAzJTIwaCUyMDMlMjB6JTIwbSUyMDQlMkMxNCUyMGglMjA1JTIwdiUyMC01JTIwaCUyMC0yJTIwdiUyMDMlMjBoJTIwLTMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzZjNmM2YyUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDEwJTJDMyUyMGglMjA1JTIwdiUyMDElMjBoJTIwLTUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE1JTJDNiUyMFYlMjAxJTIwaCUyMC01JTIwdiUyMDIlMjBoJTIwMyUyMFYlMjA2JTIweiUyME0lMjAxJTJDMTAlMjB2JTIwNSUyMEglMjA2JTIwViUyMDEzJTIwSCUyMDMlMjB2JTIwLTMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzZjNmM2YyUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDElMkMxJTIwSCUyMDYlMjBWJTIwMiUyMEglMjAxJTIweiUyMG0lMjA5JTJDMCUyMGglMjA1JTIwdiUyMDElMjBoJTIwLTUlMjB6JTIwbSUyMDMlMkM5JTIwaCUyMDIlMjB2JTIwMSUyMGglMjAtMiUyMHolMjBtJTIwLTMlMkMzJTIwaCUyMDMlMjB2JTIwMSUyMGglMjAtMyUyMHolMjBtJTIwLTclMkMwJTIwaCUyMDMlMjB2JTIwMSUyMEglMjAzJTIweiUyME0lMjAxJTJDMTAlMjBoJTIwMiUyMHYlMjAxJTIwSCUyMDElMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzRiNGI0YiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDElMkM2JTIwSCUyMDMlMjBWJTIwNyUyMEglMjAxJTIweiUyMG0lMjAxMiUyQzAlMjBoJTIwMiUyMFYlMjA3JTIwSCUyMDEzJTIweiUyME0lMjAxJTJDMTUlMjBoJTIwNSUyMHYlMjAxJTIwSCUyMDElMjB6JTIwbSUyMDklMkMwJTIwaCUyMDUlMjB2JTIwMSUyMGglMjAtNSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTZweDtoZWlnaHQ6MTZweDtiYWNrZ3JvdW5kLXNpemU6MTZweCAxNnB4fS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfZnVsbHNjcmVlbjphY3RpdmU6YWZ0ZXIsLm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfZnVsbHNjcmVlbjpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTYlMjIlMjBoZWlnaHQlM0QlMjIxNiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDEyJTJDOSUyMGglMjA0JTIwdiUyMDclMjBoJTIwLTQlMjB6JTIwbSUyMC0zJTJDMyUyMGglMjA1JTIwdiUyMDQlMjBIJTIwOSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMTAlMkMxNSUyMGglMjA1JTIwdiUyMC01JTIwaCUyMC0yJTIwdiUyMDMlMjBoJTIwLTMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzI4MjgyOCUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDAlMkM5JTIwaCUyMDQlMjB2JTIwNyUyMEglMjAwJTIweiUyMG0lMjAyJTJDMyUyMGglMjA1JTIwdiUyMDQlMjBIJTIwMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMSUyQzEwJTIwdiUyMDUlMjBIJTIwNiUyMFYlMjAxMyUyMEglMjAzJTIwdiUyMC0zJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMyODI4MjglMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAwJTJDMCUyMEglMjA0JTIwViUyMDclMjBIJTIwMCUyMHolMjBtJTIwOSUyQzAlMjBoJTIwNSUyMFYlMjA0JTIwSCUyMDklMjB6JTIwbSUyMDMlMkMwJTIwaCUyMDQlMjB2JTIwNyUyMGglMjAtNCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTUlMkM2JTIwViUyMDElMjBoJTIwLTUlMjB2JTIwMiUyMGglMjAzJTIwdiUyMDMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzI4MjgyOCUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDIlMkMwJTIwSCUyMDclMjBWJTIwNCUyMEglMjAyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA2JTJDMSUyMEglMjAxJTIwViUyMDYlMjBIJTIwMyUyMFYlMjAzJTIwaCUyMDMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzI4MjgyOCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpfS5kZy1idWlsZGluZy1jYWxsb3V0X19ib2R5e3Bvc2l0aW9uOnJlbGF0aXZlfS5kZy1idWlsZGluZy1jYWxsb3V0X19saXN0e21hcmdpbi1ib3R0b206OHB4O3BhZGRpbmctbGVmdDoyNHB4O2NvbG9yOiNmZmU2YWE7bGlzdC1zdHlsZTpub25lfS5kZy1idWlsZGluZy1jYWxsb3V0X19saXN0LWl0ZW17cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWJvdHRvbTo0cHg7Zm9udC1zaXplOjEycHh9LmRnLWJ1aWxkaW5nLWNhbGxvdXRfX2xpc3QtaXRlbTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjVweDtsZWZ0Oi0yMXB4O2NvbnRlbnQ6Jyc7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjYlMjIlMjBoZWlnaHQlM0QlMjI2JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMyUyQy0wLjAwMiUyMEMlMjA0LjY1NCUyQy0wLjAwMiUyMDUuOTk0JTJDMS4zNDIlMjA1Ljk5NCUyQzMlMjA1Ljk5NCUyQzQuNjU4JTIwNC42NTUlMkM2LjAwMiUyMDMlMkM2LjAwMiUyMDEuMzQ1JTJDNi4wMDIlMjAwLjAwNSUyQzQuNjU4JTIwMC4wMDUlMkMzJTIwMC4wMDUlMkMxLjM0MiUyMDEuMzQ2JTJDLTAuMDAyJTIwMyUyQy0wLjAwMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYWFhJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjZweDtoZWlnaHQ6NnB4O2JhY2tncm91bmQtc2l6ZTo2cHggNnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzc3ttYXJnaW4tYm90dG9tOjEwcHg7Zm9udC1zaXplOjE2cHh9LmRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlKy5kZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzc3ttYXJnaW4tdG9wOi02cHh9LmRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzLWhlYWRlcntwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tYm90dG9tOjRweDtwYWRkaW5nLWxlZnQ6MjRweH0uZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtaGVhZGVyOmZpcnN0LWNoaWxkOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NXB4O2xlZnQ6MXB4O2NvbnRlbnQ6Jyd9LmRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzLWRyaWxsZG93bntwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tYm90dG9tOjRweDtwYWRkaW5nLWxlZnQ6MjRweDtjb2xvcjojYWFhO2ZvbnQtc2l6ZToxMnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcy1kcmlsbGRvd246Zmlyc3QtY2hpbGQ6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDoycHg7bGVmdDoxcHg7Y29udGVudDonJ30uZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2V7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWJvdHRvbToxMHB4O3BhZGRpbmctbGVmdDoyNHB4O2ZvbnQtc2l6ZToxNnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcysuZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2V7bWFyZ2luLXRvcDotNnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjRweDtsZWZ0OjJweDtjb250ZW50OicnfS5kZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZV90eXBlX3N0cmVldDpiZWZvcmV7dG9wOjRweH0uZGctbWFwLWdlb2NsaWNrZXJfX3NpZ2h0LWRlc2NyaXB0aW9ue292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOi41ZW0gMCAwIDI0cHg7bWF4LWhlaWdodDozLjZlbX1hLmRnLW1hcC1nZW9jbGlja2VyX19zaG93LW1vcmUtc2lnaHRzLWxpbmt7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWxlZnQ6MjRweDtib3JkZXItYm90dG9tOjFweCBkb3R0ZWQ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9YS5kZy1tYXAtZ2VvY2xpY2tlcl9fc2hvdy1tb3JlLXNpZ2h0cy1saW5rOmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDo0cHg7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjZweDtoZWlnaHQ6MTBweDtjb250ZW50OicnO2ZvbnQtd2VpZ2h0OjcwMH0uZGctbWFwLWdlb2NsaWNrZXJfX2NsYW1wZWQtbGluZXtkaXNwbGF5OmJsb2NrO3doaXRlLXNwYWNlOm5vd3JhcH0uZGctbWFwLWdlb2NsaWNrZXJfX2NsYW1wZWQtbGluZV9sYXN0e292ZXJmbG93OmhpZGRlbjt3aWR0aDoxMDAlO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9LmRnLW1hcC1nZW9jbGlja2VyX19wcmVsb2FkZXItd3JhcHBlcntkaXNwbGF5OnRhYmxlLWNlbGw7dmVydGljYWwtYWxpZ246bWlkZGxlO3RleHQtYWxpZ246Y2VudGVyfS5kZy1tYXAtZ2VvY2xpY2tlcl9fZHJpbGxkb3due21hcmdpbi1ib3R0b206MTBweH0uZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtZHJpbGxkb3duOmZpcnN0LWNoaWxkOmJlZm9yZSwuZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtaGVhZGVyOmZpcnN0LWNoaWxkOmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyOSUyMiUyMGhlaWdodCUzRCUyMjExJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNC45NTglMkMxMSUyMEMlMjA0Ljk1OCUyQzkuMDM2JTIwNi43NTYlMkM2Ljc1MSUyMDguNzE5JTJDNi43NTElMjA4Ljg4NSUyQzYuMjIzJTIwOSUyQzUuNjU2JTIwOSUyQzUuMDYzJTIwOSUyQzIuMjY3JTIwNi45ODUlMkMwJTIwNC41JTJDMCUyMDIuMDE1JTJDMCUyMDAlMkMyLjI2NyUyMDAlMkM1LjA2MyUyMDAlMkM1LjY1NiUyMDAuMTE0JTJDNi4yMjIlMjAwLjI4JTJDNi43NTElMjAyLjI0MyUyQzYuNzUxJTIwNC4wMTglMkM5LjAxMiUyMDQuMDE4JTJDMTElMjBoJTIwMC45NCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTBhMGEwJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6OXB4O2hlaWdodDoxMXB4O2JhY2tncm91bmQtc2l6ZTo5cHggMTFweH0uZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2U6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjI4JTIyJTIwaGVpZ2h0JTNEJTIyMTIlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAzLjU4MiUyQzglMjBjJTIwMC4yMTElMkMwJTIwMC43OTglMkMwLjAzNSUyMDElMkMwJTIwdiUyMDQlMjBsJTIwLTIlMkMtMSUyMFYlMjA4JTIwYyUyMDAuMzcyJTJDMC4wNjYlMjAwLjg2MSUyQzAlMjAxJTJDMCUyMHolMjBNJTIwMC40NCUyQzUuMzg0JTIwQyUyMDAuMTYzJTJDNC44NjYlMjAwJTJDNC4yNzYlMjAwJTJDMy42NDYlMjAwJTJDMS42MzMlMjAxLjYwNCUyQzAuMDAyJTIwMy41ODIlMkMwLjAwMiUyMGMlMjAxLjk3OCUyQzAlMjAzLjU4MiUyQzEuNjMxJTIwMy41ODIlMkMzLjY0NCUyMDAlMkMwLjY0NyUyMC0wLjE2OSUyQzEuMjU0JTIwLTAuNDYxJTJDMS43ODElMjBMJTIwNi42NDElMkM1LjQ5NSUyMDYuNjE4JTJDNS41NjclMjBDJTIwNS45NTQlMkM2LjU0OSUyMDQuODQ0JTJDNy4xOTIlMjAzLjU4NCUyQzcuMTkyJTIwMi4yNSUyQzcuMTkyJTIwMS4wODQlMkM2LjQ2NyUyMDAuNDQlMkM1LjM4NCUyMHolMjBNJTIwMi42MTMlMkMxLjI3NiUyMGMlMjAtMC41NDklMkMwJTIwLTAuOTk1JTJDMC40NTMlMjAtMC45OTUlMkMxLjAxMyUyMDAlMkMwLjU1OSUyMDAuNDQ2JTJDMS4wMTMlMjAwLjk5NSUyQzEuMDEzJTIwMC41NTElMkMwJTIwMC45OTYlMkMtMC40NTQlMjAwLjk5NiUyQy0xLjAxMyUyMDAlMkMtMC41NiUyMC0wLjQ0NSUyQy0xLjAxMyUyMC0wLjk5NiUyQy0xLjAxMyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTBhMGEwJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6OHB4O2hlaWdodDoxMnB4O2JhY2tncm91bmQtc2l6ZTo4cHggMTJweH0uZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2VfdHlwZV9zdHJlZXQ6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwOC44JTJDMCUyMEglMjAzLjE5OSUyMEwlMjAwJTJDMTIlMjBIJTIwMTIlMjBMJTIwOC44JTJDMCUyMHolMjBNJTIwNyUyQzEyJTIwSCUyMDUlMjBWJTIwOSUyMGglMjAyJTIwdiUyMDMlMjB6JTIwTSUyMDclMkM4JTIwSCUyMDUlMjBWJTIwNiUyMEglMjA3JTIwViUyMDglMjB6JTIwTSUyMDclMkM1JTIwSCUyMDUlMjBWJTIwMyUyMEglMjA3JTIwViUyMDUlMjB6JTIwTSUyMDclMkMyJTIwSCUyMDUlMjBWJTIwMCUyMGglMjAyJTIwdiUyMDIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjEycHg7aGVpZ2h0OjEycHg7YmFja2dyb3VuZC1zaXplOjEycHggMTJweH0uZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2VfdHlwZV9zaWdodDpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjglMjIlMjBoZWlnaHQlM0QlMjIxMiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDclMkMwJTIwSCUyMDIuNTQ3JTIwQyUyMDAuNTQ3JTJDMCUyMDAlMkMwLjgyOCUyMDAlMkMyLjUlMjAwJTJDMy43MzQlMjAwLjUlMkM1JTIwMiUyQzUlMjAzLjM1OSUyQzUlMjA0JTJDMy44NDQlMjA0JTJDMyUyMDQlMkMyLjI4MSUyMDIuODU5JTJDMiUyMDIlMkMyJTIwMiUyQzIuNzY2JTIwMi4yMzQlMkMzJTIwMyUyQzMlMjAzJTJDMy42OSUyMDIuNDglMkM0JTIwMiUyQzQlMjAxLjIzNCUyQzQlMjAxJTJDMy4zMjklMjAxJTJDMi41JTIwMSUyQzEuNjkzJTIwMS4zNzUlMkMxJTIwMi41JTJDMSUyMDQuMzkxJTJDMSUyMDUlMkMxLjY1NiUyMDUlMkMzJTIwNSUyQzQuNiUyMDQuMzM4JTJDNS4xMTklMjAzJTJDNiUyMHYlMjA0JTIwSCUyMDIlMjB2JTIwMiUyMEglMjA4JTIwViUyMDElMjBMJTIwNyUyQzAlMjB6JTIwTSUyMDQlMkMxMCUyMFYlMjA2JTIwbCUyMDElMkMxJTIwdiUyMDMlMjBIJTIwNCUyMHolMjBtJTIwMiUyQzAlMjBWJTIwNiUyMGwlMjAxJTJDMSUyMHYlMjAzJTIwSCUyMDYlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2FhYSUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDo4cHg7aGVpZ2h0OjEycHg7YmFja2dyb3VuZC1zaXplOjhweCAxMnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZV90eXBlX3NldHRsZW1lbnQ6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwOSUyQzklMjBDJTIwOC4yMzUlMkM5JTIwNy43NjIlMkM5LjUyMiUyMDcuMjU5JTJDMTAuMDIyJTIwNy43OTUlMkMxMC4zOCUyMDguMDUxJTJDMTEuMDUlMjA3Ljg3OSUyQzEyJTIwSCUyMDEyJTIwQyUyMDEyJTJDMTAuNDYlMjAxMC41MzUlMkM5JTIwOSUyQzklMjB6JTIwbSUyMC0yLjg2OCUyQzEuMjQ4JTIwYyUyMC0wLjk2NSUyQzAlMjAtMS43NDclMkMwLjc4NCUyMC0xLjc0NyUyQzEuNzUxJTIwaCUyMDMuNDk0JTIwYyUyMDAlMkMtMC45NjclMjAtMC43ODIlMkMtMS43NTElMjAtMS43NDclMkMtMS43NTElMjB6JTIwTSUyMDEwJTJDMSUyMFYlMjAwJTIwSCUyMDclMjBWJTIwMSUyMEglMjA1JTIwViUyMDYlMjBMJTIwNiUyQzclMjBWJTIwMiUyMEglMjA3JTIwViUyMDclMjBMJTIwOCUyQzglMjBWJTIwMiUyMGglMjAxJTIwdiUyMDYlMjBoJTIwMSUyMFYlMjAyJTIwaCUyMDElMjB2JTIwNyUyMGwlMjAxJTJDMC42MDclMjBWJTIwMSUyMEglMjAxMCUyMHolMjBNJTIwNi42NiUyQzkuNTM5JTIwNi43MjElMkM5LjQ3OSUyMEMlMjA2LjkwMyUyQzkuMjk3JTIwNy4xMDQlMkM5LjE0JTIwNy4zMTQlMkM5LjAwNCUyMFYlMjA4LjQxNCUyMEwlMjA2LjEzMSUyQzcuMTg3JTIwMyUyQzglMjB2JTIwNCUyMEglMjAzLjYyJTIwQyUyMDMuNjIlMkMxMC42MTIlMjA0Ljc0NyUyQzkuNDgzJTIwNi4xMzIlMkM5LjQ4MyUyMDYuMzEyJTJDOS40ODIlMjA2LjQ5JTJDOS41MDIlMjA2LjY2JTJDOS41MzklMjB6JTIwTSUyMDIlMkMxMiUyMHolMjBNJTIwMSUyQzIlMjAwJTJDNSUyMHYlMjA3JTIwSCUyMDIlMjBWJTIwNSUyMEwlMjAxJTJDMiUyMHolMjBNJTIwMS4xMTElMkM2Ljk1NSUyMEMlMjAwLjgwNCUyQzYuOTU1JTIwMC41NTYlMkM2LjcwNiUyMDAuNTU2JTJDNi40JTIwYyUyMDAlMkMtMC4zMDclMjAwLjI0OCUyQy0wLjU1NSUyMDAuNTU1JTJDLTAuNTU1JTIwMC4zMDclMkMwJTIwMC41NTQlMkMwLjI0OCUyMDAuNTU0JTJDMC41NTUlMjAwJTJDMC4zMDYlMjAtMC4yNDclMkMwLjU1NSUyMC0wLjU1NCUyQzAuNTU1JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhMGEwYTAlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMnB4O2hlaWdodDoxMnB4O2JhY2tncm91bmQtc2l6ZToxMnB4IDEycHh9YS5kZy1tYXAtZ2VvY2xpY2tlcl9fc2hvdy1tb3JlLXNpZ2h0cy1saW5re2NvbG9yOiNmZmU2YWF9Lm5vLXRvdWNoIGEuZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGluazpob3Zlcntjb2xvcjojOWNkfWEuZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGluazphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyNiUyMiUyMGhlaWdodCUzRCUyMjEwJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwNiUyMDEwJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNiUyQzUlMjBWJTIwNS40JTIwTCUyMDEuNCUyQzEwJTIwSCUyMDAlMjBMJTIwMCUyQzguNiUyMDMuNiUyQzUlMjAwJTJDMS40JTIwMCUyQzAlMjAxLjQlMkMwJTIwNiUyQzQuNiUyMFYlMjA1JTIwbCUyMDAlMkMwJTIwMCUyQzAlMjAwJTJDMCUyMDAlMkMwJTIwMCUyQzAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2FhYSUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctbWFwLWdlb2NsaWNrZXJfX2RyaWxsZG93bntjb2xvcjojYWFhfS5kZy1wcmVsb2FkZXJ7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luOjAgYXV0bzt3aWR0aDoyMDBweDtoZWlnaHQ6NDRweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmRnLXByZWxvYWRlcl9hbmltYXRpb25fZmFsc2V7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHUHJlbG9hZGVyX19wcmVsb2FkZXIuZ2lmKTtiYWNrZ3JvdW5kLXNpemU6MTAwcHggMjZweDtiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6c2Nyb2xsO2JhY2tncm91bmQtcG9zaXRpb246NTAlIDUwJX0uZGctcHJlbG9hZGVyX2FuaW1hdGlvbl90cnVlOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2xlZnQ6NTAlO21hcmdpbjotMjJweCAwIDAgLTIycHg7d2lkdGg6NDRweDtoZWlnaHQ6NDRweDtvdXRsaW5lOnRyYW5zcGFyZW50IHNvbGlkIDFweDtjb250ZW50OicnOy13ZWJraXQtYW5pbWF0aW9uOmRnLXByZWxvYWRlcl9fb3V0ZXIgNXMgbGluZWFyIGluZmluaXRlO2FuaW1hdGlvbjpkZy1wcmVsb2FkZXJfX291dGVyIDVzIGxpbmVhciBpbmZpbml0ZTtpbWFnZS1yZW5kZXJpbmc6b3B0aW1pemVRdWFsaXR5fS5kZy1wcmVsb2FkZXJfYW5pbWF0aW9uX3RydWUuZGctcHJlbG9hZGVyX3NpemVfc21hbGw6YmVmb3Jle21hcmdpbjotMTJweCAwIDAgLTEycHg7d2lkdGg6MjRweDtoZWlnaHQ6MjRweH0uZGctcHJlbG9hZGVyX2FuaW1hdGlvbl90cnVlLmRnLXByZWxvYWRlcl9zY2hlbWVfcmVndWxhcjpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjQ0JTIyJTIwaGVpZ2h0JTNEJTIyNDQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAzNS42OCUyQzEwLjMyJTIwQyUyMDM4LjM2OCUyQzEzLjQ2NSUyMDQwJTJDMTcuNTM5JTIwNDAlMkMyMiUyMDQwJTJDMzEuOTQxJTIwMzEuOTQxJTJDNDAlMjAyMiUyQzQwJTIwMTIuMDU5JTJDNDAlMjA0JTJDMzEuOTQxJTIwNCUyQzIyJTIwNCUyQzE3LjUzOSUyMDUuNjMyJTJDMTMuNDY1JTIwOC4zMiUyQzEwLjMyJTIwTCUyMDUuNDglMkM3LjQ4JTIwQyUyMDIuMDclMkMxMS4zNTQlMjAwJTJDMTYuNDM0JTIwMCUyQzIyJTIwMCUyQzM0LjE1JTIwOS44NSUyQzQ0JTIwMjIlMkM0NCUyMDM0LjE1JTJDNDQlMjA0NCUyQzM0LjE1JTIwNDQlMkMyMiUyMDQ0JTJDMTYuNDM0JTIwNDEuOTMlMkMxMS4zNTQlMjAzOC41MiUyQzcuNDglMjBsJTIwLTIuODQlMkMyLjg0JTIweiUyMiUyMGZpbGwlM0QlMjIlMjMwZGE1ZDUlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA5LjI3MSUyQzkuMjcyJTIwQyUyMDEyLjUyOSUyQzYuMDE1JTIwMTcuMDI5JTJDNCUyMDIyJTJDNCUyMDI2Ljk3MSUyQzQlMjAzMS40NzElMkM2LjAxNSUyMDM0LjcyOSUyQzkuMjcyJTIwTCUyMDM3LjU1NyUyQzYuNDQ0JTIwQyUyMDMzLjU3NSUyQzIuNDYyJTIwMjguMDc1JTJDMCUyMDIyJTJDMCUyMDE1LjkyNSUyQzAlMjAxMC40MjUlMkMyLjQ2MiUyMDYuNDQzJTJDNi40NDQlMjBsJTIwMi44MjglMkMyLjgyOCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTZjZDJhJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7YmFja2dyb3VuZC1zaXplOjQ0cHggNDRweH0uZGctcHJlbG9hZGVyX2FuaW1hdGlvbl90cnVlLmRnLXByZWxvYWRlcl9zY2hlbWVfcmVndWxhci5kZy1wcmVsb2FkZXJfc2l6ZV9zbWFsbDpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjI0JTIyJTIwaGVpZ2h0JTNEJTIyMjQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxOC41NjQlMkM3LjQzNSUyMEMlMjAxOS40NjclMkM4LjczJTIwMjAlMkMxMC4zMDIlMjAyMCUyQzEyJTIwMjAlMkMxNi40MTglMjAxNi40MTglMkMyMCUyMDEyJTJDMjAlMjA3LjU4MiUyQzIwJTIwNCUyQzE2LjQxOCUyMDQlMkMxMiUyMDQlMkMxMC4zMDIlMjA0LjUzMyUyQzguNzMlMjA1LjQzNiUyQzcuNDM1JTIwTCUyMDIuNTgxJTJDNC41ODElMjBDJTIwMC45NjklMkM2LjYyMyUyMDAlMkM5LjE5NSUyMDAlMkMxMiUyMDAlMkMxOC42MjclMjA1LjM3MyUyQzI0JTIwMTIlMkMyNCUyMDE4LjYyNyUyQzI0JTIwMjQlMkMxOC42MjclMjAyNCUyQzEyJTIwMjQlMkM5LjE5NSUyMDIzLjAzMSUyQzYuNjIzJTIwMjEuNDE5JTJDNC41ODElMjBsJTIwLTIuODU1JTJDMi44NTQlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzBkYTVkNSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDEyJTJDMCUyMEMlMjA4LjY4NiUyQzAlMjA1LjY4NiUyQzEuMzQzJTIwMy41MTYlMkMzLjUxNSUyMEwlMjA2LjM0MyUyQzYuMzQzJTIwQyUyMDcuNzkxJTJDNC44OTUlMjA5Ljc5MSUyQzQlMjAxMiUyQzQlMjBjJTIwMi4yMDklMkMwJTIwNC4yMDklMkMwLjg5NSUyMDUuNjU3JTJDMi4zNDMlMjBMJTIwMjAuNDg0JTJDMy41MTUlMjBDJTIwMTguMzE0JTJDMS4zNDMlMjAxNS4zMTQlMkMwJTIwMTIlMkMwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhNmNkMmElMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTtiYWNrZ3JvdW5kLXNpemU6MjRweCAyNHB4fS5kZy1wcmVsb2FkZXJfYW5pbWF0aW9uX3RydWU6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTttYXJnaW46LTE2cHggMCAwIC0xNnB4O3dpZHRoOjMycHg7aGVpZ2h0OjMycHg7b3V0bGluZTp0cmFuc3BhcmVudCBzb2xpZCAxcHg7Y29udGVudDonJzstd2Via2l0LWFuaW1hdGlvbjpkZy1wcmVsb2FkZXJfX2lubmVyIDRzIGxpbmVhciBpbmZpbml0ZTthbmltYXRpb246ZGctcHJlbG9hZGVyX19pbm5lciA0cyBsaW5lYXIgaW5maW5pdGU7aW1hZ2UtcmVuZGVyaW5nOm9wdGltaXplUXVhbGl0eX0uZGctcHJlbG9hZGVyX2FuaW1hdGlvbl90cnVlLmRnLXByZWxvYWRlcl9zaXplX3NtYWxsOmFmdGVye21hcmdpbjotNnB4IDAgMCAtNnB4O3dpZHRoOjEycHg7aGVpZ2h0OjEycHh9LmRnLXByZWxvYWRlcl9hbmltYXRpb25fdHJ1ZS5kZy1wcmVsb2FkZXJfc2NoZW1lX3JlZ3VsYXI6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjMyJTIyJTIwaGVpZ2h0JTNEJTIyMzIlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA2LjU4MSUyQzIzLjQxOSUyMEMlMjA0Ljk2OSUyQzIxLjM3NyUyMDQlMkMxOC44MDQlMjA0JTJDMTYlMjA0JTJDOS4zNzMlMjA5LjM3MyUyQzQlMjAxNiUyQzQlMjBjJTIwNi42MjclMkMwJTIwMTIlMkM1LjM3MyUyMDEyJTJDMTIlMjAwJTJDMi44MDQlMjAtMC45NjklMkM1LjM3NyUyMC0yLjU4MSUyQzcuNDE5JTIwbCUyMDIuODQ3JTJDMi44NDclMjBDJTIwMzAuNTk0JTJDMjMuNDg3JTIwMzIlMkMxOS45MDklMjAzMiUyQzE2JTIwMzIlMkM3LjE2MyUyMDI0LjgzNyUyQzAlMjAxNiUyQzAlMjA3LjE2MyUyQzAlMjAwJTJDNy4xNjMlMjAwJTJDMTYlMjBjJTIwMCUyQzMuOTA5JTIwMS40MDYlMkM3LjQ4NyUyMDMuNzM0JTJDMTAuMjY2JTIwbCUyMDIuODQ3JTJDLTIuODQ3JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhNmNkMmElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAyNy4zMTQlMkMyNy4zMTQlMjAyNC40ODYlMkMyNC40ODYlMjBDJTIwMjIuMzE0JTJDMjYuNjU3JTIwMTkuMzE0JTJDMjglMjAxNiUyQzI4JTIwMTIuNjg2JTJDMjglMjA5LjY4NiUyQzI2LjY1NyUyMDcuNTE2JTJDMjQuNDg1JTIwTCUyMDQuNjg4JTJDMjcuMzEzJTIwQyUyMDcuNTgyJTJDMzAuMjA5JTIwMTEuNTgyJTJDMzIlMjAxNiUyQzMyJTIwYyUyMDQuNDE4JTJDMCUyMDguNDE4JTJDLTEuNzkxJTIwMTEuMzE0JTJDLTQuNjg2JTIweiUyMiUyMGZpbGwlM0QlMjIlMjMwZGE1ZDUlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTtiYWNrZ3JvdW5kLXNpemU6MzJweCAzMnB4fS5kZy1wcmVsb2FkZXJfYW5pbWF0aW9uX3RydWUuZGctcHJlbG9hZGVyX3NjaGVtZV9yZWd1bGFyLmRnLXByZWxvYWRlcl9zaXplX3NtYWxsOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMy4xNDElMkM2Ljg2JTIwQyUyMDMuMDU5JTJDNi41ODYlMjAzJTJDNi4zMDElMjAzJTJDNiUyMDMlMkM0LjM0MyUyMDQuMzQzJTJDMyUyMDYlMkMzJTIwNy42NTclMkMzJTIwOSUyQzQuMzQzJTIwOSUyQzYlMjA5JTJDNi4zMDElMjA4Ljk0MSUyQzYuNTg2JTIwOC44NTklMkM2Ljg2JTIwbCUyMDIuMjYlMkMyLjI1OSUyMEMlMjAxMS42NzQlMkM4LjIwOSUyMDEyJTJDNy4xNDQlMjAxMiUyQzYlMjAxMiUyQzIuNjg2JTIwOS4zMTQlMkMwJTIwNiUyQzAlMjAyLjY4NiUyQzAlMjAwJTJDMi42ODYlMjAwJTJDNiUyMDAlMkM3LjE0NCUyMDAuMzI2JTJDOC4yMDklMjAwLjg4MSUyQzkuMTE5JTIwTCUyMDMuMTQxJTJDNi44NiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTZjZDJhJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwNiUyQzEyJTIwYyUyMDEuNjU3JTJDMCUyMDMuMTU3JTJDLTAuNjcyJTIwNC4yNDMlMkMtMS43NTclMjBMJTIwOC4xMjIlMkM4LjEyMiUyMEMlMjA3LjU3OCUyQzguNjY0JTIwNi44MjglMkM5JTIwNiUyQzklMjA1LjE3MiUyQzklMjA0LjQyMiUyQzguNjY0JTIwMy44NzklMkM4LjEyMSUyMEwlMjAxLjc1OCUyQzEwLjI0MiUyMEMlMjAyLjg0MyUyQzExLjMyOCUyMDQuMzQzJTJDMTIlMjA2JTJDMTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzBkYTVkNSUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO2JhY2tncm91bmQtc2l6ZToxMnB4IDEycHh9QC13ZWJraXQta2V5ZnJhbWVzIGRnLXByZWxvYWRlcl9fb3V0ZXJ7dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIGRnLXByZWxvYWRlcl9fb3V0ZXJ7dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1ALXdlYmtpdC1rZXlmcmFtZXMgZGctcHJlbG9hZGVyX19pbm5lcnt0b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoLTM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgtMzYwZGVnKX19QGtleWZyYW1lcyBkZy1wcmVsb2FkZXJfX2lubmVye3Rvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKC0zNjBkZWcpfX0uZGctcG9wdXBfX2Zvb3Rlci1idXR0b25ze2Rpc3BsYXk6dGFibGU7bWFyZ2luLXRvcDoxMHB4O3dpZHRoOjEwMCV9LmRnLXBvcHVwX19mb290ZXItYnV0dG9uLXdyYXBwZXJ7ZGlzcGxheTp0YWJsZS1jZWxsfS5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbntwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9jazstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7bWFyZ2luLWxlZnQ6NSU7d2lkdGg6OTUlO2JvcmRlci1yYWRpdXM6MnB4O3RleHQtYWxpZ246Y2VudGVyO3RleHQtZGVjb3JhdGlvbjpub25lO2ZvbnQ6MTJweC8yNHB4IEFyaWFsLHNhbnMtc2VyaWY7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMXM7dHJhbnNpdGlvbjphbGwgLjFzfS5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbi13cmFwcGVyOmZpcnN0LWNoaWxkIC5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbnttYXJnaW46MDt3aWR0aDoxMDAlfS5uby10b3VjaCAuZGctcG9wdXBfX2Zvb3Rlci1idXR0b246aG92ZXJ7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMnM7dHJhbnNpdGlvbjphbGwgLjJzfS5kZy1wb3B1cF9fZm9vdGVyLWljb24tYnV0dG9uOmJlZm9yZXtkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW46LTJweCA1cHggMCAwO3dpZHRoOjEycHg7aGVpZ2h0OjEycHg7YmFja2dyb3VuZC1zaXplOmNvbnRhaW47YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2NvbnRlbnQ6Jyc7dmVydGljYWwtYWxpZ246bWlkZGxlfS5kZy1wb3B1cF9fYnV0dG9uX25hbWVfYmFjazpiZWZvcmUsLmRnLXBvcHVwX19idXR0b25fbmFtZV9maXJtLWNhcmQtYmFjazpiZWZvcmUsLmRnLXBvcHVwX19idXR0b25fbmFtZV9maXJtLWxpc3QtYmFjazpiZWZvcmV7d2lkdGg6OXB4O2hlaWdodDo2cHh9LmRnLXBvcHVwX19zaG93LWxlc3MtaG91c2UtbGlua3twb3NpdGlvbjpyZWxhdGl2ZTt0b3A6NnB4O21hcmdpbjowIDE1cHggMTBweDtjb2xvcjojMDA3MGMwO3RleHQtZGVjb3JhdGlvbjpub25lO2ZvbnQtc2l6ZToxMnB4O2xpbmUtaGVpZ2h0OjI0cHh9LmRnLXBvcHVwX19oZWFkZXItbGlua3N7bWFyZ2luOjhweCAxOHB4IDAgMH0uZGctcG9wdXBfX2hlYWRlci10aXRsZV9mb3JfZmlybWNhcmR7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVuO21heC1oZWlnaHQ6My40ZW19LmRnLXBvcHVwX19oZWFkZXItdGVhc2Vye2Rpc3BsYXk6LXdlYmtpdC1ib3g7aGVpZ2h0OjMuM2VtOy13ZWJraXQtbGluZS1jbGFtcDozOy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbH0uZGctcG9wdXBfX2hlYWRlci10aXRsZXtkaXNwbGF5OmJsb2NrO3doaXRlLXNwYWNlOm5vcm1hbDtmb250OjIycHgvMjRweCAnQXJpYWwgbmFycm93JyxBcmlhbCxzYW5zLXNlcmlmfS5kZy1wb3B1cF9faGVhZGVyLWxpbmt7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWxlZnQ6Mi42ZW07dmVydGljYWwtYWxpZ246bWlkZGxlO3doaXRlLXNwYWNlOm5vd3JhcH0uZGctcG9wdXBfX2hlYWRlci1saW5rOmZpcnN0LWNoaWxke21hcmdpbi1sZWZ0OjEuMmVtfS5kZy1wb3B1cF9fcmF0aW5ne2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjowIC40ZW0gM3B4IDA7d2lkdGg6NzBweDtoZWlnaHQ6MTRweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmRnLXBvcHVwX19yYXRpbmctc3RhcnN7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTQlMjIlMjBoZWlnaHQlM0QlMjIxNCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDYuOTk5JTJDMCUyMDguNzQ4JTJDNC45ODklMjAxMy45OTclMkM0Ljk5MSUyMDkuODMlMkM4LjcwOCUyMDExLjMyNCUyQzE0LjAwMiUyMDYuOTk5JTJDMTAuODcxJTIwMi42NzQlMkMxNC4wMDIlMjA0LjE2OCUyQzguNzA4JTIwMCUyQzQuOTkxJTIwNS4yNDklMkM0Ljk4OSUyMDYuOTk5JTJDMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZjODRiJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7ZmxvYXQ6bGVmdDtoZWlnaHQ6MTAwJX0uZGctcG9wdXBfX2xpbmt7cG9zaXRpb246cmVsYXRpdmU7YmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXIgYm90dG9tO2JhY2tncm91bmQtc2l6ZToxMHB4IDFweDtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDt0ZXh0LWRlY29yYXRpb246bm9uZTstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6dHJhbnNwYXJlbnR9LmRnLXBvcHVwX19saW5rX3R5cGVfZmxhbXBfcmV2aWV3c3ttYXJnaW4tbGVmdDouMWVtfS5kZy1wb3B1cF9fbGlua190eXBlX3Bob3RvczpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjJweDtsZWZ0Oi0xOHB4O2Rpc3BsYXk6aW5oZXJpdDtjb250ZW50OicnfS5kZy1wb3B1cF9fbGlua190eXBlX2Jvb2tsZXQ6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEwJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMCUyQzglMjAzJTJDMiUyMFYlMjAyJTIwTCUyMDAlMkMwJTIwViUyMDglMjB6JTIwTSUyMDQlMkMxMCUyMDglMkM4JTIwViUyMDAlMjBMJTIwNCUyQzIlMjB2JTIwOCUyMHolMjBNJTIwOSUyQzAlMjB2JTIwOCUyMGwlMjAzJTJDMiUyMFYlMjAyJTIwTCUyMDklMkMwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3ZGM4MTQlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTJweDtoZWlnaHQ6MTBweDtiYWNrZ3JvdW5kLXNpemU6MTJweCAxMHB4O3Bvc2l0aW9uOmFic29sdXRlO3RvcDoycHg7bGVmdDotMThweDtkaXNwbGF5OmluaGVyaXQ7Y29udGVudDonJ31hLmRnLXBvcHVwX19saW5re2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AscmlnaHQgdG9wLGZyb20ocmdiYSgyNTUsMjMwLDE3MCwuMykpLHRvKHJnYmEoMjU1LDIzMCwxNzAsLjMpKSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LHJnYmEoMjU1LDIzMCwxNzAsLjMpLHJnYmEoMjU1LDIzMCwxNzAsLjMpIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoMjU1LDIzMCwxNzAsLjMpLHJnYmEoMjU1LDIzMCwxNzAsLjMpIDEwMCUpO2NvbG9yOiNmZmU2YWF9Lm5vLXRvdWNoIGEuZGctcG9wdXBfX2xpbms6aG92ZXJ7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxyaWdodCB0b3AsZnJvbShyZ2JhKDE1MywyMDQsMjIxLC4zKSksdG8ocmdiYSgxNTMsMjA0LDIyMSwuMykpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KGxlZnQscmdiYSgxNTMsMjA0LDIyMSwuMykscmdiYSgxNTMsMjA0LDIyMSwuMykgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQscmdiYSgxNTMsMjA0LDIyMSwuMykscmdiYSgxNTMsMjA0LDIyMSwuMykgMTAwJSk7Y29sb3I6IzljZH0uZGctcG9wdXBfX2hlYWRlci10aXRsZXtjb2xvcjojZmZjODRifS5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbi13cmFwcGVyIC5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbiwuZGctcG9wdXBfX2Zvb3Rlci1idXR0b24td3JhcHBlciAuZGctcG9wdXBfX2Zvb3Rlci1idXR0b246aG92ZXJ7Y29sb3I6I2U2ZTZlNn0uZGctcG9wdXBfX2Zvb3Rlci1idXR0b257YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4yKTstd2Via2l0LWJveC1zaGFkb3c6MCAxcHggcmdiYSgwLDAsMCwuMSk7Ym94LXNoYWRvdzowIDFweCByZ2JhKDAsMCwwLC4xKX0ubm8tdG91Y2ggLmRnLXBvcHVwX19mb290ZXItYnV0dG9uOmhvdmVye2JhY2tncm91bmQ6IzIyMjstd2Via2l0LWJveC1zaGFkb3c6MCAxcHggM3B4IHJnYmEoMCwwLDAsLjUpO2JveC1zaGFkb3c6MCAxcHggM3B4IHJnYmEoMCwwLDAsLjUpfS5kZy1wb3B1cF9fcmF0aW5ne2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjE0JTIyJTIwaGVpZ2h0JTNEJTIyMTQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA3LjAwMiUyQzAlMjA4Ljc1MSUyQzQuOTg5JTIwMTQlMkM0Ljk5MSUyMDkuODMzJTJDOC43MDglMjAxMS4zMjclMkMxNC4wMDIlMjA3LjAwMiUyQzEwLjg3MSUyMDIuNjc3JTJDMTQuMDAyJTIwNC4xNzElMkM4LjcwOCUyMDAuMDAzJTJDNC45OTElMjA1LjI1MiUyQzQuOTg5JTIwNy4wMDIlMkMwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhYWElMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctcG9wdXBfX2xpbmtfdHlwZV9waG90b3M6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEwJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTElMkMxJTIwSCUyMDEwJTIwTCUyMDklMkMwJTIwSCUyMDYlMjBMJTIwNSUyQzElMjBIJTIwMSUyMEwlMjAwJTJDMiUyMHYlMjA3JTIwbCUyMDElMkMxJTIwSCUyMDExJTIwTCUyMDEyJTJDOSUyMFYlMjAyJTIwTCUyMDExJTJDMSUyMHolMjBNJTIwMyUyQzQlMjBIJTIwMiUyMFYlMjAzJTIwaCUyMDElMjB2JTIwMSUyMHolMjBtJTIwNC41MTglMkMzLjk5MiUyMGMlMjAtMS4zODElMkMwJTIwLTIuNSUyQy0xLjExOSUyMC0yLjUlMkMtMi41JTIwMCUyQy0xLjM4JTIwMS4xMTklMkMtMi41JTIwMi41JTJDLTIuNSUyMDEuMzglMkMwJTIwMi41JTJDMS4xMiUyMDIuNSUyQzIuNSUyMDAlMkMxLjM4MSUyMC0xLjEyMSUyQzIuNSUyMC0yLjUlMkMyLjUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzc5YjBiYyUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMnB4O2hlaWdodDoxMHB4O2JhY2tncm91bmQtc2l6ZToxMnB4IDEwcHh9LmRnLXBvcHVwX19idXR0b25fbmFtZV9maXJtLWNhcmQtYmFjazpiZWZvcmUsLmRnLXBvcHVwX19idXR0b25fbmFtZV9maXJtLWxpc3QtYmFjazpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjklMjIlMjBoZWlnaHQlM0QlMjI2JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzMlMjA0JTJDNiUyMFYlMjA0JTIwSCUyMDklMjBWJTIwMiUyMEglMjA0JTIwViUyMDAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzlmOWY5ZiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpfS5kZy1wb3B1cF9fYnV0dG9uX25hbWVfYmFjazpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjklMjIlMjBoZWlnaHQlM0QlMjI2JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzMlMjA0JTJDNiUyMFYlMjA0JTIwSCUyMDklMjBWJTIwMiUyMEglMjA0JTIwViUyMDAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzlmOWY5ZiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjlweDtoZWlnaHQ6NnB4O2JhY2tncm91bmQtc2l6ZTo5cHggNnB4fS5kZy1wb3B1cF9fYnV0dG9uX25hbWVfZ290bzpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjIwJTIyJTIwaGVpZ2h0JTNEJTIyNyUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE2LjUlMkMwJTIwQyUyMDE0LjczOCUyQzAlMjAxMy4yOTUlMkMxLjMwNiUyMDEzLjA1MSUyQzMlMjBIJTIwNC45NDklMjBDJTIwNC43MTglMkMxLjg1OCUyMDMuNzElMkMxJTIwMi41JTJDMSUyMDEuMTE5JTJDMSUyMDAlMkMyLjExOSUyMDAlMkMzLjUlMjAwJTJDNC44ODElMjAxLjExOSUyQzYlMjAyLjUlMkM2JTIwMy43MSUyQzYlMjA0LjcxOCUyQzUuMTQyJTIwNC45NDklMkM0JTIwaCUyMDguMTAyJTIwQyUyMDEzLjI5NSUyQzUuNjkzJTIwMTQuNzM5JTJDNyUyMDE2LjUlMkM3JTIwMTguNDMzJTJDNyUyMDIwJTJDNS40MzMlMjAyMCUyQzMuNSUyMDIwJTJDMS41NjYlMjAxOC40MzMlMkMwJTIwMTYuNSUyQzAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzlmOWY5ZiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjIwcHg7aGVpZ2h0OjdweDtiYWNrZ3JvdW5kLXNpemU6MjBweCA3cHh9LmRnLXBvcHVwX19idXR0b25fbmFtZV9zaG93LWVudHJhbmNlOmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTIlMjIlMjBoZWlnaHQlM0QlMjIxMiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDUlMkM5JTIwOSUyQzYlMjA1JTJDMyUyMFYlMjA1JTIwSCUyMDAlMjBWJTIwNyUyMEglMjA1JTIwViUyMDklMjB6JTIwTSUyMDkuNiUyQzAlMjBIJTIwMi40JTIwQyUyMDEuMDc0JTJDMCUyMDAlMkMxLjA3NCUyMDAlMkMyLjQlMjBWJTIwNCUyMEglMjAyJTIwViUyMDMuNiUyMEMlMjAyJTJDMi43MTYlMjAyLjcxNiUyQzIlMjAzLjYlMkMyJTIwSCUyMDguNCUyMEMlMjA5LjI4MyUyQzIlMjAxMCUyQzIuNzE2JTIwMTAlMkMzLjYlMjBWJTIwOC40JTIwQyUyMDEwJTJDOS4yODQlMjA5LjI4MyUyQzEwJTIwOC40JTJDMTAlMjBIJTIwMy42JTIwQyUyMDIuNzE2JTJDMTAlMjAyJTJDOS4yODQlMjAyJTJDOC40JTIwViUyMDglMjBIJTIwMCUyMFYlMjA5LjYlMjBDJTIwMCUyQzEwLjkyNSUyMDEuMDc0JTJDMTIlMjAyLjQlMkMxMiUyMEglMjA5LjYlMjBDJTIwMTAuOTI2JTJDMTIlMjAxMiUyQzEwLjkyNSUyMDEyJTJDOS42JTIwViUyMDIuNCUyMEMlMjAxMiUyQzEuMDc0JTIwMTAuOTI2JTJDMCUyMDkuNiUyQzAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctZmlybS1jYXJkX19pY29ue3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmctbGVmdDoyNHB4fS5kZy1maXJtLWNhcmRfX2ljb246YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDttYXJnaW46YXV0bztiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgNTAlO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtjb250ZW50OicnfS5kZy1maXJtLWNhcmRfX2xpbmt7b3ZlcmZsb3c6aGlkZGVuO21hcmdpbi1ib3R0b206NHB4O3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwO3dvcmQtd3JhcDpub3JtYWw7bGluZS1oZWlnaHQ6MTZweH0uZGctZmlybS1jYXJkX19saW5rIGF7YmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXIgYm90dG9tO2JhY2tncm91bmQtc2l6ZToxMHB4IDFweDtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDt0ZXh0LWRlY29yYXRpb246bm9uZX0uZGctZmlybS1jYXJkX19hZGRyZXNze21hcmdpbi1ib3R0b206MTBweDtmb250LXNpemU6MTZweH0uZGctZmlybS1jYXJkX19hZGRyZXNzOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NXB4O2xlZnQ6MXB4O2NvbnRlbnQ6Jyd9LmRnLWZpcm0tY2FyZF9fY29tbWVudHtwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tbGVmdDo1cHg7Zm9udC1zaXplOjEycHh9LmRnLWZpcm0tY2FyZF9fcGhvbmV7b3ZlcmZsb3c6aGlkZGVuO21hcmdpbi1ib3R0b206NHB4O3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7bGluZS1oZWlnaHQ6MTZweH0uZGctZmlybS1jYXJkX19waG9uZTpiZWZvcmV7dG9wOjNweDtsZWZ0OjFweH0uZGctZmlybS1jYXJkX19zaXRlOmJlZm9yZXt0b3A6M3B4fS5kZy1maXJtLWNhcmRfX2VtYWlsOmJlZm9yZXt0b3A6NXB4fS5kZy1maXJtLWNhcmRfX3J1YnJpY3N7b3ZlcmZsb3c6aGlkZGVuO21hcmdpbi1ib3R0b206NHB4O2ZvbnQtc2l6ZToxMnB4O2xpbmUtaGVpZ2h0OjE2cHh9LmRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0e21hcmdpbjowO3BhZGRpbmc6MDtsaXN0LXN0eWxlOm5vbmV9LmRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0LWl0ZW17ZGlzcGxheTppbmxpbmU7Y3Vyc29yOmRlZmF1bHR9LmRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0LWl0ZW06YmVmb3Jle2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjowIDRweDtjb250ZW50OifigKInfS5kZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdC1pdGVtOmZpcnN0LWNoaWxkOmJlZm9yZXttYXJnaW46MDtjb250ZW50OicnfS5kZy1maXJtLWNhcmRfX2Fhe21hcmdpbjowIDAgNHB4O3BhZGRpbmc6MCAwIDAgMjRweDtmb250LXNpemU6MTJweH0uZGctZmlybS1jYXJkX19hYS1saXN0e2Rpc3BsYXk6aW5saW5lO21hcmdpbjowO3BhZGRpbmc6MDtsaXN0LXN0eWxlOm5vbmU7bGluZS1oZWlnaHQ6MTZweH0uZGctZmlybS1jYXJkX19hYS1saXN0LWl0ZW17ZGlzcGxheTppbmxpbmU7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O21heC13aWR0aDoxMDAlO2N1cnNvcjpkZWZhdWx0fS5kZy1maXJtLWNhcmRfX2FhLWxpc3QtaXRlbTpiZWZvcmV7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luOjAgNHB4O2NvbnRlbnQ6J+KAoid9LmRnLWZpcm0tY2FyZF9fYWEtbGlzdC1pdGVtOmZpcnN0LWNoaWxkOmJlZm9yZXttYXJnaW46MDtjb250ZW50OicnfS5kZy1maXJtLWNhcmRfX2FhLWxpc3QtYWRkaXRpb25hbHtkaXNwbGF5OmlubGluZTttYXJnaW46MDtwYWRkaW5nOjA7bGlzdC1zdHlsZTpub25lO2xpbmUtaGVpZ2h0OjE2cHh9LmRnLWZpcm0tY2FyZF9fc2NoZWR1bGV7bWFyZ2luLWJvdHRvbToxMHB4fS5kZy1maXJtLWNhcmRfX2xpbmsgYXtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLHJpZ2h0IHRvcCxmcm9tKHJnYmEoMjU1LDIzMCwxNzAsLjMpKSx0byhyZ2JhKDI1NSwyMzAsMTcwLC4zKSkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCxyZ2JhKDI1NSwyMzAsMTcwLC4zKSxyZ2JhKDI1NSwyMzAsMTcwLC4zKSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byByaWdodCxyZ2JhKDI1NSwyMzAsMTcwLC4zKSxyZ2JhKDI1NSwyMzAsMTcwLC4zKSAxMDAlKTtjb2xvcjojZmZlNmFhfS5uby10b3VjaCAuZGctZmlybS1jYXJkX19saW5rIGE6aG92ZXJ7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxyaWdodCB0b3AsZnJvbShyZ2JhKDE1MywyMDQsMjIxLC4zKSksdG8ocmdiYSgxNTMsMjA0LDIyMSwuMykpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KGxlZnQscmdiYSgxNTMsMjA0LDIyMSwuMykscmdiYSgxNTMsMjA0LDIyMSwuMykgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQscmdiYSgxNTMsMjA0LDIyMSwuMykscmdiYSgxNTMsMjA0LDIyMSwuMykgMTAwJSk7Y29sb3I6IzljZH0uZGctZmlybS1jYXJkX19jb21tZW50LC5kZy1maXJtLWNhcmRfX3J1YnJpY3N7Y29sb3I6I2FhYX0uZGctZmlybS1jYXJkX19ydWJyaWNzLWxpc3QtaXRlbTphZnRlcntjb2xvcjojNmU2OTY0fS5kZy1maXJtLWNhcmRfX2FhLWxpc3QtaXRlbTphZnRlcntjb2xvcjojZTZlNmU2fS5kZy1maXJtLWNhcmRfX2FkZHJlc3M6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjI5JTIyJTIwaGVpZ2h0JTNEJTIyMTElMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA0Ljk1OCUyQzExJTIwQyUyMDQuOTU4JTJDOS4wMzYlMjA2Ljc1NiUyQzYuNzUxJTIwOC43MTklMkM2Ljc1MSUyMDguODg1JTJDNi4yMjMlMjA5JTJDNS42NTYlMjA5JTJDNS4wNjMlMjA5JTJDMi4yNjclMjA2Ljk4NSUyQzAlMjA0LjUlMkMwJTIwMi4wMTUlMkMwJTIwMCUyQzIuMjY3JTIwMCUyQzUuMDYzJTIwMCUyQzUuNjU2JTIwMC4xMTQlMkM2LjIyMiUyMDAuMjglMkM2Ljc1MSUyMDIuMjQzJTJDNi43NTElMjA0LjAxOCUyQzkuMDEyJTIwNC4wMTglMkMxMSUyMGglMjAwLjk0JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhMGEwYTAlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDo5cHg7aGVpZ2h0OjExcHg7YmFja2dyb3VuZC1zaXplOjlweCAxMXB4fS5kZy1maXJtLWNhcmRfX3Bob25lOmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTAlMjIlMjBoZWlnaHQlM0QlMjIxMCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDkuMTgxJTJDOS4wNSUyMEMlMjA4LjY3MyUyQzkuNTU2JTIwOC4wNDclMkM5Ljg3MyUyMDcuMzkxJTJDMTAlMjA2LjE1NiUyQzkuODQxJTIwNS4wMDglMkM5LjQxNyUyMDMuOTk4JTJDOC43ODglMjBMJTIwMS4yOTMlMkM2LjA5MiUyMEMlMjAwLjYzOSUyQzUuMDUzJTIwMC4yMDMlMkMzLjg2NSUyMDAuMDUyJTJDMi41ODklMjAwLjE5JTJDMS45NjQlMjAwLjQ5NCUyQzEuMzY4JTIwMC45ODMlMkMwLjg4MiUyMEwlMjAxLjgwMyUyQzAuMDY1JTIwMy45ODclMkMyLjI0MSUyMFYlMjAyLjc5JTIwTCUyMDMuNDQxJTJDMy4zMzIlMjBjJTIwLTAuNDUyJTJDMC40NTElMjAtMC40NTMlMkMxLjE4MyUyMDAlMkMxLjYzNCUyMEwlMjA1LjA4MiUyQzYuNiUyMGMlMjAwLjQ1MiUyQzAuNDUxJTIwMS4xODclMkMwLjQ1MSUyMDEuNjM5JTJDMCUyMEwlMjA3LjI0NCUyQzYuMDc5JTIwSCUyMDcuODM4JTIwTCUyMDEwJTJDOC4yMzMlMjA5LjE4MSUyQzkuMDUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMHB4O2hlaWdodDoxMHB4O2JhY2tncm91bmQtc2l6ZToxMHB4IDEwcHh9LmRnLWZpcm0tY2FyZF9fc2l0ZTpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjExJTIyJTIwaGVpZ2h0JTNEJTIyMTElMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA1LjUlMkMxMSUyMEMlMjAyLjQ2MyUyQzExJTIwMCUyQzguNTM4JTIwMCUyQzUuNSUyMDAlMkMyLjQ2MiUyMDIuNDYzJTJDMCUyMDUuNSUyQzAlMjA4LjUzNyUyQzAlMjAxMSUyQzIuNDYyJTIwMTElMkM1LjUlMjAxMSUyQzguNTM4JTIwOC41MzclMkMxMSUyMDUuNSUyQzExJTIweiUyMG0lMjAwJTJDLTklMjBDJTIwMy41NjYlMkMyJTIwMiUyQzMuNTY3JTIwMiUyQzUuNSUyMDIlMkM3LjQzMyUyMDMuNTY2JTJDOSUyMDUuNSUyQzklMjA1LjY1NSUyQzklMjA1LjgwNCUyQzguOTc0JTIwNS45NTQlMkM4Ljk1NCUyMEwlMjAzJTJDNiUyMFYlMjA1JTIwTCUyMDUuNTcxJTJDMy4yODYlMjA1Ljk4NCUyQzIuMDQ5JTIwQyUyMDUuODI0JTJDMi4wMjYlMjA1LjY2NiUyQzIlMjA1LjUlMkMyJTIweiUyME0lMjA4Ljk0OSUyQzUlMjBIJTIwNy4zNzUlMjBDJTIwNy4wMjElMkM1LjUwNSUyMDYuNTQ1JTJDNi4wODIlMjA2JTJDNi40OTclMjBWJTIwOC45NSUyMEMlMjA3LjY5MyUyQzguNzA1JTIwOSUyQzcuMjYyJTIwOSUyQzUuNSUyMDklMkM1LjMyOSUyMDguOTc0JTJDNS4xNjUlMjA4Ljk0OSUyQzUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMXB4O2hlaWdodDoxMXB4O2JhY2tncm91bmQtc2l6ZToxMXB4IDExcHh9LmRnLWZpcm0tY2FyZF9fZW1haWw6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMSUyMiUyMGhlaWdodCUzRCUyMjclMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxMSUyQzEuNTU1JTIwdiUyMDMuODklMjBDJTIwMTElMkM2LjMwMyUyMDEwLjI0MiUyQzclMjA5LjMwOSUyQzclMjBIJTIwMS42OTIlMjBDJTIwMC43NTglMkM3JTIwMCUyQzYuMzAzJTIwMCUyQzUuNDQ0JTIwViUyMDEuNTU0JTIwTCUyMDUuNSUyQzQuODI2JTIwMTElMkMxLjU1NSUyMHolMjBNJTIwMC4xOTElMkMwJTIwSCUyMDEwLjgwOCUyMEwlMjA1LjUlMkMzLjExMSUyMDAuMTkxJTJDMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYWFhJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjExcHg7aGVpZ2h0OjdweDtiYWNrZ3JvdW5kLXNpemU6MTFweCA3cHh9LmRnLXNjaGVkdWxlX190b2RheXtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tbGVmdDoyNHB4O21heC13aWR0aDo4NCU7YmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXIgYm90dG9tO2JhY2tncm91bmQtc2l6ZToycHggMXB4O2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjE2cHg7Y3Vyc29yOnBvaW50ZXJ9LmRnLXNjaGVkdWxlX190b2RheTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjNweDtsZWZ0Oi0yNHB4O2NvbnRlbnQ6Jyd9LmRnLXNjaGVkdWxlX190b2RheTphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotMTVweDtib3R0b206NHB4O2NvbnRlbnQ6Jyd9LmRnLXNjaGVkdWxlX190b2RheS1pbm5lcntvdmVyZmxvdzpoaWRkZW47d2lkdGg6MTAwJTt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcH0uZGctc2NoZWR1bGVfd29ya3MtZXZlcnlkYXlfdHJ1ZSAuZGctc2NoZWR1bGVfX3RvZGF5e2JhY2tncm91bmQtaW1hZ2U6bm9uZTtjdXJzb3I6ZGVmYXVsdH0uZGctc2NoZWR1bGVfd29ya3MtZXZlcnlkYXlfdHJ1ZSAuZGctc2NoZWR1bGVfX3RvZGF5OmFmdGVye2JhY2tncm91bmQtaW1hZ2U6bm9uZX0uZGctc2NoZWR1bGVfb3Blbl90cnVlIC5kZy1zY2hlZHVsZV9fdG9kYXk6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMSUyMiUyMGhlaWdodCUzRCUyMjExJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNS41JTJDMTElMjBDJTIwMi40NjMlMkMxMSUyMDAlMkM4LjUzNyUyMDAlMkM1LjUlMjAwJTJDMi40NjIlMjAyLjQ2MyUyQzAlMjA1LjUlMkMwJTIwOC41MzclMkMwJTIwMTElMkMyLjQ2MiUyMDExJTJDNS41JTIwMTElMkM4LjUzNyUyMDguNTM3JTJDMTElMjA1LjUlMkMxMSUyMHolMjBNJTIwNiUyQzUuMjkzJTIwViUyMDIlMjBIJTIwNSUyMFYlMjA1LjcwNyUyMEwlMjA3LjY0NiUyQzguMzUzJTIwOC4zNTMlMkM3LjY0NiUyMDYlMkM1LjI5MyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNzBiZjAwJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjExcHg7aGVpZ2h0OjExcHg7YmFja2dyb3VuZC1zaXplOjExcHggMTFweH0uZGctc2NoZWR1bGVfX25vd3ttYXJnaW46MnB4IDdweCAwIDM2cHg7Zm9udC1zaXplOjEycHh9LmRnLXNjaGVkdWxlX19zdHJpbmd7cGFkZGluZzozcHggMTZweCAzcHggMjRweDt0ZXh0LWFsaWduOmxlZnQ7Zm9udC1zaXplOjE0cHh9LmRnLXNjaGVkdWxlX19zdHJpbmctdGltZXt3aGl0ZS1zcGFjZTpub3dyYXB9LmRnLXNjaGVkdWxlX190YWJsZXtkaXNwbGF5Om5vbmU7dGV4dC1hbGlnbjpjZW50ZXI7Zm9udC1zaXplOjB9LmRnLXNjaGVkdWxlX190YWJsZS1jZWxsLWdyb3Vwe3doaXRlLXNwYWNlOm5vd3JhcH0uZGctc2NoZWR1bGVfX3Rje2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MnB4IDAgMTVweDt3aWR0aDo0NHB4O3ZlcnRpY2FsLWFsaWduOnRvcDt3aGl0ZS1zcGFjZTpub3JtYWw7Zm9udC1zaXplOjE0cHh9LmRnLXNjaGVkdWxlX190Y19wcmV7d2lkdGg6MTlweH0uZGctc2NoZWR1bGVfX2RheS1uYW1le21hcmdpbjowO2NvbG9yOiM4Yzg3ODI7dGV4dC10cmFuc2Zvcm06Y2FwaXRhbGl6ZX0uZGctc2NoZWR1bGVfX3Rke21hcmdpbjoxMHB4IDAgMH0uZGctc2NoZWR1bGVfc3RhdGVfZXhwYW5kZWQgLmRnLXNjaGVkdWxlX19wb3B1cHtkaXNwbGF5OmJsb2NrO3Zpc2liaWxpdHk6dmlzaWJsZTttYXgtaGVpZ2h0OjEwMDBweDtvcGFjaXR5OjF9LmRnLXNjaGVkdWxlX190YWJsZS1jbG9ja3ttYXJnaW46MTNweCAwIDB9LmRnLXNjaGVkdWxlX190YWJsZS1sdW5jaHttYXJnaW46MzFweCAwIDB9LmRnLXNjaGVkdWxlX190b2RheXtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLHJpZ2h0IHRvcCxmcm9tKHJnYmEoMjMwLDIzMCwyMzAsLjU1KSksY29sb3Itc3RvcCg1MCUscmdiYSgyMzAsMjMwLDIzMCwuNTUpKSxjb2xvci1zdG9wKDUxJSxyZ2JhKDAsMCwwLDApKSx0byhyZ2JhKDAsMCwwLDApKSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LHJnYmEoMjMwLDIzMCwyMzAsLjU1KSxyZ2JhKDIzMCwyMzAsMjMwLC41NSkgNTAlLHJnYmEoMCwwLDAsMCkgNTElLHJnYmEoMCwwLDAsMCkgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQscmdiYSgyMzAsMjMwLDIzMCwuNTUpLHJnYmEoMjMwLDIzMCwyMzAsLjU1KSA1MCUscmdiYSgwLDAsMCwwKSA1MSUscmdiYSgwLDAsMCwwKSAxMDAlKX0uZGctc2NoZWR1bGVfX25vd3tjb2xvcjojYWFhfS5kZy1zY2hlZHVsZV9fdGR7Y29sb3I6I2U2ZTZlNn0uZGctc2NoZWR1bGVfX3RjX2FjdGl2ZV90cnVle2JhY2tncm91bmQ6cmdiYSgyNTUsMjU1LDI1NSwuMSl9LmRnLXNjaGVkdWxlX19zdHJpbmctdGltZXtjb2xvcjojZTZlNmU2fS5kZy1zY2hlZHVsZV9fdGFibGUtY2xvY2t7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjExJTIyJTIwaGVpZ2h0JTNEJTIyMTElMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA1LjUlMkMxMSUyMEMlMjAyLjQ2MyUyQzExJTIwMCUyQzguNTM3JTIwMCUyQzUuNSUyMDAlMkMyLjQ2MiUyMDIuNDYzJTJDMCUyMDUuNSUyQzAlMjA4LjUzNyUyQzAlMjAxMSUyQzIuNDYyJTIwMTElMkM1LjUlMjAxMSUyQzguNTM3JTIwOC41MzclMkMxMSUyMDUuNSUyQzExJTIweiUyME0lMjA2JTJDNS4yOTMlMjBWJTIwMiUyMEglMjA1JTIwViUyMDUuNzA3JTIwTCUyMDcuNjQ2JTJDOC4zNTMlMjA4LjM1MyUyQzcuNjQ2JTIwNiUyQzUuMjkzJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhMGEwYTAlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTFweDtoZWlnaHQ6MTFweDtiYWNrZ3JvdW5kLXNpemU6MTFweCAxMXB4fS5kZy1zY2hlZHVsZV9fdGFibGUtbHVuY2h7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjEyJTIyJTIwaGVpZ2h0JTNEJTIyMTElMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA0JTJDNyUyMEglMjA4JTIwQyUyMDguNTglMkM3JTIwOS40NjElMkM2LjA4NCUyMDkuODI2JTJDNC45NzclMjBWJTIwNSUyMEMlMjAxMS4wNDclMkM1JTIwMTIlMkMzLjQ1MyUyMDEyJTJDMi4wMzElMjAxMiUyQzEuNDUzJTIwMTEuNTMxJTJDMSUyMDExLjAxNiUyQzElMjBIJTIwMTAlMjBDJTIwMTAlMkMwLjE4OCUyMDkuNzgxJTJDMCUyMDklMkMwJTIwSCUyMDMlMjBDJTIwMi4yOTclMkMwJTIwMiUyQzAuMTg4JTIwMiUyQzElMjB2JTIwMyUyMGMlMjAwJTJDMS40OSUyMDEuMTM3JTJDMyUyMDIlMkMzJTIweiUyMG0lMjA2JTJDLTUlMjBoJTIwMC41JTIwQyUyMDEwLjg3NSUyQzIlMjAxMSUyQzIuMjE5JTIwMTElMkMyLjUlMjAxMSUyQzMuNjI1JTIwMTAuNTYyJTJDNCUyMDEwJTJDNCUyMFYlMjAyJTIweiUyME0lMjAwJTJDOSUyMGMlMjAwJTJDMC40NDglMjAxLjc5MSUyQzElMjAzJTJDMSUyMDAlMkMwLjQwNSUyMDAuNjQ2JTJDMSUyMDElMkMxJTIwaCUyMDQlMjBjJTIwMC4zNTQlMkMwJTIwMSUyQy0wLjU5NSUyMDElMkMtMSUyMDEuMjA4JTJDMCUyMDMlMkMtMC41NTIlMjAzJTJDLTElMjBWJTIwOCUyMEglMjAwJTIwdiUyMDElMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2FhYTVhMCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjEycHg7aGVpZ2h0OjExcHg7YmFja2dyb3VuZC1zaXplOjEycHggMTFweH0uZGctc2NoZWR1bGVfb3Blbl9mYWxzZSAuZGctc2NoZWR1bGVfX3RvZGF5OmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTElMjIlMjBoZWlnaHQlM0QlMjIxMSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDUuNSUyQzExJTIwQyUyMDIuNDYzJTJDMTElMjAwJTJDOC41MzclMjAwJTJDNS41JTIwMCUyQzIuNDYyJTIwMi40NjMlMkMwJTIwNS41JTJDMCUyMDguNTM3JTJDMCUyMDExJTJDMi40NjIlMjAxMSUyQzUuNSUyMDExJTJDOC41MzclMjA4LjUzNyUyQzExJTIwNS41JTJDMTElMjB6JTIwTSUyMDYlMkM1LjI5MyUyMFYlMjAyJTIwSCUyMDUlMjBWJTIwNS43MDclMjBMJTIwNy42NDYlMkM4LjM1MyUyMDguMzUzJTJDNy42NDYlMjA2JTJDNS4yOTMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMXB4O2hlaWdodDoxMXB4O2JhY2tncm91bmQtc2l6ZToxMXB4IDExcHh9LmRnLXNjaGVkdWxlX190b2RheTphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTAlMjIlMjBoZWlnaHQlM0QlMjI2JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNSUyQzYlMjBIJTIwNC41ODYlMjBMJTIwMCUyQzEuNDE0JTIwViUyMDAlMjBIJTIwMS40MTQlMjBMJTIwNSUyQzMuNTg2JTIwOC41ODYlMkMwJTIwSCUyMDEwJTIwViUyMDEuNDE0JTIwTCUyMDUuNDE0JTJDNiUyMEglMjA1JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhNWEwOWMlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTBweDtoZWlnaHQ6NnB4O2JhY2tncm91bmQtc2l6ZToxMHB4IDZweH0uZGctc2NoZWR1bGVfX3RvZGF5X3Nob3duX3RydWU6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjEwJTIyJTIwaGVpZ2h0JTNEJTIyNiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDUlMkMwJTIwSCUyMDUuNDE0JTIwTCUyMDEwJTJDNC41ODYlMjBWJTIwNiUyMEglMjA4LjU4NiUyMEwlMjA1JTJDMi40MTQlMjAxLjQxNCUyQzYlMjBIJTIwMCUyMFYlMjA0LjU4NiUyMEwlMjA0LjU4NiUyQzAlMjBIJTIwNSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTVhMDljJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjEwcHg7aGVpZ2h0OjZweDtiYWNrZ3JvdW5kLXNpemU6MTBweCA2cHh9LmRnLWxpbmssLmRnLWxpbms6aG92ZXJ7YmFja2dyb3VuZC1wb3NpdGlvbjowIDk1JTtiYWNrZ3JvdW5kLXNpemU6MTBweCAxcHg7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXh9LmRnLWxpbmtfdHlwZV9sb2NhbHtiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLHJpZ2h0IHRvcCxmcm9tKCM5Y2QpLGNvbG9yLXN0b3AoNTAlLCM5Y2QpLGNvbG9yLXN0b3AoNTAlLHRyYW5zcGFyZW50KSk7YmFja2dyb3VuZDotd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LCM5Y2QsIzljZCA1MCUsdHJhbnNwYXJlbnQgNTAlKTtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCh0byByaWdodCwjOWNkLCM5Y2QgNTAlLHRyYW5zcGFyZW50IDUwJSl9Lm5vLXRvdWNoIC5kZy1saW5rX3R5cGVfbG9jYWw6aG92ZXJ7YmFja2dyb3VuZDotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxyaWdodCB0b3AsZnJvbSgjOWJjKSxjb2xvci1zdG9wKDUwJSwjOWJjKSxjb2xvci1zdG9wKDUwJSx0cmFuc3BhcmVudCkpO2JhY2tncm91bmQ6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCwjOWJjLCM5YmMgNTAlLHRyYW5zcGFyZW50IDUwJSk7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIzliYywjOWJjIDUwJSx0cmFuc3BhcmVudCA1MCUpfS5kZy1saW5rLmRnLWxpbmtfdHlwZV9sb2NhbCwuZGctbGluay5kZy1saW5rX3R5cGVfbG9jYWw6aG92ZXJ7YmFja2dyb3VuZC1zaXplOjZweCAxcHh9LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV90cmFmZmljOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIyMCUyMiUyMGhlaWdodCUzRCUyMjE0JTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjAlMjAxNCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE4JTJDNSUyMEMlMjAxOCUyQzQlMjAxNyUyQzElMjAxNSUyQzElMjBIJTIwMTIlMjAxMCUyMEMlMjA4JTJDMSUyMDclMkM0JTIwNyUyQzUlMjBIJTIwNSUyMHYlMjAyJTIwaCUyMDElMjB2JTIwNCUyMGMlMjAwJTJDMC42JTIwMCUyQzElMjAxJTJDMSUyMHYlMjAyJTIwaCUyMDIlMjB2JTIwLTIlMjBoJTIwNyUyMHYlMjAyJTIwaCUyMDIlMjB2JTIwLTIlMjBjJTIwMSUyQzAlMjAxJTJDLTAuNCUyMDElMkMtMSUyMFYlMjA3JTIwaCUyMDElMjBWJTIwNSUyMEglMjAxOCUyMHolMjBNJTIwMTAlMkMzJTIwaCUyMDIlMjAzJTIwYyUyMDIlMkMwJTIwMiUyQzElMjAyJTJDMyUyMEglMjA4JTIwQyUyMDglMkM0JTIwOCUyQzMlMjAxMCUyQzMlMjB6JTIwTSUyMDklMkMxMCUyMEglMjA4JTIwQyUyMDcuNCUyQzEwJTIwNyUyQzkuNiUyMDclMkM5JTIwNyUyQzguNCUyMDcuNCUyQzglMjA4JTJDOCUyMGglMjAxJTIwYyUyMDAuNiUyQzAlMjAxJTJDMC40JTIwMSUyQzElMjAwJTJDMC42JTIwLTAuNCUyQzElMjAtMSUyQzElMjB6JTIwbSUyMDglMkMwJTIwSCUyMDE2JTIwQyUyMDE1LjQlMkMxMCUyMDE1JTJDOS42JTIwMTUlMkM5JTIwMTUlMkM4LjQlMjAxNS40JTJDOCUyMDE2JTJDOCUyMGglMjAxJTIwYyUyMDAuNiUyQzAlMjAxJTJDMC40JTIwMSUyQzElMjAwJTJDMC42JTIwLTAuNCUyQzElMjAtMSUyQzElMjB6JTIwTSUyMDQlMkM0JTIwSCUyMDYlMjBWJTIwMyUyMEglMjA0JTIwQyUyMDElMkMzJTIwMSUyQzYlMjAxJTJDNyUyMEglMjAwJTIwdiUyMDElMjBoJTIwMSUyMHYlMjA0JTIwSCUyMDMlMjBWJTIwMTElMjBIJTIwNSUyMFYlMjA3JTIwSCUyMDIlMjBDJTIwMiUyQzYlMjAyJTJDNCUyMDQlMkM0JTIweiUyME0lMjAzJTJDOSUyMDQlMkMxMCUyMEglMjAyJTIwViUyMDklMjBoJTIwMSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNjE2MTYxJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ2clMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMTYlMkM4JTIwaCUyMDElMjBjJTIwMC40JTJDMCUyMDAuNyUyQzAuMiUyMDAuOCUyQzAuNSUyMEMlMjAxNy45JTJDOC40JTIwMTglMkM4LjIlMjAxOCUyQzglMjAxOCUyQzcuNCUyMDE3LjYlMkM3JTIwMTclMkM3JTIwaCUyMC0xJTIwYyUyMC0wLjYlMkMwJTIwLTElMkMwLjQlMjAtMSUyQzElMjAwJTJDMC4yJTIwMC4xJTJDMC40JTIwMC4yJTJDMC41JTIwQyUyMDE1LjMlMkM4LjIlMjAxNS42JTJDOCUyMDE2JTJDOCUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA4JTJDOCUyMEglMjA5JTIwQyUyMDkuNCUyQzglMjA5LjclMkM4LjIlMjA5LjglMkM4LjUlMjA5LjklMkM4LjQlMjAxMCUyQzguMiUyMDEwJTJDOCUyMDEwJTJDNy40JTIwOS42JTJDNyUyMDklMkM3JTIwSCUyMDglMjBDJTIwNy40JTJDNyUyMDclMkM3LjQlMjA3JTJDOCUyMDclMkM4LjIlMjA3LjElMkM4LjQlMjA3LjIlMkM4LjUlMjA3LjMlMkM4LjIlMjA3LjYlMkM4JTIwOCUyQzglMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNiUyQzMlMjBIJTIwNCUyMEMlMjA0JTJDMyUyMDQlMkMzJTIwNCUyQzMlMjAyJTJDMyUyMDIlMkM1JTIwMiUyQzYlMjBIJTIwMiUyMEMlMjAyLjElMkM1JTIwMi41JTJDNCUyMDQlMkM0JTIwSCUyMDUlMjA2JTIwViUyMDMlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMCUyMDdIMVY4SDB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTUlMkMyJTIwSCUyMDEyJTIwMTAlMjBDJTIwOCUyQzIlMjA4JTJDMyUyMDglMkM1JTIwSCUyMDglMjBDJTIwOCUyQzMuNyUyMDguMyUyQzMlMjAxMCUyQzMlMjBoJTIwMiUyMDMlMjBjJTIwMS43JTJDMCUyMDEuOSUyQzAuNyUyMDIlMkMyJTIwaCUyMDAlMjBDJTIwMTclMkMzJTIwMTclMkMyJTIwMTUlMkMyJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTMlMjA5TDQlMjA5JTIwMyUyMDglMjAyJTIwOCUyMDIlMjA5JTIwMiUyMDklMjAyJTIwOSUyMDMlMjA5eiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDclMkMxMSUyMEMlMjA2JTJDMTElMjA2JTJDMTAuNiUyMDYlMkMxMCUyMHYlMjAxJTIwYyUyMDAlMkMwLjYlMjAwJTJDMSUyMDElMkMxJTIwdiUyMC0xJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDE4JTJDMTElMjB2JTIwMSUyMGMlMjAxJTJDMCUyMDElMkMtMC40JTIwMSUyQy0xJTIwdiUyMC0xJTIwYyUyMDAlMkMwLjYlMjAwJTJDMSUyMC0xJTJDMSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xOSUyMDZIMjBWN0gxOXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0zJTIwMTFMMSUyMDExJTIwMSUyMDEyJTIwMyUyMDEyJTIwMyUyMDExJTIwNSUyMDExJTIwNSUyMDclMjA1JTIwNyUyMDUlMjAxMCUyMDMlMjAxMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNiUyMDEzSDE4VjE0SDE2eiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTUlMjA2SDZWN0g1eiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTklMjAxM0w3JTIwMTMlMjA3JTIwMTQlMjA5JTIwMTQlMjA5JTIwMTIlMjAxNiUyMDEyJTIwMTYlMjAxMSUyMDklMjAxMXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0MlMkZnJTNFJTBBJTIwJTIwJTIwJTIwJTNDZyUyMGZpbGwlM0QlMjIlMjM0NDQlMjIlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAyJTJDNiUyMEMlMjAyJTJDNi40JTIwMiUyQzYuNyUyMDIlMkM3JTIwSCUyMDUlMjBWJTIwNiUyMEglMjAyJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTIlMjA5TDIlMjAxMCUyMDQlMjAxMCUyMDMlMjA5eiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDQlMkMzJTIwSCUyMDYlMjBWJTIwMiUyMEglMjA0JTIwQyUyMDElMkMyJTIwMSUyQzUlMjAxJTJDNiUyMEglMjAwJTIwViUyMDclMjBIJTIwMSUyMEMlMjAxJTJDNiUyMDElMkMzJTIwNCUyQzMlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTglMkM0JTIwQyUyMDE4JTJDMyUyMDE3JTJDMCUyMDE1JTJDMCUyMEglMjAxMiUyMDEwJTIwQyUyMDglMkMwJTIwNyUyQzMlMjA3JTJDNCUyMEglMjA2JTIwNSUyMFYlMjA1JTIwSCUyMDclMjBDJTIwNyUyQzQlMjA4JTJDMSUyMDEwJTJDMSUyMGglMjAyJTIwMyUyMGMlMjAyJTJDMCUyMDMlMkMzJTIwMyUyQzQlMjBoJTIwMiUyMFYlMjA0JTIwaCUyMC0yJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDglMkMxMCUyMEglMjA5JTIwQyUyMDkuNiUyQzEwJTIwMTAlMkM5LjYlMjAxMCUyQzklMjAxMCUyQzguOCUyMDkuOSUyQzguNiUyMDkuOCUyQzguNSUyMDkuNyUyQzguOCUyMDkuNCUyQzklMjA5JTJDOSUyMEglMjA4JTIwQyUyMDcuNiUyQzklMjA3LjMlMkM4LjglMjA3LjIlMkM4LjUlMjA3LjElMkM4LjYlMjA3JTJDOC44JTIwNyUyQzklMjBjJTIwMCUyQzAuNiUyMDAuNCUyQzElMjAxJTJDMSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNyUyQzYlMjBDJTIwMTclMkM1LjYlMjAxNyUyQzUuMyUyMDE3JTJDNSUyMEglMjA4JTIwYyUyMDAlMkMwLjMlMjAwJTJDMC42JTIwMCUyQzElMjBoJTIwOSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNy44JTJDOC41JTIwQyUyMDE3LjclMkM4LjglMjAxNy40JTJDOSUyMDE3JTJDOSUyMEglMjAxNiUyMEMlMjAxNS42JTJDOSUyMDE1LjMlMkM4LjglMjAxNS4yJTJDOC41JTIwMTUuMSUyQzguNiUyMDE1JTJDOC44JTIwMTUlMkM5JTIwYyUyMDAlMkMwLjYlMjAwLjQlMkMxJTIwMSUyQzElMjBoJTIwMSUyMGMlMjAwLjYlMkMwJTIwMSUyQy0wLjQlMjAxJTJDLTElMjAwJTJDLTAuMiUyMC0wLjElMkMtMC40JTIwLTAuMiUyQy0wLjUlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDJTJGZyUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjIwcHg7aGVpZ2h0OjE0cHg7YmFja2dyb3VuZC1zaXplOjIwcHggMTRweDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDttYXJnaW46YXV0bztjb250ZW50OicnfS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfdHJhZmZpYzphY3RpdmU6YWZ0ZXIsLm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfdHJhZmZpYzpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMjAlMjIlMjBoZWlnaHQlM0QlMjIxNCUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDIwJTIwMTQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxOCUyQzUlMjBDJTIwMTglMkM0JTIwMTclMkMxJTIwMTUlMkMxJTIwSCUyMDEyJTIwMTAlMjBDJTIwOCUyQzElMjA3JTJDNCUyMDclMkM1JTIwSCUyMDUlMjB2JTIwMiUyMGglMjAxJTIwdiUyMDQlMjBjJTIwMCUyQzAuNiUyMDAlMkMxJTIwMSUyQzElMjB2JTIwMiUyMGglMjAyJTIwdiUyMC0yJTIwaCUyMDclMjB2JTIwMiUyMGglMjAyJTIwdiUyMC0yJTIwYyUyMDElMkMwJTIwMSUyQy0wLjQlMjAxJTJDLTElMjBWJTIwNyUyMGglMjAxJTIwViUyMDUlMjBIJTIwMTglMjB6JTIwTSUyMDEwJTJDMyUyMGglMjAyJTIwMyUyMGMlMjAyJTJDMCUyMDIlMkMxJTIwMiUyQzMlMjBIJTIwOCUyMEMlMjA4JTJDNCUyMDglMkMzJTIwMTAlMkMzJTIweiUyME0lMjA5JTJDMTAlMjBIJTIwOCUyMEMlMjA3LjQlMkMxMCUyMDclMkM5LjYlMjA3JTJDOSUyMDclMkM4LjQlMjA3LjQlMkM4JTIwOCUyQzglMjBoJTIwMSUyMGMlMjAwLjYlMkMwJTIwMSUyQzAuNCUyMDElMkMxJTIwMCUyQzAuNiUyMC0wLjQlMkMxJTIwLTElMkMxJTIweiUyMG0lMjA4JTJDMCUyMEglMjAxNiUyMEMlMjAxNS40JTJDMTAlMjAxNSUyQzkuNiUyMDE1JTJDOSUyMDE1JTJDOC40JTIwMTUuNCUyQzglMjAxNiUyQzglMjBoJTIwMSUyMGMlMjAwLjYlMkMwJTIwMSUyQzAuNCUyMDElMkMxJTIwMCUyQzAuNiUyMC0wLjQlMkMxJTIwLTElMkMxJTIweiUyME0lMjA0JTJDNCUyMEglMjA2JTIwViUyMDMlMjBIJTIwNCUyMEMlMjAxJTJDMyUyMDElMkM2JTIwMSUyQzclMjBIJTIwMCUyMHYlMjAxJTIwaCUyMDElMjB2JTIwNCUyMEglMjAzJTIwViUyMDExJTIwSCUyMDUlMjBWJTIwNyUyMEglMjAyJTIwQyUyMDIlMkM2JTIwMiUyQzQlMjA0JTJDNCUyMHolMjBNJTIwMyUyQzklMjA0JTJDMTAlMjBIJTIwMiUyMFYlMjA5JTIwaCUyMDElMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzQyNDI0MiUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NnJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDE2JTJDOCUyMGglMjAxJTIwYyUyMDAuNCUyQzAlMjAwLjclMkMwLjIlMjAwLjglMkMwLjUlMjBDJTIwMTcuOSUyQzguNCUyMDE4JTJDOC4yJTIwMTglMkM4JTIwMTglMkM3LjQlMjAxNy42JTJDNyUyMDE3JTJDNyUyMGglMjAtMSUyMGMlMjAtMC42JTJDMCUyMC0xJTJDMC40JTIwLTElMkMxJTIwMCUyQzAuMiUyMDAuMSUyQzAuNCUyMDAuMiUyQzAuNSUyMEMlMjAxNS4zJTJDOC4yJTIwMTUuNiUyQzglMjAxNiUyQzglMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwOCUyQzglMjBIJTIwOSUyMEMlMjA5LjQlMkM4JTIwOS43JTJDOC4yJTIwOS44JTJDOC41JTIwOS45JTJDOC40JTIwMTAlMkM4LjIlMjAxMCUyQzglMjAxMCUyQzcuNCUyMDkuNiUyQzclMjA5JTJDNyUyMEglMjA4JTIwQyUyMDcuNCUyQzclMjA3JTJDNy40JTIwNyUyQzglMjA3JTJDOC4yJTIwNy4xJTJDOC40JTIwNy4yJTJDOC41JTIwNy4zJTJDOC4yJTIwNy42JTJDOCUyMDglMkM4JTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDYlMkMzJTIwSCUyMDQlMjBDJTIwNCUyQzMlMjA0JTJDMyUyMDQlMkMzJTIwMiUyQzMlMjAyJTJDNSUyMDIlMkM2JTIwSCUyMDIlMjBDJTIwMi4xJTJDNSUyMDIuNSUyQzQlMjA0JTJDNCUyMEglMjA1JTIwNiUyMFYlMjAzJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTAlMjA3SDFWOEgweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE1JTJDMiUyMEglMjAxMiUyMDEwJTIwQyUyMDglMkMyJTIwOCUyQzMlMjA4JTJDNSUyMEglMjA4JTIwQyUyMDglMkMzLjclMjA4LjMlMkMzJTIwMTAlMkMzJTIwaCUyMDIlMjAzJTIwYyUyMDEuNyUyQzAlMjAxLjklMkMwLjclMjAyJTJDMiUyMGglMjAwJTIwQyUyMDE3JTJDMyUyMDE3JTJDMiUyMDE1JTJDMiUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0zJTIwOUw0JTIwOSUyMDMlMjA4JTIwMiUyMDglMjAyJTIwOSUyMDIlMjA5JTIwMiUyMDklMjAzJTIwOXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA3JTJDMTElMjBDJTIwNiUyQzExJTIwNiUyQzEwLjYlMjA2JTJDMTAlMjB2JTIwMSUyMGMlMjAwJTJDMC42JTIwMCUyQzElMjAxJTJDMSUyMHYlMjAtMSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxOCUyQzExJTIwdiUyMDElMjBjJTIwMSUyQzAlMjAxJTJDLTAuNCUyMDElMkMtMSUyMHYlMjAtMSUyMGMlMjAwJTJDMC42JTIwMCUyQzElMjAtMSUyQzElMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTklMjA2SDIwVjdIMTl6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMyUyMDExTDElMjAxMSUyMDElMjAxMiUyMDMlMjAxMiUyMDMlMjAxMSUyMDUlMjAxMSUyMDUlMjA3JTIwNSUyMDclMjA1JTIwMTAlMjAzJTIwMTB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTYlMjAxM0gxOFYxNEgxNnolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk01JTIwNkg2VjdINXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk05JTIwMTNMNyUyMDEzJTIwNyUyMDE0JTIwOSUyMDE0JTIwOSUyMDEyJTIwMTYlMjAxMiUyMDE2JTIwMTElMjA5JTIwMTF6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDJTJGZyUzRSUwQSUyMCUyMCUyMCUyMCUzQ2clMjBmaWxsJTNEJTIyJTIzMmUyZTJlJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMiUyQzYlMjBDJTIwMiUyQzYuNCUyMDIlMkM2LjclMjAyJTJDNyUyMEglMjA1JTIwViUyMDYlMjBIJTIwMiUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yJTIwOUwyJTIwMTAlMjA0JTIwMTAlMjAzJTIwOXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA0JTJDMyUyMEglMjA2JTIwViUyMDIlMjBIJTIwNCUyMEMlMjAxJTJDMiUyMDElMkM1JTIwMSUyQzYlMjBIJTIwMCUyMFYlMjA3JTIwSCUyMDElMjBDJTIwMSUyQzYlMjAxJTJDMyUyMDQlMkMzJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE4JTJDNCUyMEMlMjAxOCUyQzMlMjAxNyUyQzAlMjAxNSUyQzAlMjBIJTIwMTIlMjAxMCUyMEMlMjA4JTJDMCUyMDclMkMzJTIwNyUyQzQlMjBIJTIwNiUyMDUlMjBWJTIwNSUyMEglMjA3JTIwQyUyMDclMkM0JTIwOCUyQzElMjAxMCUyQzElMjBoJTIwMiUyMDMlMjBjJTIwMiUyQzAlMjAzJTJDMyUyMDMlMkM0JTIwaCUyMDIlMjBWJTIwNCUyMGglMjAtMiUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA4JTJDMTAlMjBIJTIwOSUyMEMlMjA5LjYlMkMxMCUyMDEwJTJDOS42JTIwMTAlMkM5JTIwMTAlMkM4LjglMjA5LjklMkM4LjYlMjA5LjglMkM4LjUlMjA5LjclMkM4LjglMjA5LjQlMkM5JTIwOSUyQzklMjBIJTIwOCUyMEMlMjA3LjYlMkM5JTIwNy4zJTJDOC44JTIwNy4yJTJDOC41JTIwNy4xJTJDOC42JTIwNyUyQzguOCUyMDclMkM5JTIwYyUyMDAlMkMwLjYlMjAwLjQlMkMxJTIwMSUyQzElMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTclMkM2JTIwQyUyMDE3JTJDNS42JTIwMTclMkM1LjMlMjAxNyUyQzUlMjBIJTIwOCUyMGMlMjAwJTJDMC4zJTIwMCUyQzAuNiUyMDAlMkMxJTIwaCUyMDklMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTcuOCUyQzguNSUyMEMlMjAxNy43JTJDOC44JTIwMTcuNCUyQzklMjAxNyUyQzklMjBIJTIwMTYlMjBDJTIwMTUuNiUyQzklMjAxNS4zJTJDOC44JTIwMTUuMiUyQzguNSUyMDE1LjElMkM4LjYlMjAxNSUyQzguOCUyMDE1JTJDOSUyMGMlMjAwJTJDMC42JTIwMC40JTJDMSUyMDElMkMxJTIwaCUyMDElMjBjJTIwMC42JTJDMCUyMDElMkMtMC40JTIwMSUyQy0xJTIwMCUyQy0wLjIlMjAtMC4xJTJDLTAuNCUyMC0wLjIlMkMtMC41JTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQyUyRmclM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3RyYWZmaWM6YWN0aXZlOmFmdGVyLC5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX2FjdGl2ZS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfdHJhZmZpYzphZnRlciwubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV90cmFmZmljOmhvdmVyOmFmdGVye2JhY2tncm91bmQtaW1hZ2U6bm9uZX1hLmRnLXRyYWZmaWMtY29udHJvbHt6LWluZGV4OjA7Y29sb3I6I2YyZjJmMjt0ZXh0LWRlY29yYXRpb246bm9uZTt0ZXh0LXNoYWRvdzowIDFweCAycHggcmdiYSgwLDAsMCwuMyk7Zm9udDo0MDAgMTVweC8zMnB4ICdBcmlhbCBuYXJyb3cnLEFyaWFsLHNhbnMtc2VyaWZ9YS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfZ3JlZW46YWZ0ZXIsYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfcmVkOmFmdGVyLGEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX3llbGxvdzphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDt6LWluZGV4Oi0xO21hcmdpbjphdXRvO3dpZHRoOjIycHg7aGVpZ2h0OjIycHg7Ym9yZGVyLXJhZGl1czo1MCU7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMXB4IDAgMCByZ2JhKDAsMCwwLC4yKSwwIDFweCAwIDAgI2ZmZjtib3gtc2hhZG93Omluc2V0IDAgMXB4IDAgMCByZ2JhKDAsMCwwLC4yKSwwIDFweCAwIDAgI2ZmZn0ubm8tdG91Y2ggYS5kZy10cmFmZmljLWNvbnRyb2w6aG92ZXJ7Y29sb3I6I2YyZjJmMn0ubm8tdG91Y2ggYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfZ3JlZW46aG92ZXI6YWZ0ZXIsLm5vLXRvdWNoIGEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX3JlZDpob3ZlcjphZnRlciwubm8tdG91Y2ggYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfeWVsbG93OmhvdmVyOmFmdGVye3dpZHRoOjIycHg7aGVpZ2h0OjIycHh9YS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfZ3JlZW46YWZ0ZXJ7YmFja2dyb3VuZDojM2ZjMDNifS5uby10b3VjaCBhLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl9ncmVlbjpob3ZlcjphZnRlcixhLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl9ncmVlbjphY3RpdmU6YWZ0ZXJ7YmFja2dyb3VuZDotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IGJvdHRvbSxsZWZ0IHRvcCxmcm9tKCMyYWE3MzEpLHRvKCM1M2UxM2EpKSAjM2VjNDM1O2JhY2tncm91bmQ6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQoYm90dG9tLCMyYWE3MzEsIzUzZTEzYSkgIzNlYzQzNTtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCh0byB0b3AsIzJhYTczMSwjNTNlMTNhKSAjM2VjNDM1fWEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX3llbGxvdzphZnRlcntiYWNrZ3JvdW5kOiNmM2IyMjN9Lm5vLXRvdWNoIGEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX3llbGxvdzpob3ZlcjphZnRlcixhLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl95ZWxsb3c6YWN0aXZlOmFmdGVye2JhY2tncm91bmQ6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCBib3R0b20sbGVmdCB0b3AsZnJvbSgjZWY5MzFiKSx0bygjZjdiZTI2KSkgI2Y0YTgyMDtiYWNrZ3JvdW5kOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KGJvdHRvbSwjZWY5MzFiLCNmN2JlMjYpICNmNGE4MjA7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQodG8gdG9wLCNlZjkzMWIsI2Y3YmUyNikgI2Y0YTgyMH1hLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl9yZWQ6YWZ0ZXJ7YmFja2dyb3VuZDojZWIyNDBjfS5uby10b3VjaCBhLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl9yZWQ6aG92ZXI6YWZ0ZXIsYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfcmVkOmFjdGl2ZTphZnRlcntiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgYm90dG9tLGxlZnQgdG9wLGZyb20oI2MwMWMwYSksdG8oI2Y3MzQxNikpICNkYjI4MTE7YmFja2dyb3VuZDotd2Via2l0LWxpbmVhci1ncmFkaWVudChib3R0b20sI2MwMWMwYSwjZjczNDE2KSAjZGIyODExO2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIHRvcCwjYzAxYzBhLCNmNzM0MTYpICNkYjI4MTF9LmxlYWZsZXQtcnVsZXJNYXJrZXItcGFuZXt6LWluZGV4OjYwMH0uZGctcnVsZXJfX2xhYmVse3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt6LWluZGV4OjIwMDstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6dHJhbnNwYXJlbnR9LmRnLXJ1bGVyX19sYWJlbC1zcGFjZXJ7ZGlzcGxheTpibG9ja30uZGctcnVsZXJfX2xhYmVsLWNvbnRhaW5lcntkaXNwbGF5Om5vbmU7cGFkZGluZzoycHggNHB4O2JvcmRlcjo0cHggc29saWQgI2ZmZjtib3JkZXItcmFkaXVzOjEzcHg7YmFja2dyb3VuZDojMGRhNWQ1O2JhY2tncm91bmQtY2xpcDpwYWRkaW5nLWJveDtjb2xvcjojZmZmO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LXNpemU6MTJweH0uZGctcnVsZXJfX3BvaW50e2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjoycHggNHB4IDAgMDt3aWR0aDoxMHB4O2hlaWdodDoxMHB4O2JvcmRlci1yYWRpdXM6NXB4O2JhY2tncm91bmQ6I2ZmZn0uZGctcnVsZXJfX2xhYmVsLXJlbW92ZS1saW5re2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNiUyQzAlMjBDJTIwMi42ODclMkMwJTIwMCUyQzIuNjg3JTIwMCUyQzYlMjAwJTJDOS4zMTMlMjAyLjY4NyUyQzEyJTIwNiUyQzEyJTIwOS4zMTMlMkMxMiUyMDEyJTJDOS4zMTMlMjAxMiUyQzYlMjAxMiUyQzIuNjg3JTIwOS4zMTMlMkMwJTIwNiUyQzAlMjB6JTIwTSUyMDkuNDAxJTJDOS4zOTglMjA4LjglMkM5LjYlMjA2JTJDNi44JTIwMy4xOTklMkM5LjYlMjAyLjU5JTJDOS40MTUlMjAyLjM3NSUyQzguNzc0JTIwNS4xOTklMkM2JTIwMi4zOTklMkMzLjE3NSUyMDIuNjIlMkMyLjU5MSUyMDMuMTc1JTJDMi4zNzUlMjA1Ljk0OSUyQzUuMjI1JTIwOC43NzQlMkMyLjM3NSUyMDkuNDE1JTJDMi42MDUlMjA5LjU2NiUyQzMuMTk2JTIwNi44MjQlMkM2JTIwOS42JTJDOC44JTIwOS40MDElMkM5LjM5OCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjEycHg7aGVpZ2h0OjEycHg7YmFja2dyb3VuZC1zaXplOjEycHggMTJweDtkaXNwbGF5Om5vbmU7bWFyZ2luOjFweCAwIDAgNHB4O3ZlcnRpY2FsLWFsaWduOnRvcDstd2Via2l0LXRyYW5zaXRpb246YWxsIC4ycyBlYXNlO3RyYW5zaXRpb246YWxsIC4ycyBlYXNlfS5uby10b3VjaCAuZGctcnVsZXJfX2xhYmVsLXJlbW92ZS1saW5rOmhvdmVyey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7LW1zLXRyYW5zZm9ybTpyb3RhdGUoOTBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfS5kZy1ydWxlcl9fcmVtb3ZlLWxpbmstb3ZlcmxheXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTdweDtyaWdodDotN3B4O2JvdHRvbTotN3B4O3dpZHRoOjQwcHh9Lm5vLXRvdWNoIC5kZy1ydWxlcl9fcmVtb3ZlLWxpbmstb3ZlcmxheXtkaXNwbGF5Om5vbmV9LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9ydWxlcjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTYlMjIlMjBoZWlnaHQlM0QlMjI5JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMTIuOTk5JTJDMCUyMHYlMjA0LjAwMSUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0yJTIwdiUyMDIlMjBoJTIwLTElMjBWJTIwMCUyMGglMjAtMiUyMFYlMjAyJTIwSCUyMDYlMjBWJTIwMCUyMEglMjAzLjk5OCUyMHYlMjA0LjAwMSUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0zJTIwViUyMDglMjBIJTIwMTYlMjBWJTIwMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNjE2MTYxJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMi45OTklMkM0JTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjBtJTIwMyUyQy0yJTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjBtJTIwMyUyQzAlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDMiUyMGglMjAxJTIwdiUyMDElMjBoJTIwLTElMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzQ0NCUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDAlMkM4JTIwSCUyMDE2JTIwViUyMDklMjBIJTIwMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzAlMjBIJTIwMyUyMFYlMjAxJTIwSCUyMDAlMjB6JTIwbSUyMDEzJTJDMCUyMGglMjAzJTIwdiUyMDElMjBoJTIwLTMlMjB6JTIwbSUyMC0zJTJDMCUyMGglMjAyJTIwViUyMDElMjBIJTIwMTAlMjB6JTIwTSUyMDclMkMwJTIwSCUyMDklMjBWJTIwMSUyMEglMjA3JTIweiUyME0lMjA0JTJDMCUyMEglMjA2JTIwViUyMDElMjBIJTIwNCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNDQ0JTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTZweDtoZWlnaHQ6OXB4O2JhY2tncm91bmQtc2l6ZToxNnB4IDlweDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDttYXJnaW46YXV0bztjb250ZW50OicnfS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfcnVsZXI6YWN0aXZlOmFmdGVyLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3J1bGVyOmhvdmVyOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxNiUyMiUyMGhlaWdodCUzRCUyMjklMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxMi45OTklMkMwJTIwdiUyMDQuMDAxJTIwaCUyMC0xJTIwViUyMDAlMjBoJTIwLTIlMjB2JTIwMiUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0yJTIwViUyMDIlMjBIJTIwNiUyMFYlMjAwJTIwSCUyMDMuOTk4JTIwdiUyMDQuMDAxJTIwaCUyMC0xJTIwViUyMDAlMjBoJTIwLTMlMjBWJTIwOCUyMEglMjAxNiUyMFYlMjAwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0MjQyNDIlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAyLjk5OSUyQzQlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDLTIlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDMCUyMGglMjAxJTIwdiUyMDElMjBoJTIwLTElMjB6JTIwbSUyMDMlMkMyJTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMmUyZTJlJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzglMjBIJTIwMTYlMjBWJTIwOSUyMEglMjAwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAwJTJDMCUyMEglMjAzJTIwViUyMDElMjBIJTIwMCUyMHolMjBtJTIwMTMlMkMwJTIwaCUyMDMlMjB2JTIwMSUyMGglMjAtMyUyMHolMjBtJTIwLTMlMkMwJTIwaCUyMDIlMjBWJTIwMSUyMEglMjAxMCUyMHolMjBNJTIwNyUyQzAlMjBIJTIwOSUyMFYlMjAxJTIwSCUyMDclMjB6JTIwTSUyMDQlMkMwJTIwSCUyMDYlMjBWJTIwMSUyMEglMjA0JTIweiUyMiUyMGZpbGwlM0QlMjIlMjMyZTJlMmUlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3J1bGVyOmFjdGl2ZTphZnRlciwuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3J1bGVyOmFmdGVyLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3J1bGVyOmhvdmVyOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxNiUyMiUyMGhlaWdodCUzRCUyMjklMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxMi45OTklMkMwJTIwdiUyMDQuMDAxJTIwaCUyMC0xJTIwViUyMDAlMjBoJTIwLTIlMjB2JTIwMiUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0yJTIwViUyMDIlMjBIJTIwNiUyMFYlMjAwJTIwSCUyMDMuOTk5JTIwdiUyMDQuMDAxJTIwaCUyMC0xJTIwViUyMDAlMjBoJTIwLTMlMjBWJTIwOCUyMEglMjAxNiUyMFYlMjAwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMyMWE3ZDYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAyLjk5OSUyQzQlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDLTIlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDMCUyMGglMjAxJTIwdiUyMDElMjBoJTIwLTElMjB6JTIwbSUyMDMlMkMyJTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMTQ3NTk2JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzglMjBIJTIwMTYlMjBWJTIwOSUyMEglMjAwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAwJTJDMCUyMEglMjAzJTIwViUyMDElMjBIJTIwMCUyMHolMjBtJTIwMTMlMkMwJTIwaCUyMDMlMjB2JTIwMSUyMGglMjAtMyUyMHolMjBtJTIwLTMlMkMwJTIwaCUyMDIlMjBWJTIwMSUyMEglMjAxMCUyMHolMjBNJTIwNyUyQzAlMjBIJTIwOSUyMFYlMjAxJTIwSCUyMDclMjB6JTIwTSUyMDQlMkMwJTIwSCUyMDYlMjBWJTIwMSUyMEglMjA0JTIweiUyMiUyMGZpbGwlM0QlMjIlMjMxNDc1OTYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX1cIjsgKHJlcXVpcmUoXCJicm93c2VyaWZ5LWNzc1wiKS5jcmVhdGVTdHlsZShjc3MsIHsgXCJocmVmXCI6IFwiZGlzdC9jc3Mvc3R5bGVzLmZ1bGwuZGFyay5jc3NcIiB9LCB7IFwiaW5zZXJ0QXRcIjogXCJib3R0b21cIiB9KSk7IG1vZHVsZS5leHBvcnRzID0gY3NzOyIsIi8qIHJlZHVjZSBpbXBsZW1pbnRhdGlvbiBieSBNb3ppbGEgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvUmVkdWNlP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZBcnJheSUyRlJlZHVjZSovXG5pZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UpIHtcbiAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBvcHRfaW5pdGlhbFZhbHVlKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKG51bGwgPT09IHRoaXMgfHwgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzKSB7XG4gICAgICAvLyBBdCB0aGUgbW9tZW50IGFsbCBtb2Rlcm4gYnJvd3NlcnMsIHRoYXQgc3VwcG9ydCBzdHJpY3QgbW9kZSwgaGF2ZVxuICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuIEZvciBpbnN0YW5jZSwgSUU4XG4gICAgICAvLyBkb2VzIG5vdCBzdXBwb3J0IHN0cmljdCBtb2RlLCBzbyB0aGlzIGNoZWNrIGlzIGFjdHVhbGx5IHVzZWxlc3MuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdBcnJheS5wcm90b3R5cGUucmVkdWNlIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgaW5kZXgsIHZhbHVlLFxuICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgaXNWYWx1ZVNldCA9IGZhbHNlO1xuICAgIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFsdWUgPSBvcHRfaW5pdGlhbFZhbHVlO1xuICAgICAgaXNWYWx1ZVNldCA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaW5kZXggPSAwOyBsZW5ndGggPiBpbmRleDsgKytpbmRleCkge1xuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaW5kZXgpKSB7XG4gICAgICAgIGlmIChpc1ZhbHVlU2V0KSB7XG4gICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgdGhpc1tpbmRleF0sIGluZGV4LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXNbaW5kZXhdO1xuICAgICAgICAgIGlzVmFsdWVTZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNWYWx1ZVNldCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaFxuLy8gUHJvZHVjdGlvbiBzdGVwcyBvZiBFQ01BLTI2MiwgRWRpdGlvbiA1LCAxNS40LjQuMThcbi8vIFJlZmVyZW5jZTogaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE4XG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG5cbiAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBULCBrO1xuXG4gICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoaXMgaXMgbnVsbCBvciBub3QgZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICB2YXIga1ZhbHVlLFxuICAgICAgICAvLyAxLiBMZXQgTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgVG9PYmplY3QgcGFzc2luZyB0aGUgfHRoaXN8IHZhbHVlIGFzIHRoZSBhcmd1bWVudC5cbiAgICAgICAgTyA9IE9iamVjdCh0aGlzKSxcblxuICAgICAgICAvLyAyLiBMZXQgbGVuVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCB0aGUgYXJndW1lbnQgXCJsZW5ndGhcIi5cbiAgICAgICAgLy8gMy4gTGV0IGxlbiBiZSBUb1VpbnQzMihsZW5WYWx1ZSkuXG4gICAgICAgIGxlbiA9IE8ubGVuZ3RoID4+PiAwOyAvLyBIYWNrIHRvIGNvbnZlcnQgTy5sZW5ndGggdG8gYSBVSW50MzJcblxuICAgIC8vIDQuIElmIElzQ2FsbGFibGUoY2FsbGJhY2spIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgLy8gU2VlOiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjExXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoY2FsbGJhY2spICE9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICAvLyA1LiBJZiB0aGlzQXJnIHdhcyBzdXBwbGllZCwgbGV0IFQgYmUgdGhpc0FyZzsgZWxzZSBsZXQgVCBiZSB1bmRlZmluZWQuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgVCA9IHRoaXNBcmc7XG4gICAgfVxuXG4gICAgLy8gNi4gTGV0IGsgYmUgMFxuICAgIGsgPSAwO1xuXG4gICAgLy8gNy4gUmVwZWF0LCB3aGlsZSBrIDwgbGVuXG4gICAgd2hpbGUgKGsgPCBsZW4pIHtcblxuICAgICAgLy8gYS4gTGV0IFBrIGJlIFRvU3RyaW5nKGspLlxuICAgICAgLy8gICBUaGlzIGlzIGltcGxpY2l0IGZvciBMSFMgb3BlcmFuZHMgb2YgdGhlIGluIG9wZXJhdG9yXG4gICAgICAvLyBiLiBMZXQga1ByZXNlbnQgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBIYXNQcm9wZXJ0eSBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuICAgICAgLy8gICBUaGlzIHN0ZXAgY2FuIGJlIGNvbWJpbmVkIHdpdGggY1xuICAgICAgLy8gYy4gSWYga1ByZXNlbnQgaXMgdHJ1ZSwgdGhlblxuICAgICAgaWYgKGsgaW4gTykge1xuXG4gICAgICAgIC8vIGkuIExldCBrVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cbiAgICAgICAga1ZhbHVlID0gT1trXTtcblxuICAgICAgICAvLyBpaS4gQ2FsbCB0aGUgQ2FsbCBpbnRlcm5hbCBtZXRob2Qgb2YgY2FsbGJhY2sgd2l0aCBUIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAvLyBhcmd1bWVudCBsaXN0IGNvbnRhaW5pbmcga1ZhbHVlLCBrLCBhbmQgTy5cbiAgICAgICAgY2FsbGJhY2suY2FsbChULCBrVmFsdWUsIGssIE8pO1xuICAgICAgfVxuICAgICAgLy8gZC4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgaysrO1xuICAgIH1cbiAgICAvLyA4LiByZXR1cm4gdW5kZWZpbmVkXG4gIH07XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2tleXNcbmlmICghT2JqZWN0LmtleXMpIHtcbiAgT2JqZWN0LmtleXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICBoYXNEb250RW51bUJ1ZyA9ICEoe3RvU3RyaW5nOiBudWxsfSkucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyksXG4gICAgICAgIGRvbnRFbnVtcyA9IFtcbiAgICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgICAgICAgJ3ZhbHVlT2YnLFxuICAgICAgICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgICAgICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAgICAgJ2NvbnN0cnVjdG9yJ1xuICAgICAgICBdLFxuICAgICAgICBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiAodHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmogPT09IG51bGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBub24tb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSwgcHJvcCwgaTtcblxuICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkb250RW51bXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgZG9udEVudW1zW2ldKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZG9udEVudW1zW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfSgpKTtcbn1cblxuLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lXG5pZiAoIUFycmF5LnByb3RvdHlwZS5zb21lKVxue1xuICBBcnJheS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uKGZ1biAvKiwgdGhpc0FyZyAqLylcbiAge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAodHlwZW9mIGZ1biAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAge1xuICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzQXJnLCB0W2ldLCBpLCB0KSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L21hcFxuaWYgKCFBcnJheS5wcm90b3R5cGUubWFwKVxue1xuICBBcnJheS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24oZnVuIC8qLCB0aGlzQXJnICovKVxuICB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG4gICAgaWYgKHR5cGVvZiBmdW4gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHtcbiAgICAgIC8vIE5PVEU6IEFic29sdXRlIGNvcnJlY3RuZXNzIHdvdWxkIGRlbWFuZCBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgICAgIC8vICAgICAgIGJlIHVzZWQuICBCdXQgdGhpcyBtZXRob2QgaXMgZmFpcmx5IG5ldywgYW5kIGZhaWx1cmUgaXNcbiAgICAgIC8vICAgICAgIHBvc3NpYmxlIG9ubHkgaWYgT2JqZWN0LnByb3RvdHlwZSBvciBBcnJheS5wcm90b3R5cGVcbiAgICAgIC8vICAgICAgIGhhcyBhIHByb3BlcnR5IHxpfCAodmVyeSB1bmxpa2VseSksIHNvIHVzZSBhIGxlc3MtY29ycmVjdFxuICAgICAgLy8gICAgICAgYnV0IG1vcmUgcG9ydGFibGUgYWx0ZXJuYXRpdmUuXG4gICAgICBpZiAoaSBpbiB0KVxuICAgICAgICByZXNbaV0gPSBmdW4uY2FsbCh0aGlzQXJnLCB0W2ldLCBpLCB0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuXG4vL0Zyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsdGVyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maWx0ZXIpXG57XG4gIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmdW4gLyosIHRoaXNBcmcgKi8pXG4gIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAodHlwZW9mIGZ1biAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICB7XG4gICAgICBpZiAoaSBpbiB0KVxuICAgICAge1xuICAgICAgICB2YXIgdmFsID0gdFtpXTtcblxuICAgICAgICAvLyBOT1RFOiBUZWNobmljYWxseSB0aGlzIHNob3VsZCBPYmplY3QuZGVmaW5lUHJvcGVydHkgYXRcbiAgICAgICAgLy8gICAgICAgdGhlIG5leHQgaW5kZXgsIGFzIHB1c2ggY2FuIGJlIGFmZmVjdGVkIGJ5XG4gICAgICAgIC8vICAgICAgIHByb3BlcnRpZXMgb24gT2JqZWN0LnByb3RvdHlwZSBhbmQgQXJyYXkucHJvdG90eXBlLlxuICAgICAgICAvLyAgICAgICBCdXQgdGhhdCBtZXRob2QncyBuZXcsIGFuZCBjb2xsaXNpb25zIHNob3VsZCBiZVxuICAgICAgICAvLyAgICAgICByYXJlLCBzbyB1c2UgdGhlIG1vcmUtY29tcGF0aWJsZSBhbHRlcm5hdGl2ZS5cbiAgICAgICAgaWYgKGZ1bi5jYWxsKHRoaXNBcmcsIHZhbCwgaSwgdCkpXG4gICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuXG4vL0Zyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZFxuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvVGhpcykge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDUgaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlXCIpO1xuICAgIH1cblxuICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgIGZUb0JpbmQgPSB0aGlzLFxuICAgICAgICBmTk9QID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGZCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCAmJiBvVGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG9UaGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG5cbiAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xuXG4gICAgcmV0dXJuIGZCb3VuZDtcbiAgfTtcbn1cblxuLy9Gcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2Y/cmVkaXJlY3Rsb2NhbGU9ZW4tVVMmcmVkaXJlY3RzbHVnPUphdmFTY3JpcHQlMkZSZWZlcmVuY2UlMkZHbG9iYWxfT2JqZWN0cyUyRkFycmF5JTJGaW5kZXhPZlxuaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICBpZiAoIHRoaXMgPT09IHVuZGVmaW5lZCB8fCB0aGlzID09PSBudWxsICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggJ1widGhpc1wiIGlzIG51bGwgb3Igbm90IGRlZmluZWQnICk7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoID4+PiAwOyAvLyBIYWNrIHRvIGNvbnZlcnQgb2JqZWN0Lmxlbmd0aCB0byBhIFVJbnQzMlxuXG4gICAgZnJvbUluZGV4ID0gK2Zyb21JbmRleCB8fCAwO1xuXG4gICAgaWYgKE1hdGguYWJzKGZyb21JbmRleCkgPT09IEluZmluaXR5KSB7XG4gICAgICBmcm9tSW5kZXggPSAwO1xuICAgIH1cblxuICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICBmcm9tSW5kZXggKz0gbGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDtmcm9tSW5kZXggPCBsZW5ndGg7IGZyb21JbmRleCsrKSB7XG4gICAgICBpZiAodGhpc1tmcm9tSW5kZXhdID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmcm9tSW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xufVxuIiwiaWYgKHR5cGVvZiBQcm9taXNlICE9PSAnZnVuY3Rpb24nKSB7XG4gIChmdW5jdGlvbigpIHtcbiAgdmFyIGRlZmluZSwgcmVxdWlyZU1vZHVsZSwgcmVxdWlyZSwgcmVxdWlyZWpzO1xuXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVnaXN0cnkgPSB7fSwgc2VlbiA9IHt9O1xuXG4gICAgZGVmaW5lID0gZnVuY3Rpb24obmFtZSwgZGVwcywgY2FsbGJhY2spIHtcbiAgICAgIHJlZ2lzdHJ5W25hbWVdID0geyBkZXBzOiBkZXBzLCBjYWxsYmFjazogY2FsbGJhY2sgfTtcbiAgICB9O1xuXG4gICAgcmVxdWlyZWpzID0gcmVxdWlyZSA9IHJlcXVpcmVNb2R1bGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmVxdWlyZWpzLl9lYWtfc2VlbiA9IHJlZ2lzdHJ5O1xuXG4gICAgICBpZiAoc2VlbltuYW1lXSkgeyByZXR1cm4gc2VlbltuYW1lXTsgfVxuICAgICAgc2VlbltuYW1lXSA9IHt9O1xuXG4gICAgICBpZiAoIXJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIG1vZHVsZSBcIiArIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbW9kID0gcmVnaXN0cnlbbmFtZV0sXG4gICAgICAgICAgZGVwcyA9IG1vZC5kZXBzLFxuICAgICAgICAgIGNhbGxiYWNrID0gbW9kLmNhbGxiYWNrLFxuICAgICAgICAgIHJlaWZpZWQgPSBbXSxcbiAgICAgICAgICBleHBvcnRzO1xuXG4gICAgICBmb3IgKHZhciBpPTAsIGw9ZGVwcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgIGlmIChkZXBzW2ldID09PSAnZXhwb3J0cycpIHtcbiAgICAgICAgICByZWlmaWVkLnB1c2goZXhwb3J0cyA9IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWlmaWVkLnB1c2gocmVxdWlyZU1vZHVsZShyZXNvbHZlKGRlcHNbaV0pKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gY2FsbGJhY2suYXBwbHkodGhpcywgcmVpZmllZCk7XG4gICAgICByZXR1cm4gc2VlbltuYW1lXSA9IGV4cG9ydHMgfHwgdmFsdWU7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmUoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLmNoYXJBdCgwKSAhPT0gJy4nKSB7IHJldHVybiBjaGlsZDsgfVxuICAgICAgICB2YXIgcGFydHMgPSBjaGlsZC5zcGxpdChcIi9cIik7XG4gICAgICAgIHZhciBwYXJlbnRCYXNlID0gbmFtZS5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpO1xuXG4gICAgICAgIGZvciAodmFyIGk9MCwgbD1wYXJ0cy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICAgIGlmIChwYXJ0ID09PSAnLi4nKSB7IHBhcmVudEJhc2UucG9wKCk7IH1cbiAgICAgICAgICBlbHNlIGlmIChwYXJ0ID09PSAnLicpIHsgY29udGludWU7IH1cbiAgICAgICAgICBlbHNlIHsgcGFyZW50QmFzZS5wdXNoKHBhcnQpOyB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50QmFzZS5qb2luKFwiL1wiKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIGRlZmluZShcInByb21pc2UvYWxsXCIsXG4gICAgW1wiLi91dGlsc1wiLFwiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2RlcGVuZGVuY3kxX18sIF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIC8qIGdsb2JhbCB0b1N0cmluZyAqL1xuXG4gICAgICB2YXIgaXNBcnJheSA9IF9fZGVwZW5kZW5jeTFfXy5pc0FycmF5O1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSBfX2RlcGVuZGVuY3kxX18uaXNGdW5jdGlvbjtcblxuICAgICAgLyoqXG4gICAgICAgIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIHRoZSBnaXZlbiBwcm9taXNlcyBoYXZlIGJlZW5cbiAgICAgICAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuIFRoZSByZXR1cm4gcHJvbWlzZVxuICAgICAgICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSB0aGF0IGdpdmVzIGFsbCB0aGUgdmFsdWVzIGluIHRoZSBvcmRlciB0aGV5IHdlcmVcbiAgICAgICAgcGFzc2VkIGluIHRoZSBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50LlxuXG4gICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICB2YXIgcHJvbWlzZTEgPSBSU1ZQLnJlc29sdmUoMSk7XG4gICAgICAgIHZhciBwcm9taXNlMiA9IFJTVlAucmVzb2x2ZSgyKTtcbiAgICAgICAgdmFyIHByb21pc2UzID0gUlNWUC5yZXNvbHZlKDMpO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICAgICAgICBSU1ZQLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgICAgICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gICAgICAgIH0pO1xuICAgICAgICBgYGBcblxuICAgICAgICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYFJTVlAuYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gICAgICAgIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICAgICAgICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBwcm9taXNlMSA9IFJTVlAucmVzb2x2ZSgxKTtcbiAgICAgICAgdmFyIHByb21pc2UyID0gUlNWUC5yZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gICAgICAgIHZhciBwcm9taXNlMyA9IFJTVlAucmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICAgICAgICBSU1ZQLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgICAgICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGBgYFxuXG4gICAgICAgIEBtZXRob2QgYWxsXG4gICAgICAgIEBmb3IgUlNWUFxuICAgICAgICBAcGFyYW0ge0FycmF5fSBwcm9taXNlc1xuICAgICAgICBAcGFyYW0ge1N0cmluZ30gbGFiZWxcbiAgICAgICAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICAgICAgICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgICAgICovXG4gICAgICBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgdmFyIFByb21pc2UgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNBcnJheShwcm9taXNlcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIGFsbC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLCByZW1haW5pbmcgPSBwcm9taXNlcy5sZW5ndGgsXG4gICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZUFsbChpbmRleCwgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlQWxsKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlc1tpXTtcblxuICAgICAgICAgICAgaWYgKHByb21pc2UgJiYgaXNGdW5jdGlvbihwcm9taXNlLnRoZW4pKSB7XG4gICAgICAgICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlcihpKSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmVBbGwoaSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18uYWxsID0gYWxsO1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL2FzYXBcIixcbiAgICBbXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIHZhciBicm93c2VyR2xvYmFsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHt9O1xuICAgICAgdmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICAgIHZhciBsb2NhbCA9IHdpbmRvdztcblxuICAgICAgLy8gbm9kZVxuICAgICAgZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5vZGUuZGF0YSA9IChpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb2NhbC5zZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0dXBsZSA9IHF1ZXVlW2ldO1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IHR1cGxlWzBdLCBhcmcgPSB0dXBsZVsxXTtcbiAgICAgICAgICBjYWxsYmFjayhhcmcpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBzY2hlZHVsZUZsdXNoO1xuXG4gICAgICAvLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAgICAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG4gICAgICB9IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHF1ZXVlLnB1c2goW2NhbGxiYWNrLCBhcmddKTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIElmIGxlbmd0aCBpcyAxLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAgICAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgICAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18uYXNhcCA9IGFzYXA7XG4gICAgfSk7XG4gIGRlZmluZShcInByb21pc2UvY29uZmlnXCIsXG4gICAgW1wiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICBpbnN0cnVtZW50OiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gY29uZmlndXJlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgY29uZmlnW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZ1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfX2V4cG9ydHNfXy5jb25maWcgPSBjb25maWc7XG4gICAgICBfX2V4cG9ydHNfXy5jb25maWd1cmUgPSBjb25maWd1cmU7XG4gICAgfSk7XG4gIGRlZmluZShcInByb21pc2UvcG9seWZpbGxcIixcbiAgICBbXCIuL3Byb21pc2VcIixcIi4vdXRpbHNcIixcImV4cG9ydHNcIl0sXG4gICAgZnVuY3Rpb24oX19kZXBlbmRlbmN5MV9fLCBfX2RlcGVuZGVuY3kyX18sIF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIC8qZ2xvYmFsIHNlbGYqL1xuICAgICAgdmFyIFJTVlBQcm9taXNlID0gX19kZXBlbmRlbmN5MV9fLlByb21pc2U7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IF9fZGVwZW5kZW5jeTJfXy5pc0Z1bmN0aW9uO1xuXG4gICAgICBmdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgICAgICAgdmFyIGxvY2FsO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgICBsb2NhbCA9IHdpbmRvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXM2UHJvbWlzZVN1cHBvcnQgPVxuICAgICAgICAgIFwiUHJvbWlzZVwiIGluIGxvY2FsICYmXG4gICAgICAgICAgLy8gU29tZSBvZiB0aGVzZSBtZXRob2RzIGFyZSBtaXNzaW5nIGZyb21cbiAgICAgICAgICAvLyBGaXJlZm94L0Nocm9tZSBleHBlcmltZW50YWwgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgXCJyZXNvbHZlXCIgaW4gbG9jYWwuUHJvbWlzZSAmJlxuICAgICAgICAgIFwicmVqZWN0XCIgaW4gbG9jYWwuUHJvbWlzZSAmJlxuICAgICAgICAgIFwiYWxsXCIgaW4gbG9jYWwuUHJvbWlzZSAmJlxuICAgICAgICAgIFwicmFjZVwiIGluIGxvY2FsLlByb21pc2UgJiZcbiAgICAgICAgICAvLyBPbGRlciB2ZXJzaW9uIG9mIHRoZSBzcGVjIGhhZCBhIHJlc29sdmVyIG9iamVjdFxuICAgICAgICAgIC8vIGFzIHRoZSBhcmcgcmF0aGVyIHRoYW4gYSBmdW5jdGlvblxuICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlO1xuICAgICAgICAgICAgbmV3IGxvY2FsLlByb21pc2UoZnVuY3Rpb24ocikgeyByZXNvbHZlID0gcjsgfSk7XG4gICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihyZXNvbHZlKTtcbiAgICAgICAgICB9KCkpO1xuXG4gICAgICAgIGlmICghZXM2UHJvbWlzZVN1cHBvcnQpIHtcbiAgICAgICAgICBsb2NhbC5Qcm9taXNlID0gUlNWUFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18ucG9seWZpbGwgPSBwb2x5ZmlsbDtcbiAgICB9KTtcbiAgZGVmaW5lKFwicHJvbWlzZS9wcm9taXNlXCIsXG4gICAgW1wiLi9jb25maWdcIixcIi4vdXRpbHNcIixcIi4vYWxsXCIsXCIuL3JhY2VcIixcIi4vcmVzb2x2ZVwiLFwiLi9yZWplY3RcIixcIi4vYXNhcFwiLFwiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2RlcGVuZGVuY3kxX18sIF9fZGVwZW5kZW5jeTJfXywgX19kZXBlbmRlbmN5M19fLCBfX2RlcGVuZGVuY3k0X18sIF9fZGVwZW5kZW5jeTVfXywgX19kZXBlbmRlbmN5Nl9fLCBfX2RlcGVuZGVuY3k3X18sIF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIHZhciBjb25maWcgPSBfX2RlcGVuZGVuY3kxX18uY29uZmlnO1xuICAgICAgdmFyIGNvbmZpZ3VyZSA9IF9fZGVwZW5kZW5jeTFfXy5jb25maWd1cmU7XG4gICAgICB2YXIgb2JqZWN0T3JGdW5jdGlvbiA9IF9fZGVwZW5kZW5jeTJfXy5vYmplY3RPckZ1bmN0aW9uO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSBfX2RlcGVuZGVuY3kyX18uaXNGdW5jdGlvbjtcbiAgICAgIHZhciBub3cgPSBfX2RlcGVuZGVuY3kyX18ubm93O1xuICAgICAgdmFyIGFsbCA9IF9fZGVwZW5kZW5jeTNfXy5hbGw7XG4gICAgICB2YXIgcmFjZSA9IF9fZGVwZW5kZW5jeTRfXy5yYWNlO1xuICAgICAgdmFyIHN0YXRpY1Jlc29sdmUgPSBfX2RlcGVuZGVuY3k1X18ucmVzb2x2ZTtcbiAgICAgIHZhciBzdGF0aWNSZWplY3QgPSBfX2RlcGVuZGVuY3k2X18ucmVqZWN0O1xuICAgICAgdmFyIGFzYXAgPSBfX2RlcGVuZGVuY3k3X18uYXNhcDtcblxuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgICBjb25maWcuYXN5bmMgPSBhc2FwOyAvLyBkZWZhdWx0IGFzeW5jIGlzIGFzYXA7XG5cbiAgICAgIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJlc29sdmVyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gICAgICAgIGludm9rZVJlc29sdmVyKHJlc29sdmVyLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52b2tlUmVzb2x2ZXIocmVzb2x2ZXIsIHByb21pc2UpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc29sdmVyKHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgcmVqZWN0UHJvbWlzZShlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICAgIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgICAgICAgdmFsdWUsIGVycm9yLCBzdWNjZWVkZWQsIGZhaWxlZDtcblxuICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gZGV0YWlsO1xuICAgICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFuZGxlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBQRU5ESU5HICAgPSB2b2lkIDA7XG4gICAgICB2YXIgU0VBTEVEICAgID0gMDtcbiAgICAgIHZhciBGVUxGSUxMRUQgPSAxO1xuICAgICAgdmFyIFJFSkVDVEVEICA9IDI7XG5cbiAgICAgIGZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICAgIHN1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gICAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSAgPSBvblJlamVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHVibGlzaChwcm9taXNlLCBzZXR0bGVkKSB7XG4gICAgICAgIHZhciBjaGlsZCwgY2FsbGJhY2ssIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnMsIGRldGFpbCA9IHByb21pc2UuX2RldGFpbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgICAgICAgIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UuX3N1YnNjcmliZXJzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBQcm9taXNlLFxuXG4gICAgICAgIF9zdGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBfZGV0YWlsOiB1bmRlZmluZWQsXG4gICAgICAgIF9zdWJzY3JpYmVyczogdW5kZWZpbmVkLFxuXG4gICAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgICAgICAgdmFyIHRoZW5Qcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24oKSB7fSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBjb25maWcuYXN5bmMoZnVuY3Rpb24gaW52b2tlUHJvbWlzZUNhbGxiYWNrKCkge1xuICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhwcm9taXNlLl9zdGF0ZSwgdGhlblByb21pc2UsIGNhbGxiYWNrc1twcm9taXNlLl9zdGF0ZSAtIDFdLCBwcm9taXNlLl9kZXRhaWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZSh0aGlzLCB0aGVuUHJvbWlzZSwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGVuUHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBQcm9taXNlLmFsbCA9IGFsbDtcbiAgICAgIFByb21pc2UucmFjZSA9IHJhY2U7XG4gICAgICBQcm9taXNlLnJlc29sdmUgPSBzdGF0aWNSZXNvbHZlO1xuICAgICAgUHJvbWlzZS5yZWplY3QgPSBzdGF0aWNSZWplY3Q7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICAgIHZhciB0aGVuID0gbnVsbCxcbiAgICAgICAgcmVzb2x2ZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhlbiA9IHZhbHVlLnRoZW47XG5cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoZW4pKSB7XG4gICAgICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmVqZWN0KHByb21pc2UsIHZhbCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFoYW5kbGVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSkpIHtcbiAgICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykgeyByZXR1cm47IH1cbiAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSBTRUFMRUQ7XG4gICAgICAgIHByb21pc2UuX2RldGFpbCA9IHZhbHVlO1xuXG4gICAgICAgIGNvbmZpZy5hc3luYyhwdWJsaXNoRnVsZmlsbG1lbnQsIHByb21pc2UpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykgeyByZXR1cm47IH1cbiAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSBTRUFMRUQ7XG4gICAgICAgIHByb21pc2UuX2RldGFpbCA9IHJlYXNvbjtcblxuICAgICAgICBjb25maWcuYXN5bmMocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHB1Ymxpc2hGdWxmaWxsbWVudChwcm9taXNlKSB7XG4gICAgICAgIHB1Ymxpc2gocHJvbWlzZSwgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgcHVibGlzaChwcm9taXNlLCBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEKTtcbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18uUHJvbWlzZSA9IFByb21pc2U7XG4gICAgfSk7XG4gIGRlZmluZShcInByb21pc2UvcmFjZVwiLFxuICAgIFtcIi4vdXRpbHNcIixcImV4cG9ydHNcIl0sXG4gICAgZnVuY3Rpb24oX19kZXBlbmRlbmN5MV9fLCBfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAvKiBnbG9iYWwgdG9TdHJpbmcgKi9cbiAgICAgIHZhciBpc0FycmF5ID0gX19kZXBlbmRlbmN5MV9fLmlzQXJyYXk7XG5cbiAgICAgIC8qKlxuICAgICAgICBgUlNWUC5yYWNlYCBhbGxvd3MgeW91IHRvIHdhdGNoIGEgc2VyaWVzIG9mIHByb21pc2VzIGFuZCBhY3QgYXMgc29vbiBhcyB0aGVcbiAgICAgICAgZmlyc3QgcHJvbWlzZSBnaXZlbiB0byB0aGUgYHByb21pc2VzYCBhcmd1bWVudCBmdWxmaWxscyBvciByZWplY3RzLlxuXG4gICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICB2YXIgcHJvbWlzZTEgPSBuZXcgUlNWUC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmVzb2x2ZShcInByb21pc2UgMVwiKTtcbiAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJvbWlzZTIgPSBuZXcgUlNWUC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmVzb2x2ZShcInByb21pc2UgMlwiKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBSU1ZQLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgICAvLyByZXN1bHQgPT09IFwicHJvbWlzZSAyXCIgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgICAgICAgLy8gd2FzIHJlc29sdmVkLlxuICAgICAgICB9KTtcbiAgICAgICAgYGBgXG5cbiAgICAgICAgYFJTVlAucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdCBjb21wbGV0ZWRcbiAgICAgICAgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGUgYHByb21pc2VzYFxuICAgICAgICBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3QgY29tcGxldGVkIHByb21pc2UgaGFzIGJlY29tZVxuICAgICAgICByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZCBwcm9taXNlXG4gICAgICAgIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgdmFyIHByb21pc2UxID0gbmV3IFJTVlAuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJlc29sdmUoXCJwcm9taXNlIDFcIik7XG4gICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHByb21pc2UyID0gbmV3IFJTVlAuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJwcm9taXNlIDJcIikpO1xuICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFJTVlAucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSBcInByb21pc2UyXCIgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgICAgICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gICAgICAgIH0pO1xuICAgICAgICBgYGBcblxuICAgICAgICBAbWV0aG9kIHJhY2VcbiAgICAgICAgQGZvciBSU1ZQXG4gICAgICAgIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgICAgICAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgZGVzY3JpYmluZyB0aGUgcHJvbWlzZSByZXR1cm5lZC5cbiAgICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCBiZWNvbWVzIGZ1bGZpbGxlZCB3aXRoIHRoZSB2YWx1ZSB0aGUgZmlyc3RcbiAgICAgICAgY29tcGxldGVkIHByb21pc2VzIGlzIHJlc29sdmVkIHdpdGggaWYgdGhlIGZpcnN0IGNvbXBsZXRlZCBwcm9taXNlIHdhc1xuICAgICAgICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiB0aGF0IHRoZSBmaXJzdCBjb21wbGV0ZWQgcHJvbWlzZVxuICAgICAgICB3YXMgcmVqZWN0ZWQgd2l0aC5cbiAgICAgICovXG4gICAgICBmdW5jdGlvbiByYWNlKHByb21pc2VzKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHZhciBQcm9taXNlID0gdGhpcztcblxuICAgICAgICBpZiAoIWlzQXJyYXkocHJvbWlzZXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLCBwcm9taXNlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2VzW2ldO1xuXG4gICAgICAgICAgICBpZiAocHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBfX2V4cG9ydHNfXy5yYWNlID0gcmFjZTtcbiAgICB9KTtcbiAgZGVmaW5lKFwicHJvbWlzZS9yZWplY3RcIixcbiAgICBbXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIC8qKlxuICAgICAgICBgUlNWUC5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkXG4gICAgICAgIGByZWFzb25gLiBgUlNWUC5yZWplY3RgIGlzIGVzc2VudGlhbGx5IHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFJTVlAuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgICAgICAgfSk7XG4gICAgICAgIGBgYFxuXG4gICAgICAgIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBwcm9taXNlID0gUlNWUC5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgICAgICAgfSk7XG4gICAgICAgIGBgYFxuXG4gICAgICAgIEBtZXRob2QgcmVqZWN0XG4gICAgICAgIEBmb3IgUlNWUFxuICAgICAgICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICAgICAgICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBpZGVudGlmeWluZyB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cbiAgICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlblxuICAgICAgICBgcmVhc29uYC5cbiAgICAgICovXG4gICAgICBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHZhciBQcm9taXNlID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18ucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL3Jlc29sdmVcIixcbiAgICBbXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIGZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IHRoaXMpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgUHJvbWlzZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIF9fZXhwb3J0c19fLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL3V0aWxzXCIsXG4gICAgW1wiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICBmdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oeCkgfHwgKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIHggIT09IG51bGwpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzQXJyYXkoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIERhdGUubm93IGlzIG5vdCBhdmFpbGFibGUgaW4gYnJvd3NlcnMgPCBJRTlcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvbm93I0NvbXBhdGliaWxpdHlcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuXG5cbiAgICAgIF9fZXhwb3J0c19fLm9iamVjdE9yRnVuY3Rpb24gPSBvYmplY3RPckZ1bmN0aW9uO1xuICAgICAgX19leHBvcnRzX18uaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgICBfX2V4cG9ydHNfXy5pc0FycmF5ID0gaXNBcnJheTtcbiAgICAgIF9fZXhwb3J0c19fLm5vdyA9IG5vdztcbiAgICB9KTtcbiAgcmVxdWlyZU1vZHVsZSgncHJvbWlzZS9wb2x5ZmlsbCcpLnBvbHlmaWxsKCk7XG4gIH0oKSk7XG59XG4iLCJyZXF1aXJlKCdsZWFmbGV0Jyk7XG5yZXF1aXJlKCdodG1sNXNoaXYnKTtcblxuLy8gREcgaW5oZXJpdGFuY2VcbnZhciBvbGRERyA9IHdpbmRvdy5ERztcbnZhciBERyA9IG5ldyAoXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgRGdBcGkgPSBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgRGdBcGlDb3JlID0gZnVuY3Rpb24oKSB7fTtcblxuICAgICAgICBEZ0FwaUNvcmUucHJvdG90eXBlID0gTDtcbiAgICAgICAgRGdBcGkucHJvdG90eXBlID0gbmV3IERnQXBpQ29yZSgpO1xuXG4gICAgICAgIHJldHVybiBEZ0FwaTtcbiAgICB9KSgpXG4pKCk7XG5cbmZvciAodmFyIHByb3AgaW4gb2xkREcpIHtcbiAgICBpZiAob2xkREcuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgdHlwZW9mIERHW3Byb3BdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBER1twcm9wXSA9IG9sZERHW3Byb3BdO1xuICAgIH1cbn1cblxud2luZG93Ll9fZGdBcGlfXyA9IHdpbmRvdy5fX2RnQXBpX18gfHwge307XG5ERy52ZXJzaW9uID0gd2luZG93Ll9fZGdBcGlfXy52ZXJzaW9uO1xuREcuSWNvbi5EZWZhdWx0LmltYWdlUGF0aCAgPSAnLi4vaW1nL3ZlbmRvcnMvbGVhZmxldCc7XG5cbkRHLk1hcC5hZGRJbml0SG9vaygoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluaXRlZCA9IGZhbHNlO1xuXG4gICAgLy8gQW5hbHl0aWNzIGluaXRlZCBvbmNlXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWluaXRlZCkge1xuICAgICAgICAgICAgLyplc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgICAgICAgKGZ1bmN0aW9uKGkscyxvLGcscixhLG0pe2lbJ0dvb2dsZUFuYWx5dGljc09iamVjdCddPXI7aVtyXT1pW3JdfHxmdW5jdGlvbigpe1xuICAgICAgICAgICAgKGlbcl0ucT1pW3JdLnF8fFtdKS5wdXNoKGFyZ3VtZW50cyl9LGlbcl0ubD0xKm5ldyBEYXRlKCk7YT1zLmNyZWF0ZUVsZW1lbnQobyksXG4gICAgICAgICAgICBtPXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUobylbMF07YS5hc3luYz0xO2Euc3JjPWc7bS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLG0pXG4gICAgICAgICAgICB9KSh3aW5kb3csZG9jdW1lbnQsJ3NjcmlwdCcsREcuY29uZmlnLnByb3RvY29sK0RHLmNvbmZpZy5nb29nbGVBbmFseXRpY3MsJ2dhJyk7XG4gICAgICAgICAgICAvKmVzbGludC1lbmFibGUgKi9cblxuICAgICAgICAgICAgaW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgZ2EoJ2NyZWF0ZScsIERHLmNvbmZpZy5nYUNvZGUsICdub25lJywge25hbWU6ICdtYXBzYXBpMmdpcyd9KTtcbiAgICAgICAgZ2EoJ21hcHNhcGkyZ2lzLnNlbmQnLCAncGFnZXZpZXcnKTtcbiAgICAgICAgLyplc2xpbnQtZW5hYmxlICovXG5cbiAgICAgICAgdmFyIG5ld0ltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBuZXdJbWcuc3JjID0gREcuY29uZmlnLnByb3RvY29sICsgREcuY29uZmlnLmFuYWx5dGljcyArICc/JyArXG4gICAgICAgICAgICAnc3I9JyArIHdpbmRvdy5zY3JlZW4ud2lkdGggKyAneCcgKyB3aW5kb3cuc2NyZWVuLmhlaWdodCArICcmJyArXG4gICAgICAgICAgICAndj0nICsgREcudmVyc2lvbjtcbiAgICB9O1xufSkoKSk7XG5cbi8vIEltcHJvdmUgSUhhbmRsZXJcbkRHLk1hcC5pbmNsdWRlKHtcbiAgICBhZGRIYW5kbGVyOiBmdW5jdGlvbihuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcbiAgICAgICAgaWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1tuYW1lXSxcbiAgICAgICAgICAgIHBhcmFtID0gKG9wdGlvbnMgPT09IE9iamVjdChvcHRpb25zKSkgPyBvcHRpb25zIDogbnVsbCxcbiAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzLCBwYXJhbSk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaGFuZGxlci5lbmFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuXG4vLyBBcHBseSBjbGFzcyB0byBtYXAgY29udGFpbmVyIGZvciBkZXRlY3Qgd2hlbiB3ZSBkb250IG5lZWQgaG92ZXIgZWZmZWN0c1xuREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uKCkge1xuICAgIGlmICghREcuQnJvd3Nlci50b3VjaEVuYWJsZWQpIHtcbiAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICduby10b3VjaCcpO1xuICAgIH1cbn0pO1xuXG53aW5kb3cuREcgPSBERztcbm1vZHVsZS5leHBvcnRzID0gREc7XG4iLCJ2YXIgaGFuZGxlcnMgPSB3aW5kb3cuX19kZ0FwaV9fLmNhbGxiYWNrcyB8fCBbXSxcbiAgICBjaGFpbiA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG5oYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXJzKSB7XG4gICAgY2hhaW4gPSBjaGFpbi50aGVuKGhhbmRsZXJzWzBdLCBoYW5kbGVyc1sxXSk7XG59KTtcblxuREcudGhlbiA9IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJldHVybiBjaGFpbi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG4vLyBJRTggdGhyb3cgZXJyb3IgaWYgYGNoYWluLmNhdGNoYFxuLyogZXNsaW50LWRpc2FibGUgZG90LW5vdGF0aW9uLCBuby1jb25zb2xlICovXG5jaGFpblsnY2F0Y2gnXShmdW5jdGlvbihlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG59KTtcbi8qIGVzbGludC1lbmFibGUgZG90LW5vdGF0aW9uLCBuby1jb25zb2xlICovXG4iLCJERy5wbHVnaW4gPSBmdW5jdGlvbihwbHVnaW5zKSB7XG4gICAgdmFyIGNvdW50LFxuICAgICAgICBqc1JlZyA9IG5ldyBSZWdFeHAoLy5qcyQvaSksXG4gICAgICAgIGNzc1JlZyA9IG5ldyBSZWdFeHAoLy5jc3MkL2kpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMb2FkaW5nKCkge1xuICAgICAgICAgICAgY291bnQtLTtcblxuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kSlMobGluaykge1xuICAgICAgICAgICAgdmFyIGpzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBqcy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9qYXZhc2NyaXB0Jyk7XG4gICAgICAgICAgICBqcy5zZXRBdHRyaWJ1dGUoJ3NyYycsIGxpbmspO1xuICAgICAgICAgICAganMub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkaW5nKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAganMub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNoZWNrTG9hZGluZygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGxvYWQvZXJyb3IgZm9yIElFXG4gICAgICAgICAgICBqcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoanMucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJyB8fCBqcy5yZWFkeVN0YXRlID09PSAnbG9hZGVkJykge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0xvYWRpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGpzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZENTUyhsaW5rKSB7XG4gICAgICAgICAgICB2YXIgY3NzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAgICAgY3NzLnNldEF0dHJpYnV0ZSgncmVsJywgJ3N0eWxlc2hlZXQnKTtcbiAgICAgICAgICAgIGNzcy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgICAgICAgIGNzcy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBsaW5rKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoY3NzKTtcblxuICAgICAgICAgICAgY2hlY2tMb2FkaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0pzKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzUmVnLnRlc3QodXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzQ3NzKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIGNzc1JlZy50ZXN0KHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhcHBlbmRBc3NldChhc3NldCkge1xuICAgICAgICAgICAgaWYgKGlzSnMoYXNzZXQpKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kSlMoYXNzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Nzcyhhc3NldCkpIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRDU1MoYXNzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKERHLlV0aWwuaXNBcnJheShwbHVnaW5zKSkge1xuICAgICAgICAgICAgY291bnQgPSBwbHVnaW5zLmxlbmd0aDtcbiAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRBc3NldChwbHVnaW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBsdWdpbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgICAgICBhcHBlbmRBc3NldChwbHVnaW5zKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbiIsIkRHLmFqYXggPSAoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgd2luID0gd2luZG93LFxuICAgICAgICBkb2MgPSBkb2N1bWVudCxcblxuICAgICAgICBydXJsID0gL14oW1xcdy4rLV0rOik/KD86XFwvXFwvKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFxuICAgICAgICB0d29IdW5kbyA9IC9eMjBcXGQkLyxcblxuICAgICAgICAvLyBEb2N1bWVudCBsb2NhdGlvblxuICAgICAgICBhamF4TG9jUGFydHMsXG4gICAgICAgIGFqYXhMb2NhdGlvbixcblxuICAgICAgICBieVRhZyA9ICdnZXRFbGVtZW50c0J5VGFnTmFtZScsXG4gICAgICAgIHJlYWR5U3RhdGUgPSAncmVhZHlTdGF0ZScsXG4gICAgICAgIGNvbnRlbnRUeXBlID0gJ0NvbnRlbnQtVHlwZScsXG4gICAgICAgIHJlcXVlc3RlZFdpdGggPSAnWC1SZXF1ZXN0ZWQtV2l0aCcsXG4gICAgICAgIGhlYWQgPSBkb2NbYnlUYWddKCdoZWFkJylbMF0sXG4gICAgICAgIHVuaXFpZCA9IDAsXG4gICAgICAgIGNhbGxiYWNrUHJlZml4ID0gJ2xfZGdfYWpheF9jYWxsYmFja18nICsgKCtuZXcgRGF0ZSgpKSxcbiAgICAgICAgbGFzdFZhbHVlLCAvLyBkYXRhIHN0b3JlZCBieSB0aGUgbW9zdCByZWNlbnQgSlNPTlAgY2FsbGJhY2tcbiAgICAgICAgeG1sSHR0cFJlcXVlc3QgPSAnWE1MSHR0cFJlcXVlc3QnLFxuICAgICAgICB4RG9tYWluUmVxdWVzdCA9ICdYRG9tYWluUmVxdWVzdCcsIC8vIElFIDggYW5kIDkgb25seVxuICAgICAgICBub29wID0gZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICByZXF1ZXN0ZWRXaXRoOiB4bWxIdHRwUmVxdWVzdCxcbiAgICAgICAgICAgIGFjY2VwdDoge1xuICAgICAgICAgICAgICAgICcqJzogICd0ZXh0L2phdmFzY3JpcHQsIHRleHQvaHRtbCwgYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCwgKi8qJyxcbiAgICAgICAgICAgICAgICB4bWw6ICAnYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCcsXG4gICAgICAgICAgICAgICAgaHRtbDogJ3RleHQvaHRtbCcsXG4gICAgICAgICAgICAgICAgdGV4dDogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgICAgICAgIGpzb246ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgICAgIGpzOiAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCB0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qZ2xvYmFsIFhEb21haW5SZXF1ZXN0OmZhbHNlICovXG4gICAgICAgIHhociA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgIC8vIGlzIGl0IHgtZG9tYWluXG4gICAgICAgICAgICBpZiAoby5jcm9zc0RvbWFpbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciB4aHIgPSB3aW5beG1sSHR0cFJlcXVlc3RdID8gbmV3IFhNTEh0dHBSZXF1ZXN0KCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh4aHIgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4aHI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5beERvbWFpblJlcXVlc3RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBjcm9zcy1vcmlnaW4gcmVxdWVzdHMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnbG9iYWxTZXR1cE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkYXRhRmlsdGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAvLyBJRSBtYXkgdGhyb3cgYW4gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nXG4gICAgLy8gYSBmaWVsZCBmcm9tIHdpbmRvdy5sb2NhdGlvbiBpZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gc2V0XG4gICAgdHJ5IHtcbiAgICAgICAgYWpheExvY2F0aW9uID0gbG9jYXRpb24uaHJlZjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUgb2YgYW4gQSBlbGVtZW50XG4gICAgICAgIC8vIHNpbmNlIElFIHdpbGwgbW9kaWZ5IGl0IGdpdmVuIGRvY3VtZW50LmxvY2F0aW9uXG4gICAgICAgIGFqYXhMb2NhdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgYWpheExvY2F0aW9uLmhyZWYgPSAnJztcbiAgICAgICAgYWpheExvY2F0aW9uID0gYWpheExvY2F0aW9uLmhyZWY7XG4gICAgfVxuXG4gICAgLy8gU2VnbWVudCBsb2NhdGlvbiBpbnRvIHBhcnRzXG4gICAgYWpheExvY1BhcnRzID0gcnVybC5leGVjKGFqYXhMb2NhdGlvbi50b0xvd2VyQ2FzZSgpKSB8fCBbXTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlYWR5U3RhdGUociwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gdXNlIF9hYm9ydGVkIHRvIG1pdGlnYXRlIGFnYWluc3QgSUUgZXJyIGMwMGMwMjNmXG4gICAgICAgICAgICAvLyAoY2FuJ3QgcmVhZCBwcm9wcyBvbiBhYm9ydGVkIHJlcXVlc3Qgb2JqZWN0cylcbiAgICAgICAgICAgIGlmIChyLl9hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKHIucmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoci5yZXF1ZXN0ICYmIHIucmVxdWVzdFtyZWFkeVN0YXRlXSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHIucmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBub29wO1xuICAgICAgICAgICAgICAgIGlmICh0d29IdW5kby50ZXN0KHIucmVxdWVzdC5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3Moci5yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihyLnJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRIZWFkZXJzKGh0dHAsIG8pIHtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBvLmhlYWRlcnMgfHwge30sXG4gICAgICAgICAgICBoO1xuXG4gICAgICAgIGhlYWRlcnMuQWNjZXB0ID0gaGVhZGVycy5BY2NlcHQgfHwgZGVmYXVsdEhlYWRlcnMuYWNjZXB0W28uZGF0YVR5cGVdIHx8IGRlZmF1bHRIZWFkZXJzLmFjY2VwdFsnKiddO1xuXG4gICAgICAgIC8vIGJyZWFrcyBjcm9zcy1vcmlnaW4gcmVxdWVzdHMgd2l0aCBsZWdhY3kgYnJvd3NlcnNcbiAgICAgICAgaWYgKCFvLmNyb3NzRG9tYWluICYmICFoZWFkZXJzW3JlcXVlc3RlZFdpdGhdKSB7XG4gICAgICAgICAgICBoZWFkZXJzW3JlcXVlc3RlZFdpdGhdID0gZGVmYXVsdEhlYWRlcnMucmVxdWVzdGVkV2l0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhlYWRlcnNbY29udGVudFR5cGVdKSB7XG4gICAgICAgICAgICBoZWFkZXJzW2NvbnRlbnRUeXBlXSA9IG8uY29udGVudFR5cGUgfHwgZGVmYXVsdEhlYWRlcnMuY29udGVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChoIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzLmhhc093blByb3BlcnR5KGgpICYmICdzZXRSZXF1ZXN0SGVhZGVyJyBpbiBodHRwKSB7XG4gICAgICAgICAgICAgICAgaHR0cC5zZXRSZXF1ZXN0SGVhZGVyKGgsIGhlYWRlcnNbaF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Q3JlZGVudGlhbHMoaHR0cCwgbykge1xuICAgICAgICBpZiAodHlwZW9mIG8ud2l0aENyZWRlbnRpYWxzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaHR0cC53aXRoQ3JlZGVudGlhbHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBodHRwLndpdGhDcmVkZW50aWFscyA9ICEhby53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmFsQ2FsbGJhY2soZGF0YSkge1xuICAgICAgICBsYXN0VmFsdWUgPSBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVybGFwcGVuZCh1cmwsIHMpIHtcbiAgICAgICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVKc29ucChvLCBmbiwgZXJyLCB1cmwpIHtcbiAgICAgICAgdmFyIHJlcUlkID0gdW5pcWlkKyssXG4gICAgICAgICAgICBjYmtleSA9IG8uanNvbnBDYWxsYmFjayB8fCAnY2FsbGJhY2snLCAvLyB0aGUgJ2NhbGxiYWNrJyBrZXlcbiAgICAgICAgICAgIGNidmFsID0gby5qc29ucENhbGxiYWNrTmFtZSB8fCBjYWxsYmFja1ByZWZpeCxcbiAgICAgICAgICAgIGNicmVnID0gbmV3IFJlZ0V4cCgnKChefFxcXFw/fCYpJyArIGNia2V5ICsgJyk9KFteJl0rKScpLFxuICAgICAgICAgICAgbWF0Y2ggPSB1cmwubWF0Y2goY2JyZWcpLFxuICAgICAgICAgICAgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgICAgICAgbG9hZGVkID0gMCxcbiAgICAgICAgICAgIGlzSUUxMCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRSAxMC4wJykgIT09IC0xO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoWzNdID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShjYnJlZywgJyQxPScgKyBjYnZhbCk7IC8vIHdpbGRjYXJkIGNhbGxiYWNrIGZ1bmMgbmFtZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYnZhbCA9IG1hdGNoWzNdOyAvLyBwcm92aWRlZCBjYWxsYmFjayBmdW5jIG5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybCA9IHVybGFwcGVuZCh1cmwsIGNia2V5ICsgJz0nICsgY2J2YWwpOyAvLyBubyBjYWxsYmFjayBkZXRhaWxzLCBhZGQgJ2VtXG4gICAgICAgIH1cblxuICAgICAgICB3aW5bY2J2YWxdID0gZ2VuZXJhbENhbGxiYWNrO1xuXG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzSUUxMCkge1xuICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGZvciBJRSBkdWUgdG8gb3V0LW9mLW9yZGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSgpLCBiaW5kaW5nIHNjcmlwdFxuICAgICAgICAgICAgLy8gZXhlY3V0aW9uIHRvIGFuIGV2ZW50IGxpc3RlbmVyIGdpdmVzIHVzIGNvbnRyb2wgb3ZlciB3aGVuIHRoZSBzY3JpcHRcbiAgICAgICAgICAgIC8vIGlzIGV4ZWN1dGVkLiBTZWUgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBoYWNrIGlzIHVzZWQgaW4gSUUxMCBqc29ucCBjYWxsYmFjayBhcmUgbmV2ZXIgY2FsbGVkXG4gICAgICAgICAgICBzY3JpcHQuZXZlbnQgPSAnb25jbGljayc7XG4gICAgICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZCA9ICdfcmVxdWVzdF8nICsgcmVxSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICBlcnIoe30sICdSZXF1ZXN0IHVua25vd24gZXJyb3InLCB7fSk7XG4gICAgICAgICAgICBsYXN0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICBsb2FkZWQgPSAxO1xuICAgICAgICB9O1xuICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKChzY3JpcHRbcmVhZHlTdGF0ZV0gJiYgc2NyaXB0W3JlYWR5U3RhdGVdICE9PSAnY29tcGxldGUnICYmIHNjcmlwdFtyZWFkeVN0YXRlXSAhPT0gJ2xvYWRlZCcpIHx8IGxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNjcmlwdC5vbmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9uY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGwgdGhlIHVzZXIgY2FsbGJhY2sgd2l0aCB0aGUgbGFzdCB2YWx1ZSBzdG9yZWQgYW5kIGNsZWFuIHVwIHZhbHVlcyBhbmQgc2NyaXB0cy5cbiAgICAgICAgICAgIGZuKGxhc3RWYWx1ZSk7XG4gICAgICAgICAgICBsYXN0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICBsb2FkZWQgPSAxO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFkZCB0aGUgc2NyaXB0IHRvIHRoZSBET00gaGVhZFxuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cbiAgICAgICAgLy8gRW5hYmxlIEpTT05QIHRpbWVvdXRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBlcnIoe30sICdSZXF1ZXN0IGlzIGFib3J0ZWQ6IHRpbWVvdXQnLCB7fSk7XG4gICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlcXVlc3QoZm4sIGVycikge1xuICAgICAgICB2YXIgbyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIG1ldGhvZCA9IChvLnR5cGUgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICB1cmwgPSB0eXBlb2YgbyA9PT0gJ3N0cmluZycgPyBvIDogby51cmwsXG4gICAgICAgICAgICAvLyBjb252ZXJ0IG5vbi1zdHJpbmcgb2JqZWN0cyB0byBxdWVyeS1zdHJpbmcgZm9ybSB1bmxlc3Mgby5wcm9jZXNzRGF0YSBpcyBmYWxzZVxuICAgICAgICAgICAgZGF0YSA9IChvLnByb2Nlc3NEYXRhICE9PSBmYWxzZSAmJiBvLmRhdGEgJiYgdHlwZW9mIG8uZGF0YSAhPT0gJ3N0cmluZycpID8gQWpheC50b1F1ZXJ5U3RyaW5nKG8uZGF0YSkgOiAoby5kYXRhIHx8IG51bGwpLFxuICAgICAgICAgICAgaHR0cCxcbiAgICAgICAgICAgIHNlbmRXYWl0ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgd2UncmUgd29ya2luZyBvbiBhIEdFVCByZXF1ZXN0IGFuZCB3ZSBoYXZlIGRhdGEgdGhlbiB3ZSBzaG91bGQgYXBwZW5kXG4gICAgICAgIC8vIHF1ZXJ5IHN0cmluZyB0byBlbmQgb2YgVVJMIGFuZCBub3QgcG9zdCBkYXRhXG4gICAgICAgIGlmICgoby50eXBlID09PSAnanNvbnAnIHx8IG1ldGhvZCA9PT0gJ0dFVCcpICYmIGRhdGEpIHtcbiAgICAgICAgICAgIHVybCA9IHVybGFwcGVuZCh1cmwsIGRhdGEpO1xuICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoby50eXBlID09PSAnanNvbnAnKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlSnNvbnAobywgZm4sIGVyciwgdXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGh0dHAgPSB4aHIobyk7XG4gICAgICAgIGh0dHAub3BlbihtZXRob2QsIHVybCwgby5hc3luYyAhPT0gZmFsc2UpO1xuXG4gICAgICAgIHNldEhlYWRlcnMoaHR0cCwgbyk7XG4gICAgICAgIHNldENyZWRlbnRpYWxzKGh0dHAsIG8pO1xuXG4gICAgICAgIGlmICh3aW5beERvbWFpblJlcXVlc3RdICYmIGh0dHAgaW5zdGFuY2VvZiB3aW5beERvbWFpblJlcXVlc3RdKSB7XG4gICAgICAgICAgICBodHRwLm9ubG9hZCA9IGZuO1xuICAgICAgICAgICAgaHR0cC5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgIGh0dHAub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgIGh0dHAub25lcnJvciA9IGVycjtcbiAgICAgICAgICAgIHNlbmRXYWl0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlUmVhZHlTdGF0ZSh0aGlzLCBmbiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VuZFdhaXQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaHR0cC5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0dHAuc2VuZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHR0cDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFBhcmFtcyhwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCkge1xuICAgICAgICB2YXIgbmFtZSwgaSwgdixcbiAgICAgICAgICAgIHJicmFja2V0ID0gL1xcW1xcXSQvO1xuXG4gICAgICAgIGlmIChERy5VdGlsLmlzQXJyYXkob2JqKSkge1xuICAgICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IG9iaiAmJiBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdiA9IG9ialtpXTtcbiAgICAgICAgICAgICAgICBpZiAodHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdChwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cbiAgICAgICAgICAgICAgICAgICAgYWRkKHByZWZpeCwgdik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgJ1snICsgKHR5cGVvZiB2ID09PSAnb2JqZWN0JyA/IGkgOiAnJykgKyAnXScsIHYsIHRyYWRpdGlvbmFsLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvYmogJiYgb2JqLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyAnWycgKyBuYW1lICsgJ10nLCBvYmpbbmFtZV0sIHRyYWRpdGlvbmFsLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cbiAgICAgICAgICAgIGFkZChwcmVmaXgsIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUeXBlKHVybCkge1xuICAgICAgICB2YXIgbSA9IHVybC5tYXRjaCgvXFwuKGpzb258anNvbnB8aHRtbHx4bWwpKFxcP3wkKS8pO1xuICAgICAgICByZXR1cm4gbSA/IG1bMV0gOiAnanMnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ3Jvc3NEb21haW4odXJsKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHJ1cmwuZXhlYyh1cmwudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHJldHVybiAhIShwYXJ0cyAmJlxuICAgICAgICAgICAgICAgIChwYXJ0c1sxXSAhPT0gYWpheExvY1BhcnRzWzFdIHx8IHBhcnRzWzJdICE9PSBhamF4TG9jUGFydHNbMl0gfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhcnRzWzNdIHx8IChwYXJ0c1sxXSA9PT0gJ2h0dHA6JyA/ICc4MCcgOiAnNDQzJykpICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgKGFqYXhMb2NQYXJ0c1szXSB8fCAoYWpheExvY1BhcnRzWzFdID09PSAnaHR0cDonID8gJzgwJyA6ICc0NDMnKSkpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvUmVxdWVzdChvKSB7XG5cbiAgICAgICAgaWYgKCEoJ2Nyb3NzRG9tYWluJyBpbiBvKSkge1xuICAgICAgICAgICAgby5jcm9zc0RvbWFpbiA9IGlzQ3Jvc3NEb21haW4oby51cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcbiAgICAgICAgc2VsZi5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBzZWxmLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCdhYm9ydGVkJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzZWxmLnVybCA9IG8udXJsO1xuICAgICAgICAgICAgc2VsZi50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucyA9IG87XG5cbiAgICAgICAgICAgIHNlbGYuX2Fib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuX2VycmVkID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLl9yZXNwb25zZUFyZ3MgPSB7fTtcblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBvLnR5cGUgPT09ICdqc29ucCcgPyBvLnR5cGUgOiAoby5kYXRhVHlwZSB8fCBzZXRUeXBlKHNlbGYudXJsKSk7XG5cbiAgICAgICAgICAgIGlmIChvLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfSwgby50aW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGxldGUocmVzcCkge1xuICAgICAgICAgICAgICAgIGlmIChvLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYudGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2VycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXNwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3VjY2VzcyhyZXNwKSB7XG4gICAgICAgICAgICAgICAgcmVzcCA9ICh0eXBlICE9PSAnanNvbnAnKSA/IHNlbGYucmVxdWVzdCA6IHJlc3A7XG4gICAgICAgICAgICAgICAgLy8gdXNlIGdsb2JhbCBkYXRhIGZpbHRlciBvbiByZXNwb25zZSB0ZXh0XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkUmVzcG9uc2UgPSBnbG9iYWxTZXR1cE9wdGlvbnMuZGF0YUZpbHRlcihyZXNwLnJlc3BvbnNlVGV4dCwgdHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHIgPSBmaWx0ZXJlZFJlc3BvbnNlO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcC5yZXNwb25zZVRleHQgPSByO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuJ3QgYXNzaWduIHRoaXMgaW4gSUU8PTgsIGp1c3QgaWdub3JlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWV2YWwgKi9cbiAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSB3aW4uSlNPTi5wYXJzZShyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKHJlc3AsICdDb3VsZCBub3QgcGFyc2UgSlNPTiBpbiByZXNwb25zZScsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnanMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSBldmFsKCcoJyArIHIgKyAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcCA9IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4bWwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSByZXNwLnJlc3BvbnNlWE1MICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvciAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IuZXJyb3JDb2RlICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvci5yZWFzb24gPyBudWxsIDogcmVzcC5yZXNwb25zZVhNTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWV2YWwgKi9cbiAgICAgICAgICAgICAgICBzZWxmLl9yZXNwb25zZUFyZ3MucmVzcCA9IHJlc3A7XG4gICAgICAgICAgICAgICAgY29tcGxldGUocmVzcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGVycm9yKHJlc3AsIG1zZywgdCkge1xuICAgICAgICAgICAgICAgIHJlc3AgPSBzZWxmLnJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnJlc3AgPSByZXNwO1xuICAgICAgICAgICAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5tc2cgPSBtc2c7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnQgPSB0O1xuICAgICAgICAgICAgICAgIHNlbGYuX2VycmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZShyZXNwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5yZXF1ZXN0ID0gZ2V0UmVxdWVzdC5jYWxsKHNlbGYsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQWpheCh1cmwsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHVybCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdXJsO1xuICAgICAgICAgICAgdXJsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnVybCA9IHVybCB8fCBvcHRpb25zLnVybDtcblxuICAgICAgICB2YXIgcmVxdWVzdFByb21pc2UgPSBkb1JlcXVlc3Qob3B0aW9ucyksXG4gICAgICAgICAgICByZXN1bHRQcm9taXNlID0gcmVxdWVzdFByb21pc2UucHJvbWlzZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zdWNjZXNzIHx8IG9wdGlvbnMuZXJyb3IgfHwgb3B0aW9ucy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmVzdWx0UHJvbWlzZS50aGVuKG9wdGlvbnMuc3VjY2Vzcywgb3B0aW9ucy5lcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRQcm9taXNlLmFib3J0ID0gcmVxdWVzdFByb21pc2UuYWJvcnQ7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgfVxuXG4gICAgQWpheC5zZXR1cCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxTZXR1cE9wdGlvbnNba10gPSBvcHRpb25zW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFqYXgudG9RdWVyeVN0cmluZyA9IGZ1bmN0aW9uKG8sIHRyYWQpIHtcbiAgICAgICAgdmFyIHByZWZpeCwgaSxcbiAgICAgICAgICAgIHRyYWRpdGlvbmFsID0gdHJhZCB8fCBmYWxzZSxcbiAgICAgICAgICAgIHMgPSBbXSxcbiAgICAgICAgICAgIGVuYyA9IGVuY29kZVVSSUNvbXBvbmVudCxcbiAgICAgICAgICAgIGFkZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgfHwgJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc1tzLmxlbmd0aF0gPSBlbmMoa2V5KSArICc9JyArIGVuYyh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgICAgIGlmIChERy5VdGlsLmlzQXJyYXkobykpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IG8gJiYgaSA8IG8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhZGQob1tpXS5uYW1lLCBvW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG4gICAgICAgICAgICAvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cbiAgICAgICAgICAgIGZvciAocHJlZml4IGluIG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCwgb1twcmVmaXhdLCB0cmFkaXRpb25hbCwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzcGFjZXMgc2hvdWxkIGJlICsgYWNjb3JkaW5nIHRvIHNwZWNcbiAgICAgICAgcmV0dXJuIHMuam9pbignJicpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xuICAgIH07XG5cbiAgICB2YXIgdGVzdHhociA9IHdpblt4bWxIdHRwUmVxdWVzdF0gPyBuZXcgWE1MSHR0cFJlcXVlc3QoKSA6IG51bGw7XG5cbiAgICBBamF4LmNvcnNTdXBwb3J0ID0gISghKHRlc3R4aHIgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gdGVzdHhocikgJiYgIXdpblt4RG9tYWluUmVxdWVzdF0pICYmXG4gICAgICAgIC8vIGNvcnMgbm90IGF2YWlsYWJsZSBpbiBJRSBhbmQgd2l0aCBjeXJpbGxpYyBkb21haW5cbiAgICAgICAgIShERy5Ccm93c2VyLmllICYmIGRvY3VtZW50LmxvY2F0aW9uLmhvc3QudG9Mb3dlckNhc2UoKS5zZWFyY2goL1vQsC3Rj10vKSAhPSAtMSk7XG5cbiAgICByZXR1cm4gQWpheDtcbn0pKCk7XG4iLCJERy5Xa3QgPSB7fTtcblxuREcuV2t0LnRvR2VvSlNPTiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKERHLlV0aWwuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhID0gZGF0YVswXTtcbiAgICB9XG4gICAgdmFyIHBhcnRzID0gZGF0YS5zcGxpdCgnOycpO1xuICAgIGRhdGEgPSBwYXJ0cy5wb3AoKTtcblxuICAgIHZhciBpID0gMCxcbiAgICAgICAgc3JpZCA9IChwYXJ0cy5zaGlmdCgpIHx8ICcnKS5zcGxpdCgnPScpLnBvcCgpO1xuXG4gICAgZnVuY3Rpb24gJChyZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkYXRhLnN1YnN0cmluZyhpKS5tYXRjaChyZSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcnMob2JqKSB7XG4gICAgICAgIGlmIChvYmogJiYgc3JpZC5tYXRjaCgvXFxkKy8pKSB7XG4gICAgICAgICAgICBvYmouY3JzID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICduYW1lJyxcbiAgICAgICAgICAgICAgICAncHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3VybjpvZ2M6ZGVmOmNyczpFUFNHOjonICsgc3JpZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdoaXRlKCkgeyAkKC9eXFxzKi8pOyB9XG5cbiAgICBmdW5jdGlvbiBtdWx0aWNvb3JkcygpIHtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgdmFyIGRlcHRoID0gMCwgcmluZ3MgPSBbXSwgc3RhY2sgPSBbcmluZ3NdLFxuICAgICAgICAgICAgcG9pbnRlciA9IHJpbmdzLCBlbGVtO1xuICAgICAgICB3aGlsZSAoZWxlbSA9XG4gICAgICAgICAgICAkKC9eKFxcKCkvKSB8fFxuICAgICAgICAgICAgJCgvXihcXCkpLykgfHxcbiAgICAgICAgICAgICQoL14oXFwsKS8pIHx8XG4gICAgICAgICAgICAkKC9eWy0rXT8oWzAtOV0qXFwuWzAtOV0rfFswLTldKykvKSkge1xuICAgICAgICAgICAgaWYgKGVsZW0gPT09ICcoJykge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IFtdO1xuICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnB1c2gocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbSA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IFtdO1xuICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnB1c2gocG9pbnRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50ZXIucHVzaChwYXJzZUZsb2F0KGVsZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKGRlcHRoICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmluZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29vcmRzKCkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdLCBpdGVtLCBwdDtcbiAgICAgICAgd2hpbGUgKHB0ID1cbiAgICAgICAgICAgICQoL15bLStdPyhbMC05XSpcXC5bMC05XSt8WzAtOV0rKS8pIHx8XG4gICAgICAgICAgICAkKC9eKFxcLCkvKSkge1xuICAgICAgICAgICAgaWYgKHB0ID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaXRlbSA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtLnB1c2gocGFyc2VGbG9hdChwdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0Lmxlbmd0aCA/IGxpc3QgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50KCkge1xuICAgICAgICBpZiAoISQoL14ocG9pbnQpL2kpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIGlmICghJCgvXihcXCgpLykpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIGMgPSBjb29yZHMoKTtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgaWYgKCEkKC9eKFxcKSkvKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BvaW50JyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjWzBdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlwb2ludCgpIHtcbiAgICAgICAgaWYgKCEkKC9eKG11bHRpcG9pbnQpL2kpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHZhciBjID0gbXVsdGljb29yZHMoKTtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdNdWx0aVBvaW50JyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlsaW5lc3RyaW5nKCkge1xuICAgICAgICBpZiAoISQoL14obXVsdGlsaW5lc3RyaW5nKS9pKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICB2YXIgYyA9IG11bHRpY29vcmRzKCk7XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZXN0cmluZygpIHtcbiAgICAgICAgaWYgKCEkKC9eKGxpbmVzdHJpbmcpL2kpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIGlmICghJCgvXihcXCgpLykpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIGMgPSBjb29yZHMoKTtcbiAgICAgICAgaWYgKCEkKC9eKFxcKSkvKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uKCkge1xuICAgICAgICBpZiAoISQoL14ocG9seWdvbikvaSkpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBtdWx0aWNvb3JkcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlwb2x5Z29uKCkge1xuICAgICAgICBpZiAoISQoL14obXVsdGlwb2x5Z29uKS9pKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICAgICAgICBjb29yZGluYXRlczogbXVsdGljb29yZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlb21ldHJ5Y29sbGVjdGlvbigpIHtcbiAgICAgICAgdmFyIGdlb21ldHJpZXMgPSBbXSwgZ2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKCEkKC9eKGdlb21ldHJ5Y29sbGVjdGlvbikvaSkpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgd2hpdGUoKTtcblxuICAgICAgICBpZiAoISQoL14oXFwoKS8pKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaWxlIChnZW9tZXRyeSA9IHJvb3QoKSkge1xuICAgICAgICAgICAgZ2VvbWV0cmllcy5wdXNoKGdlb21ldHJ5KTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAkKC9eKFxcLCkvKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkKC9eKFxcKSkvKSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcbiAgICAgICAgICAgIGdlb21ldHJpZXM6IGdlb21ldHJpZXNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb290KCkge1xuICAgICAgICByZXR1cm4gcG9pbnQoKSB8fFxuICAgICAgICAgICAgbGluZXN0cmluZygpIHx8XG4gICAgICAgICAgICBwb2x5Z29uKCkgfHxcbiAgICAgICAgICAgIG11bHRpcG9pbnQoKSB8fFxuICAgICAgICAgICAgbXVsdGlsaW5lc3RyaW5nKCkgfHxcbiAgICAgICAgICAgIG11bHRpcG9seWdvbigpIHx8XG4gICAgICAgICAgICBnZW9tZXRyeWNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JzKHJvb3QoKSk7XG59O1xuXG5ERy5Xa3QuZ2VvSnNvbkxheWVyID0gZnVuY3Rpb24gKGRhdGEsIG9wdHMpIHtcbiAgICByZXR1cm4gREcuZ2VvSnNvbihERy5Xa3QudG9HZW9KU09OKGRhdGEpLCBvcHRzKTtcbn07XG5cbkRHLldrdC5fY29vcmRzVG9MYXRMbmdzID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIGlmIChERy5VdGlsLmlzQXJyYXkoY29vcmRzKSAmJiAhREcuVXRpbC5pc0FycmF5KGNvb3Jkc1swXSkpIHtcbiAgICAgICAgcmV0dXJuIFtERy5HZW9KU09OLmNvb3Jkc1RvTGF0TG5nKGNvb3JkcyldO1xuICAgIH1cblxuICAgIHJldHVybiBjb29yZHMubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIERHLldrdC5fY29vcmRzVG9MYXRMbmdzKGVsKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBjb29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5jb25jYXQoY29vcmQpO1xuICAgICAgICB9KTtcbn07XG5cbkRHLldrdC50b0xhdExuZ3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghREcuVXRpbC5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgY29vcmRzID0gREcuV2t0LnRvR2VvSlNPTihlbCkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgcmV0dXJuIERHLldrdC5fY29vcmRzVG9MYXRMbmdzKGNvb3Jkcyk7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uIChhcnIsIGNvb3JkKSB7XG4gICAgICAgIHJldHVybiBhcnIuY29uY2F0KGNvb3JkKTtcbiAgICB9KTtcbn07XG5cbkRHLldrdC50b1BvaW50cyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIERHLldrdC50b0dlb0pTT04oZGF0YSkuY29vcmRpbmF0ZXM7XG59O1xuXG5ERy5Xa3QucG9pbnRzVG9MYXRMbmdPbk1hcCA9IGZ1bmN0aW9uICh3a3QsIG1hcCkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gcGFyc2VQb2ludHMocG9pbnRzKSB7XG4gICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShwb2ludHMpICYmIEFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSkgP1xuICAgICAgICAgICAgcG9pbnRzLm1hcChwYXJzZVBvaW50cykgOlxuICAgICAgICAgICAgbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnRzKTtcbiAgICB9KShERy5Xa3QudG9Qb2ludHMod2t0KSk7XG59O1xuIiwiREcuUHJvamVjdERldGVjdG9yID0gREcuSGFuZGxlci5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG1hcCkgeyAvLyAoT2JqZWN0KVxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuX29zbVZpZXdwb3J0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Byb2plY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2xvYWRQcm9qZWN0TGlzdCgpO1xuICAgIH0sXG5cbiAgICBhZGRIb29rczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX21hcC5vbignbW92ZScsIHRoaXMuX3Byb2plY3RXYXRjaCwgdGhpcyk7XG4gICAgfSxcblxuICAgIHJlbW92ZUhvb2tzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbWFwLm9mZignbW92ZScsIHRoaXMuX3Byb2plY3RXYXRjaCwgdGhpcyk7XG4gICAgfSxcblxuICAgIGdldFByb2plY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Byb2plY3QpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgcmV0dXJuIERHLlV0aWwuZXh0ZW5kKHt9LCB0aGlzLl9wcm9qZWN0KTtcbiAgICB9LFxuXG4gICAgZ2V0UHJvamVjdHNMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RMaXN0LnNsaWNlKDApO1xuICAgIH0sXG5cbiAgICBpc1Byb2plY3RIZXJlOiBmdW5jdGlvbihjb29yZHMsIHByb2plY3QsIGNoZWNrTWV0aG9kKSB7XG4gICAgICAgIGlmICghY29vcmRzKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgICAgaWYgKCEoY29vcmRzIGluc3RhbmNlb2YgREcuTGF0TG5nKSAmJiAhKGNvb3JkcyBpbnN0YW5jZW9mIERHLkxhdExuZ0JvdW5kcykpIHtcbiAgICAgICAgICAgIGNvb3JkcyA9IERHLmxhdExuZyhjb29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29vcmRzID0gKGNvb3JkcyBpbnN0YW5jZW9mIERHLkxhdExuZ0JvdW5kcykgP1xuICAgICAgICAgICAgREcubGF0TG5nQm91bmRzKGNvb3Jkcy5nZXRTb3V0aFdlc3QoKS53cmFwKCksIGNvb3Jkcy5nZXROb3J0aEVhc3QoKS53cmFwKCkpIDogY29vcmRzLndyYXAoKTtcblxuICAgICAgICBjaGVja01ldGhvZCA9IGNoZWNrTWV0aG9kIHx8ICgoY29vcmRzIGluc3RhbmNlb2YgREcuTGF0TG5nQm91bmRzKSA/ICAnaW50ZXJzZWN0cycgOiAnY29udGFpbnMnKTtcblxuICAgICAgICB2YXIgbWV0aG9kID0gY2hlY2tNZXRob2QgPT0gJ2ludGVyc2VjdHMnID8gdGhpcy5fdGVzdFByb2plY3RJbnRlcnNlY3RzIDogdGhpcy5fdGVzdFByb2plY3RDb250YWlucztcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kLmJpbmQodGhpcywgY29vcmRzKTtcblxuICAgICAgICBpZiAocHJvamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZChwcm9qZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0TGlzdC5maWx0ZXIobWV0aG9kKVswXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcHJvamVjdFdhdGNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX29zbVZpZXdwb3J0ID09PSAodGhpcy5fcHJvamVjdCAmJiB0aGlzLl9jZW50ZXJJblByb2plY3QodGhpcy5fcHJvamVjdCwgJ2NvbnRhaW5zJykpKSB7XG4gICAgICAgICAgICB0aGlzLl9vc21WaWV3cG9ydCA9ICF0aGlzLl9vc21WaWV3cG9ydDtcbiAgICAgICAgICAgIHRoaXMuX21hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuX3VwZGF0ZShudWxsLCB0aGlzLl9vc21WaWV3cG9ydCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcHJvamVjdCAmJiB0aGlzLl96b29tSW5Qcm9qZWN0KHRoaXMuX3Byb2plY3QpICYmIHRoaXMuX2NlbnRlckluUHJvamVjdCh0aGlzLl9wcm9qZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2VhcmNoUHJvamVjdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9wcm9qZWN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3NtVmlld3BvcnQgPT09ICh0aGlzLl9wcm9qZWN0ICYmIHRoaXMuX2NlbnRlckluUHJvamVjdCh0aGlzLl9wcm9qZWN0LCAnY29udGFpbnMnKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vc21WaWV3cG9ydCA9ICF0aGlzLl9vc21WaWV3cG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuX3VwZGF0ZShudWxsLCB0aGlzLl9vc21WaWV3cG9ydCwgdGhpcy5fcHJvamVjdC5jb3VudHJ5X2NvZGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jaGVja1Byb2plY3REYXRhOiBmdW5jdGlvbihwcm9qZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9qZWN0ICYmXG4gICAgICAgICAgICAgICAgcHJvamVjdC5ib3VuZHMgJiZcbiAgICAgICAgICAgICAgICBjaGVjayhwcm9qZWN0LmNvZGUpICYmXG4gICAgICAgICAgICAgICAgY2hlY2socHJvamVjdC5kb21haW4pICYmXG4gICAgICAgICAgICAgICAgY2hlY2socHJvamVjdC5jb3VudHJ5X2NvZGUpICYmXG4gICAgICAgICAgICAgICAgcHJvamVjdC56b29tX2xldmVsICYmXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrKHByb2plY3Quem9vbV9sZXZlbC5taW4pICYmXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrKHByb2plY3Quem9vbV9sZXZlbC5tYXgpICYmXG4gICAgICAgICAgICAgICAgcHJvamVjdC50aW1lX3pvbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hlY2socHJvamVjdC50aW1lX3pvbmUub2Zmc2V0KTtcbiAgICB9LFxuXG4gICAgX2xvYWRQcm9qZWN0TGlzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIERHLmZhbGxiYWNrUHJvamVjdHNMaXN0ID0gREcuZmFsbGJhY2tQcm9qZWN0c0xpc3QgfHwgW107XG5cbiAgICAgICAgaWYgKCFERy5wcm9qZWN0c0xpc3QpIHtcbiAgICAgICAgICAgIERHLnByb2plY3RzTGlzdCA9IERHLmZhbGxiYWNrUHJvamVjdHNMaXN0O1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBERy5mYWxsYmFja1Byb2plY3RzTGlzdDtcblxuICAgICAgICB0aGlzLl9wcm9qZWN0TGlzdCA9IERHLnByb2plY3RzTGlzdFxuICAgICAgICAgICAgLmZpbHRlcih0aGlzLl9jaGVja1Byb2plY3REYXRhKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kID0gREcuV2t0LnRvR2VvSlNPTihwcm9qZWN0LmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgdmFyIGxhdExuZ0JvdW5kcyA9IERHLmdlb0pTT04oYm91bmQpLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0UG9zID0gcHJvamVjdC5kZWZhdWx0X3BvcyA/IERHLmxhdExuZyhwcm9qZWN0LmRlZmF1bHRfcG9zLmxhdCwgcHJvamVjdC5kZWZhdWx0X3Bvcy5sb24pIDogbnVsbDtcblxuXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHByb2plY3QuaWQsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHByb2plY3QuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWluWm9vbTogcHJvamVjdC56b29tX2xldmVsLm1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4Wm9vbTogcHJvamVjdC56b29tX2xldmVsLm1heCxcbiAgICAgICAgICAgICAgICAgICAgdGltZU9mZnNldDogcHJvamVjdC50aW1lX3pvbmUub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBib3VuZDogYm91bmQsXG4gICAgICAgICAgICAgICAgICAgIGxhdExuZ0JvdW5kczogbGF0TG5nQm91bmRzLFxuICAgICAgICAgICAgICAgICAgICB0cmFmZmljOiAhIXByb2plY3QuZmxhZ3MudHJhZmZpYyxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0OiAhIXByb2plY3QuZmxhZ3MucHVibGljX3RyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICAgICAgcm9hZHM6ICEhcHJvamVjdC5mbGFncy5yb2FkX25ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgIGNvdW50cnlfY29kZTogcHJvamVjdC5jb3VudHJ5X2NvZGUsXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbjogcHJvamVjdC5kb21haW4sXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQb3M6IGRlZmF1bHRQb3NcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3NlYXJjaFByb2plY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyDQktC90LDRh9Cw0LvQtSDQvtGC0YHQtdC40LLQsNC10Lwg0YDQtdCz0LjQvtC90Ysg0L/QviDQt9GD0LzRg1xuICAgICAgICB2YXIgZmlsdGVyZWRCeVpvb20gPSB0aGlzLl9wcm9qZWN0TGlzdC5maWx0ZXIodGhpcy5fem9vbUluUHJvamVjdCwgdGhpcyk7XG5cbiAgICAgICAgLy8g0J3QsNGF0L7QtNC40Lwg0L/RgNC+0LXQutGCINCyINCz0YDQsNC90LjRhtGLINC60L7RgtC+0YDQvtCz0L4g0L/QvtC/0LDQtNCw0LXRgiDRhtC10L3RgtGAINC60LDRgNGC0YtcbiAgICAgICAgdmFyIGZvdW5kUHJvamVjdHMgPSBmaWx0ZXJlZEJ5Wm9vbS5maWx0ZXIodGhpcy5fY2VudGVySW5Qcm9qZWN0LCB0aGlzKTtcblxuICAgICAgICAvLyDQldGB0LvQuCDRgtCw0LrQvtC5INC/0YDQvtC10LrRgiDQvdC1INC90LDQudC00LXQvSwg0YLQviDQuNGJ0LXQvCDQv9GA0L7QtdC60YLRiyDQsdCw0YPQvdC0INCx0L7QutGB0Ysg0LrQvtGC0L7RgNGL0YUg0L/QtdGA0LXRgdC10LrQsNGO0YLRgdGPINGBINGN0LrRgNCw0L3QvtC8XG4gICAgICAgIGlmIChmb3VuZFByb2plY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIG1hcEJvdW5kcyA9IHRoaXMuX21hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIGZvdW5kUHJvamVjdHMgPSBmaWx0ZXJlZEJ5Wm9vbS5maWx0ZXIoREcuYmluZCh0aGlzLl90ZXN0UHJvamVjdEludGVyc2VjdHMsIHRoaXMsIG1hcEJvdW5kcykpO1xuXG4gICAgICAgICAgICBpZiAoZm91bmRQcm9qZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcENlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmVhcmVhc3RQcm9qZWN0ID0gZm91bmRQcm9qZWN0c1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGZvdW5kUHJvamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm9qZWN0ID0gZm91bmRQcm9qZWN0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9qZWN0LmRlZmF1bHRQb3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcENlbnRlci5kaXN0YW5jZVRvKG5lYXJlYXN0UHJvamVjdC5kZWZhdWx0UG9zKSA+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBDZW50ZXIuZGlzdGFuY2VUbyhjdXJyZW50UHJvamVjdC5kZWZhdWx0UG9zKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lYXJlYXN0UHJvamVjdCA9IGN1cnJlbnRQcm9qZWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvdW5kUHJvamVjdHMgPSBbbmVhcmVhc3RQcm9qZWN0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdQcm9qZWN0ID0gZm91bmRQcm9qZWN0c1swXSB8fCBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLl9wcm9qZWN0ID09PSBuZXdQcm9qZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Byb2plY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3QgPSBudWxsO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9tYXAuZmlyZSgncHJvamVjdGxlYXZlJyk7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdQcm9qZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9qZWN0ID0gbmV3UHJvamVjdDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fbWFwLmZpcmUoJ3Byb2plY3RjaGFuZ2UnLCB7Z2V0UHJvamVjdDogc2VsZi5nZXRQcm9qZWN0LmJpbmQoc2VsZil9KTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF90ZXN0UHJvamVjdEludGVyc2VjdHM6IGZ1bmN0aW9uKGJvdW5kcywgcHJvamVjdCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdC5sYXRMbmdCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpO1xuICAgIH0sXG5cbiAgICBfdGVzdFByb2plY3RDb250YWluczogZnVuY3Rpb24obGF0bG5nLCBwcm9qZWN0KSB7XG4gICAgICAgIHJldHVybiBERy5Qb2x5VXRpbC5pbnNpZGUoW2xhdGxuZy5sbmcsIGxhdGxuZy5sYXRdLCBwcm9qZWN0LmJvdW5kKTtcbiAgICB9LFxuXG4gICAgX2NlbnRlckluUHJvamVjdDogZnVuY3Rpb24ocHJvamVjdCwgY2hlY2tNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNQcm9qZWN0SGVyZSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHByb2plY3QsIGNoZWNrTWV0aG9kKTtcbiAgICB9LFxuXG4gICAgX3pvb21JblByb2plY3Q6IGZ1bmN0aW9uKHByb2plY3QpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9tYXAuZ2V0Wm9vbSgpID49IHByb2plY3QubWluWm9vbSk7XG4gICAgfVxufSk7XG5cbkRHLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIHByb2plY3REZXRlY3RvcjogdHJ1ZVxufSk7XG5cbkRHLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdwcm9qZWN0RGV0ZWN0b3InLCBERy5Qcm9qZWN0RGV0ZWN0b3IpO1xuIiwiLypcbiAqIFV0aWxpdHkgZnVuY3Rpb25zXG4gKi9cblxuREcuTWV0cmljID0gZnVuY3Rpb24oKSB7fTtcblxuLypcbiAqIERHLk1ldHJpYy5TZWdtZW50cyBjbGFzcyBjYW4gY2FsY3VsYXRlIHRvdGFsIHB1c2hlZCBzZWdtZW50cyBsZW5ndGggYW5kIHVzZWQgdG8gc2hvcnRjdXRcbiAqICdnZXQgU29tZXRoaW5nIGJ5IHByb3ZpZGVkIExlbmd0aCcgY2FsY3VsYXRpb25zIChzZWdtZW50J3MgSW5kZXgsIHNlZ21lbnQncyBMZW5ndGgsIGV0Yy4uLilcbiAqL1xuREcuTWV0cmljLlNlZ21lbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxuREcuTWV0cmljLlNlZ21lbnRzLnByb3RvdHlwZSA9IHtcbiAgICBwdXNoOiBmdW5jdGlvbihsZW4pIHtcbiAgICAgICAgdGhpc1t0aGlzLmxlbmd0aF0gPSB0aGlzLmxlbmd0aCA+IDAgPyB0aGlzW3RoaXMubGVuZ3RoIC0gMV0gKyBsZW4gOiBsZW47XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgfSxcblxuICAgIGdldFJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VnbWVudHMgPSBuZXcgREcuTWV0cmljLlNlZ21lbnRzKCk7XG4gICAgICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIGlmIChpIDwgMCkgeyByZXR1cm4gc2VnbWVudHM7IH1cblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHRoaXNbaSArIDFdIC0gdGhpc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VnbWVudHMucHVzaCh0aGlzWzBdKTtcbiAgICB9LFxuXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKGxlbikge1xuICAgICAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgICAgICBpZiAoaSA8IDApIHsgcmV0dXJuIGk7IH1cblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA8PSBsZW4pIHsgYnJlYWs7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICB9LFxuXG4gICAgZ2V0U2VnUmF0aW86IGZ1bmN0aW9uKGxlbikge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0SW5kZXgobGVuKTtcbiAgICAgICAgdmFyIHN1YiA9IGkgPiAwID8gdGhpc1tpIC0gMV0gOiAwO1xuXG4gICAgICAgIHJldHVybiAobGVuIC0gc3ViKSAvICh0aGlzW2ldIC0gc3ViKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VnTGVuZ3RoOiBmdW5jdGlvbihsZW4pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmdldEluZGV4KGxlbik7XG4gICAgICAgIHZhciBzdWIgPSBpID4gMCA/IHRoaXNbaSAtIDFdIDogMDtcblxuICAgICAgICByZXR1cm4gbGVuIC0gc3ViO1xuICAgIH1cbn07XG4iLCIvKlxuICogREcuVmVydGV4VHJhbnNmb3JtIGlzIGEgY2xhc3NpYyAyRCBtYXRyaXggdHJhbnNmb3JtYXRpb24gY2xhc3NcbiAqXG4gKiBQcm90b3R5cGUgbWV0aG9kcyBjYW4gc2NhbGUvcm90YXRlL3RyYW5zbGF0ZSB2ZXJ0aWNlc1xuICpcbiAqIFN0YXRpYyBtZXRob2RzIGRvIHRoZSBzYW1lIGJ1dCByZXR1cm4gc2ltcGxlIGFycmF5IGluc3RhbmNlcyB3aXRoIGF0dGFjaGVkXG4gKiAuY2xvbmUoKSBtZXRob2Qgd2hpY2ggY2FuIHJlY29uc3RydWN0IGZ1bGwgREcuVmVydGV4VHJhbnNmb3JtIG9iamVjdFxuICovXG5cbkRHLlZlcnRleFRyYW5zZm9ybSA9IERHLkNsYXNzLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICAgICAgdGhpcy5fdmVydGljZXMgPSB2ZXJ0aWNlcztcblxuICAgICAgICB0aGlzLl9zY2FsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FuZ2xlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdHJhbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBudWxsO1xuXG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IHRoaXMuX3ZlcnRpY2VzLm1hcChmdW5jdGlvbih2ZXJ0ZXgpIHsgcmV0dXJuIHZlcnRleC5jbG9uZSgpOyB9KTtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5jbG9uZSA9IERHLlZlcnRleFRyYW5zZm9ybS5jbG9uZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcy5tYXAoZnVuY3Rpb24odmVydGV4KSB7IHJldHVybiB2ZXJ0ZXguY2xvbmUoKTsgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFNjYWxlOiBmdW5jdGlvbihzY2FsZSkge1xuICAgICAgICB0aGlzLl9zY2FsZSA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0U2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gICAgfSxcblxuICAgIHNldEFuZ2xlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICB0aGlzLl9hbmdsZSA9IGFuZ2xlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0QW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5nbGU7XG4gICAgfSxcblxuICAgIHNldFRyYW5zbGF0aW9uOiBmdW5jdGlvbih0cmFucykge1xuICAgICAgICB0aGlzLl90cmFucyA9IHRyYW5zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0VHJhbnNsYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnM7XG4gICAgfSxcblxuICAgIHNldE1hdHJpeDogZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldE1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRyaXg7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzY2FsZSkge1xuICAgICAgICB2YXIgdiA9IHRoaXMudmVydGljZXM7XG4gICAgICAgIHZhciBpID0gdi5sZW5ndGg7XG5cbiAgICAgICAgc2NhbGUgPSBzY2FsZSB8fCB0aGlzLl9zY2FsZSB8fCAxO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB2W2ldLnggKj0gc2NhbGU7XG4gICAgICAgICAgICB2W2ldLnkgKj0gc2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5TY2FsZTogZnVuY3Rpb24oc2NhbGUpIHtcbiAgICAgICAgc2NhbGUgPSBzY2FsZSB8fCB0aGlzLl9zY2FsZSB8fCAxOyAgICAgIC8vICBBbHNvIHNhZmVndWFyZCBhZ2FpbnN0IHplcm8gc2NhbGVcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUoMSAvIHNjYWxlKTtcbiAgICB9LFxuXG4gICAgcm90YXRlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gYW5nbGUgPyBhbmdsZS5jb3MgOiAodGhpcy5fYW5nbGUgPyB0aGlzLl9hbmdsZS5jb3MgOiAxKTtcbiAgICAgICAgdmFyIHNpbiA9IGFuZ2xlID8gYW5nbGUuc2luIDogKHRoaXMuX2FuZ2xlID8gdGhpcy5fYW5nbGUuc2luIDogMCk7XG4gICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgdmFyIGkgPSB2Lmxlbmd0aDtcbiAgICAgICAgdmFyIHgsIHk7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgeCA9IHZbaV0ueDtcbiAgICAgICAgICAgIHkgPSB2W2ldLnk7XG4gICAgICAgICAgICB2W2ldLnggPSB4ICogY29zIC0geSAqIHNpbjtcbiAgICAgICAgICAgIHZbaV0ueSA9IHggKiBzaW4gKyB5ICogY29zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVuUm90YXRlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gYW5nbGUgPyBhbmdsZS5jb3MgOiAodGhpcy5fYW5nbGUgPyB0aGlzLl9hbmdsZS5jb3MgOiAxKTtcbiAgICAgICAgdmFyIHNpbiA9IGFuZ2xlID8gYW5nbGUuc2luIDogKHRoaXMuX2FuZ2xlID8gdGhpcy5fYW5nbGUuc2luIDogMCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlKHtjb3M6IGNvcywgc2luOiAtc2lufSk7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHJhbnMpIHtcbiAgICAgICAgdmFyIGR4ID0gdHJhbnMgPyB0cmFucy54IDogKHRoaXMuX3RyYW5zID8gdGhpcy5fdHJhbnMueCA6IDApO1xuICAgICAgICB2YXIgZHkgPSB0cmFucyA/IHRyYW5zLnkgOiAodGhpcy5fdHJhbnMgPyB0aGlzLl90cmFucy55IDogMCk7XG4gICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgdmFyIGkgPSB2Lmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB2W2ldLnggKz0gZHg7XG4gICAgICAgICAgICB2W2ldLnkgKz0gZHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5UcmFuc2xhdGU6IGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgIHZhciBkeCA9IHRyYW5zID8gdHJhbnMueCA6ICh0aGlzLl90cmFucyA/IHRoaXMuX3RyYW5zLnggOiAwKTtcbiAgICAgICAgdmFyIGR5ID0gdHJhbnMgPyB0cmFucy55IDogKHRoaXMuX3RyYW5zID8gdGhpcy5fdHJhbnMueSA6IDApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZSh7eDogLWR4LCB5OiAtZHl9KTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgdmFyIGEsIGIsIGMsIGQsIGR4LCBkeTtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICB2YXIgaSA9IHYubGVuZ3RoO1xuICAgICAgICB2YXIgeCwgeTtcblxuICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICBhID0gbWF0cml4WzBdOyBiID0gbWF0cml4WzFdOyBkeCA9IG1hdHJpeFsyXTtcbiAgICAgICAgICAgIGMgPSBtYXRyaXhbM107IGQgPSBtYXRyaXhbNF07IGR5ID0gbWF0cml4WzVdO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX21hdHJpeCkge1xuICAgICAgICAgICAgYSA9IHRoaXMuX21hdHJpeFswXTsgYiA9IHRoaXMuX21hdHJpeFsxXTsgZHggPSB0aGlzLl9tYXRyaXhbMl07XG4gICAgICAgICAgICBjID0gdGhpcy5fbWF0cml4WzNdOyBkID0gdGhpcy5fbWF0cml4WzRdOyBkeSA9IHRoaXMuX21hdHJpeFs1XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGEgPSAxOyBiID0gMDsgZHggPSAwO1xuICAgICAgICAgICAgYyA9IDA7IGQgPSAxOyBkeSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB4ID0gdltpXS54O1xuICAgICAgICAgICAgeSA9IHZbaV0ueTtcbiAgICAgICAgICAgIHZbaV0ueCA9IHggKiBhICsgeSAqIGIgKyBkeDtcbiAgICAgICAgICAgIHZbaV0ueSA9IHggKiBjICsgeSAqIGQgKyBkeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbih2dCwgc2NhbGUpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdnQudmVydGljZXM7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgeCwgeTtcblxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZSB8fCAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeCA9IHZbaV0ueCAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHkgPSB2W2ldLnkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgREcuUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNsb25lID0gREcuVmVydGV4VHJhbnNmb3JtLmNsb25lO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHVuU2NhbGU6IGZ1bmN0aW9uKHZ0LCBzY2FsZSkge1xuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZSB8fCAxOyAgICAgICAgIC8vICBBbHNvIHNhZmVndWFyZCBhZ2FpbnN0IHplcm8gc2NhbGVcbiAgICAgICAgICAgIHJldHVybiBERy5WZXJ0ZXhUcmFuc2Zvcm0uc2NhbGUodnQsIDEgLyBzY2FsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcm90YXRlOiBmdW5jdGlvbih2dCwgYW5nbGUpIHtcbiAgICAgICAgICAgIHZhciBjb3MgPSBhbmdsZSA/IGFuZ2xlLmNvcyA6IDE7XG4gICAgICAgICAgICB2YXIgc2luID0gYW5nbGUgPyBhbmdsZS5zaW4gOiAwO1xuICAgICAgICAgICAgdmFyIHYgPSB2dC52ZXJ0aWNlcztcbiAgICAgICAgICAgIHZhciB4LCB5LCByeCwgcnk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJ4ID0gdltpXS54O1xuICAgICAgICAgICAgICAgIHJ5ID0gdltpXS55O1xuICAgICAgICAgICAgICAgIHggPSByeCAqIGNvcyAtIHJ5ICogc2luO1xuICAgICAgICAgICAgICAgIHkgPSByeCAqIHNpbiArIHJ5ICogY29zO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBERy5Qb2ludCh4LCB5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2xvbmUgPSBERy5WZXJ0ZXhUcmFuc2Zvcm0uY2xvbmU7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5Sb3RhdGU6IGZ1bmN0aW9uKHZ0LCBhbmdsZSkge1xuICAgICAgICAgICAgdmFyIGNvcyA9IGFuZ2xlID8gYW5nbGUuY29zIDogMTtcbiAgICAgICAgICAgIHZhciBzaW4gPSBhbmdsZSA/IGFuZ2xlLnNpbiA6IDA7XG5cbiAgICAgICAgICAgIHJldHVybiBERy5WZXJ0ZXhUcmFuc2Zvcm0ucm90YXRlKHZ0LCB7Y29zOiBjb3MsIHNpbjogLXNpbn0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odnQsIHRyYW5zKSB7XG4gICAgICAgICAgICB2YXIgZHggPSB0cmFucyA/IHRyYW5zLnggOiAwO1xuICAgICAgICAgICAgdmFyIGR5ID0gdHJhbnMgPyB0cmFucy55IDogMDtcbiAgICAgICAgICAgIHZhciB2ID0gdnQudmVydGljZXM7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgeCwgeTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeCA9IHZbaV0ueCArIGR4O1xuICAgICAgICAgICAgICAgIHkgPSB2W2ldLnkgKyBkeTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgREcuUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNsb25lID0gREcuVmVydGV4VHJhbnNmb3JtLmNsb25lO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHVuVHJhbnNsYXRlOiBmdW5jdGlvbih2dCwgdHJhbnMpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHRyYW5zID8gdHJhbnMueCA6IDA7XG4gICAgICAgICAgICB2YXIgZHkgPSB0cmFucyA/IHRyYW5zLnkgOiAwO1xuXG4gICAgICAgICAgICByZXR1cm4gREcuVmVydGV4VHJhbnNmb3JtLnRyYW5zbGF0ZSh2dCwge3g6IC1keCwgeTogLWR5fSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gICd0aGlzJyBpcyBhbiBhcnJheVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBERy5WZXJ0ZXhUcmFuc2Zvcm0odGhpcykuc2F2ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExlbmd0aDogZnVuY3Rpb24odmVjMSwgdmVjMikge1xuICAgICAgICAgICAgdmFyIGR4LCBkeTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ZWMxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vICAndmVjMScgYW5kICd2ZWMyJyBhcmUgYWJzb2x1dGUgY29vcmRpbmF0ZXMgb2YgdmVjdG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh2ZWMxICogdmVjMSArIHZlYzIgKiB2ZWMyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gICd2ZWMxJyBhbmQgJ3ZlYzInIGFyZSB2ZWN0b3Igb2JqZWN0c1xuICAgICAgICAgICAgICAgIGR4ID0gdmVjMi54IC0gdmVjMS54O1xuICAgICAgICAgICAgICAgIGR5ID0gdmVjMi55IC0gdmVjMS55O1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNjYWxlZDogZnVuY3Rpb24odmVjMSwgdmVjMiwgc2NhbGUpIHtcbiAgICAgICAgICAgIHZhciBkeCwgZHk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmVjMSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAvLyAgJ3ZlYzEnIGFuZCAndmVjMicgYXJlIGFic29sdXRlIGNvb3JkaW5hdGVzIG9mIHZlY3RvclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgREcuUG9pbnQodmVjMSAqIHNjYWxlLCB2ZWMyICogc2NhbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAgJ3ZlYzEnIGFuZCAndmVjMicgYXJlIHZlY3RvciBvYmplY3RzXG4gICAgICAgICAgICAgICAgZHggPSAodmVjMi54IC0gdmVjMS54KSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIGR5ID0gKHZlYzIueSAtIHZlYzEueSkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERHLlBvaW50KHZlYzEueCArIGR4LCB2ZWMxLnkgKyBkeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QW5nbGU6IGZ1bmN0aW9uKHZlYzEsIHZlYzIsIG9yaWdpbikge1xuICAgICAgICAgICAgdmFyIGwsIHNwLCB4MSwgeTEsIHgyLCB5MjtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ZWMxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vICAndmVjMScgYW5kICd2ZWMyJyBhcmUgYWJzb2x1dGUgY29vcmRpbmF0ZXMgb2YgdmVjdG9yXG4gICAgICAgICAgICAgICAgbCA9IE1hdGguc3FydCh2ZWMxICogdmVjMSArIHZlYzIgKiB2ZWMyKTtcbiAgICAgICAgICAgICAgICBpZiAobCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb3M6IHZlYzEgLyBsLCBzaW46IHZlYzIgLyBsfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvczogMSwgc2luOiAwfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICAndmVjMScgYW5kICd2ZWMyJyBhcmUgdmVjdG9yIG9iamVjdHNcbiAgICAgICAgICAgICAgICB4MSA9IHZlYzEueDsgeTEgPSB2ZWMxLnk7XG4gICAgICAgICAgICAgICAgeDIgPSB2ZWMyLng7IHkyID0gdmVjMi55O1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgeDEgLT0gb3JpZ2luLng7IHkxIC09IG9yaWdpbi55O1xuICAgICAgICAgICAgICAgICAgICB4MiAtPSBvcmlnaW4ueDsgeTIgLT0gb3JpZ2luLnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwID0gTWF0aC5zcXJ0KHgxICogeDEgKyB5MSAqIHkxKSAqIE1hdGguc3FydCh4MiAqIHgyICsgeTIgKiB5Mik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29zOiAoeDEgKiB4MiArIHkxICogeTIpIC8gc3AsXG4gICAgICAgICAgICAgICAgICAgIHNpbjogKHgxICogeTIgLSB4MiAqIHkxKSAvIHNwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBbmdsZXNTdW06IGZ1bmN0aW9uKGFuZ2xlMSwgYW5nbGUyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvczogYW5nbGUxLmNvcyAqIGFuZ2xlMi5jb3MgLSBhbmdsZTEuc2luICogYW5nbGUyLnNpbixcbiAgICAgICAgICAgICAgICBzaW46IGFuZ2xlMS5zaW4gKiBhbmdsZTIuY29zICsgYW5nbGUxLmNvcyAqIGFuZ2xlMi5zaW5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QW5nbGVzRGlmOiBmdW5jdGlvbihhbmdsZTEsIGFuZ2xlMikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb3M6IGFuZ2xlMS5jb3MgKiBhbmdsZTIuY29zICsgYW5nbGUxLnNpbiAqIGFuZ2xlMi5zaW4sXG4gICAgICAgICAgICAgICAgc2luOiBhbmdsZTEuc2luICogYW5nbGUyLmNvcyAtIGFuZ2xlMS5jb3MgKiBhbmdsZTIuc2luXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIvKlxuICogREcuQXJyb3dQYXRoVHJhbnNmb3JtIGNsYXNzIGlzIGEgY29yZSBvZiBhcnJvdydzIGJvZHkgY2FsY3VsYXRpb25zXG4gKlxuICogR2VuZXJhbCBpZGVhcyBhcmU6XG4gKiAgICAgIFdlIGNvbnN0cnVjdCBhcnJvdyBib2R5IHdpdGggc3Ryb2tlIHBvaW50cyBtYWtpbmcgYXJjcyBvbiBvdXRlciBwYXRoIHR1cm5zXG4gKiAgICAgIFByb2Nlc3NpbmcgaXMgZG9uZSBzZWdtZW50IGJ5IHNlZ21lbnQgYXJvdW5kIHswLCAwfSB2aXJ0dWFsIHBvaW50XG4gKiAgICAgICAgICBhbmQgcmVzdWx0aW5nICdwYXRoJyBmaW5hbGx5IHJvdGF0ZWQgdG8gaXQncyBvcmlnaW5hbCBtYXAncyBhbmdsZSAoLmZ1bGxBbmdsZSlcbiAqICAgICAgU3Vic2V0IG9mIHRoaXMgdmVydGljZXMgbGF0ZWx5IHVzZWQgaW4gLnN1YlBhdGgoKSBjYWxjdWxhdGlvbnMgd2hpY2ggY2FuIGJlIHVzZWRcbiAqICAgICAgICAgIGluIGFuaW1hdGlvbnMgZm9yIGV4LlxuICpcbiAqICBGaW5hbCB0cmFuc2xhdGlvbiAoc2VlIERHLkVudHJhbmNlLkFycm93KSBtb3ZlcyBhcnJvdyBvYmplY3RzIHRvIHRoZWlyIG9yaWdpbmFsIHBvc2l0aW9uc1xuICovXG5cbkRHLkFycm93UGF0aFRyYW5zZm9ybSA9IERHLlZlcnRleFRyYW5zZm9ybS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgLy8gICdwYXRoLm9mZnNldCcgaXMgaW5pdGlhbCBwb2ludHMgb2Zmc2V0ICgteCAvICt4KSB0byBjb21wZW5zYXRlIGFycm93IHRpcCBsZW5ndGhcblxuICAgICAgICAvLyAgU2tpcCBzdXBlciBpbml0aWFsaXphdGlvbiBhcyB3ZSBuZWVkIG9ubHkgc3Vic2V0IG9mIERHLlZlcnRleFRyYW5zZm9ybSBwb3dlclxuICAgICAgICB0aGlzLl9sZW5ndGhzID0gbmV3IERHLk1ldHJpYy5TZWdtZW50cygpO1xuICAgICAgICB0aGlzLl92ZXJ0aWNlcyA9IFtbXSwgW11dO1xuICAgICAgICB0aGlzLl9kcmF3aW5ncyA9IFtbXSwgW11dO1xuICAgICAgICAvLyAgdGhpcy5fYXJjcyA9IFtdOyAgICAvLyAgaW5pdGlhbGl6ZWQgaW4gX3NldFBhdGgoKVxuXG4gICAgICAgIHRoaXMuX3NldFBhdGgocGF0aCk7XG4gICAgICAgIHRoaXMuc3ViUGF0aCgxKTtcbiAgICB9LFxuXG4gICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YlBhdGgoMSk7XG4gICAgfSxcblxuICAgIHNhdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpczsgICAgLy8gIE5vT3BcbiAgICB9LFxuXG4gICAgLy8gIE1ldGhvZCBjb25zdHJ1Y3RzIG5ldyBwYXRoIHBvaW50cyB3aXRoIHNvbWUgZGlzcGxhY2VtZW50IGZyb20gb3JpZ2luYWwgJ3BhdGgnXG4gICAgLy8gIE91dGVyIGNvcm5lcnMgd2lsbCBiZSBzbW9vdGhlZCBieSBhcmNzIChjdWJpYyBCw6l6aWVyIGN1cnZlcylcbiAgICBfc2V0UGF0aDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gREcuQXJyb3dQYXRoVHJhbnNmb3JtLnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5fdmVydGljZXM7XG4gICAgICAgIHZhciBkcmF3aW5ncyA9IHRoaXMuX2RyYXdpbmdzO1xuICAgICAgICB2YXIgUG9pbnQgPSBERy5Qb2ludDtcbiAgICAgICAgdmFyIHdpZHRoID0gcGF0aC53aWR0aDtcbiAgICAgICAgdmFyIGFyY3MgPSBbW10sIFtdLCBbXV07XG4gICAgICAgIHZhciBsZW5ndGhzID0gW107XG5cbiAgICAgICAgdmFyIGksIHgsXG4gICAgICAgICAgICBheCwgYngsIGN4LFxuICAgICAgICAgICAgYW5nbGVzLCBhbmdsZTtcblxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBhdGgudmVydGljZXMpOyAgIC8vICBleHBlY3QgLnBvcCgpIGluIGZpbmFsIHRyYW5zZm9ybVxuICAgICAgICB2ZXJ0aWNlc1swXS5wdXNoKG5ldyBERy5Qb2ludChwYXRoLm9mZnNldCwgK3dpZHRoKSk7XG4gICAgICAgIHZlcnRpY2VzWzFdLnB1c2gobmV3IERHLlBvaW50KHBhdGgub2Zmc2V0LCAtd2lkdGgpKTtcbiAgICAgICAgYW5nbGVzID0gREcuQXJyb3dQYXRoVHJhbnNmb3JtLmdldEFuZ2xlcyhwYXRoKTtcblxuICAgICAgICBjeCA9IC1wYXRoLm9mZnNldDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFuZ2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeCA9IHBhdGgudmVydGljZXNbaSArIDFdLng7XG4gICAgICAgICAgICBheCA9IHdpZHRoICogYW5nbGVzW2ldLmNvdDtcblxuICAgICAgICAgICAgLy8gIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jY2lyY2xlc19jdWJpY1xuICAgICAgICAgICAgLy8gIGFjdHVhbCBlcXVhdGlvbiBpcyAoNC8zICogdGFuKM6xLzQpICogcmFkaXVzKVxuICAgICAgICAgICAgYnggPSBhbmdsZXNbaV0udGFuICogd2lkdGggKiA4IC8gMztcblxuICAgICAgICAgICAgLy8gIE5leHQgY29kZSBjYW4gYmUgY29tYmluZWQgYnkgLS8rIGludmVyc2lvbiBidXQgZm9yIHNpbXBsaWNpdHkgaXQgaXMgbGVmdCBhcyBpc1xuICAgICAgICAgICAgaWYgKGF4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzWzBdLnB1c2gobmV3IFBvaW50KHggKyBheCwgICAgICArd2lkdGgpKTtcbiAgICAgICAgICAgICAgICBkcmF3aW5nc1swXS5wdXNoKCdMJyk7XG5cbiAgICAgICAgICAgICAgICBhcmNzWzJdLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgYXJjc1sxXS5wdXNoKHZlcnRpY2VzWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbMV0ucHVzaChuZXcgUG9pbnQoeCArIGF4LCAgICAgIC13aWR0aCkpO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzWzFdLnB1c2gobmV3IFBvaW50KHggKyBheCAtIGJ4LCAtd2lkdGgpKTtcblxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSh2ZXJ0aWNlcywgYW5nbGVzW2ldLCB7eDogeCwgeTogMH0pO1xuXG4gICAgICAgICAgICAgICAgdmVydGljZXNbMV0ucHVzaChuZXcgUG9pbnQoMCAtIGF4ICsgYngsIC13aWR0aCkpO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzWzFdLnB1c2gobmV3IFBvaW50KDAgLSBheCwgICAgICAtd2lkdGgpKTtcbiAgICAgICAgICAgICAgICBkcmF3aW5nc1sxXS5wdXNoKCdMJywgJ0MnKTtcblxuICAgICAgICAgICAgICAgIGxlbmd0aHMucHVzaChNYXRoLmFicyh4ICsgYXgpIC0gY3gpOyBjeCA9ICtheDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbMV0ucHVzaChuZXcgUG9pbnQoeCAtIGF4LCAgICAgIC13aWR0aCkpO1xuICAgICAgICAgICAgICAgIGRyYXdpbmdzWzFdLnB1c2goJ0wnKTtcblxuICAgICAgICAgICAgICAgIGFyY3NbMl0ucHVzaCgwKTtcbiAgICAgICAgICAgICAgICBhcmNzWzBdLnB1c2godmVydGljZXNbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1swXS5wdXNoKG5ldyBQb2ludCh4IC0gYXgsICAgICAgK3dpZHRoKSk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbMF0ucHVzaChuZXcgUG9pbnQoeCAtIGF4ICsgYngsICt3aWR0aCkpO1xuXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKHZlcnRpY2VzLCBhbmdsZXNbaV0sIHt4OiB4LCB5OiAwfSk7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1swXS5wdXNoKG5ldyBQb2ludCgwICsgYXggLSBieCwgK3dpZHRoKSk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbMF0ucHVzaChuZXcgUG9pbnQoMCArIGF4LCAgICAgICt3aWR0aCkpO1xuICAgICAgICAgICAgICAgIGRyYXdpbmdzWzBdLnB1c2goJ0wnLCAnQycpO1xuXG4gICAgICAgICAgICAgICAgbGVuZ3Rocy5wdXNoKE1hdGguYWJzKHggLSBheCkgLSBjeCk7IGN4ID0gLWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gIEZpbmFsIHNlZ21lbnRzIGFuZCB0YWlsIGFyY1xuICAgICAgICBheCA9IHBhdGgudmVydGljZXNbaSArIDFdLng7XG4gICAgICAgIGJ4ID0gd2lkdGggKiA0IC8gMzsgLy8gdGFuKFBJLzQpID0gMVxuXG4gICAgICAgIHZlcnRpY2VzWzBdLnB1c2gobmV3IFBvaW50KGF4LCArd2lkdGgpKTtcbiAgICAgICAgdmVydGljZXNbMV0ucHVzaChuZXcgUG9pbnQoYXgsIC13aWR0aCkpO1xuXG4gICAgICAgIHZlcnRpY2VzWzBdLnB1c2gobmV3IFBvaW50KGF4IC0gYngsICt3aWR0aCkpO1xuICAgICAgICB2ZXJ0aWNlc1sxXS5wdXNoKG5ldyBQb2ludChheCAtIGJ4LCAtd2lkdGgpKTtcblxuICAgICAgICBkcmF3aW5nc1swXS5wdXNoKCdMJyk7XG4gICAgICAgIGRyYXdpbmdzWzFdLnB1c2goJ0wnKTtcblxuICAgICAgICBsZW5ndGhzLnB1c2goTWF0aC5hYnMoYXgpIC0gY3gpO1xuXG4gICAgICAgIC8vICBSZXZlcnNlIHJpZ2h0IHBhdGhcbiAgICAgICAgdmVydGljZXNbMV0ucmV2ZXJzZSgpO1xuICAgICAgICBkcmF3aW5nc1sxXS5yZXZlcnNlKCk7XG5cbiAgICAgICAgLy8gIE1vdmUgdmVydGljZXMgaW50byBvcmlnaW5hbCBwb3NpdGlvbiAoYmVmb3JlIGxhc3QgdHJhbnNsYXRpb24pXG4gICAgICAgIGFuZ2xlID0gREcuVmVydGV4VHJhbnNmb3JtLmdldEFuZ2xlc1N1bShhbmdsZXMuZnVsbEFuZ2xlLCBwYXRoLmdldEFuZ2xlKCkpO1xuICAgICAgICB0cmFuc2Zvcm0odmVydGljZXMsIGFuZ2xlLCB2ZXJ0aWNlcy5wb3AoKVswXSk7ICAvLyAgcGF0aC52ZXJ0aWNlc1swXVxuXG4gICAgICAgIC8vICBXZSBuZWVkIHRvIHJlY29uc3RydWN0IGFyYydzIGluZGV4ZXMgYnV0IHRvbyBtYW55IHZhcmlhYmxlcyBhbHJlYWR5IHRvdWNoZWQsIHJldXNlIHNvbWUgb2YgdGhlbVxuICAgICAgICBheCA9IHZlcnRpY2VzWzBdLmxlbmd0aDtcbiAgICAgICAgYnggPSB2ZXJ0aWNlc1sxXS5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2FyY3MgPSBhcmNzWzJdLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICBjeCA9IGFyY3NbaV0uc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgREcuQXJjQmV6aWVyKHZlcnRpY2VzWzFdLnNsaWNlKGJ4IC0gY3ggLSA0LCBieCAtIGN4KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgREcuQXJjQmV6aWVyKHZlcnRpY2VzWzBdLnNsaWNlKGN4LCBjeCArIDQpLnJldmVyc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnJldmVyc2UoKTtcblxuICAgICAgICB0aGlzLl9sZW5ndGhzLnB1c2gobGVuZ3Rocy5wb3AoKSk7XG4gICAgICAgIGxlbmd0aHMucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24obCwgaSkge1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3Rocy5wdXNoKHRoaXMuX2FyY3NbaV0uZ2V0TGVuZ3RoKCkpLnB1c2gobCk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vICBTaG9ydGN1dCBib3JkZXIgY2FzZXMgKDAlLWxlbmd0aCBzdWItcGF0aCBhbmQgZnVsbC1wYXRoKVxuICAgICAgICB0aGlzWzBdID0ge1xuICAgICAgICAgICAgdmVydGljZXM6IFt2ZXJ0aWNlc1swXVtheCAtIDJdLCB2ZXJ0aWNlc1swXVtheCAtIDFdLCB2ZXJ0aWNlc1sxXVswXSwgdmVydGljZXNbMV1bMV1dLFxuICAgICAgICAgICAgZHJhd2luZ3M6IFsnTScsICdDJ11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpc1sxXSA9IHtcbiAgICAgICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlc1swXS5jb25jYXQodmVydGljZXNbMV0pLFxuICAgICAgICAgICAgZHJhd2luZ3M6IFsnTSddLmNvbmNhdChkcmF3aW5nc1swXSwgJ0MnLCBkcmF3aW5nc1sxXSlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX3NldEFuZ2xlQW5kRGlzcGxhY2VtZW50OiBmdW5jdGlvbih2TCwgdlIpIHsgLy8gVXNlZCBpbiBERy5BcnJvd1RpcFRyYW5zZm9ybS5zdWJTaGFwZSgpXG4gICAgICAgIHRoaXMuYW5nbGUgPSBERy5WZXJ0ZXhUcmFuc2Zvcm0uZ2V0QW5nbGUoe3g6IHZMLnggLSB2Ui54LCB5OiB2TC55IC0gdlIueX0sIHt4OiAwLCB5OiAxfSk7XG4gICAgICAgIHRoaXMuZGlzcGwgPSB2Ui5jbG9uZSgpO1xuICAgIH0sXG5cbiAgICBzdWJQYXRoOiBmdW5jdGlvbihwYXRoUmF0aW8pIHtcbiAgICAgICAgcGF0aFJhdGlvID0gcGF0aFJhdGlvID4gMSA/IDEgOiBwYXRoUmF0aW87XG5cbiAgICAgICAgLy8gIFNob3J0Y3V0IGJvcmRlciBjYXNlcyAoMCUtbGVuZ3RoIHN1Yi1wYXRoIGFuZCBmdWxsLXBhdGgpXG4gICAgICAgIGlmIChwYXRoUmF0aW8gPT09IDAgfHwgcGF0aFJhdGlvID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzID0gdGhpc1twYXRoUmF0aW9dLnZlcnRpY2VzLm1hcChmdW5jdGlvbih2ZXJ0ZXgpIHsgcmV0dXJuIHZlcnRleC5jbG9uZSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuZHJhd2luZ3MgPSB0aGlzW3BhdGhSYXRpb10uZHJhd2luZ3M7XG4gICAgICAgICAgICB0aGlzLl9zZXRBbmdsZUFuZERpc3BsYWNlbWVudCh0aGlzLnZlcnRpY2VzWzBdLCB0aGlzLnZlcnRpY2VzW3RoaXMudmVydGljZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0U2NhbGVkID0gREcuVmVydGV4VHJhbnNmb3JtLmdldFNjYWxlZDtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5fdmVydGljZXM7XG4gICAgICAgIHZhciBkcmF3aW5ncyA9IHRoaXMuX2RyYXdpbmdzO1xuICAgICAgICB2YXIgbGVuZ3RocyA9IHRoaXMuX2xlbmd0aHM7XG4gICAgICAgIHZhciBsZW4gPSBsZW5ndGhzLmdldExlbmd0aCgpICogcGF0aFJhdGlvO1xuICAgICAgICB2YXIgc2VnSW5kZXggPSBsZW5ndGhzLmdldEluZGV4KGxlbik7XG4gICAgICAgIHZhciBzZWdSYXRpbyA9IGxlbmd0aHMuZ2V0U2VnUmF0aW8obGVuKTtcbiAgICAgICAgdmFyIHZlcnRleEluZGV4TGVmdCA9IHZlcnRpY2VzWzBdLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciB2ZXJ0ZXhJbmRleFJpZ2h0ID0gMTtcbiAgICAgICAgdmFyIGRyYXdpbmdJbmRleExlZnQgPSBkcmF3aW5nc1swXS5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgZHJhd2luZ0luZGV4UmlnaHQgPSAwO1xuICAgICAgICB2YXIgdmVydGV4TGVmdCwgdmVydGV4UmlnaHQ7XG4gICAgICAgIHZhciBhcmMgPSAwLCBhZWQgPSAwO1xuXG4gICAgICAgIHdoaWxlIChhZWQrKyA8IHNlZ0luZGV4KSB7XG4gICAgICAgICAgICBpZiAoYWVkICUgMiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4SW5kZXhMZWZ0LS07XG4gICAgICAgICAgICAgICAgZHJhd2luZ0luZGV4TGVmdC0tO1xuICAgICAgICAgICAgICAgIHZlcnRleEluZGV4UmlnaHQrKztcbiAgICAgICAgICAgICAgICBkcmF3aW5nSW5kZXhSaWdodCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZHJhd2luZ3NbMF1bZHJhd2luZ0luZGV4TGVmdF0gPT09ICdDJykge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhJbmRleExlZnQgLT0gMztcbiAgICAgICAgICAgICAgICAgICAgZHJhd2luZ0luZGV4TGVmdCAtPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleEluZGV4UmlnaHQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgZHJhd2luZ0luZGV4UmlnaHQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJjKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VnSW5kZXggJSAyID09IDEpIHtcbiAgICAgICAgICAgIC8vICBPbmUgcGF0aCBlbmRzIHdpdGggYW4gYXJjXG4gICAgICAgICAgICBhcmMgPSB0aGlzLl9hcmNzW2FyY107XG4gICAgICAgICAgICBpZiAoZHJhd2luZ3NbMF1bZHJhd2luZ0luZGV4TGVmdF0gPT09ICdDJykge1xuICAgICAgICAgICAgICAgIGFyYyA9IGFyYy5nZXRDdXJ2ZUJlZm9yZShhcmMuZ2V0VGJ5TChsZW5ndGhzLmdldFNlZ0xlbmd0aChsZW4pKSk7XG4gICAgICAgICAgICAgICAgdmVydGV4TGVmdCA9IGFyYy5wb2ludHNbM107XG4gICAgICAgICAgICAgICAgdmVydGV4UmlnaHQgPSB2ZXJ0aWNlc1sxXVt2ZXJ0ZXhJbmRleFJpZ2h0XTtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzID0gYXJjLnBvaW50cy5zbGljZSgxKS5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh2ZXJ0aWNlc1swXS5zbGljZSh2ZXJ0ZXhJbmRleExlZnQpLCB2ZXJ0aWNlc1sxXS5zbGljZSgwLCB2ZXJ0ZXhJbmRleFJpZ2h0ICsgMSkpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odmVydGV4KSB7IHJldHVybiB2ZXJ0ZXguY2xvbmUoKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3aW5ncyA9IFsnTSddLmNvbmNhdChkcmF3aW5nc1swXS5zbGljZShkcmF3aW5nSW5kZXhMZWZ0KSwgJ0MnLCBkcmF3aW5nc1sxXS5zbGljZSgwLCBkcmF3aW5nSW5kZXhSaWdodCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmMgPSBhcmMuZ2V0Q3VydmVCZWZvcmUoYXJjLmdldFRieUwobGVuZ3Rocy5nZXRTZWdMZW5ndGgobGVuKSkpO1xuICAgICAgICAgICAgICAgIHZlcnRleExlZnQgPSB2ZXJ0aWNlc1swXVt2ZXJ0ZXhJbmRleExlZnRdO1xuICAgICAgICAgICAgICAgIHZlcnRleFJpZ2h0ID0gYXJjLnBvaW50c1szXTtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXNbMF0uc2xpY2UodmVydGV4SW5kZXhMZWZ0KVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHZlcnRpY2VzWzFdLnNsaWNlKDAsIHZlcnRleEluZGV4UmlnaHQgKyAxKSwgYXJjLnBvaW50cy5zbGljZSgxKSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbih2ZXJ0ZXgpIHsgcmV0dXJuIHZlcnRleC5jbG9uZSgpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdpbmdzID0gWydNJ10uY29uY2F0KGRyYXdpbmdzWzBdLnNsaWNlKGRyYXdpbmdJbmRleExlZnQgKyAxKSwgJ0MnLCBkcmF3aW5nc1sxXS5zbGljZSgwLCBkcmF3aW5nSW5kZXhSaWdodCArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICBCb3RoIHBhdGhzIGVuZCB3aXRoIGxpbmVzXG4gICAgICAgICAgICB2ZXJ0ZXhMZWZ0ID0gZ2V0U2NhbGVkKHZlcnRpY2VzWzBdW3ZlcnRleEluZGV4TGVmdF0sIHZlcnRpY2VzWzBdW3ZlcnRleEluZGV4TGVmdCAtIDFdLCBzZWdSYXRpbyk7XG4gICAgICAgICAgICB2ZXJ0ZXhSaWdodCA9IGdldFNjYWxlZCh2ZXJ0aWNlc1sxXVt2ZXJ0ZXhJbmRleFJpZ2h0XSwgdmVydGljZXNbMV1bdmVydGV4SW5kZXhSaWdodCArIDFdLCBzZWdSYXRpbyk7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzID0gW3ZlcnRleExlZnRdXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh2ZXJ0aWNlc1swXS5zbGljZSh2ZXJ0ZXhJbmRleExlZnQpLCB2ZXJ0aWNlc1sxXS5zbGljZSgwLCB2ZXJ0ZXhJbmRleFJpZ2h0ICsgMSksIHZlcnRleFJpZ2h0KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odmVydGV4KSB7IHJldHVybiB2ZXJ0ZXguY2xvbmUoKTsgfSk7XG4gICAgICAgICAgICB0aGlzLmRyYXdpbmdzID0gWydNJ10uY29uY2F0KGRyYXdpbmdzWzBdLnNsaWNlKGRyYXdpbmdJbmRleExlZnQpLCAnQycsIGRyYXdpbmdzWzFdLnNsaWNlKDAsIGRyYXdpbmdJbmRleFJpZ2h0ICsgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0QW5nbGVBbmREaXNwbGFjZW1lbnQodmVydGV4TGVmdCwgdmVydGV4UmlnaHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBnZXRBbmdsZXM6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgIHZhciBnZXRBbmdsZSA9IERHLlZlcnRleFRyYW5zZm9ybS5nZXRBbmdsZTtcbiAgICAgICAgICAgIHZhciBmdWxsQW5nbGUgPSB7Y29zOiAxLCBzaW46IDB9O1xuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gcGF0aC52ZXJ0aWNlcztcbiAgICAgICAgICAgIHZhciBhbmdsZXMgPSBbXTtcblxuICAgICAgICAgICAgdmFyIGFic1NpbiwgYW5nbGUsXG4gICAgICAgICAgICAgICAgY29zLCBzaW4sIGNvdCwgdGVtcCwgc2lnbjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHZlcnRpY2VzLmxlbmd0aCAtIDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gZ2V0QW5nbGUodmVydGljZXNbaSAtIDFdLCB2ZXJ0aWNlc1tpICsgMV0sIHZlcnRpY2VzW2ldKTtcblxuICAgICAgICAgICAgICAgIGFic1NpbiA9IE1hdGguYWJzKGFuZ2xlLnNpbik7XG4gICAgICAgICAgICAgICAgaWYgKGFic1NpbiA8IDAuMDAwMDAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICBFeGNsdWRlIDE4MMKwIGFuZ2xlIGZyb20gdmVydGljZXMgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMuc3BsaWNlKHZlcnRpY2VzLmxlbmd0aCAtIGkgLSAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAgVGhpcyBpcyBoYWxmIOKIos6xIGNvdGFuZ2VudCwgc2lnbiBkZXNjcmliZXMgYW5nbGUgZGlyZWN0aW9uIGFuZCB1c2VkIHRvIHNob3J0Y3V0IHN0cm9rZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gICctMScgLSByaWdodCBhbmdsZSBpcyBpbm5lciBhbmdsZSwgJzEnIC0gbGVmdCBhbmdsZSBpcyBpbm5lciBhbmdsZSAoaWYgc2VlbiBmcm9tIFswLCAwXSB0byBbLTEsIDBdKVxuICAgICAgICAgICAgICAgICAgICBhbmdsZS5jb3QgPSAoMSArIGFuZ2xlLmNvcykgLyBhbmdsZS5zaW47XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gIFdlIG5lZWQgdG8gcm90YXRlIG5leHQgc2VnbWVudCB0byBbLTEsIDBdIGF4aXMsIHNvIHdlIG5lZWQgY29tcGxlbWVudGFyeSBhbmdsZSBhY3R1YWxseVxuICAgICAgICAgICAgICAgICAgICBhbmdsZS5jb3MgPSAtYW5nbGUuY29zO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vICBDb21wbGltZW50YXJ5IGFuZ2xlIGFsc28gdXNlZCB0byBjYWxjdWxhdGUgaXQncyBxdWF0ZXJuYXJ5IOKIos6yIHRhbmdlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gIOKIos6yIHRhbmdlbnQgdXNlZCBpbiBhcHByb3hpbWF0aW9uIG9mIG91dGVyIGFyYyBzZWdtZW50IGJ5IELDqXppZXIgY3VydmVcbiAgICAgICAgICAgICAgICAgICAgY290ID0gKDEgKyBhbmdsZS5jb3MpIC8gYW5nbGUuc2luO1xuICAgICAgICAgICAgICAgICAgICBzaWduID0gY290IDwgMCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHNpZ24gKiBNYXRoLnNxcnQoNCAqIGNvdCAqIGNvdCArIDQpO1xuICAgICAgICAgICAgICAgICAgICBhbmdsZS50YW4gPSAtMC41ICogKGNvdCArIGNvdCAtIHRlbXApO1xuXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlcy5wdXNoKGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgICAgICBjb3MgPSBmdWxsQW5nbGUuY29zICogYW5nbGUuY29zIC0gZnVsbEFuZ2xlLnNpbiAqIGFuZ2xlLnNpbjtcbiAgICAgICAgICAgICAgICAgICAgc2luID0gZnVsbEFuZ2xlLnNpbiAqIGFuZ2xlLmNvcyArIGZ1bGxBbmdsZS5jb3MgKiBhbmdsZS5zaW47XG5cbiAgICAgICAgICAgICAgICAgICAgZnVsbEFuZ2xlID0ge2NvczogY29zLCBzaW46IHNpbn07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgVXNlZCBpbiBmaW5hbCBzdHJva2UgcG9pbnRzIHRyYW5zbGF0aW9uXG4gICAgICAgICAgICBhbmdsZXMuZnVsbEFuZ2xlID0gIHtjb3M6IGZ1bGxBbmdsZS5jb3MsIHNpbjogLWZ1bGxBbmdsZS5zaW59O1xuICAgICAgICAgICAgcmV0dXJuIGFuZ2xlcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAgVE9ETyAtIGlmIGxlbmd0aCBvZiAnbGF0bG5ncycgYXJyYXkgaXMgbGVzcyB0aGFuIDIgb3IgaXQgaXMgdW5kZWZpbmVkIG5leHQgZnVuY3Rpb24gcHJvZHVjZXMgZXhjZXB0aW9uXG4gICAgICAgIC8vICBjaGVjayB0aGlzIGNvbmRpdGlvbiBpbiBvdXRlciByb3V0aW5lcz8hXG4gICAgICAgIGdldFRyYW5zbGF0ZWRQYXRoOiBmdW5jdGlvbihtYXAsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gbmV3IERHLlZlcnRleFRyYW5zZm9ybShbXSk7XG4gICAgICAgICAgICB2YXIgaSA9IGxhdGxuZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciB2ID0gbWFwLnByb2plY3QobGF0bG5nc1tpXSk7XG4gICAgICAgICAgICB2YXIgZHggPSB2LngsIGR5ID0gdi55O1xuXG4gICAgICAgICAgICBwYXRoLnZlcnRpY2VzLnB1c2gobmV3IERHLlBvaW50KDAsIDApKTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICB2ID0gbWFwLnByb2plY3QobGF0bG5nc1tpXSk7XG4gICAgICAgICAgICAgICAgcGF0aC52ZXJ0aWNlcy5wdXNoKG5ldyBERy5Qb2ludCh2LnggLSBkeCwgdi55IC0gZHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoXG4gICAgICAgICAgICAgICAgLnNldEFuZ2xlKERHLlZlcnRleFRyYW5zZm9ybS5nZXRBbmdsZSgtcGF0aC52ZXJ0aWNlc1sxXS54LCAtcGF0aC52ZXJ0aWNlc1sxXS55KSlcbiAgICAgICAgICAgICAgICAudW5Sb3RhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHJpbmdzLCBhbmdsZSwgdmVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHJpbmdzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb3MgPSBhbmdsZS5jb3M7XG4gICAgICAgICAgICB2YXIgc2luID0gYW5nbGUuc2luO1xuICAgICAgICAgICAgdmFyIGR4ID0gdmVjdG9yLng7XG4gICAgICAgICAgICB2YXIgZHkgPSB2ZWN0b3IueTtcbiAgICAgICAgICAgIHZhciByaW5nLCB4LCB5LCBqO1xuXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgICAgICAgICAgIGogPSByaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSByaW5nW2pdLnggLSBkeDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHJpbmdbal0ueSAtIGR5O1xuICAgICAgICAgICAgICAgICAgICByaW5nW2pdLnggPSB4ICogY29zIC0geSAqIHNpbjtcbiAgICAgICAgICAgICAgICAgICAgcmluZ1tqXS55ID0geCAqIHNpbiArIHkgKiBjb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIvKlxuICogREcuQXJyb3dUaXBUcmFuc2Zvcm0gY2xhc3MgaXMgYSBjb3JlIG9mIGFycm93J3MgdGlwIGNhbGN1bGF0aW9uc1xuICpcbiAqIC5zdWJTaGFwZSgpIHJvdXRpbmUgJ2JvdW5kJyBhcnJvdydzIHRpcCB0byB0aGUgZW5kaW5nIHBvaW50cyBvZiAuc3ViUGF0aCgpXG4gKiBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgaW4gREcuQXJyb3dQYXRoVHJhbnNmb3JtXG4gKlxuICogIEZpbmFsIHRyYW5zbGF0aW9uIChzZWUgREcuRW50cmFuY2UuQXJyb3cpIG1vdmVzIGFycm93IG9iamVjdHMgdG8gdGhlaXIgb3JpZ2luYWwgcG9zaXRpb25zXG4gKi9cblxuREcuQXJyb3dUaXBUcmFuc2Zvcm0gPSBERy5WZXJ0ZXhUcmFuc2Zvcm0uZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBzaGFwZSkge1xuICAgICAgICB0aGlzLmRyYXdpbmdzID0gc2hhcGUuZHJhd2luZ3M7IC8vICBzdGF0aWMgbWFwcGluZ1xuICAgICAgICB0aGlzLl92ZXJ0aWNlcyA9IHNoYXBlLnZlcnRpY2VzO1xuXG4gICAgICAgIHRoaXMuX3NldFNoYXBlKHBhdGgsIHNoYXBlKTtcbiAgICB9LFxuXG4gICAgX3NldFNoYXBlOiBmdW5jdGlvbihwYXRoLCBzaGFwZSkge1xuICAgICAgICB2YXIgc3AgPSBzaGFwZS52ZXJ0aWNlc1swXTtcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5hYnMoc3AueSk7XG4gICAgICAgIHZhciBwbCA9IHBhdGgudmVydGljZXNbMV0ueDsgICAgLy8gIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIHZhciBsZW5ndGggPSBzcC54OyAgICAgICAgICAgICAgLy8gIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIHZhciBvZmZzZXQgPSBwbCAtIGxlbmd0aCArIHdpZHRoICsgd2lkdGg7XG5cbiAgICAgICAgcGF0aC53aWR0aCA9IHdpZHRoO1xuICAgICAgICBwYXRoLm9mZnNldCA9IGxlbmd0aCArIChvZmZzZXQgPiAwID8gb2Zmc2V0IDogMCk7XG4gICAgICAgIGlmIChwYXRoLnZlcnRpY2VzLmxlbmd0aCA8IDMgJiYgbGVuZ3RoID4gLTEwKSB7XG4gICAgICAgICAgICBwYXRoLm9mZnNldCArPSAyLjU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92ZXJ0aWNlcyA9IHRoaXMubG9hZCgpLnVuVHJhbnNsYXRlKHNwKS52ZXJ0aWNlcztcbiAgICB9LFxuXG4gICAgc3ViU2hhcGU6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLmxvYWQoKS51blJvdGF0ZSh0cmFuc2Zvcm0uYW5nbGUpLnRyYW5zbGF0ZSh0cmFuc2Zvcm0uZGlzcGwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcbiIsIi8qXG4gKiBERy5Db21wbGV4UGF0aCBpcyBhIHNpbXBsZSB2ZWN0b3IgbGF5ZXIgY2xhc3Mgd2l0aCBlbXB0eSAuZ2V0RXZlbnRzKCkgb2JqZWN0KCEpXG4gKiBJdCdzIGRyYXdpbmcgbG9naWMgaXMgbWFpbnRhaW5lZCBpbiBERy5FbnRyYW5jZS5BcnJvdyBjbGFzc1xuICpcbiAqIF9weEJvdW5kcyBpcyBhIHBpeGVsIGJvdW5kcyBvZiB0aGlzIGRyYXdpbmdzIGFuZCB0aGV5IGFyZSB1c2VkIGluIEwuQ2FudmFzXG4gKi9cblxuREcuQ29tcGxleFBhdGggPSBERy5QYXRoLmV4dGVuZCh7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBmaWxsOiB0cnVlLFxuICAgICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgREcuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9lbXB0eSA9IFtdO1xuXG4gICAgICAgIHRoaXMuX3B4RW1wdHkgPSBERy5ib3VuZHMoXG4gICAgICAgICAgICBERy5wb2ludCgwLCAwKSwgREcucG9pbnQoMCwgMClcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fcHhCb3VuZHMgPSB0aGlzLl9weEVtcHR5O1xuXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzID0gW3RoaXMuX2VtcHR5XTtcbiAgICAgICAgdGhpcy5fZHJhd2luZ3MgPSBbdGhpcy5fZW1wdHldO1xuICAgIH0sXG5cbiAgICBnZXRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcblxuICAgIF9wcm9qZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICB6b29tLCB3ZWlnaHQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy52aXNpYmlsaXR5LmlzU2hvd24gJiYgb3B0cy50cmFuc2Zvcm1bem9vbV0pIHtcbiAgICAgICAgICAgIC8vICBOZXh0IG51bWJlcnMgd2FzIGVtcGlyaWNhbGx5IHNlbGVjdGVkIGluIG9yZGVyIHRvIHByb3ZpZGUgdmlzdWFsIGNvbXBsaWFuY2VcbiAgICAgICAgICAgIC8vICB0byB0aGUgb3JpZ2luYWwgYXJyb3cncyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgd2VpZ2h0ID0gMi4yIC0gKCgxOSAtIHpvb20pICogMC4yKTtcbiAgICAgICAgICAgIGlmIChvcHRzLndlaWdodCAhPT0gd2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSh7d2VpZ2h0OiArd2VpZ2h0LnRvRml4ZWQoMil9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmVydGljZXNbMF0gPSBvcHRzLnRyYW5zZm9ybVt6b29tXS52ZXJ0aWNlcztcbiAgICAgICAgICAgIHRoaXMuX2RyYXdpbmdzWzBdID0gb3B0cy50cmFuc2Zvcm1bem9vbV0uZHJhd2luZ3M7XG5cbiAgICAgICAgICAgIHRoaXMuX3B4Qm91bmRzID0gb3B0cy50cmFuc2Zvcm1bem9vbV0uX3B4Qm91bmRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdmVydGljZXNbMF0gPSB0aGlzLl9lbXB0eTtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdpbmdzWzBdID0gdGhpcy5fZW1wdHk7XG5cbiAgICAgICAgICAgIHRoaXMuX3B4Qm91bmRzID0gdGhpcy5fcHhFbXB0eTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGVQYXRoOiBmdW5jdGlvbigpIHsgIC8vICB1c2VkIGluIENhbnZhcyByZW5kZXJlclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ29tcGxleFBhdGgodGhpcyk7XG4gICAgfVxufSk7XG4iLCIvKlxuICogQWN0dWFsIHBhaW50aW5nIG1ldGhvZHMgdGhhdCBjYW4gZHJhdyBjb21wbGV4IG9iamVjdHMgd2l0aCBjdXJ2ZXNcbiAqXG4gKiBQb2ludCBjb29yZGluYXRlcyBtdXN0IGJlIHByb3ZpZGVkIGluIGxheWVyLl92ZXJ0aWNlcyBvYmplY3RcbiAqIEFuZCB0eXBlcyBvZiBsaW5lIG11c3QgYmUgcHJvdmlkZWQgaW4gbGF5ZXIuX2RyYXdpbmdzIG9iamVjdFxuICovXG5cbkRHLmV4dGVuZChMLkNhbnZhcy5wcm90b3R5cGUsIHtcbiAgICBfdXBkYXRlQ29tcGxleFBhdGg6IGZ1bmN0aW9uKGxheWVyLCBjbG9zZWQpIHtcbiAgICAgICAgdmFyIGksIGosIGssIGQsIHgsIHksIF94LCBfeSwgJHgsICR5LCBwb2ludHM7XG4gICAgICAgIHZhciBkcmF3aW5ncyA9IGxheWVyLl9kcmF3aW5ncztcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gbGF5ZXIuX3ZlcnRpY2VzO1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgICAgIHRoaXMuX2RyYXduTGF5ZXJzW2xheWVyLl9sZWFmbGV0X2lkXSA9IGxheWVyO1xuXG4gICAgICAgIC8vICBUT0RPOiBEbyB3ZSBuZWVkIHRvIGRvIGEgJ2JlZ2luUGF0aCgpJyBhbmQgcG9zc2libGUgJ2Nsb3NlUGF0aCgpJyBwZXIgcmluZz8hXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgeCA9IHkgPSAwO1xuICAgICAgICAgICAgaiA9IGsgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZCA9IGRyYXdpbmdzW2ldW2srK107XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF94ID0gcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBfeSA9IHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHggPSBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICR5ID0gcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhfeCwgX3ksICR4LCAkeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF94ID0geCArIHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3kgPSB5ICsgcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAkeCA9IHggKyBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICR5ID0geSArIHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHggKyBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB5ICsgcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhfeCwgX3ksICR4LCAkeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF94ID0gcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBfeSA9IHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oX3gsIF95LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3ggPSB4ICsgcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBfeSA9IHkgKyBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB4ICsgcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0geSArIHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oX3gsIF95LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuICAgIH1cbn0pO1xuXG5cbkRHLmV4dGVuZChMLlNWRy5wcm90b3R5cGUsIHtcbiAgICBfdXBkYXRlQ29tcGxleFBhdGg6IGZ1bmN0aW9uKGxheWVyLCBjbG9zZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0UGF0aChsYXllciwgTC5TVkcuY29tcGxleFBvaW50c1RvUGF0aChsYXllci5fdmVydGljZXMsIGxheWVyLl9kcmF3aW5ncywgY2xvc2VkKSk7XG4gICAgfVxufSk7XG5cblxuREcuZXh0ZW5kKEwuU1ZHLCB7XG4gICAgY29tcGxleFBvaW50c1RvUGF0aDogZnVuY3Rpb24odmVydGljZXMsIGRyYXdpbmdzLCBjbG9zZWQpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICB2YXIgc3ZnID0gREcuQnJvd3Nlci5zdmc7XG4gICAgICAgIHZhciBpLCBqLCBrLCBuLCBkLCBwb2ludHM7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHMgPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgICAgICAgLy8gIFNwZWVkdXAgaG90IHBhdGggYnkgcmVtb3ZpbmcgaWYvdGVybmFyeSBjb25kaXRpb24gY2hlY2tzIGJ1dCBkdXBsaWNhdGluZyBsb29wc1xuICAgICAgICAgICAgaWYgKHN2Zykge1xuICAgICAgICAgICAgICAgIGogPSBrID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGRyYXdpbmdzW2ldW2srK107XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzogICBuID0gMzsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOiAgIG4gPSAyOyBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogICAgbiA9IDE7ICAvLyAgJ00nLCAnbScsICdMJywgJ2wnLCAuLi5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gZDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHBvaW50c1tqXS54LnRvRml4ZWQoNCkgKyAnLCcgKyBwb2ludHNbal0ueS50b0ZpeGVkKDQpICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAgdm1sIGluIElFOCBjYW4gc3VwcG9ydCBvbmx5IGludGVnZXIgdmFsdWVzIGluICdwYXRoJywgc29ycnkgYWJvdXQgbG9zcyBvZiBwcmVjaXNpb25cbiAgICAgICAgICAgICAgICBqID0gayA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBkcmF3aW5nc1tpXVtrKytdO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOiAgIGQgPSAnbSc7IG4gPSAxOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOiAgIGQgPSAndCc7IG4gPSAxOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOiAgIGQgPSAnbCc7IG4gPSAxOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOiAgIGQgPSAncic7IG4gPSAxOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOiAgIGQgPSAnYyc7IG4gPSAzOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOiAgIGQgPSAndic7IG4gPSAzOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBWTUwgc3BlYyBoYXMgJ3FiJyBjb21tYW5kIGluICd2JyBhdHRyaWJ1dGUgc3RyaW5nIGJ1dCBubyAncmVsYXRpdmVUbycgY29tcGxpbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBTbyB3ZSdsbCBlbXVsYXRlIEN1YmljIELDqXppZXIgY3VydmUgYnkgYXBwbHlpbmcgUXVhZHJhdGljIHZhcmlhbnQgaW4gYm90aCBjYXNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBUT0RPOiBCb3RoIGNvbnRyb2wgcG9pbnRzIHdpbGwgdXNlIHRoZSBzYW1lIHZhbHVlIGJ1dCB0aGlzIGlzIG5vdCB0cnVlIHNvbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdDJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1tqXS54LnRvRml4ZWQoMCkgKyAnLCcgKyBwb2ludHNbal0ueS50b0ZpeGVkKDApICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2pdLngudG9GaXhlZCgwKSArICcsJyArIHBvaW50c1tqXS55LnRvRml4ZWQoMCkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbaiArIDFdLngudG9GaXhlZCgwKSArICcsJyArIHBvaW50c1tqICsgMV0ueS50b0ZpeGVkKDApICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ2MnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2pdLngudG9GaXhlZCgwKSArICcsJyArIHBvaW50c1tqXS55LnRvRml4ZWQoMCkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbal0ueC50b0ZpeGVkKDApICsgJywnICsgcG9pbnRzW2pdLnkudG9GaXhlZCgwKSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1tqICsgMV0ueC50b0ZpeGVkKDApICsgJywnICsgcG9pbnRzW2ogKyAxXS55LnRvRml4ZWQoMCkgKyAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogICAgbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IGQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBwb2ludHNbal0ueC50b0ZpeGVkKDApICsgJywnICsgcG9pbnRzW2pdLnkudG9GaXhlZCgwKSArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RyICs9IGNsb3NlZCA/IChzdmcgPyAneicgOiAneCcpIDogJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuICAgICAgICByZXR1cm4gc3RyIHx8ICdtMCwwJztcbiAgICB9XG59KTtcbiIsIi8qXG4gKiBER0JlemllckN1cnZlcyBpcyBhIGNvbGxlY3Rpb24gb2YgdGhyZWUgY2xhc3NlczpcbiAqIE9yaWdpbmFsIERHLkJlemllciBjbGFzcyBwcm92aWRlcyBiYXNpYyBtYXRoIGZvciBDdWJpYyBhbmQgUXVhZHJhdGljIELDqXppZXIgY3VydmVzXG4gKiBERy5UaW1lQmV6aWVyIHVzZWQgaW4gYW5pbWF0aW9uIGVmZmVjdHMgaXQgY2FuIHJldHVybiAnRGlzdGFuY2UnIChZKSBieSBUaW1lIChYKSB2YWx1ZVxuICogREcuQXJjQmV6aWVyIGNhbiByZXR1cm4gJ3QnIHZhbHVlIGJ5IGN1cnZlJ3Mgc2VnbWVudCBsZW5ndGhcbiAqIEFjdHVhbCBjYWxjdWxhdGlvbnMgY2FuIGJlIHZlcnkgaGFyZCAoaW4gbWF0aCB0ZXJtcykgc28gd2UgdXNlIExVVCdzIHRvIG9wdGltaXplIHRoZW1cbiAqXG4gKiBPcmlnaW5hbCBpZGVhcyBjb21lIGZyb20gdGhpcyBzb3VyY2U6ICAgaHR0cHM6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby9cbiAqL1xuXG5ERy5CZXppZXIgPSBERy5DbGFzcy5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgY3VydmUgb2JqZWN0IGJ5IHByb3ZpZGVkIGNvbnRyb2wgcG9pbnRzXG4gICAgICogQHBhcmFtIHtBcnJheTxERy5Qb2ludD59IGNvb3JkcyBDdXJ2ZSdzIGNvbnRyb2wgcG9pbnRzIGluIERHLlBvaW50IGZvcm1hdCAodXAgdG8gZm91ciBjb250cm9sIHBvaW50cyBzdXBwb3J0ZWQpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2xvbmVdIENsb25lIG9yaWdpbmFsIHBvaW50cyBvciBub3QgKERlZmF1bHQpXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY29vcmRzLCBjbG9uZSkge1xuICAgICAgICBpZiAoY2xvbmUpIHtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gY29vcmRzLm1hcChmdW5jdGlvbihjb29yZCkgeyByZXR1cm4gY29vcmQuY2xvbmUoKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IGNvb3JkcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRwb2ludHMgPSB0aGlzLl9nZXREZXJpdmF0aXZlcygpO1xuICAgICAgICB0aGlzLm9yZGVyID0gdGhpcy5wb2ludHMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5fbHV0ID0gW107XG4gICAgfSxcblxuICAgIGdldFBvaW50OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBtdCwgbXQyLCB0MjtcbiAgICAgICAgdmFyIGEsIGIsIGMsIGQ7XG5cbiAgICAgICAgaWYgKHQgPT09IDApIHsgcmV0dXJuIHBbMF07IH1cbiAgICAgICAgaWYgKHQgPT09IDEpIHsgcmV0dXJuIHBbdGhpcy5vcmRlcl07IH1cblxuICAgICAgICBtdCA9IDEgLSB0O1xuICAgICAgICBtdDIgPSBtdCAqIG10O1xuICAgICAgICB0MiA9IHQgKiB0O1xuXG4gICAgICAgIGlmICh0aGlzLm9yZGVyID4gMikge1xuICAgICAgICAgICAgYSA9IG10MiAqIG10O1xuICAgICAgICAgICAgYiA9IG10MiAqIHQgKiAzO1xuICAgICAgICAgICAgYyA9IG10ICogdDIgKiAzO1xuICAgICAgICAgICAgZCA9IHQgKiB0MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBbcFswXSwgcFsxXSwgcFsyXSwge3g6IDAsIHk6IDB9XTtcbiAgICAgICAgICAgIGEgPSBtdDI7XG4gICAgICAgICAgICBiID0gbXQgKiB0ICogMjtcbiAgICAgICAgICAgIGMgPSB0MjtcbiAgICAgICAgICAgIGQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBERy5Qb2ludChcbiAgICAgICAgICAgIGEgKiBwWzBdLnggKyBiICogcFsxXS54ICsgYyAqIHBbMl0ueCArIGQgKiBwWzNdLngsXG4gICAgICAgICAgICBhICogcFswXS55ICsgYiAqIHBbMV0ueSArIGMgKiBwWzJdLnkgKyBkICogcFszXS55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGRlcml2YXRpdmU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmRwb2ludHNbMF07XG4gICAgICAgIHZhciBtdCA9IDEgLSB0O1xuICAgICAgICB2YXIgYSwgYiwgYztcblxuICAgICAgICBpZiAodGhpcy5vcmRlciA+IDIpIHtcbiAgICAgICAgICAgIGEgPSBtdCAqIG10O1xuICAgICAgICAgICAgYiA9IG10ICogdCAqIDI7XG4gICAgICAgICAgICBjID0gdCAqIHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gW3BbMF0sIHBbMV0sIHt4OiAwLCB5OiAwfV07XG4gICAgICAgICAgICBhID0gbXQ7IGIgPSB0OyBjID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICBhICogcFswXS54ICsgYiAqIHBbMV0ueCArIGMgKiBwWzJdLngsXG4gICAgICAgICAgICBhICogcFswXS55ICsgYiAqIHBbMV0ueSArIGMgKiBwWzJdLnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICAgIHZhciB3X2kgPSBERy5CZXppZXIuV0VJR0hUO1xuICAgICAgICB2YXIgeF9pID0gREcuQmV6aWVyLkFCU0NJU1NBO1xuICAgICAgICB2YXIgeiA9IDAuNTtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHZhciBkLCBsLCB0O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeF9pLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ID0geiAqIHhfaVtpXSArIHo7XG4gICAgICAgICAgICBkID0gdGhpcy5kZXJpdmF0aXZlKHQpO1xuICAgICAgICAgICAgbCA9IGQueCAqIGQueCArIGQueSAqIGQueTtcbiAgICAgICAgICAgIHN1bSArPSB3X2lbaV0gKiBNYXRoLnNxcnQobCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cblxuICAgICAgICByZXR1cm4geiAqIHN1bTtcbiAgICB9LFxuXG4gICAgZ2V0Q3VydmVCZWZvcmU6IGZ1bmN0aW9uKHopIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIHoyLCB6MywgbXosIG16MiwgbXozO1xuICAgICAgICB2YXIgYiQzLCBiJDQsIGMkNDtcbiAgICAgICAgdmFyIGN1cnZlO1xuXG4gICAgICAgIGlmICh6ID09PSAxKSB7IHJldHVybiB0aGlzLmNsb25lKCk7IH1cblxuICAgICAgICBjdXJ2ZSA9IFtdO1xuICAgICAgICB6MiA9IHogKiB6O1xuICAgICAgICBteiA9IHogLSAxO1xuICAgICAgICBtejIgPSBteiAqIG16O1xuXG4gICAgICAgIGN1cnZlWzBdID0gbmV3IERHLlBvaW50KFxuICAgICAgICAgICAgcFswXS54LFxuICAgICAgICAgICAgcFswXS55XG4gICAgICAgICk7XG5cbiAgICAgICAgY3VydmVbMV0gPSBuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICB6ICogcFsxXS54IC0gbXogKiBwWzBdLngsXG4gICAgICAgICAgICB6ICogcFsxXS55IC0gbXogKiBwWzBdLnlcbiAgICAgICAgKTtcblxuICAgICAgICBiJDMgPSB6ICogbXogKiAyO1xuICAgICAgICBjdXJ2ZVsyXSA9IG5ldyBERy5Qb2ludChcbiAgICAgICAgICAgIHoyICogcFsyXS54IC0gYiQzICogcFsxXS54ICsgbXoyICogcFswXS54LFxuICAgICAgICAgICAgejIgKiBwWzJdLnkgLSBiJDMgKiBwWzFdLnkgKyBtejIgKiBwWzBdLnlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5vcmRlciA+IDIpIHtcbiAgICAgICAgICAgIHozID0gejIgKiB6O1xuICAgICAgICAgICAgbXozID0gbXoyICogbXo7XG4gICAgICAgICAgICBiJDQgPSB6MiAqIG16ICogMztcbiAgICAgICAgICAgIGMkNCA9IHogKiBtejIgKiAzO1xuICAgICAgICAgICAgY3VydmVbM10gPSBuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICAgICAgejMgKiBwWzNdLnggLSBiJDQgKiBwWzJdLnggKyBjJDQgKiBwWzFdLnggLSBtejMgKiBwWzBdLngsXG4gICAgICAgICAgICAgICAgejMgKiBwWzNdLnkgLSBiJDQgKiBwWzJdLnkgKyBjJDQgKiBwWzFdLnkgLSBtejMgKiBwWzBdLnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERHLkJlemllcihjdXJ2ZSk7XG4gICAgfSxcblxuICAgIGdldEN1cnZlQWZ0ZXI6IGZ1bmN0aW9uKHopIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG4gPSB0aGlzLm9yZGVyO1xuICAgICAgICB2YXIgejIsIHozLCBteiwgbXoyLCBtejM7XG4gICAgICAgIHZhciBiJDMsIGIkNCwgYyQ0O1xuICAgICAgICB2YXIgY3VydmU7XG5cbiAgICAgICAgaWYgKHogPT09IDEpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKTsgfVxuXG4gICAgICAgIGN1cnZlID0gW107XG4gICAgICAgIHoyID0geiAqIHo7XG4gICAgICAgIG16ID0geiAtIDE7XG4gICAgICAgIG16MiA9IG16ICogbXo7XG5cbiAgICAgICAgY3VydmVbbl0gPSBuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICBwW25dLngsXG4gICAgICAgICAgICBwW25dLnlcbiAgICAgICAgKTtcblxuICAgICAgICBjdXJ2ZVstLW5dID0gbmV3IERHLlBvaW50KFxuICAgICAgICAgICAgeiAqIHBbbiArIDFdLnggLSBteiAqIHBbbl0ueCxcbiAgICAgICAgICAgIHogKiBwW24gKyAxXS55IC0gbXogKiBwW25dLnlcbiAgICAgICAgKTtcblxuICAgICAgICBiJDMgPSB6ICogbXogKiAyO1xuICAgICAgICBjdXJ2ZVstLW5dID0gbmV3IERHLlBvaW50KFxuICAgICAgICAgICAgejIgKiBwW24gKyAyXS54IC0gYiQzICogcFtuICsgMV0ueCArIG16MiAqIHBbbl0ueCxcbiAgICAgICAgICAgIHoyICogcFtuICsgMl0ueSAtIGIkMyAqIHBbbiArIDFdLnkgKyBtejIgKiBwW25dLnlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5vcmRlciA+IDIpIHtcbiAgICAgICAgICAgIHozID0gejIgKiB6O1xuICAgICAgICAgICAgbXozID0gbXoyICogbXo7XG4gICAgICAgICAgICBiJDQgPSB6MiAqIG16ICogMztcbiAgICAgICAgICAgIGMkNCA9IHogKiBtejIgKiAzO1xuICAgICAgICAgICAgY3VydmVbLS1uXSA9IG5ldyBERy5Qb2ludChcbiAgICAgICAgICAgICAgICB6MyAqIHBbbiArIDNdLnggLSBiJDQgKiBwW24gKyAyXS54ICsgYyQ0ICogcFtuICsgMV0ueCAtIG16MyAqIHBbbl0ueCxcbiAgICAgICAgICAgICAgICB6MyAqIHBbbiArIDNdLnkgLSBiJDQgKiBwW24gKyAyXS55ICsgYyQ0ICogcFtuICsgMV0ueSAtIG16MyAqIHBbbl0ueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgREcuQmV6aWVyKGN1cnZlKTtcbiAgICB9LFxuXG4gICAgX2dldERlcml2YXRpdmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIGQsIGMsIGosIGxpc3Q7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKGQgPSBwLmxlbmd0aCwgYyA9IGQgLSAxOyBkID4gMTsgZC0tLCBjLS0pIHtcbiAgICAgICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2gobmV3IERHLlBvaW50KFxuICAgICAgICAgICAgICAgICAgICBjICogKHBbaiArIDFdLnggLSBwW2pdLngpLFxuICAgICAgICAgICAgICAgICAgICBjICogKHBbaiArIDFdLnkgLSBwW2pdLnkpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChsaXN0KTtcbiAgICAgICAgICAgIHAgPSBsaXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0TFVUOiBmdW5jdGlvbihzdGVwcykge1xuICAgICAgICBzdGVwcyA9IHN0ZXBzIHx8IDEyNTtcblxuICAgICAgICBpZiAodGhpcy5fbHV0Lmxlbmd0aCAhPT0gc3RlcHMgKyAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcmRlciA+IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRMVVQzKHN0ZXBzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0TFVUMihzdGVwcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbHV0O1xuICAgIH0sXG5cbiAgICBfc2V0TFVUMjogZnVuY3Rpb24oc3RlcHMpIHtcbiAgICAgICAgdmFyIGx1dCA9IHRoaXMuX2x1dCA9IFtdO1xuICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgdCwgbXQ7XG4gICAgICAgIHZhciBhLCBiLCBjO1xuXG4gICAgICAgIGx1dC5wdXNoKHt4OiBwWzBdLngsIHk6IHBbMF0ueSwgbDogMH0pO1xuICAgICAgICBmb3IgKHZhciBzID0gMTsgcyA8IHN0ZXBzOyBzKyspIHtcbiAgICAgICAgICAgIHQgPSBzIC8gc3RlcHM7XG4gICAgICAgICAgICBtdCA9IDEgLSB0O1xuICAgICAgICAgICAgYSA9IG10ICogbXQ7XG4gICAgICAgICAgICBiID0gbXQgKiB0ICogMjtcbiAgICAgICAgICAgIGMgPSB0ICogdDtcbiAgICAgICAgICAgIGx1dC5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiBhICogcFswXS54ICsgYiAqIHBbMV0ueCArIGMgKiBwWzJdLngsXG4gICAgICAgICAgICAgICAgeTogYSAqIHBbMF0ueSArIGIgKiBwWzFdLnkgKyBjICogcFsyXS55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsdXQucHVzaCh7eDogcFsyXS54LCB5OiBwWzJdLnksIGw6IDB9KTtcbiAgICB9LFxuXG4gICAgX3NldExVVDM6IGZ1bmN0aW9uKHN0ZXBzKSB7XG4gICAgICAgIHZhciBsdXQgPSB0aGlzLl9sdXQgPSBbXTtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIHQsIHQyLCBtdCwgbXQyO1xuICAgICAgICB2YXIgYSwgYiwgYywgZDtcblxuICAgICAgICBsdXQucHVzaCh7eDogcFswXS54LCB5OiBwWzBdLnksIGw6IDB9KTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDE7IHMgPCBzdGVwczsgcysrKSB7XG4gICAgICAgICAgICB0ID0gcyAvIHN0ZXBzO1xuICAgICAgICAgICAgbXQgPSAxIC0gdDtcbiAgICAgICAgICAgIG10MiA9IG10ICogbXQ7XG4gICAgICAgICAgICB0MiA9IHQgKiB0O1xuICAgICAgICAgICAgYSA9IG10MiAqIG10O1xuICAgICAgICAgICAgYiA9IG10MiAqIHQgKiAzO1xuICAgICAgICAgICAgYyA9IG10ICogdDIgKiAzO1xuICAgICAgICAgICAgZCA9IHQgKiB0MjtcbiAgICAgICAgICAgIGx1dC5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiBhICogcFswXS54ICsgYiAqIHBbMV0ueCArIGMgKiBwWzJdLnggKyBkICogcFszXS54LFxuICAgICAgICAgICAgICAgIHk6IGEgKiBwWzBdLnkgKyBiICogcFsxXS55ICsgYyAqIHBbMl0ueSArIGQgKiBwWzNdLnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGx1dC5wdXNoKHt4OiBwWzNdLngsIHk6IHBbM10ueSwgbDogMH0pO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgREcuQmV6aWVyKHRoaXMucG9pbnRzLCB0cnVlKTtcbiAgICB9XG59KTtcblxuREcuYmV6aWVyID0gZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgaWYgKHR5cGVvZiBjb29yZHMgPT09ICdudW1iZXInIHx8IGNvb3JkcyBpbnN0YW5jZW9mIERHLlBvaW50KSB7XG4gICAgICAgIGNvb3JkcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb29yZHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChjb29yZHMubGVuZ3RoIDwgNykge1xuICAgICAgICAgICAgY29vcmRzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBERy5Qb2ludChjb29yZHNbMF0sIGNvb3Jkc1sxXSksXG4gICAgICAgICAgICAgICAgbmV3IERHLlBvaW50KGNvb3Jkc1syXSwgY29vcmRzWzNdKSxcbiAgICAgICAgICAgICAgICBuZXcgREcuUG9pbnQoY29vcmRzWzRdLCBjb29yZHNbNV0pXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29vcmRzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBERy5Qb2ludChjb29yZHNbMF0sIGNvb3Jkc1sxXSksXG4gICAgICAgICAgICAgICAgbmV3IERHLlBvaW50KGNvb3Jkc1syXSwgY29vcmRzWzNdKSxcbiAgICAgICAgICAgICAgICBuZXcgREcuUG9pbnQoY29vcmRzWzRdLCBjb29yZHNbNV0pLFxuICAgICAgICAgICAgICAgIG5ldyBERy5Qb2ludChjb29yZHNbNl0sIGNvb3Jkc1s3XSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBERy5CZXppZXIoY29vcmRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERHLkJlemllcihjb29yZHMsIHRydWUpO1xuICAgIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuREcuQmV6aWVyLldFSUdIVCA9IFtcbiAgICAwLjM2MjY4Mzc4MzM3ODM2MjAsXG4gICAgMC4zNjI2ODM3ODMzNzgzNjIwLFxuICAgIDAuMzEzNzA2NjQ1ODc3ODg3MyxcbiAgICAwLjMxMzcwNjY0NTg3Nzg4NzMsXG4gICAgMC4yMjIzODEwMzQ0NTMzNzQ1LFxuICAgIDAuMjIyMzgxMDM0NDUzMzc0NSxcbiAgICAwLjEwMTIyODUzNjI5MDM3NjMsXG4gICAgMC4xMDEyMjg1MzYyOTAzNzYzXG5dO1xuREcuQmV6aWVyLkFCU0NJU1NBID0gW1xuICAgLTAuMTgzNDM0NjQyNDk1NjQ5OCxcbiAgICAwLjE4MzQzNDY0MjQ5NTY0OTgsXG4gICAtMC41MjU1MzI0MDk5MTYzMjkwLFxuICAgIDAuNTI1NTMyNDA5OTE2MzI5MCxcbiAgIC0wLjc5NjY2NjQ3NzQxMzYyNjcsXG4gICAgMC43OTY2NjY0Nzc0MTM2MjY3LFxuICAgLTAuOTYwMjg5ODU2NDk3NTM2MyxcbiAgICAwLjk2MDI4OTg1NjQ5NzUzNjNcbl07XG4vKiBlc2xpbnQtZW5hYmxlIGluZGVudCAqL1xuXG5cbi8vICBUaGlzIGN1cnZlIGlzIG1vbm90b25pY2FsbHkgb3JkZXJlZCBieSAnWCcgY29vcmRpbmF0ZSBhbmQgaGFzIFBbMF0gPSB7MCwgMH0gYW5kIFBbM10gPSB7MSwgMX1cbi8vICBXZSBjYW4gdXRpbGl6ZSB0aGlzIGZhY3RzIHRvIHNob3J0Y3V0IGNhbGN1bGF0aW9uc1xuREcuVGltZUJlemllciA9IERHLkJlemllci5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbnRyb2xQb2ludDEsIGNvbnRyb2xQb2ludDIsIGNsb25lKSB7XG4gICAgICAgIERHLkJlemllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIFtERy5UaW1lQmV6aWVyLlNUQVJULCBjb250cm9sUG9pbnQxLCBjb250cm9sUG9pbnQyLCBERy5UaW1lQmV6aWVyLkVORF0sXG4gICAgICAgICAgICBjbG9uZVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBnZXRZYnlYOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBsdXQgPSB0aGlzLmdldExVVCgpO1xuICAgICAgICB2YXIgbWF4ID0gbHV0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgICB2YXIgbWlkO1xuXG4gICAgICAgIGlmICh4IDw9IDApIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgaWYgKHggPj0gMSkgeyByZXR1cm4gMTsgfVxuXG4gICAgICAgIC8vICAnWCcgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHNvIHdlIGNhbiBkbyBhIHNpbXBsZSBiaW5hcnkgc2VhcmNoIChMVVQpXG4gICAgICAgIC8vICBhbmQgdGhlbiBmaW5lLXR1bmUgdGhlIHJlc3VsdCBieSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBhc3N1bWluZyAnWScgaXMgbm90IGNoYW5nZWQgc28gcmFkaWNhbGx5XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBtaWQgPSBtaW4gKyAobWF4IC0gbWluID4+IDEpO1xuICAgICAgICAgICAgaWYgKHggPCBsdXRbbWlkXS54KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gbWlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4IC0gbWluIDwgMikgeyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIHggPSAoeCAtIGx1dFttaW5dLngpIC8gKGx1dFttYXhdLnggLSBsdXRbbWluXS54KTtcblxuICAgICAgICByZXR1cm4gKGx1dFttaW5dLnkgKyAobHV0W21heF0ueSAtIGx1dFttaW5dLnkpICogeCk7XG4gICAgfSxcblxuICAgIGdldExVVDogZnVuY3Rpb24oc3RlcHMpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIHQsIHQyLCBtdDtcbiAgICAgICAgdmFyIGIsIGMsIGQ7XG4gICAgICAgIHZhciBsdXQ7XG5cbiAgICAgICAgc3RlcHMgPSBzdGVwcyB8fCAyNDA7XG4gICAgICAgIGlmICh0aGlzLl9sdXQubGVuZ3RoID09PSBzdGVwcyArIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sdXQgPSBsdXQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGx1dC5wdXNoKHt4OiAwLCB5OiAwfSk7XG4gICAgICAgIGZvciAodmFyIHMgPSAxOyBzIDwgc3RlcHM7IHMrKykge1xuICAgICAgICAgICAgdCA9IHMgLyBzdGVwcztcbiAgICAgICAgICAgIG10ID0gMSAtIHQ7XG4gICAgICAgICAgICB0MiA9IHQgKiB0O1xuICAgICAgICAgICAgLy8gIFdlIGRvbid0IG5lZWQgJ2EnIGNvZWZmaWNpZW50IGJlY2F1c2UgcFswXSBpcyB7MCwgMH1cbiAgICAgICAgICAgIGIgPSBtdCAqIG10ICogdCAqIDM7XG4gICAgICAgICAgICBjID0gbXQgKiB0MiAqIDM7XG4gICAgICAgICAgICBkID0gdCAqIHQyO1xuICAgICAgICAgICAgbHV0LnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IGIgKiBwWzFdLnggKyBjICogcFsyXS54ICsgZCxcbiAgICAgICAgICAgICAgICB5OiBiICogcFsxXS55ICsgYyAqIHBbMl0ueSArIGRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGx1dC5wdXNoKHt4OiAxLCB5OiAxfSk7XG5cbiAgICAgICAgcmV0dXJuIGx1dDtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IERHLlRpbWVCZXppZXIodGhpcy5wb2ludHMsIHRydWUpO1xuICAgIH1cbn0pO1xuXG5ERy5UaW1lQmV6aWVyLlNUQVJUID0gREcucG9pbnQoMCwgMCk7XG5ERy5UaW1lQmV6aWVyLkVORCA9IERHLnBvaW50KDEsIDEpO1xuXG5cbi8vICBUaGlzIGlzIGN1YmljIEJlemllciBkZXNjcmliaW5nIGNpcmN1bGFyIGFyY1xuREcuQXJjQmV6aWVyID0gREcuQmV6aWVyLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY29vcmRzLCBjbG9uZSkge1xuICAgICAgICBERy5CZXppZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBjb29yZHMsIGNsb25lKTtcbiAgICAgICAgdGhpcy5nZXRMVVQoKTtcbiAgICAgICAgdGhpcy5fc2V0THV0TGVuZ3RocygpO1xuICAgIH0sXG5cbiAgICBnZXRUYnlMOiBmdW5jdGlvbihsKSB7XG4gICAgICAgIHZhciBsdXQgPSB0aGlzLmdldExVVCgpO1xuICAgICAgICB2YXIgbWF4ID0gbHV0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgICB2YXIgbWlkO1xuICAgICAgICB2YXIgeCwgeTtcblxuICAgICAgICBpZiAobCA8PSAwKSB7IHJldHVybiAwOyB9XG4gICAgICAgIGlmIChsID49IGx1dFttYXhdLmwpIHsgcmV0dXJuIDE7IH1cblxuICAgICAgICAvLyAgJ0wnIGlzIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBzbyB3ZSBjYW4gZG8gYSBiaW5hcnkgc2VhcmNoIChMVVQpXG4gICAgICAgIC8vICBhbmQgdGhlbiBmaW5lLXR1bmUgdGhlIHJlc3VsdCBieSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbWlkID0gbWluICsgKG1heCAtIG1pbiA+PiAxKTtcbiAgICAgICAgICAgIGlmIChsIDwgbHV0W21pZF0ubCkge1xuICAgICAgICAgICAgICAgIG1heCA9IG1pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1heCAtIG1pbiA8IDIpIHsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBsID0gKGwgLSBsdXRbbWluXS5sKSAvIChsdXRbbWF4XS5sIC0gbHV0W21pbl0ubCk7XG5cbiAgICAgICAgeCA9IChsdXRbbWluXS54ICsgKGx1dFttYXhdLnggLSBsdXRbbWluXS54KSAqIGwpO1xuICAgICAgICB5ID0gKGx1dFttaW5dLnkgKyAobHV0W21heF0ueSAtIGx1dFttaW5dLnkpICogbCk7XG5cbiAgICAgICAgLy8gIEJVVCB0aGlzIGlzIGEgcGFydCBvZiBzdG9yeSwgd2UgbmVlZCBhIHByb2plY3Rpb24gb2YgdGhpcyBwb2ludCB0byB0aGUgYWN0dWFsIGN1cnZlIGFuZCBpdCdzIHJldmVyc2UgJ3QnIHZhbFxuICAgICAgICB2YXIgcCwgZHgsIGR5LCB0O1xuICAgICAgICB2YXIgZXQgPSBtYXggLyBsdXQubGVuZ3RoO1xuICAgICAgICB2YXIgZHQgPSBtaW4gLyBsdXQubGVuZ3RoO1xuICAgICAgICB2YXIgcyA9IDEgLyBsdXQubGVuZ3RoIC8gMTA7ICAgIC8vICBUT0RPXG4gICAgICAgIHZhciBkID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICAgICAgICBmb3IgKHQgPSBkdDsgZHQgPCBldDsgZHQgKz0gcykge1xuICAgICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnQoZHQpO1xuICAgICAgICAgICAgZHggPSBwLnggLSB4OyBkeSA9IHAueSAtIHk7XG4gICAgICAgICAgICBsID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIGlmIChsIDwgZCkge1xuICAgICAgICAgICAgICAgIGQgPSBsO1xuICAgICAgICAgICAgICAgIHQgPSBkdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0O1xuICAgIH0sXG5cbiAgICBfc2V0THV0TGVuZ3RoczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsdXQgPSB0aGlzLl9sdXQ7XG4gICAgICAgIHZhciBkeCwgZHk7XG5cbiAgICAgICAgbHV0WzBdLmwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGx1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZHggPSBsdXRbaV0ueCAtIGx1dFtpIC0gMV0ueDtcbiAgICAgICAgICAgIGR5ID0gbHV0W2ldLnkgLSBsdXRbaSAtIDFdLnk7XG4gICAgICAgICAgICBsdXRbaV0ubCA9IGx1dFtpIC0gMV0ubCArIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2x1dFt0aGlzLl9sdXQubGVuZ3RoIC0gMV0ubDtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IERHLkFyY0Jlemllcih0aGlzLnBvaW50cywgdHJ1ZSk7XG4gICAgfVxufSk7XG4iLCIvKlxuICogREcuQW5pbWF0aW9uIHByb3ZpZGVzIHRpY2sgKHN0ZXApIGxvZ2ljIHJldHVybmluZyBwcm9ncmVzc2lvbiB2YWx1ZXNcbiAqIGNhbGN1bGF0ZWQgb3ZlciBwcm92aWRlZCBvciBjdXN0b20gQsOpemllciBjdXJ2ZXNcbiAqIE9yaWdpbmFsIGlucHV0IGNhbiBiZSBhcnJheSBvYmplY3QgYnR3Li4uXG4gKi9cblxuREcuQW5pbWF0aW9uID0gREcuRXZlbnRlZC5leHRlbmQoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgLy8gYW5pbWF0aW9uOiB7ICAgIC8vICBPciBhcnJheSBvZiBvYmplY3RzXG4gICAgICAgIC8vICAgICBmdW5jdGlvbjogREcuQW5pbWF0aW9uLkVBU0UsXG4gICAgICAgIC8vICAgICBkdXJhdGlvbjogMjAwMCxcbiAgICAgICAgLy8gICAgIGZyYW1lczogbnVsbFxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy9vZmZzZXQ6IDBcbiAgICAgICAgLy9yZXBlYXQ6IDBcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBERy5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2FuaW1JRCA9IC0xO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9ucyA9IG51bGw7XG4gICAgfSxcblxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmUoKTtcblxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cbiAgICAgICAgLy8gIERhdGUubm93KCksIGJ1dC4uLiBJRTkrXG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIHRoaXMuX2FuaW1hdGUoKTtcbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9ydW4odGhpcy5fZHVyYXRpb25zLmdldExlbmd0aCgpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcHJlcGFyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IERHLlV0aWwuaXNBcnJheSh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSA/IHRoaXMub3B0aW9ucy5hbmltYXRpb24gOiBbdGhpcy5vcHRpb25zLmFuaW1hdGlvbl07XG5cbiAgICAgICAgdGhpcy5fZHVyYXRpb25zID0gbmV3IERHLk1ldHJpYy5TZWdtZW50cygpO1xuICAgICAgICB0aGlzLl9hbmltYXRpb24uZm9yRWFjaChmdW5jdGlvbihhbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChhbmltYXRpb24uZHVyYXRpb24pO1xuICAgICAgICB9LCB0aGlzLl9kdXJhdGlvbnMpO1xuICAgIH0sXG5cbiAgICBfYW5pbWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2FuaW1JRCA9IERHLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcnVuKCk7XG4gICAgfSxcblxuICAgIF9ydW46IGZ1bmN0aW9uKGVsYXBzZWQpIHtcbiAgICAgICAgdmFyIGVsLCBpbmRleCwgcHJvZ3Jlc3M7XG4gICAgICAgIC8vICBQb3NzaWJsZSBza2lwIHplcm8gZGVsdGEgdGltZSBidXQgd2hvIGNhcmVzPyFcbiAgICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPyBlbGFwc2VkIDogbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9zdGFydFRpbWU7XG5cbiAgICAgICAgaWYgKGVsYXBzZWQgPCB0aGlzLl9kdXJhdGlvbnMuZ2V0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5fZHVyYXRpb25zLmdldEluZGV4KGVsYXBzZWQpO1xuICAgICAgICAgICAgZWwgPSB0aGlzLl9kdXJhdGlvbnMuZ2V0U2VnUmF0aW8oZWxhcHNlZCk7XG4gICAgICAgICAgICBwcm9ncmVzcyA9IHRoaXMuX2FuaW1hdGlvbltpbmRleF1bJ2Z1bmN0aW9uJ10uZ2V0WWJ5WChlbCk7XG4gICAgICAgICAgICB0aGlzLl9zdGVwKHRoaXMuX2dldEZyYW1lVmFsdWVzKGluZGV4LCBwcm9ncmVzcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9kdXJhdGlvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAodGhpcy5fZ2V0RnJhbWVWYWx1ZXMoaW5kZXgsIDEpKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3N0ZXA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB0aGlzLmZpcmUoJ3N0ZXAnLCBvYmopO1xuICAgIH0sXG5cbiAgICBfY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBERy5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSUQpO1xuXG4gICAgICAgIHRoaXMuX2R1cmF0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maXJlKCdlbmQnKTtcbiAgICB9LFxuXG4gICAgX2dldEZyYW1lVmFsdWVzOiBmdW5jdGlvbihpbmRleCwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuX2FuaW1hdGlvbltpbmRleF0uZnJhbWVzO1xuICAgICAgICB2YXIgb2JqID0ge3Byb2dyZXNzOiBwcm9ncmVzc307XG4gICAgICAgIHZhciBmciwgdG87XG5cbiAgICAgICAgaWYgKGZyYW1lcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGZyYW1lcykge1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZXNba2V5XS5wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGZyYW1lc1trZXldLnByb2dyZXNzKHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmciA9IGZyYW1lc1trZXldLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJhbWVzW2tleV0udG87XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gZnIgKyAodG8gLSBmcikgKiBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG59KTtcblxuREcuYW5pbWF0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuQW5pbWF0aW9uKG9wdGlvbnMpO1xufTtcblxuREcuQW5pbWF0aW9uLkxJTkVBUiAgICAgICAgID0gbmV3IERHLlRpbWVCZXppZXIoREcucG9pbnQoMC4wMCwgMC4wKSwgREcucG9pbnQoMS4wMCwgMS4wKSk7XG5ERy5BbmltYXRpb24uRUFTRSAgICAgICAgICAgPSBuZXcgREcuVGltZUJlemllcihERy5wb2ludCgwLjI1LCAwLjEpLCBERy5wb2ludCgwLjI1LCAxLjApKTtcbkRHLkFuaW1hdGlvbi5FQVNFX0lOICAgICAgICA9IG5ldyBERy5UaW1lQmV6aWVyKERHLnBvaW50KDAuNDIsIDAuMCksIERHLnBvaW50KDEuMDAsIDEuMCkpO1xuREcuQW5pbWF0aW9uLkVBU0VfSU5fT1VUICAgID0gbmV3IERHLlRpbWVCZXppZXIoREcucG9pbnQoMC40MiwgMC4wKSwgREcucG9pbnQoMC41OCwgMS4wKSk7XG5ERy5BbmltYXRpb24uRUFTRV9PVVQgICAgICAgPSBuZXcgREcuVGltZUJlemllcihERy5wb2ludCgwLjAwLCAwLjApLCBERy5wb2ludCgwLjU4LCAxLjApKTtcbiIsIi8qXG4gKiBERy5FbnRyYW5jZSBpcyBhIG1haW4gY2xhc3MgdGhhdCBob3N0cyBhY3R1YWwgYXJyb3cgbGF5ZXJzXG4gKiBJdCBvcmNoZXN0cmF0ZXMgYW5pbWF0aW9uIGFuZCBwcm92aWRlcyB1c2VyIHNwYWNlIG1ldGhvZHMgbGlrZSAuc2hvdygpIGFuZCAuaGlkZSgpXG4gKi9cblxuREcuRW50cmFuY2UgPSBERy5GZWF0dXJlR3JvdXAuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdmVjdG9yczogW10sXG5cbiAgICAgICAgZmlsbENvbG9yOiAnIzAwODVhMCcsXG4gICAgICAgIHN0cm9rZUNvbG9yOiAnI2ZmZicsXG5cbiAgICAgICAgZW5hYmxlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG5cbiAgICAgICAgYXV0b0Nsb3NlOiB0cnVlXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgREcuTGF5ZXJHcm91cC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIERHLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fYm91bmRzID1cbiAgICAgICAgICAgIG5ldyBERy5MYXRMbmdCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9ucyA9IHtcbiAgICAgICAgICAgIGJvdW5jZTogREcuYW5pbWF0aW9uKERHLkVudHJhbmNlLkJPVU5DRV9BTklNQVRJT04pLFxuICAgICAgICAgICAgcGF0aDogREcuYW5pbWF0aW9uKERHLkVudHJhbmNlLlBBVEhfQU5JTUFUSU9OKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2luaXRBcnJvd3MoKTtcblxuICAgICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgREcuTGF5ZXJHcm91cC5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgREcuTGF5ZXJHcm91cC5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgIH0sXG5cbiAgICBnZXRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnRzID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgIGV2ZW50c1snbGF5ZXJhZGQnXSA9IHRoaXMuX3JlbW92ZUVudHJhbmNlOyAgLy8gIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGV2ZW50c1snem9vbWVuZCddID0gdGhpcy5fYW5pbWF0ZTsgICAgICAgICAgLy8gIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlbnRzO1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbihmaXRCb3VuZHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgaWYgKGZpdEJvdW5kcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZml0Qm91bmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2hMYXllcihmdW5jdGlvbihhcnJvdykge1xuICAgICAgICAgICAgICAgICAgICBhcnJvdy5zZXRWaXNpYmlsaXR5KHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ2VudHJhbmNlc2hvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbGF5ZXJzICYmIHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uKGFycm93KSB7XG4gICAgICAgICAgICAgICAgYXJyb3cuc2V0VmlzaWJpbGl0eShmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5maXJlKCdlbnRyYW5jZWhpZGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpc1Nob3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd247XG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gICAgfSxcblxuICAgIHNldEZpbGxDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24oYXJyb3cpIHtcbiAgICAgICAgICAgIGFycm93LnNldFN0eWxlKHtmaWxsQ29sb3I6IGNvbG9yfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzZXRTdHJva2VDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24oYXJyb3cpIHtcbiAgICAgICAgICAgIGFycm93LnNldFN0eWxlKHtjb2xvcjogY29sb3J9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9pbml0QXJyb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJhc2UgPSB7XG4gICAgICAgICAgICBjb2xvcjogdGhpcy5vcHRpb25zLnN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgZmlsbENvbG9yOiB0aGlzLm9wdGlvbnMuZmlsbENvbG9yLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy52ZWN0b3JzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBERy5Xa3QudG9MYXRMbmdzKHZlY3Rvcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obGF0bG5ncykge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gREcuVXRpbC5jcmVhdGUoYmFzZSksXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcyA9IERHLmxhdExuZ0JvdW5kcyhsYXRsbmdzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5leHRlbmQoYm91bmRzKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMubGF0bG5ncyA9IGxhdGxuZ3M7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ib3VuZHMgPSBib3VuZHM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhdGxuZ3MubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB0aGlzLl9hbmltYXRpb25zLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHRoaXMuX2FuaW1hdGlvbnMuYm91bmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kaXN0YW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZExheWVyKERHLmVudHJhbmNlLmFycm93KG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cblxuICAgIF9hbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnMuYm91bmNlLnN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb25zLnBhdGguc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAgQ3VycmVudCBsb2dpYyBvZiBuZXh0IGZvdXIgbWV0aG9kcyBleHRyYWN0ZWQgZnJvbSBvcmlnaW5hbCBhcnJvdydzIGltcGxlbWVudGF0aW9uXG4gICAgZml0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCwgZml0Wm9vbSxcbiAgICAgICAgICAgIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cbiAgICAgICAgaWYgKCFtYXAuZ2V0Qm91bmRzKCkuY29udGFpbnMoYm91bmRzKSB8fCAhdGhpcy5faXNBbGxvd2VkWm9vbSgpKSB7XG4gICAgICAgICAgICBmaXRab29tID0gdGhpcy5fZ2V0Rml0Wm9vbSgpO1xuICAgICAgICAgICAgaWYgKCFtYXAucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKSkge1xuICAgICAgICAgICAgICAgIG1hcC5vbmNlKCdtb3ZlZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5zZXRab29tKHRoaXMuX2dldEZpdFpvb20oKSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXAuc2V0Vmlldyhib3VuZHMuZ2V0Q2VudGVyKCksIGZpdFpvb20sIHthbmltYXRlOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2dldEZpdFpvb206IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkubWF4Wm9vbSB8fCBERy5FbnRyYW5jZS5TSE9XX0ZST01fWk9PTTtcbiAgICB9LFxuXG4gICAgX2lzQWxsb3dlZFpvb206IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmdldFpvb20oKSA+PSBERy5FbnRyYW5jZS5TSE9XX0ZST01fWk9PTTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUVudHJhbmNlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmxheWVyIGluc3RhbmNlb2YgREcuUG9wdXAgfHxcbiAgICAgICAgICAgIChlLmxheWVyIGluc3RhbmNlb2YgREcuRW50cmFuY2UgJiYgZS5sYXllciAhPT0gdGhpcykpIHtcblxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5ERy5lbnRyYW5jZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLkVudHJhbmNlKG9wdGlvbnMpO1xufTtcblxuREcuRW50cmFuY2UuU0hPV19GUk9NX1pPT00gPSAxNjtcbkRHLkVudHJhbmNlLlBBVEhfQU5JTUFUSU9OID0ge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAnZnVuY3Rpb24nOiBERy5BbmltYXRpb24uRUFTRV9JTl9PVVQsXG4gICAgICAgICdkdXJhdGlvbic6IDc1MFxuICAgIH1cbn07XG5ERy5FbnRyYW5jZS5CT1VOQ0VfQU5JTUFUSU9OID0ge1xuICAgIGFuaW1hdGlvbjogW1xuICAgICAgICB7J2Z1bmN0aW9uJzogREcuQW5pbWF0aW9uLkVBU0VfSU5fT1VULCAnZHVyYXRpb24nOiAyNTAsICdmcmFtZXMnOiB7J2Rpc3RhbmNlJzogeydmcm9tJzogMCwgJ3RvJzogMC42fX19LFxuICAgICAgICB7J2Z1bmN0aW9uJzogREcuQW5pbWF0aW9uLkVBU0VfSU4sICdkdXJhdGlvbic6IDEzNSwgJ2ZyYW1lcyc6IHsnZGlzdGFuY2UnOiB7J2Zyb20nOiAwLjYsICd0byc6IDB9fX0sXG4gICAgICAgIHsnZnVuY3Rpb24nOiBERy5BbmltYXRpb24uRUFTRV9PVVQsICdkdXJhdGlvbic6IDEzNSwgJ2ZyYW1lcyc6IHsnZGlzdGFuY2UnOiB7J2Zyb20nOiAwLCAndG8nOiAwLjE2fX19LFxuICAgICAgICB7J2Z1bmN0aW9uJzogREcuQW5pbWF0aW9uLkVBU0VfSU4sICdkdXJhdGlvbic6IDkwLCAnZnJhbWVzJzogeydkaXN0YW5jZSc6IHsnZnJvbSc6IDAuMTYsICd0byc6IDB9fX0sXG4gICAgICAgIHsnZnVuY3Rpb24nOiBERy5BbmltYXRpb24uRUFTRV9PVVQsICdkdXJhdGlvbic6IDkwLCAnZnJhbWVzJzogeydkaXN0YW5jZSc6IHsnZnJvbSc6IDAsICd0byc6IDAuMDZ9fX0sXG4gICAgICAgIHsnZnVuY3Rpb24nOiBERy5BbmltYXRpb24uRUFTRV9JTiwgJ2R1cmF0aW9uJzogNTAsICdmcmFtZXMnOiB7J2Rpc3RhbmNlJzogeydmcm9tJzogMC4wNiwgJ3RvJzogMH19fVxuICAgIF1cbn07XG4iLCIvKlxuICogREcuRW50cmFuY2UuQXJyb3cgY2xhc3MgaG9zdHMgdHdvIGxheWVycywgb25lIGZvciBhcnJvdyBib2R5IChwYXRoKSBhbmQgb25lIGZvciBhcnJvdyB0aXBcbiAqIEl0IG92ZXJyaWRlcyBwcm9qZWN0aW9uIGV2ZW50cyBmcm9tIGhvc3RlZCBsYXllcnMgdG8gbWluaW1pemUgdG90YWwgb3ZlcmhlYWRcbiAqIEFjdHVhbCBjYWxjdWxhdGlvbnMgcHJvZHVjZWQgaW4gREcuQXJyb3dQYXRoVHJhbnNmb3JtIGFuZCBERy5BcnJvd1RpcFRyYW5zZm9ybSBjbGFzc2VzXG4gKi9cblxuREcuRW50cmFuY2UuQXJyb3cgPSBERy5GZWF0dXJlR3JvdXAuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIERHLkxheWVyR3JvdXAucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcblxuICAgICAgICBERy5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzID0gMTtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl92aXNpYmlsaXR5ID0ge1xuICAgICAgICAgICAgaXNTaG93bjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPVxuICAgICAgICAgICAgb3B0aW9ucy5sYXRsbmdzW29wdGlvbnMubGF0bG5ncy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5fc2hhcGUgPVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNoYXBlIHx8XG4gICAgICAgICAgICBERy5FbnRyYW5jZS5BcnJvdy5TSEFQRTtcblxuICAgICAgICB0aGlzLl9hcHQgPSB7fTsgLy8gREcuQXJyb3dQYXRoVHJhbnNmb3JtIG9iamVjdHMgYnkgem9vbSBsZXZlbHNcbiAgICAgICAgdGhpcy5fYXR0ID0ge307IC8vIERHLkFycm93VGlwVHJhbnNmb3JtIG9iamVjdHMgYnkgem9vbSBsZXZlbHNcbiAgICB9LFxuXG4gICAgYmVmb3JlQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgLy8gIHRoaXMuX21hcCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LCBzbyB3ZSBjYW4gZnJlZWx5IGFkZExheWVyKHMpXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIC8vICBUT0RPOiBDaGVjayBDYW52YXMgcHJvY2Vzc2luZyBvcmRlclxuICAgICAgICAvLyAgQWRkaXRpb25hbCBsb2dpYyB0byBESVNBQkxFIGFuaW1hdGlvbiBvbiBDYW52YXMgZm9yIG5vdyFcbiAgICAgICAgaWYgKG9wdHMuYW5pbWF0aW9uICYmICFtYXAub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgIURHLkJyb3dzZXIuaWVsdDkpIHtcbiAgICAgICAgICAgIG9wdHMuYW5pbWF0aW9uLm9uKCdzdGVwJywgdGhpcy5fYW5pbWF0aW9uLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvamVjdGlvbigpO1xuXG4gICAgICAgIHRoaXMuYWRkTGF5ZXIobmV3IERHLkNvbXBsZXhQYXRoKHtcbiAgICAgICAgICAgIGxpbmVDYXA6ICdidXR0JyxcbiAgICAgICAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgICAgICAgZmlsbENvbG9yOiBvcHRzLmZpbGxDb2xvcixcbiAgICAgICAgICAgIGludGVyYWN0aXZlOiBvcHRzLmludGVyYWN0aXZlLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogdGhpcy5fdmlzaWJpbGl0eSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fYXB0XG4gICAgICAgIH0pKTtcblxuICAgICAgICB0aGlzLmFkZExheWVyKG5ldyBERy5Db21wbGV4UGF0aCh7XG4gICAgICAgICAgICBsaW5lSm9pbjogJ21pdGVyJyxcbiAgICAgICAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgICAgICAgZmlsbENvbG9yOiBvcHRzLmZpbGxDb2xvcixcbiAgICAgICAgICAgIGludGVyYWN0aXZlOiBvcHRzLmludGVyYWN0aXZlLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogdGhpcy5fdmlzaWJpbGl0eSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fYXR0XG4gICAgICAgIH0pKTtcbiAgICB9LFxuXG4gICAgZ2V0RXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHpvb21lbmQ6IHRoaXMuX3Byb2plY3QsXG4gICAgICAgICAgICBtb3ZlZW5kOiB0aGlzLl91cGRhdGUsXG4gICAgICAgICAgICB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHNldFZpc2liaWxpdHk6IGZ1bmN0aW9uKGlzU2hvd24pIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2liaWxpdHkuaXNTaG93biAhPT0gaXNTaG93bikge1xuICAgICAgICAgICAgdGhpcy5fdmlzaWJpbGl0eS5pc1Nob3duID0gaXNTaG93bjtcbiAgICAgICAgICAgIGlmIChpc1Nob3duKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm91bmRzO1xuICAgIH0sXG5cbiAgICBwcm9qZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCB8fCB0aGlzLl9tYXBUb0FkZDtcbiAgICAgICAgdmFyIHpvb20gPSBtYXAgPyBtYXAuZ2V0Wm9vbSgpIDogMDtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5fc2hhcGUudmVydGljZXNbem9vbV07XG4gICAgICAgIHZhciBkcmF3aW5ncyA9IHRoaXMuX3NoYXBlLmRyYXdpbmdzW3pvb21dO1xuICAgICAgICB2YXIgbGF0bG5ncyA9IHRoaXMub3B0aW9ucy5sYXRsbmdzO1xuICAgICAgICB2YXIgc2hhcGUsIHBhdGgsIGxhc3RQb2ludCwgcHJldlBvaW50O1xuXG4gICAgICAgIGlmICh6b29tICYmIHZlcnRpY2VzICYmIGRyYXdpbmdzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dFt6b29tXSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBERy5BcnJvd1BhdGhUcmFuc2Zvcm0uZ2V0VHJhbnNsYXRlZFBhdGgobWFwLCBsYXRsbmdzKTtcbiAgICAgICAgICAgICAgICBzaGFwZSA9IHt2ZXJ0aWNlczogdmVydGljZXMsIGRyYXdpbmdzOiBkcmF3aW5nc307XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0W3pvb21dID0gbmV3IERHLkFycm93VGlwVHJhbnNmb3JtKHBhdGgsIHNoYXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHRbem9vbV0gPSBuZXcgREcuQXJyb3dQYXRoVHJhbnNmb3JtKHBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0UG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX3Bvc2l0aW9uKTtcbiAgICAgICAgICAgIHByZXZQb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nc1tsYXRsbmdzLmxlbmd0aCAtIDJdKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXB0W3pvb21dLl9weEJvdW5kcykge1xuICAgICAgICAgICAgICAgIC8vICBPbmUtdGltZSBhY3Rpb24gcGVyICd2aWV3cmVzZXQnIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gIENhY2hpbmcgX3B4Qm91bmRzIGZvciB1c2luZyB3aXRoIENhbnZhcyByZW5kZXJlclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEJvdW5kcyhsYXN0UG9pbnQsIHByZXZQb2ludCwgdGhpcy5fYXB0W3pvb21dLCB0aGlzLl9hdHRbem9vbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIC8vICBBcnJvdyBwb3NpdGlvbiByZWNhbGN1bGF0ZWQgZm9yIEJvdW5jZSBhbmltYXRpb24gZWZmZWN0XG4gICAgICAgICAgICAgICAgbGFzdFBvaW50ID0gREcuVmVydGV4VHJhbnNmb3JtLmdldFNjYWxlZChsYXN0UG9pbnQsIHByZXZQb2ludCwgdGhpcy5fZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgTWFpbiBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgIC8vICBHZXQgcGFydCBvZiB0aGUgYXJyb3cgcGF0aCBhbmQgbW92ZSAoYm91bmQpIGFycm93IHRpcCB0byBpdFxuICAgICAgICAgICAgdGhpcy5fYXB0W3pvb21dLnN1YlBhdGgodGhpcy5fcHJvZ3Jlc3MpLnRyYW5zbGF0ZShsYXN0UG9pbnQpO1xuICAgICAgICAgICAgdGhpcy5fYXR0W3pvb21dLnN1YlNoYXBlKHRoaXMuX2FwdFt6b29tXSkudHJhbnNsYXRlKGxhc3RQb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FuaW1hdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5kaXN0YW5jZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gZS5kaXN0YW5jZTsgICAgLy8gIGJvdW5jZSBhbmltYXRpb24gZWZmZWN0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IGUucHJvZ3Jlc3M7ICAgIC8vICBwYXRoIGFuaW1hdGlvbiBlZmZlY3RcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdmlzaWJpbGl0eS5pc1Nob3duKSB7XG4gICAgICAgICAgICAvLyAgVE9ETzogQWRkaXRpb25hbCBsb2dpYyBmb3IgYW5pbWF0aW9uIG9uIENhbnZhc1xuICAgICAgICAgICAgLy8gdGhpcy5wcm9qZWN0aW9uKCkuaW52b2tlKCdyZWRyYXcnKTtcblxuICAgICAgICAgICAgdGhpcy5fcHJvamVjdCgpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Byb2plY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByb2plY3Rpb24oKS5pbnZva2UoJ19wcm9qZWN0Jyk7XG4gICAgfSxcblxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmludm9rZSgnX3VwZGF0ZScpO1xuICAgIH0sXG5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9yZXNldEJvdW5kcygpO1xuXG4gICAgICAgIHRoaXMuX3Byb2plY3QoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfSxcblxuICAgIF9yZXNldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICBDYW52YXMgcmVuZGVyZXIgc3BlY2lmaWNcbiAgICAgICAgdmFyIHo7XG5cbiAgICAgICAgZm9yICh6IGluIHRoaXMuX2FwdCkge1xuICAgICAgICAgICAgdGhpcy5fYXB0W3pdLl9weEJvdW5kcyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHogaW4gdGhpcy5fYXR0KSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRbel0uX3B4Qm91bmRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0Qm91bmRzOiBmdW5jdGlvbihwbCwgcHAsIGFwdCwgYXR0KSB7XG4gICAgICAgIHZhciBfYXB0ID0gYXB0LnN1YlBhdGgoMSkudHJhbnNsYXRlKHBsKS52ZXJ0aWNlcyxcbiAgICAgICAgICAgIF9hdHQgPSBhdHQuc3ViU2hhcGUoYXB0KS50cmFuc2xhdGUocGwpLnZlcnRpY2VzO1xuXG4vKlxuICAgICAgICAvLyAgVE9ETzogQWRkaXRpb25hbCBsb2dpYyBmb3IgYW5pbWF0aW9uIG9uIENhbnZhc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBwbCA9IERHLlZlcnRleFRyYW5zZm9ybS5nZXRTY2FsZWQocGwsIHBwLCAxKTtcbiAgICAgICAgICAgIF9hcHQgPSBfYXB0LmNvbmNhdChhcHQuc3ViUGF0aCgxKS50cmFuc2xhdGUocGwpLnZlcnRpY2VzKTtcbiAgICAgICAgICAgIF9hdHQgPSBfYXR0LmNvbmNhdChhdHQuc3ViU2hhcGUoYXB0KS50cmFuc2xhdGUocGwpLnZlcnRpY2VzKTtcbiAgICAgICAgfVxuKi9cbiAgICAgICAgYXB0Ll9weEJvdW5kcyA9IG5ldyBERy5Cb3VuZHMoX2FwdCk7XG4gICAgICAgIGF0dC5fcHhCb3VuZHMgPSBuZXcgREcuQm91bmRzKF9hdHQpO1xuICAgIH1cbn0pO1xuXG5ERy5lbnRyYW5jZS5hcnJvdyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLkVudHJhbmNlLkFycm93KG9wdGlvbnMpO1xufTtcbiIsIi8qXG4gKiBQcmVkZWZpbmVkIGFycm93IHRpcHNcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbkRHLkVudHJhbmNlLkFycm93LlNIQVBFID0ge1xuICAgIHZlcnRpY2VzOiB7XG4gICAgICAgIDE2OiBbXG4gICAgICAgICAgICBbIC02LjUwMDAsICAtMS44MDAwXSxcbiAgICAgICAgICAgIFsgLTYuMDUyMiwgIC0xLjgwMDBdLFxuICAgICAgICAgICAgWyAtNy4wOTc1LCAgLTUuMjUzN10sXG4gICAgICAgICAgICBbIC02LjY2MTksICAtNi4yNTY1XSwgWyAtNi41OTgwLCAgLTYuMzU1MF0sIFsgLTYuMTc1NywgIC02LjE0NzBdLFxuICAgICAgICAgICAgWyAgMC44MzcxLCAgLTAuMzU1Ml0sXG4gICAgICAgICAgICBbICAwLjkyNzUsICAtMC4xNzY0XSwgWyAgMC45Mjc1LCAgIDAuMTc2NF0sIFsgIDAuODM3MSwgICAwLjM1NTJdLFxuICAgICAgICAgICAgWyAtNi4xNzU3LCAgIDYuMTQ3MF0sXG4gICAgICAgICAgICBbIC02LjU5ODAsICAgNi4zNTUwXSwgWyAtNi42NjE5LCAgIDYuMjU2NV0sIFsgLTcuMDk3NSwgICA1LjI1MzddLFxuICAgICAgICAgICAgWyAtNi4wNTIyLCAgIDEuODAwMF0sXG4gICAgICAgICAgICBbIC02LjUwMDAsICAgMS44MDAwXVxuICAgICAgICBdLFxuICAgICAgICAxNzogW1xuICAgICAgICAgICAgWyAtOS4wMDAwLCAgLTIuNDAwMF0sXG4gICAgICAgICAgICBbIC03Ljg4OTAsICAtMi40MDAwXSxcbiAgICAgICAgICAgIFsgLTkuOTI0NSwgIC03LjI1NDhdLFxuICAgICAgICAgICAgWyAtOS4zMzYzLCAgLTguNjQwNF0sIFsgLTkuMzQ0OCwgIC04LjY0NDhdLCBbIC04Ljg3MTcsICAtOC4zNTA4XSxcbiAgICAgICAgICAgIFsgIDEuMDI4NSwgIC0wLjM1NTJdLFxuICAgICAgICAgICAgWyAgMS4xMTkwLCAgLTAuMTc2NF0sIFsgIDEuMTE5MCwgICAwLjE3NjRdLCBbICAxLjAyODUsICAgMC4zNTUyXSxcbiAgICAgICAgICAgIFsgLTguODcxNywgICA4LjM1MDhdLFxuICAgICAgICAgICAgWyAtOS4zNDQ4LCAgIDguNjQ0OF0sIFsgLTkuMzM2MywgICA4LjY0MDRdLCBbIC05LjkyNDUsICAgNy4yNTQ4XSxcbiAgICAgICAgICAgIFsgLTcuODg5MCwgICAyLjQwMDBdLFxuICAgICAgICAgICAgWyAtOS4wMDAwLCAgIDIuNDAwMF1cbiAgICAgICAgXSxcbiAgICAgICAgMTg6IFtcbiAgICAgICAgICAgIFstMTEuNTAwMCwgIC0zLjAwMDBdLFxuICAgICAgICAgICAgWy0xMC4wNzk1LCAgLTMuMDAwMF0sXG4gICAgICAgICAgICBbLTEyLjQ5MDksICAtOS4zMTczXSxcbiAgICAgICAgICAgIFstMTEuODQwMiwgLTEwLjc2NTRdLCBbLTExLjU5ODYsIC0xMC43MDczXSwgWy0xMC45MzgwLCAtMTAuMjI1OF0sXG4gICAgICAgICAgICBbICAxLjE0OTcsICAtMC4zNTUyXSxcbiAgICAgICAgICAgIFsgIDEuMjQwMiwgIC0wLjE3NjRdLCBbICAxLjI0MDIsICAgMC4xNzY0XSwgWyAgMS4xNDk3LCAgIDAuMzU1Ml0sXG4gICAgICAgICAgICBbLTEwLjkzODAsICAxMC4yMjU4XSxcbiAgICAgICAgICAgIFstMTEuNTk4NiwgIDEwLjcwNzNdLCBbLTExLjg0MDIsICAxMC43NjU0XSwgWy0xMi40OTA5LCAgIDkuMzE3M10sXG4gICAgICAgICAgICBbLTEwLjA3OTUsICAgMy4wMDAwXSxcbiAgICAgICAgICAgIFstMTEuNTAwMCwgICAzLjAwMDBdXG4gICAgICAgIF0sXG4gICAgICAgIDE5OiBbXG4gICAgICAgICAgICBbLTEzLjAwMDAsICAtMy42MDAwXSxcbiAgICAgICAgICAgIFstMTEuNjYwMCwgIC0zLjYwMDBdLFxuICAgICAgICAgICAgWy0xNC4xNjk2LCAtMTAuODM1MV0sXG4gICAgICAgICAgICBbLTEzLjUxODksIC0xMi4yODMyXSwgWy0xMy4yNzczLCAtMTIuMjI1MV0sIFstMTIuNjE2NywgLTExLjc0MzZdLFxuICAgICAgICAgICAgWyAgMS4zMDYxLCAgLTAuMzU1Ml0sXG4gICAgICAgICAgICBbICAxLjM5NjYsICAtMC4xNzY0XSwgWyAgMS4zOTY2LCAgIDAuMTc2NF0sIFsgIDEuMzA2MSwgICAwLjM1NTJdLFxuICAgICAgICAgICAgWy0xMi42MTY3LCAgMTEuNzQzNl0sXG4gICAgICAgICAgICBbLTEzLjI3NzMsICAxMi4yMjUxXSwgWy0xMy41MTg5LCAgMTIuMjgzMl0sIFstMTQuMTY5NiwgIDEwLjgzNTFdLFxuICAgICAgICAgICAgWy0xMS42NjAwLCAgIDMuNjAwMF0sXG4gICAgICAgICAgICBbLTEzLjAwMDAsICAgMy42MDAwXVxuICAgICAgICBdXG4gICAgfSxcbiAgICBkcmF3aW5nczoge1xuICAgICAgICAxNjogWydNJywgJ0wnLCAnTCcsICdDJywgJ0wnLCAnQycsICdMJywgJ0MnLCAnTCcsICdMJ10sXG4gICAgICAgIDE3OiBbJ00nLCAnTCcsICdMJywgJ0MnLCAnTCcsICdDJywgJ0wnLCAnQycsICdMJywgJ0wnXSxcbiAgICAgICAgMTg6IFsnTScsICdMJywgJ0wnLCAnQycsICdMJywgJ0MnLCAnTCcsICdDJywgJ0wnLCAnTCddLFxuICAgICAgICAxOTogWydNJywgJ0wnLCAnTCcsICdDJywgJ0wnLCAnQycsICdMJywgJ0MnLCAnTCcsICdMJ11cbiAgICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSBhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuXG4oZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICBmb3IgKHZhciBpIGluIHZlcnRpY2VzKSB7XG4gICAgICAgIHZlcnRpY2VzW2ldID0gdmVydGljZXNbaV0ubWFwKGZ1bmN0aW9uKHZlcnRleCkgeyByZXR1cm4gREcucG9pbnQodmVydGV4KTsgfSk7XG4gICAgfVxufSkoREcuRW50cmFuY2UuQXJyb3cuU0hBUEUudmVydGljZXMpO1xuIiwiREcuTGFiZWwgPSBERy5MYXllci5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBvZmZzZXQ6IG5ldyBERy5Qb2ludCgxMiwgMTUpLFxuICAgICAgICBjbGFzc05hbWU6ICdkZy1sYWJlbCcsXG4gICAgICAgIHpJbmRleE9mZnNldDogMFxuICAgIH0sXG5cbiAgICBfdHlwZU9mU3RyaW5nIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCdzJyksXG4gICAgX2RlZmF1bHRaSW5kZXg6IDEwMCxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgREcuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2FuaW1hdGVkID0gREcuQnJvd3Nlci5hbnkzZDtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuXG4gICAgICAgIGlmICghdGhpcy5fZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRET00oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC5zZXRDb250ZW50KHRoaXMuX2NvbnRlbnQpXG4gICAgICAgICAgICAuX29uVmlld1Jlc2V0KCk7XG5cbiAgICAgICAgbWFwXG4gICAgICAgICAgICAub24oJ3ZpZXdyZXNldCcsIHRoaXMuX29uVmlld1Jlc2V0LCB0aGlzKVxuICAgICAgICAgICAgLm9uKCd6b29tYW5pbScsIHRoaXMuX29uWm9vbUFuaW1hdGlvbiwgdGhpcyk7XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgbWFwXG4gICAgICAgICAgICAub2ZmKCd2aWV3cmVzZXQnLCB0aGlzLl9vblZpZXdSZXNldCwgdGhpcylcbiAgICAgICAgICAgIC5vZmYoJ3pvb21hbmltJywgdGhpcy5fb25ab29tQW5pbWF0aW9uLCB0aGlzKTtcblxuICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgREcuVXRpbC5mYWxzZUZuKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aCk7IC8vIHdlIG5lZWQgcmVmbG93IGhlcmVcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcblxuICAgICAgICBtYXAuZ2V0UGFuZXMoKS50b29sdGlwUGFuZS5yZW1vdmVDaGlsZCh0aGlzLl9lbCk7XG4gICAgICAgIHRoaXMuX2VsID0gbnVsbDtcbiAgICB9LFxuXG4gICAgX2luaXRET006IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9lbCA9IERHLkRvbVV0aWwuY3JlYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl9hbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLmdldFBhbmVzKCkudG9vbHRpcFBhbmUpO1xuICAgICAgICB0aGlzLl9lbC5zdHlsZS56SW5kZXggPSB0aGlzLl9kZWZhdWx0WkluZGV4ICsgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldDtcblxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSArICdfX2NvbnRlbnQnLCB0aGlzLl9lbCk7XG4gICAgICAgIERHLkRvbUV2ZW50XG4gICAgICAgICAgICAuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fZWwpXG4gICAgICAgICAgICAub24odGhpcy5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIERHLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgIC5vbih0aGlzLl9jb250YWluZXIsICdjb250ZXh0bWVudScsIERHLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XG4gICAgfSxcblxuICAgIF9vblZpZXdSZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl92aXNpYmxlICYmIHRoaXMuX2xhdGxuZykge1xuICAgICAgICAgICAgREcuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLmFkZCh0aGlzLm9wdGlvbnMub2Zmc2V0KSwgREcuQnJvd3Nlci5pZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uWm9vbUFuaW1hdGlvbjogZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXRsbmcpIHtcbiAgICAgICAgICAgIERHLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpLmFkZCh0aGlzLm9wdGlvbnMub2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0T2Zmc2V0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICBpZiAocG9pbnQgaW5zdGFuY2VvZiBERy5Qb2ludCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9mZnNldCA9IHBvaW50O1xuICAgICAgICAgICAgdGhpcy5fb25WaWV3UmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbih6SW5kZXgpIHtcbiAgICAgICAgaWYgKCFpc05hTigrekluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9ICt6SW5kZXg7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsLnN0eWxlLnpJbmRleCA9IHRoaXMuX2RlZmF1bHRaSW5kZXggKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29udGVudCkgIT09IHRoaXMuX3R5cGVPZlN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICBpZiAoIShsYXRsbmcgaW5zdGFuY2VvZiBERy5MYXRMbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xhdGxuZyA9IGxhdGxuZztcbiAgICAgICAgdGhpcy5fb25WaWV3UmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG5cbkRHLmxhYmVsID0gZnVuY3Rpb24oY29udGVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuTGFiZWwoY29udGVudCwgb3B0aW9ucyk7XG59O1xuIiwiREcuTWFya2VyLmluY2x1ZGUoe1xuXG4gICAgYmluZExhYmVsOiBmdW5jdGlvbihjb250ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0Q29udGVudChjb250ZW50KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgIT09IG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLnNldE9mZnNldCh0aGlzLm9wdGlvbnMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YXRpYyAhPT0gb3B0aW9ucy5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmJpbmRMYWJlbCgpLmJpbmRMYWJlbChjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gREcuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG5ldyBERy5Qb2ludCg1LCA1KVxuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gREcubGFiZWwoY29udGVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHRoaXMub25jZSgncmVtb3ZlJywgdGhpcy5fb25NYXJrZXJSZW1vdmUpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dMYWJlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgdGhpcy5fbW91c2VPdmVyTGFiZWwpXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCB0aGlzLl9tb3VzZU91dExhYmVsKVxuICAgICAgICAgICAgICAgICAgICAub24oJ2RyYWdzdGFydCcsIHRoaXMuX2RyYWdTdGFydExhYmVsKVxuICAgICAgICAgICAgICAgICAgICAub24oJ2RyYWdlbmQnLCB0aGlzLl9kcmFnRW5kTGFiZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX21hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYWJlbFpJbmRleCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2FkZCcsIHRoaXMuX3VwZGF0ZUxhYmVsWkluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5iaW5kTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAuaGlkZUxhYmVsKClcbiAgICAgICAgICAgICAgICAub2ZmKCdyZW1vdmUnLCB0aGlzLnVuYmluZExhYmVsKVxuICAgICAgICAgICAgICAgIC5vZmYoJ21vdXNlb3ZlcicsIHRoaXMuX21vdXNlT3ZlckxhYmVsKVxuICAgICAgICAgICAgICAgIC5vZmYoJ21vdXNlb3V0JywgdGhpcy5fbW91c2VPdXRMYWJlbClcbiAgICAgICAgICAgICAgICAub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9kcmFnU3RhcnRMYWJlbClcbiAgICAgICAgICAgICAgICAub2ZmKCdkcmFnZW5kJywgdGhpcy5fZHJhZ0VuZExhYmVsKVxuICAgICAgICAgICAgICAgIC5vZmYoJ21vdmUnLCB0aGlzLl91cGRhdGVQb3NpdGlvbilcbiAgICAgICAgICAgICAgICAub2ZmKCdhZGQnLCB0aGlzLl91cGRhdGVMYWJlbFpJbmRleCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX29uTWFya2VyUmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuX2xhYmVsLl9jb250ZW50O1xuICAgICAgICAgICAgdGhpcy5vbmNlKCdhZGQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHsgcmV0dXJuOyB9IC8vIG5ldyBsYWJlbCBhZGRlZCBhZnRlciByZW1vdmluZyBtYXJrZXJcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRMYWJlbChjb250ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51bmJpbmRMYWJlbCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldExhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsID8gdGhpcy5fbGFiZWwgOiBudWxsO1xuICAgIH0sXG5cbiAgICBfb3JpZ2luYWxVcGRhdGVaSW5kZXg6IERHLk1hcmtlci5wcm90b3R5cGUuX3VwZGF0ZVpJbmRleCxcbiAgICBfdXBkYXRlWkluZGV4OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl96SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3pJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3JpZ2luYWxVcGRhdGVaSW5kZXgob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWxaSW5kZXgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF91cGRhdGVMYWJlbFpJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCAmJiB0aGlzLl9pY29uKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5zZXRaSW5kZXhPZmZzZXQodGhpcy5faWNvbi5zdHlsZS56SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzaG93TGFiZWwgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgLm9uKCdtb3ZlJywgdGhpcy5fdXBkYXRlUG9zaXRpb24pXG4gICAgICAgICAgICAgICAgLl9tYXAuYWRkTGF5ZXIodGhpcy5fbGFiZWwuc2V0UG9zaXRpb24odGhpcy5nZXRMYXRMbmcoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGhpZGVMYWJlbCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAub2ZmKCdtb3ZlJywgdGhpcy5fdXBkYXRlUG9zaXRpb24pXG4gICAgICAgICAgICAgICAgLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlUG9zaXRpb24gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbGFiZWwuc2V0UG9zaXRpb24odGhpcy5nZXRMYXRMbmcoKSk7XG4gICAgfSxcblxuICAgIF9kcmFnU3RhcnRMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsLmlzTWFya2VyRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuaGlkZUxhYmVsKCk7XG4gICAgfSxcblxuICAgIF9kcmFnRW5kTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9sYWJlbC5pc01hcmtlckRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsLmlzTW91c2VPdmVyTWFya2VyKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dMYWJlbCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9tb3VzZU92ZXJMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsLmlzTW91c2VPdmVyTWFya2VyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2xhYmVsLmlzTWFya2VyRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0xhYmVsKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX21vdXNlT3V0TGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9sYWJlbC5pc01vdXNlT3Zlck1hcmtlciA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaGlkZUxhYmVsKCk7XG4gICAgfVxufSk7XG5cbkRHLk1hcmtlci5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5iaW5kTGFiZWwodGhpcy5vcHRpb25zLmxhYmVsKTtcbiAgICB9XG59KTtcbiIsIkRHLlBhdGguaW5jbHVkZSh7XG4gICAgYmluZExhYmVsOiBmdW5jdGlvbihjb250ZW50LCBvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBERy5sYWJlbChjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMub24odGhpcy5fbGFiZWxFdmVudHMsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0Q29udGVudChjb250ZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsLm9wdGlvbnMub2Zmc2V0ICE9PSBvcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLnNldE9mZnNldChvcHRpb25zLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVuYmluZExhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm9mZih0aGlzLl9sYWJlbEV2ZW50cywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGFiZWwpO1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYWJlbCA/IHRoaXMuX2xhYmVsIDogbnVsbDtcbiAgICB9LFxuXG4gICAgX2xhYmVsRXZlbnRzIDoge1xuICAgICAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fbGFiZWwuc2V0UG9zaXRpb24oZXZlbnQubGF0bG5nKSk7XG4gICAgICAgICAgICBERy5Eb21FdmVudC5zdG9wKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0UG9zaXRpb24oZXZlbnQubGF0bG5nKTtcbiAgICAgICAgICAgIERHLkRvbUV2ZW50LnN0b3AoZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGFiZWwpO1xuICAgICAgICAgICAgREcuRG9tRXZlbnQuc3RvcChldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGFiZWwpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLlBhdGguYWRkSW5pdEhvb2soZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubGFiZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuYmluZExhYmVsKHRoaXMub3B0aW9ucy5sYWJlbCk7XG4gICAgfVxufSk7XG4iLCJERy5FbnRyYW5jZS5pbmNsdWRlKHtcbiAgICBiaW5kTGFiZWw6IGZ1bmN0aW9uKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbCA9IERHLmxhYmVsKGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5vbih0aGlzLl9sYWJlbEV2ZW50cywgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwub3B0aW9ucy5vZmZzZXQgIT09IG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0T2Zmc2V0KG9wdGlvbnMub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5iaW5kTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHRoaXMuX2xhYmVsRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbCk7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldExhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsID8gdGhpcy5fbGFiZWwgOiBudWxsO1xuICAgIH0sXG5cbiAgICBfbGFiZWxFdmVudHMgOiB7XG4gICAgICAgIG1vdXNlb3ZlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl9sYWJlbC5zZXRQb3NpdGlvbihldmVudC5sYXRsbmcpKTtcbiAgICAgICAgICAgIERHLkRvbUV2ZW50LnN0b3AoZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5zZXRQb3NpdGlvbihldmVudC5sYXRsbmcpO1xuICAgICAgICAgICAgREcuRG9tRXZlbnQuc3RvcChldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnJlbW92ZSgpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuREcuRW50cmFuY2UuYWRkSW5pdEhvb2soZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubGFiZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuYmluZExhYmVsKHRoaXMub3B0aW9ucy5sYWJlbCk7XG4gICAgfVxufSk7XG4iLCJERy5jb25maWdUaGVtZSA9IERHLmNvbmZpZ1RoZW1lIHx8IHt9O1xuXG5ERy5jb25maWdUaGVtZS5iYWxsb29uT3B0aW9ucyA9IHtcbiAgICBvZmZzZXQ6IHtcbiAgICAgICAgeDogMSxcbiAgICAgICAgeTogLTQzXG4gICAgfVxufTtcbiIsInJlcXVpcmUoJy4uLy4uLy4uL3ZlbmRvcnMvYmFyb24nKTtcblxuLy8gMkdJUy1yZWxhdGVkIHBvcHVwIGNvbnRlbnQgd3JhcHBlciBhbmQgb2Zmc2V0XG4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9mZnNldFggPSBERy5jb25maWdUaGVtZS5iYWxsb29uT3B0aW9ucy5vZmZzZXQueCxcbiAgICAgICAgb2Zmc2V0WSA9IERHLmNvbmZpZ1RoZW1lLmJhbGxvb25PcHRpb25zLm9mZnNldC55LFxuICAgICAgICBvcmlnaW5hbEluaXRpYWxpemUgPSBERy5Qb3B1cC5wcm90b3R5cGUuaW5pdGlhbGl6ZSxcbiAgICAgICAgb3JpZ2luYWxJbml0TGF5b3V0ID0gREcuUG9wdXAucHJvdG90eXBlLl9pbml0TGF5b3V0LFxuICAgICAgICBvcmlnaW5hbE9uQWRkID0gREcuUG9wdXAucHJvdG90eXBlLm9uQWRkLFxuICAgICAgICBvcmlnaW5hbEFkanVzdFBhbiA9IERHLlBvcHVwLnByb3RvdHlwZS5fYWRqdXN0UGFuLFxuICAgICAgICBncmFmID0gYmFyb24ubm9Db25mbGljdCgpO1xuXG4gICAgdmFyIEJhcm9uRG9tSGVscGVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB0aGlzWzBdID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH07XG4gICAgQmFyb25Eb21IZWxwZXIucHJvdG90eXBlID0ge1xuICAgICAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzWzBdLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QXR0cmlidXRlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUF0dHJpYnV0ZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdGhpc1swXS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY3NzOiBmdW5jdGlvbihzdHlsZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXNbMF0uc3R5bGVbc3R5bGVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBERy5Eb21VdGlsLmdldFN0eWxlKHRoaXNbMF0sIHN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBERy5Qb3B1cC5wcm90b3R5cGUub3B0aW9ucy5vZmZzZXQgPSBERy5wb2ludChvZmZzZXRYLCBvZmZzZXRZKTtcblxuICAgIERHLlBvcHVwLm1lcmdlT3B0aW9ucyh7XG4gICAgICAgIGJvcmRlcjogMTYsXG4gICAgICAgIG1hcENvbnRyb2xzV2lkdGg6IDYwXG4gICAgfSk7XG5cbiAgICBERy5Qb3B1cC5pbmNsdWRlKHtcbiAgICAgICAgX2hlYWRlckNvbnRlbnQ6IG51bGwsXG4gICAgICAgIF9mb290ZXJDb250ZW50OiBudWxsLFxuXG4gICAgICAgIC8vYmFyb24gZWxlbWVudHMgcmVmZXJlbmNlc1xuICAgICAgICBfc2Nyb2xsZXI6IG51bGwsXG4gICAgICAgIF9zY3JvbGxlckJhcjogbnVsbCxcbiAgICAgICAgX2JhcldyYXBwZXI6IG51bGwsXG4gICAgICAgIF9iYXJvbjogbnVsbCxcbiAgICAgICAgX2lzQmFyb25FeGlzdDogZmFsc2UsXG5cbiAgICAgICAgX3BvcHVwU2hvd0NsYXNzOiAnbGVhZmxldC1wb3B1cF9zaG93X3RydWUnLFxuICAgICAgICBfcG9wdXBIaWRlQ2xhc3M6ICdsZWFmbGV0LXBvcHVwX3Nob3dfZmFsc2UnLFxuXG4gICAgICAgIF9wb3B1cFRpcENsYXNzOiAnbGVhZmxldC1wb3B1cC10aXAtY29udGFpbmVyJyxcbiAgICAgICAgX3RpcFNWR1BhdGg6ICdNMCAwYzEyLjY0MyAwIDI4IDcuMTE1IDI4IDQ0aDJjMC0zNi44ODUgMTUuMzU4LTQ0IDI4LTQ0aC01OHonLFxuXG4gICAgICAgIF9pc0F1dG9QYW5QYWRkaW5nVXNlckRlZmluZWQ6IGZhbHNlLFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIHNvdXJjZSkgeyAvLyAoT2JqZWN0LCBPYmplY3QpXG4gICAgICAgICAgICB0aGlzLl9wb3B1cFN0cnVjdHVyZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5faXNBdXRvUGFuUGFkZGluZ1VzZXJEZWZpbmVkID0gb3B0aW9ucyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KCdhdXRvUGFuUGFkZGluZycpO1xuICAgICAgICAgICAgb3JpZ2luYWxJbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucywgc291cmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7IC8vIChNYXApXG4gICAgICAgICAgICBtYXAub24oe1xuICAgICAgICAgICAgICAgIGVudHJhbmNlc2hvdzogdGhpcy5fY2xvc2VQb3B1cCxcbiAgICAgICAgICAgICAgICByZXNpemU6IHRoaXMucmVzaXplXG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIG9yaWdpbmFsT25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZU9wZW5pbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7IC8vIChNYXApXG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlQ2xvc2luZygpO1xuICAgICAgICAgICAgbWFwLm9mZih7XG4gICAgICAgICAgICAgICAgZW50cmFuY2VzaG93OiB0aGlzLl9jbG9zZVBvcHVwLFxuICAgICAgICAgICAgICAgIHJlc2l6ZTogdGhpcy5yZXNpemVcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoREcuRG9tVXRpbC5UUkFOU0lUSU9OKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKEwuRG9tVXRpbC5yZW1vdmUsIEwuRG9tVXRpbCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXAuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7IC8vIChET01FbGVtZW50IHwgT2JqZWN0IHwgSFRNTCkgLT4gUG9wdXBcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNOb2RlKGNvbnRlbnQpICYmIHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRlbnQpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGl0ZW0gKyAnQ29udGVudCddID0gY29udGVudFtpdGVtXTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keUNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRIZWFkZXJDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7IC8vIChIVE1MKSAtPiBQb3B1cFxuICAgICAgICAgICAgdGhpcy5faGVhZGVyQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRGb290ZXJDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7IC8vIChIVE1MKSAtPiBQb3B1cFxuICAgICAgICAgICAgdGhpcy5fZm9vdGVyQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb250ZW50OiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gSFRNTFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHlDb250ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEhlYWRlckNvbnRlbnQ6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBIVE1MXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyQ29udGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRGb290ZXJDb250ZW50OiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gSFRNTFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvb3RlckNvbnRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBQb3B1cFxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcG9wdXBTdHJ1Y3R1cmUpLmZvckVhY2godGhpcy5fY2xlYXJFbGVtZW50LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gdGhpbmsgYWJvdXQgbW92ZSB0aGlzIHNldCB0byBhbm90aGVyIHB1YmxpYyBtZXRob2RcbiAgICAgICAgICAgIHRoaXMuX2lzQmFyb25FeGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJIZWFkZXI6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBQb3B1cFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyRWxlbWVudCgnaGVhZGVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJGb290ZXI6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBQb3B1cFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyRWxlbWVudCgnZm9vdGVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluZEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHsgLy8gKFN0cmluZykgLT4gRE9NRWxlbWVudFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FuaW1hdGVPcGVuaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW5uZXJDb250YWluZXIsIHRoaXMuX3BvcHVwU2hvd0NsYXNzKTtcbiAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5faW5uZXJDb250YWluZXIsIHRoaXMuX3BvcHVwSGlkZUNsYXNzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYW5pbWF0ZUNsb3Npbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbm5lckNvbnRhaW5lciwgdGhpcy5fcG9wdXBIaWRlQ2xhc3MpO1xuICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9pbm5lckNvbnRhaW5lciwgdGhpcy5fcG9wdXBTaG93Q2xhc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbG9zZVBvcHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pc05vZGU6IGZ1bmN0aW9uKG8pIHsgLy8gKE9iamVjdCkgLT4gQm9vbGVhblxuICAgICAgICAgICAgcmV0dXJuIChvLm5vZGVOYW1lID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgICAgIGlmIChERy5Ccm93c2VyLm1vYmlsZSAmJiB0aGlzLl9tYXAuZ2VvY2xpY2tlciAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayB8fCB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIFdlIG5lZWQgdG8gc2lnbmFsIGdlb2NsaWNrZXIgdGhhdCBwb3B1cCB3YXMgb3BlbiBiZWZvcmUgJ2NsaWNrJyBldmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgQnV0IGJ5IHRpbWUgaXQgd2lsbCBnZXQgaXQncyBldmVudCB0aGUgcG9wdXAgd2lsbCBiZSBhbHJlYWR5IGNsb3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyAgU2VlICdER0dlb2NsaWNrZXInIGZvciAnX21hcEV2ZW50c0xpc3RlbmVycycgYW5kICdfc2luZ2xlQ2xpY2snIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZ2VvY2xpY2tlci5wb3B1cFdhc09wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0TGF5b3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsSW5pdExheW91dC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faW5uZXJDb250YWluZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtcG9wdXAtaW5uZXIgJyArIHRoaXMuX3BvcHVwSGlkZUNsYXNzLCB0aGlzLl9jb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50cyBtb3VzZSBldmVudHMgZnJvbSBsZWFraW5nIHRocm91Z2ggY2xvc2UgYnV0dG9uXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tLzJnaXMvbWFwc2FwaS9wdWxsLzE1My9cbiAgICAgICAgICAgIERHLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2lubmVyQ29udGFpbmVyKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RldGFjaEVsKHRoaXMuX2Nsb3NlQnV0dG9uKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RldGFjaEVsKHRoaXMuX3dyYXBwZXIpKTtcblxuICAgICAgICAgICAgdmFyIHRpcCA9IHRoaXMuX2RldGFjaEVsKHRoaXMuX3RpcENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmIChERy5Ccm93c2VyLnN2Zykge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gREcuU1ZHLmNyZWF0ZSgncGF0aCcpO1xuICAgICAgICAgICAgICAgIHZhciBzdmdDbGFzcyA9IHRoaXMuX3BvcHVwVGlwQ2xhc3MgKyAnICcgKyB0aGlzLl9wb3B1cFRpcENsYXNzICsgJ19zdmcnO1xuXG4gICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLl90aXBTVkdQYXRoKTtcblxuICAgICAgICAgICAgICAgIHRpcCA9IERHLlNWRy5jcmVhdGUoJ3N2ZycpO1xuICAgICAgICAgICAgICAgIHRpcC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgc3ZnQ2xhc3MpO1xuXG4gICAgICAgICAgICAgICAgdGlwLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHRpcCwgdGhpcy5fcG9wdXBUaXBDbGFzcyArICdfaW1hZ2UnKTtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbm5lckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhckVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW0pIHsgLy8gKERPTUVsZW1lbnQpIC0+IFBvcHVwXG4gICAgICAgICAgICB0aGlzWydfJyArIGVsZW0gKyAnQ29udGVudCddID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2RldGFjaEVsKHRoaXMuX3BvcHVwU3RydWN0dXJlW2VsZW1dKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wb3B1cFN0cnVjdHVyZVtlbGVtXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYmFyb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYXJvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNjcm9sbGVkID0gdGhpcy5fdXBkYXRlTGF5b3V0KCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoIXNjcm9sbGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQmFyb25FeGlzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxlcldyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fc2Nyb2xsZXIsICdkZy1zY3JvbGxlcicpO1xuXG4gICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fc2Nyb2xsZXIsICdkZy1zY3JvbGxlcl9oaWRkZW5fdHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Njcm9sbGVyLCAnZGctc2Nyb2xsZXInKTtcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tRXZlbnQub2ZmKHRoaXMuX3Njcm9sbGVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNCYXJvbkV4aXN0KSB7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9zY3JvbGxlciwgJ2RnLXNjcm9sbGVyX2hpZGRlbl90cnVlJyk7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9zY3JvbGxlciwgJ2RnLXNjcm9sbGVyJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5faXNCYXJvbkV4aXN0ID8gdGhpcy5fc2Nyb2xsZXIuc2Nyb2xsVG9wIDogZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGVyLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0IC0gdGhpcy5vcHRpb25zLmJvcmRlciAqIDIgLSB0aGlzLl9nZXREZWx0YSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGVyV3JhcHBlci5zdHlsZS5oZWlnaHQgPSBpbm5lckhlaWdodCArICdweCc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNDb250ZW50SGVpZ2h0RW5vdWdoKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0QmFyb25TY3JvbGxlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRCYXJvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hZGp1c3RQYW4oKTtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRBZGp1c3RQYW5PblRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRqdXN0UGFuOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5wcm9wZXJ0eU5hbWUgPT09ICdtYXgtaGVpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KG9yaWdpbmFsQWRqdXN0UGFuLmJpbmQodGhpcyksIDEpOyAvL0pTQVBJLTM0MDkgZml4IHNhZmFyaSBnbGljaFxuICAgICAgICAgICAgICAgICAgICBERy5Eb21FdmVudC5vZmYodGhpcy5fd3JhcHBlciwgREcuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fYWRqdXN0UGFuKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYXV0b1BhbikgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyV2lkdGgsXG4gICAgICAgICAgICAgICAgbGF5ZXJQb3MgPSBuZXcgTC5Qb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuICAgICAgICAgICAgICAgIGxheWVyUG9zLl9hZGQoTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXV0b1BhblBhZGRpbmcgPSBbb3B0aW9ucy5hdXRvUGFuUGFkZGluZ1swXSwgb3B0aW9ucy5hdXRvUGFuUGFkZGluZ1sxXV07XG5cbiAgICAgICAgICAgIC8vIGlmIHdpZHRoIG9mIG1hcCBpcyBtb3JlIHRoZW4gd2lkdGggb2YgcG9wdXAgYW5kIGNvbnRyb2xzXG4gICAgICAgICAgICAvLyBzZXQgZGVmYXVsdCBhdXRvUGFuUGFkZGluZyB0byB3aWR0aCBjb250cm9sc1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICF0aGlzLl9pc0F1dG9QYW5QYWRkaW5nVXNlckRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLl9jb250YWluZXIub2Zmc2V0V2lkdGggPj0gb3B0aW9ucy5tYXhXaWR0aCArIG9wdGlvbnMubWFwQ29udHJvbHNXaWR0aCAqIDJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGF1dG9QYW5QYWRkaW5nWzBdID0gb3B0aW9ucy5tYXBDb250cm9sc1dpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nID0gTC5wb2ludChhdXRvUGFuUGFkZGluZyksXG4gICAgICAgICAgICAgICAgcGFkZGluZ1RMID0gTC5wb2ludChvcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nQlIgPSBMLnBvaW50KG9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcbiAgICAgICAgICAgICAgICBzaXplID0gbWFwLmdldFNpemUoKSxcbiAgICAgICAgICAgICAgICBkeCA9IDAsXG4gICAgICAgICAgICAgICAgZHkgPSAwO1xuXG4gICAgICAgICAgICBpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XG4gICAgICAgICAgICAgICAgZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XG4gICAgICAgICAgICAgICAgZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXG4gICAgICAgICAgICAgICAgZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXG4gICAgICAgICAgICAgICAgZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgICAgICAgICAgICBtYXBcbiAgICAgICAgICAgICAgICAgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXG4gICAgICAgICAgICAgICAgICAgIC5wYW5CeShbZHgsIGR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2JpbmRBZGp1c3RQYW5PblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKERHLkRvbVV0aWwuVFJBTlNJVElPTikge1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50Lm9uKHRoaXMuX3dyYXBwZXIsIERHLkRvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX2FkanVzdFBhbiwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkanVzdFBhbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pc0NvbnRlbnRIZWlnaHRFbm91Z2g6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBCb29sZWFuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLm1heEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcG9wdXBIZWlnaHQgPSB0aGlzLl9wb3B1cFN0cnVjdHVyZS5ib2R5ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9wb3B1cFN0cnVjdHVyZS5ib2R5Lm9mZnNldEhlaWdodCArIHRoaXMuX2dldERlbHRhKCkgOlxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnROb2RlLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgcG9wdXBIZWlnaHQgKz0gb3B0aW9ucy5ib3JkZXIgKiAyO1xuXG4gICAgICAgICAgICByZXR1cm4gcG9wdXBIZWlnaHQgPD0gb3B0aW9ucy5tYXhIZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRCYXJvblNjcm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50Tm9kZSA9IHRoaXMuX3BvcHVwU3RydWN0dXJlLmJvZHkucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxlcldyYXBwZXIgPSB0aGlzLl9zY3JvbGxlcldyYXBwZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLXNjcm9sbGVyX193cmFwcGVyJywgY29udGVudE5vZGUpLFxuICAgICAgICAgICAgICAgIHNjcm9sbGVyID0gdGhpcy5fc2Nyb2xsZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLXNjcm9sbGVyJywgc2Nyb2xsZXJXcmFwcGVyKSxcbiAgICAgICAgICAgICAgICBiYXJXcmFwcGVyID0gdGhpcy5fYmFyV3JhcHBlciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctc2Nyb2xsZXJfX2Jhci13cmFwcGVyJywgc2Nyb2xsZXIpLFxuICAgICAgICAgICAgICAgIGlubmVySGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCAtIHRoaXMub3B0aW9ucy5ib3JkZXIgKiAyO1xuXG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxlckJhciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctc2Nyb2xsZXJfX2JhcicsIGJhcldyYXBwZXIpO1xuICAgICAgICAgICAgc2Nyb2xsZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGV0YWNoRWwodGhpcy5fcG9wdXBTdHJ1Y3R1cmUuYm9keSkpO1xuXG4gICAgICAgICAgICBpbm5lckhlaWdodCAtPSB0aGlzLl9nZXREZWx0YSgpO1xuICAgICAgICAgICAgc2Nyb2xsZXJXcmFwcGVyLnN0eWxlLmhlaWdodCA9IE1hdGgubWF4KDE4LCBpbm5lckhlaWdodCkgKyAncHgnO1xuICAgICAgICAgICAgc2Nyb2xsZXJXcmFwcGVyLnN0eWxlLndpZHRoID0gY29udGVudE5vZGUub2Zmc2V0V2lkdGggKyA1ICsgJ3B4JzsgLy9UT0RPXG5cbiAgICAgICAgICAgIHRoaXMuX2lzQmFyb25FeGlzdCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX3N3aXRjaEV2ZW50cygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vblNjcm9sbDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdzY3JvbGwnLCB7b3JpZ2luYWxFdmVudDogZX0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9tb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NsaWNrJywge29yaWdpbmFsRXZlbnQ6IGV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfb25TdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdGhpcy5fbW92ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX21vdmluZykgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcblxuICAgICAgICAgICAgdGhpcy5fc3RhcnRQb2ludCA9IG5ldyBERy5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlVG91Y2hFdmVudHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25FbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZVRvdWNoRXZlbnRzKHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9vbkNsaWNrKGUpO1xuXG4gICAgICAgICAgICB0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25Nb3ZlOiBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZmlyc3QgPSAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgPyBlLnRvdWNoZXNbMF0gOiBlKSxcbiAgICAgICAgICAgICAgICBuZXdQb2ludCA9IERHLnBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IE1hdGguYWJzKG5ld1BvaW50LnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpLnkpO1xuXG4gICAgICAgICAgICBpZiAoIW9mZnNldCB8fCBvZmZzZXQgPCAxMCkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdGhpcy5fbW92aW5nID0gdGhpcy5fbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRCYXJvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX3Njcm9sbGVyV3JhcHBlcjtcbiAgICAgICAgICAgIHRoaXMuX2Jhcm9uID0gZ3JhZih7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXI6ICcuZGctc2Nyb2xsZXInLFxuICAgICAgICAgICAgICAgIGJhcjogJy5kZy1zY3JvbGxlcl9fYmFyJyxcbiAgICAgICAgICAgICAgICB0cmFjazogJy5kZy1zY3JvbGxlcl9fYmFyLXdyYXBwZXInLFxuICAgICAgICAgICAgICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0ge30udG9TdHJpbmcuY2FsbChzZWxlY3RvcikgPT09ICdbb2JqZWN0IFN0cmluZ10nID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBzZWxlY3RvcjtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJhcm9uRG9tSGVscGVyKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50LCBmdW5jLCBtb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBERy5Eb21FdmVudFttb2RlIHx8ICdvbiddKGVsZW0sIHR5cGUsIGZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdEhlYWRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFN0cnVjdHVyZS5oZWFkZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnaGVhZGVyJywgJ2RnLXBvcHVwX19oZWFkZXInLCB0aGlzLl9jb250ZW50Tm9kZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRGb290ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuZm9vdGVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2Zvb3RlcicsICdkZy1wb3B1cF9fZm9vdGVyJywgdGhpcy5fY29udGVudE5vZGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0Qm9keUNvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFN0cnVjdHVyZS53cmFwcGVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1wb3B1cF9fY29udGFpbmVyLXdyYXBwZXInLCB0aGlzLl9jb250ZW50Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFN0cnVjdHVyZS5ib2R5ID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1wb3B1cF9fY29udGFpbmVyJywgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUud3JhcHBlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICBpZiAoIURHLkJyb3dzZXIuaWVsdDkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3dpdGNoRXZlbnRzKHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9jbGVhck5vZGUodGhpcy5fY29udGVudE5vZGUpO1xuICAgICAgICAgICAgdGhpcy5faXNCYXJvbkV4aXN0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGluaXQgcG9wdXAgY29udGVudCBkb20gc3RydWN0dXJlXG4gICAgICAgICAgICBpZiAodGhpcy5faGVhZGVyQ29udGVudCkgeyB0aGlzLl9pbml0SGVhZGVyKCk7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5Q29udGVudCkgeyB0aGlzLl9pbml0Qm9keUNvbnRhaW5lcigpOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZm9vdGVyQ29udGVudCkgeyB0aGlzLl9pbml0Rm9vdGVyKCk7IH1cblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9wdXBTdHJ1Y3R1cmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgICAgIERHLkRvbUV2ZW50Lm9uKHRoaXMuX3dyYXBwZXIsICdjbGljaycsIERHLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgICAgICB0aGlzLl9zd2l0Y2hFdmVudHMoKTtcblxuICAgICAgICAgICAgaWYgKERHLkJyb3dzZXIuaWVsdDkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuX3BvcHVwU3RydWN0dXJlLmZvb3RlcjtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSArPSAnIGllOCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIURHLkJyb3dzZXIuaWVsdDkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXREZWx0YTogZnVuY3Rpb24oKSB7IC8vICgpIC0+IE51bWJlclxuICAgICAgICAgICAgdmFyIGRlbHRhID0gMCxcbiAgICAgICAgICAgICAgICBwb3B1cCA9IHRoaXMuX3BvcHVwU3RydWN0dXJlO1xuXG4gICAgICAgICAgICBpZiAocG9wdXAuaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgKz0gcG9wdXAuaGVhZGVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3B1cC5mb290ZXIpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSArPSBwb3B1cC5mb290ZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVsdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZUxheW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5fY29udGVudE5vZGUsIC8vIGxlYWZsZXQtcG9wdXAtY29udGVudFxuICAgICAgICAgICAgICAgIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyLCAvLyBsZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlclxuICAgICAgICAgICAgICAgIHN0eWxlID0gY29udGVudC5zdHlsZSxcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUgPSB3cmFwcGVyLnN0eWxlLFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHN0eWxlLm1hcmdpbiA9IG9wdHMuYm9yZGVyICsgJ3B4JztcblxuICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250ZW50LCBzY3JvbGxlZENsYXNzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ29udGVudEhlaWdodEVub3VnaCgpKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLm1heEhlaWdodCA9IGNvbnRlbnQub2Zmc2V0SGVpZ2h0ICsgb3B0cy5ib3JkZXIgKiAyICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLm1heEhlaWdodCA9IG9wdHMubWF4SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKGNvbnRlbnQsIHNjcm9sbGVkQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG9wdHMuYXV0b1BhblBhZGRpbmdbMF0gKiAyO1xuXG4gICAgICAgICAgICBpZiAob3B0cy5zcHJhd2xpbmcpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IG9wdHMubWF4V2lkdGg7XG5cbiAgICAgICAgICAgICAgICB3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLl9tYXAuX2NvbnRhaW5lci5vZmZzZXRXaWR0aCAtIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBvcHRzLm1pbldpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLndpZHRoID0gJyc7XG5cbiAgICAgICAgICAgICAgICBzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XG4gICAgICAgICAgICAgICAgd2lkdGggPSB3cmFwcGVyLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIHN0eWxlLndoaXRlU3BhY2UgPSAnJztcblxuICAgICAgICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMuX21hcC5fY29udGFpbmVyLm9mZnNldFdpZHRoIC0gYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgod2lkdGgsIG9wdHMubWluV2lkdGgpLCBvcHRzLm1heFdpZHRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlUG9wdXBTdHJ1Y3R1cmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcG9wdXBTdHJ1Y3R1cmUpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luc2VydENvbnRlbnQodGhpc1snXycgKyBpdGVtICsgJ0NvbnRlbnQnXSwgdGhpcy5fcG9wdXBTdHJ1Y3R1cmVbaXRlbV0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbnNlcnRDb250ZW50OiBmdW5jdGlvbihjb250ZW50LCBub2RlKSB7IC8vIChTdHJpbmcgfCBET01FbGVtZW50LCBET01FbGVtZW50KVxuICAgICAgICAgICAgaWYgKCFjb250ZW50IHx8ICFub2RlKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICBjb250ZW50ID0gKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSA/IGNvbnRlbnQodGhpcy5fc291cmNlIHx8IHRoaXMpIDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFyTm9kZTogZnVuY3Rpb24obm9kZSkgeyAvLyAoRE9NRWxlbWVudClcbiAgICAgICAgICAgIHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZGV0YWNoRWw6IGZ1bmN0aW9uKGVsZW0pIHsgLy8gKERPTUVsZW1lbnQpIC0+IERPTUVsZW1lbnRcbiAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc3dpdGNoRXZlbnRzOiBmdW5jdGlvbihvbikgeyAvLyAoQm9vbGVhbilcbiAgICAgICAgICAgIHZhciBzd2l0Y2hlciA9IG9uID8gJ29mZicgOiAnb24nO1xuXG4gICAgICAgICAgICBpZiAoIURHLkJyb3dzZXIudG91Y2gpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudFtzd2l0Y2hlcl0odGhpcy5fY29udGVudE5vZGUsICdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudFtzd2l0Y2hlcl0odGhpcy5fY29udGVudE5vZGUsICd0b3VjaHN0YXJ0IG1vdXNlZG93biBtb3VzZW1vdmUnLCB0aGlzLl9vblN0YXJ0LCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQmFyb25FeGlzdCkge1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50W3N3aXRjaGVyXSh0aGlzLl9zY3JvbGxlciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfdG9nZ2xlVG91Y2hFdmVudHM6IGZ1bmN0aW9uKG9uKSB7XG4gICAgICAgICAgICB2YXIgc3dpdGNoZXIgPSBvbiA/ICdvZmYnIDogJ29uJztcblxuICAgICAgICAgICAgREcuRG9tRXZlbnRbc3dpdGNoZXJdKHRoaXMuX2NvbnRlbnROb2RlLCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcbiAgICAgICAgICAgIERHLkRvbUV2ZW50W3N3aXRjaGVyXSh0aGlzLl9jb250ZW50Tm9kZSwgJ3RvdWNoZW5kJywgdGhpcy5fb25FbmQsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICB9KTtcbn0oKSk7XG5cblxuREcuTWFwLmluY2x1ZGUoe1xuICAgIF9tYXJrZXJDbGFzczogJ2RnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tJyxcbiAgICBfbWFya2VyU2hvd0NsYXNzOiAnZGctY3VzdG9taXphdGlvbl9fbWFya2VyX2FwcGVhcicsXG4gICAgX21hcmtlckhpZGVDbGFzczogJ2RnLWN1c3RvbWl6YXRpb25fX21hcmtlcl9kaXNhcHBlYXInLFxuICAgIF9kZ0hpZGVDbGFzczogJ2RnLXBvcHVwX2hpZGRlbl90cnVlJyxcbiAgICBvcGVuUG9wdXA6IGZ1bmN0aW9uKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHsgLy8gKFBvcHVwKSBvciAoU3RyaW5nIHx8IEhUTUxFbGVtZW50LCBMYXRMbmdbLCBPYmplY3RdKVxuICAgICAgICBpZiAoIShwb3B1cCBpbnN0YW5jZW9mIEwuUG9wdXApKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHBvcHVwO1xuXG4gICAgICAgICAgICBwb3B1cCA9IG5ldyBMLlBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF0bG5nKSB7XG4gICAgICAgICAgICBwb3B1cC5zZXRMYXRMbmcobGF0bG5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0xheWVyKHBvcHVwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fcG9wdXAub3B0aW9ucy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wdXAgPSBwb3B1cDtcblxuICAgICAgICBpZiAocG9wdXAuX3NvdXJjZSAmJiBwb3B1cC5fc291cmNlLl9pY29uKSB7XG4gICAgICAgICAgICBpZiAocG9wdXAuX3NvdXJjZS5faWNvbi5jbGFzc05hbWUuaW5kZXhPZih0aGlzLl9tYXJrZXJDbGFzcykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyhwb3B1cC5fc291cmNlLl9pY29uLCB0aGlzLl9tYXJrZXJTaG93Q2xhc3MpO1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3MocG9wdXAuX3NvdXJjZS5faWNvbiwgdGhpcy5fbWFya2VySGlkZUNsYXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhwb3B1cC5fc291cmNlLl9pY29uLCB0aGlzLl9kZ0hpZGVDbGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcHVwLl9zb3VyY2UuX3NoYWRvdykge1xuICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHBvcHVwLl9zb3VyY2UuX3NoYWRvdywgdGhpcy5fZGdIaWRlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmFkZExheWVyKHBvcHVwKTtcbiAgICB9LFxuXG4gICAgY2xvc2VQb3B1cDogZnVuY3Rpb24ocG9wdXApIHsgIC8vIChQb3B1cCkgLT4gUG9wdXBcbiAgICAgICAgaWYgKCFwb3B1cCB8fCBwb3B1cCA9PT0gdGhpcy5fcG9wdXApIHtcbiAgICAgICAgICAgIHBvcHVwID0gdGhpcy5fcG9wdXA7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcHVwKSB7XG4gICAgICAgICAgICBpZiAocG9wdXAuX3NvdXJjZSAmJiBwb3B1cC5fc291cmNlLl9pY29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcHVwLl9zb3VyY2UuX2ljb24uY2xhc3NOYW1lLmluZGV4T2YodGhpcy5fbWFya2VyQ2xhc3MpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHBvcHVwLl9zb3VyY2UuX2ljb24sIHRoaXMuX21hcmtlckhpZGVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3MocG9wdXAuX3NvdXJjZS5faWNvbiwgdGhpcy5fbWFya2VyU2hvd0NsYXNzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHBvcHVwLl9zb3VyY2UuX2ljb24sIHRoaXMuX2RnSGlkZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcHVwLl9zb3VyY2UuX3NoYWRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyhwb3B1cC5fc291cmNlLl9zaGFkb3csIHRoaXMuX2RnSGlkZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG4iLCJERy5EaWN0aW9uYXJ5ID0ge307XG5cbkRHLkRpY3Rpb25hcnkucnUgPSB7XG4gICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiBuICUgMTAwICE9PSAxMSkgeyAvLyAxLCAyMVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChuICUgMTAgPj0gMiAmJiBuICUgMTAgPD0gNCAmJiAobiAlIDEwKSAlIDEgPT09IDApICYmIChuICUgMTAwIDwgMTIgfHwgbiAlIDEwMCA+IDE0KSkgeyAvLyAyLCAzXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobiAlIDEwID09PSAwKSB8fCAobiAlIDEwID49IDUgJiYgbiAlIDEwIDw9IDkgJiYgKG4gJSAxMCkgJSAxID09PSAwKSB8fCAobiAlIDEwMCA+PSAxMSAmJiAobiAlIDEwMCkgPD0gMTQgJiYgKG4gJSAxMDApICUgMSA9PT0gMCkpIHsgLy8gMTMsIDE3XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkRHLkRpY3Rpb25hcnkuZW4gPSB7XG4gICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgaWYgKG4gPT09IDEpIHsgLy8gMVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTsgLy8wLCAyLCAzLCA0IC4uXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5ERy5EaWN0aW9uYXJ5Lml0ID0ge1xuICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbihuKSB7IC8vIChOdW1iZXIpXG4gICAgICAgIGlmIChuID09PSAxKSB7IC8vIDFcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7IC8vMCwgMiwgMywgNCAuLlxuICAgICAgICB9XG4gICAgfVxufTtcblxuREcuRGljdGlvbmFyeS5jcyA9IHtcbiAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24obikgeyAvLyAoTnVtYmVyKVxuICAgICAgICByZXR1cm4gKG4gPT09IDEpID8gMCA6IChuID49IDIgJiYgbiA8PSA0KSA/IDEgOiAyO1xuICAgIH1cbn07XG5cbkRHLkRpY3Rpb25hcnkuZXMgPSB7XG4gICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgcmV0dXJuIChuID49IDIpID8gMSA6IDA7XG4gICAgfVxufTtcbiIsIkRHLkxvY2FsZSA9IHtcbiAgICB0OiBmdW5jdGlvbihtc2csIGFyZ3VtZW50KSB7IC8vIChTdHJpbmcsIE51bWJlcikgLT4gU3RyaW5nXG4gICAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgICBsYW5nID0gdGhpcy5fbWFwLmdldExhbmcoKSxcbiAgICAgICAgICAgIG1zZ0lzc2V0ID0gZmFsc2UsXG4gICAgICAgICAgICBkaWN0aW9uYXJ5TXNnLFxuICAgICAgICAgICAgZXhwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5EaWN0aW9uYXJ5W2xhbmddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGFuZyA9IERHLmNvbmZpZy5kZWZhdWx0TGFuZztcbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXRMYW5nKGxhbmcpO1xuICAgICAgICB9XG4gICAgICAgIGRpY3Rpb25hcnlNc2cgPSB0aGlzLmNvbnN0cnVjdG9yLkRpY3Rpb25hcnlbbGFuZ11bbXNnXTtcbiAgICAgICAgbXNnSXNzZXQgPSB0eXBlb2YgZGljdGlvbmFyeU1zZyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghbXNnSXNzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbXNnSXNzZXQgPyBkaWN0aW9uYXJ5TXNnIDogbXNnO1xuXG4gICAgICAgIGlmIChhcmd1bWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlSW50KGFyZ3VtZW50LCAxMCk7XG4gICAgICAgICAgICBhcmd1bWVudCA9IGlzTmFOKGFyZ3VtZW50KSA/IDAgOiBhcmd1bWVudDtcbiAgICAgICAgICAgIGV4cCA9IHRoaXMuY29uc3RydWN0b3IuRGljdGlvbmFyeVtsYW5nXS5wbHVyYWxSdWxlcyhhcmd1bWVudCk7XG4gICAgICAgICAgICByZXN1bHQgPSBkaWN0aW9uYXJ5TXNnW2V4cF07XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBERy5VdGlsLnRlbXBsYXRlKHJlc3VsdCwge246IGFyZ3VtZW50fSk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQgOiBtc2c7XG4gICAgfVxufTtcblxuREcuTWFwLmluY2x1ZGUoe1xuICAgIHNldExhbmc6IGZ1bmN0aW9uKGxhbmcpIHsgLy8gKFN0cmluZylcbiAgICAgICAgaWYgKGxhbmcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGxhbmcpID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmN1cnJlbnRMYW5nID0gbGFuZztcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbGFuZ2NoYW5nZScsIHsnbGFuZyc6IGxhbmd9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRMYW5nOiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gU3RyaW5nXG4gICAgICAgIC8vIElmIHRoZSBsYW5ndWFnZSBoYXNuJ3QgYmVlbiBzZXQgYmVmb3JlLCBzZXQgaXQgdG8gcGFnZSBsYW5ndWFnZSBvclxuICAgICAgICAvLyBkZWZhdWx0IGxhbmd1YWdlIGZyb20gY29uZmlnXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmN1cnJlbnRMYW5nKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHZhciBsYW5nID0gcm9vdC5sYW5nIHx8IChyb290LmdldEF0dHJpYnV0ZU5TICYmIHJvb3QuZ2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsICdsYW5nJykpIHx8IERHLmNvbmZpZy5kZWZhdWx0TGFuZztcblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmN1cnJlbnRMYW5nID0gbGFuZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY3VycmVudExhbmc7XG4gICAgfVxufSk7XG4iLCJERy5Sb3VuZENvbnRyb2wgPSBERy5Db250cm9sLmV4dGVuZCh7XG4gICAgaW5jbHVkZXM6IERHLk1peGluLkV2ZW50cyxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3ByaWdodCcsXG4gICAgICAgIGljb25DbGFzczogJ2RlZmF1bHQnXG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdmFyIGNvbnRyb2xDbGFzcyA9IHRoaXMuX2NvbnRyb2xDTGFzcyA9ICdkZy1jb250cm9sLXJvdW5kJyxcbiAgICAgICAgICAgIGNvbnRyb2xJY29uQ2xhc3MgPSB0aGlzLl9jb250cm9sSWNvbkNMYXNzID0gdGhpcy5fY29udHJvbENMYXNzICsgJ19faWNvbicsXG4gICAgICAgICAgICBjb250YWluZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJycpO1xuXG4gICAgICAgIGlmICh0aGlzLl9kaXNhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCBjb250cm9sQ2xhc3MpO1xuXG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5fbGluayA9IERHLkRvbVV0aWwuY3JlYXRlKFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgY29udHJvbEljb25DbGFzcyArICcgJyArIGNvbnRyb2xJY29uQ2xhc3MgKyAnX25hbWVfJyArIHRoaXMub3B0aW9ucy5pY29uQ2xhc3MsXG4gICAgICAgICAgICBjb250YWluZXJcbiAgICAgICAgKTtcblxuICAgICAgICBsaW5rLmhyZWYgPSAnIyc7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyVHJhbnNsYXRpb24oKTtcblxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG5cbiAgICAgICAgREcuRG9tRXZlbnRcbiAgICAgICAgICAgIC5vbihjb250YWluZXIsICdjbGljaycsIHRoaXMuX3RvZ2dsZUNvbnRyb2wsIHRoaXMpXG4gICAgICAgICAgICAub24oY29udGFpbmVyLCAnZGJsY2xpY2snLCBERy5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAub24obGluaywgJ21vdXNlZG93bicsIERHLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XG5cbiAgICAgICAgdGhpcy5maXJlRXZlbnQoJ2FkZCcpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3JlbW92ZScpO1xuICAgICAgICBERy5Eb21FdmVudC5vZmYodGhpcy5fbGluaywgJ2NsaWNrJywgdGhpcy5fdG9nZ2xlQ29udHJvbCk7XG4gICAgfSxcblxuICAgIHNldFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xpbmsgfHwgIXRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCB0aGlzLl9jb250cm9sQ0xhc3MgKyAnX3N0YXRlXycgKyB0aGlzLl9zdGF0ZSk7XG4gICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2xpbmssIHRoaXMuX2NvbnRyb2xJY29uQ0xhc3MgKyAnX3N0YXRlXycgKyB0aGlzLl9zdGF0ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcblxuICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsIHRoaXMuX2NvbnRyb2xDTGFzcyArICdfc3RhdGVfJyArIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbGluaywgdGhpcy5fY29udHJvbEljb25DTGFzcyArICdfc3RhdGVfJyArIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdG9nZ2xlQ29udHJvbDogZnVuY3Rpb24oZSkge1xuICAgICAgICBERy5Eb21FdmVudC5zdG9wKGUpO1xuICAgICAgICB0aGlzLmZpcmVFdmVudCgnY2xpY2snKTtcbiAgICB9XG59KTtcblxuREcuUm91bmRDb250cm9sLmluY2x1ZGUoREcuTG9jYWxlKTtcblxuREcucm91bmRDb250cm9sID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuUm91bmRDb250cm9sKG9wdGlvbnMpO1xufTtcbiIsIkRHLmNvbmZpZ1RoZW1lID0gREcuY29uZmlnVGhlbWUgfHwge307XG5cbkRHLmNvbmZpZ1RoZW1lLm1hcmtlcnNEYXRhID0ge1xuICAgIGljb25TaXplOiBbMjIsIDM0XSxcbiAgICBjbGFzc05hbWU6ICdkZy1jdXN0b21pemF0aW9uX19tYXJrZXIgZGctY3VzdG9taXphdGlvbl9fbWFya2VyX3R5cGVfbXVzaHJvb20nLFxuICAgIGljb25BbmNob3I6IFsxMCwgMzJdXG59O1xuIiwiLy8gRml4IGEgbG90IG9mIGJ1Z3Mgd2l0aCBwaW5jaC16b29taW5nXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tLzJnaXMvbWFwc2FwaS9pc3N1ZXMvMzI3XG5ERy5NYXAubWVyZ2VPcHRpb25zKHtcbiAgICBib3VuY2VBdFpvb21MaW1pdHM6IGZhbHNlXG59KTtcblxuLy9JbmplY3Qgb2JzZXJ2aW5nIGxvY2FsaXphdGlvbiBjaGFuZ2VcbnZhciBjb250cm9sQWRkVG8gPSBERy5Db250cm9sLnByb3RvdHlwZS5hZGRUbztcblxuREcuQ29udHJvbC5pbmNsdWRlKHtcbiAgICBhZGRUbzogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIG1hcC5vbignbGFuZ2NoYW5nZScsIHRoaXMuX3JlbmRlclRyYW5zbGF0aW9uLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gY29udHJvbEFkZFRvLmNhbGwodGhpcywgbWFwKTtcbiAgICB9LFxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7fVxufSk7XG5cbi8vIEFkZCBzb21lIGJyb3dzZXIgZGV0ZWN0aW9uXG5ERy5Ccm93c2VyLnNhZmFyaTUxID0gREcuQnJvd3Nlci5zYWZhcmkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdWZXJzaW9uLzUuMScpICE9PSAtMTtcblxuLy8gREcuQnJvd3Nlci50b3VjaCBjaGVja3Mgd2hldGhlciB0b3VjaCBldmVudHMgc3VwcG9ydGVkIG9yIG5vdDsgdG91Y2hFbmFibGVkIGNoZWNrcyBpZiBpdCdzIGEgdG91Y2ggZGV2aWNlXG52YXIgbXNQb2ludGVyID0gbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgJiYgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgJiYgIXdpbmRvdy5Qb2ludGVyRXZlbnQ7XG52YXIgcG9pbnRlciA9ICh3aW5kb3cuUG9pbnRlckV2ZW50ICYmIG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMpIHx8IG1zUG9pbnRlcjtcbnZhciBkb2N1bWVudFRvdWNoID0gd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaDtcbkRHLkJyb3dzZXIudG91Y2hFbmFibGVkID0gcG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgZG9jdW1lbnRUb3VjaDtcblxuLy8gQXBwbGllcyAyR0lTIGRpdkljb24gdG8gbWFya2VyXG5ERy5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMuaWNvbiA9IERHLmRpdkljb24oREcuY29uZmlnVGhlbWUubWFya2Vyc0RhdGEpO1xuXG4vLyBzdXBwb3J0IG9sZCBvcHRpb24gY2xpY2thYmxlXG52YXIgdXRpbFNldE9wdGlvbnMgPSBERy5VdGlsLnNldE9wdGlvbnM7XG5cbkRHLnNldE9wdGlvbnMgPSBMLnNldE9wdGlvbnMgPSBERy5VdGlsLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5jbGlja2FibGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMuaW50ZXJhY3RpdmUgPSBvcHRpb25zLmNsaWNrYWJsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbFNldE9wdGlvbnMuY2FsbCh0aGlzLCBvYmosIG9wdGlvbnMpO1xufTtcblxuREcuTGF5ZXIubWVyZ2VPcHRpb25zKHtcbiAgICBub25CdWJibGluZ0V2ZW50czogWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnY29udGV4dG1lbnUnXVxufSk7XG4iLCJ2YXIgaW5pdE1hcCA9IERHLk1hcC5wcm90b3R5cGUuaW5pdGlhbGl6ZSxcbiAgICBwYW5CeSA9IERHLk1hcC5wcm90b3R5cGUucGFuQnksXG4gICAgZ2V0Qm91bmRzWm9vbSA9IERHLk1hcC5wcm90b3R5cGUuZ2V0Qm91bmRzWm9vbSxcbiAgICBzZXRNYXhab29tID0gREcuTWFwLnByb3RvdHlwZS5zZXRNYXhab29tO1xuXG4vLyBSZXN0cmljdCB6b29tIGxldmVsIGFjY29yZGluZyB0byAyZ2lzIHByb2plY3RzLCBpbiBjYXNlIGlmIGRnVGlsZUxheWVyIGlzIG9ubHkgb25lXG5ERy5NYXAuaW5jbHVkZSh7XG5cbiAgICAvLyBudW1iZXIgb2YgdGlsZUxheWVycyB3aXRob3V0IDJnaXMgbGF5ZXJzXG4gICAgX3RpbGVMYXllcnNOdW1iZXI6IDAsXG5cbiAgICBfbWFwTWF4Wm9vbUNhY2hlOiBudWxsLFxuXG4gICAgLy9UT0RPIHRyeSByZWZhY3RvciBpdCBhZnRlciB1cCBvbiBuZXcgbGVhZmxldCAoPiAwLjcpXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IHdoZWVsUHhQZXJab29tTGV2ZWwgdmFsdWUgdG8gYXZvaWQgem9vbWluZyB0b28gZmFzdFxuICAgICAgICAvLyBvbiBtb3VzZSB3aGVlbCByb3RhdGlvblxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tLzJnaXMvbWFwc2FwaS9pc3N1ZXMvMzQzXG4gICAgICAgIG9wdGlvbnMgPSBERy5leHRlbmQoe3doZWVsUHhQZXJab29tTGV2ZWw6IDEwMDAwfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5tZXRhTGF5ZXJzID0gW107XG5cbiAgICAgICAgaW5pdE1hcC5jYWxsKHRoaXMsIGlkLCBvcHRpb25zKTtcblxuICAgICAgICAvLyAgUHJvamVjdCBtdXN0IGJlIGNoZWNrZWQgYWZ0ZXIgQmFzZUxheWVyIGluaXQgd2hpY2ggb2NjdXJzIGluIEluaXRIb29rIChzZWUgb3JpZyBtZXRob2QgZGVmaW5pdGlvbilcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jZW50ZXIgJiYgdGhpcy5vcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWaWV3KERHLmxhdExuZyh0aGlzLm9wdGlvbnMuY2VudGVyKSwgdGhpcy5vcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldFZpZXc6IGZ1bmN0aW9uKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9yZXN0cmljdFpvb20oY2VudGVyLCB6b29tKTtcblxuICAgICAgICB6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcbiAgICAgICAgY2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoREcubGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFuaW1hdGUgPSB0aGlzLl90ZXN0QW5pbWF0aW9uKGNlbnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdG9wKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuem9vbSA9IERHLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb25cbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLnpvb20pO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFuID0gREcuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvblxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMucGFuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxuICAgICAgICAgICAgdmFyIGFuaW1hdGVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cbiAgICAgICAgICAgIHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcblxuICAgICAgICAgICAgaWYgKGFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcbiAgICAgICAgdGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHBhbkJ5OiBmdW5jdGlvbihvZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1hcCA9IHBhbkJ5LmNhbGwodGhpcywgb2Zmc2V0LCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgem9vbSA9IHRoaXMuX3Jlc3RyaWN0Wm9vbSh0aGlzLmdldENlbnRlcigpKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0Wm9vbSgpID4gem9vbSkge1xuICAgICAgICAgICAgdGhpcy5zZXRab29tKHpvb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzWm9vbTogZnVuY3Rpb24oYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHtcbiAgICAgICAgYm91bmRzID0gREcubGF0TG5nQm91bmRzKGJvdW5kcyk7XG4gICAgICAgIHRoaXMuX3Jlc3RyaWN0Wm9vbShib3VuZHMpO1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRzWm9vbS5jYWxsKHRoaXMsIGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKTtcbiAgICB9LFxuXG4gICAgZ2V0VGlsZUxheWVyc051bWJlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlTGF5ZXJzTnVtYmVyO1xuICAgIH0sXG5cbiAgICBzZXRNYXhab29tOiBmdW5jdGlvbih6b29tKSB7XG4gICAgICAgIHRoaXMuX21hcE1heFpvb21DYWNoZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBzZXRNYXhab29tLmNhbGwodGhpcywgem9vbSk7XG4gICAgfSxcblxuICAgIF90ZXN0QW5pbWF0aW9uOiBmdW5jdGlvbihjb29yZHMpIHsvL2lmIHdlIGp1bXAgdG8gb3RoZXIgcHJvamVjdCAtIGRpc2FibGUgYW5pbWF0aW9uXG4gICAgICAgIGlmICh0aGlzLnByb2plY3REZXRlY3Rvci5lbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0RnJvbSA9IHRoaXMucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKSxcbiAgICAgICAgICAgICAgICBwcm9qZWN0VG8gPSB0aGlzLnByb2plY3REZXRlY3Rvci5pc1Byb2plY3RIZXJlKGNvb3Jkcyk7XG5cbiAgICAgICAgICAgIGlmIChwcm9qZWN0RnJvbSAmJiBwcm9qZWN0VG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdEZyb20uY29kZSA9PT0gcHJvamVjdFRvLmNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVRpbGVMYXllcnM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCEoZS5sYXllciBpbnN0YW5jZW9mIERHLlRpbGVMYXllcikgfHwgZS5sYXllci5faXNEZykgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAoZS50eXBlID09PSAnbGF5ZXJhZGQnKSB7XG4gICAgICAgICAgICB0aGlzLl90aWxlTGF5ZXJzTnVtYmVyKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aWxlTGF5ZXJzTnVtYmVyLS07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2dldE5ld0JvdW5kczogZnVuY3Rpb24oY29vcmRzLCB6b29tKSB7XG4gICAgICAgIGlmIChjb29yZHMgaW5zdGFuY2VvZiBERy5MYXRMbmdCb3VuZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLnByb2plY3QoY29vcmRzLCB6b29tKTtcbiAgICAgICAgdmFyIHNjcmVlblNpemUgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKTtcblxuICAgICAgICB2YXIgc3cgPSB0aGlzLnVucHJvamVjdChwb2ludC5zdWJ0cmFjdChzY3JlZW5TaXplKSwgem9vbSk7XG4gICAgICAgIHZhciBuZSA9IHRoaXMudW5wcm9qZWN0KHBvaW50LmFkZChzY3JlZW5TaXplKSwgem9vbSk7XG5cbiAgICAgICAgcmV0dXJuIERHLmxhdExuZ0JvdW5kcyhzdywgbmUpO1xuICAgIH0sXG5cbiAgICBfcmVzdHJpY3Rab29tOiBmdW5jdGlvbihjb29yZHMsIHpvb20pIHtcbiAgICAgICAgaWYgKHRoaXMuX2xheWVycyAmJlxuICAgICAgICAgICAgdGhpcy5wcm9qZWN0RGV0ZWN0b3IuZW5hYmxlZCgpICYmXG4gICAgICAgICAgICAodGhpcy5fdGlsZUxheWVyc051bWJlciA9PT0gMCkpIHtcblxuICAgICAgICAgICAgdmFyIG1hcE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaXNNYXBNYXhab29tID0gISFtYXBPcHRpb25zLm1heFpvb20sXG4gICAgICAgICAgICAgICAgZGdUaWxlTGF5ZXIgPSB0aGlzLmJhc2VMYXllcixcbiAgICAgICAgICAgICAgICBib3VuZHMgPSB0aGlzLl9nZXROZXdCb3VuZHMoY29vcmRzLCB6b29tKSxcbiAgICAgICAgICAgICAgICBwcm9qZWN0ID0gdGhpcy5wcm9qZWN0RGV0ZWN0b3IuaXNQcm9qZWN0SGVyZShib3VuZHMpO1xuXG4gICAgICAgICAgICBpZiAoaXNNYXBNYXhab29tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXBNYXhab29tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFzZUxheWVyLm9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIERHLkJyb3dzZXIucmV0aW5hICYmIG1hcE9wdGlvbnMubWF4Wm9vbSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcE9wdGlvbnMubWF4Wm9vbS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwTWF4Wm9vbUNhY2hlID0gbWFwT3B0aW9ucy5tYXhab29tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBPcHRpb25zLm1heFpvb20gPSAodGhpcy5fbWFwTWF4Wm9vbUNhY2hlICYmIHByb2plY3QpID8gdGhpcy5fbWFwTWF4Wm9vbUNhY2hlIDogIERHLmNvbmZpZy5wcm9qZWN0TGVhdmVNYXhab29tO1xuICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcE1heFpvb21DYWNoZSA9IG1hcE9wdGlvbnMubWF4Wm9vbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwT3B0aW9ucy5tYXhab29tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGdUaWxlTGF5ZXIub3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgREcuQnJvd3Nlci5yZXRpbmEgJiYgcHJvamVjdC5tYXhab29tID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGdUaWxlTGF5ZXIub3B0aW9ucy5tYXhab29tID0gcHJvamVjdC5tYXhab29tIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRnVGlsZUxheWVyLm9wdGlvbnMubWF4Wm9vbSA9IHByb2plY3QubWF4Wm9vbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRnVGlsZUxheWVyLm9wdGlvbnMubWF4Wm9vbSA9IERHLmNvbmZpZy5wcm9qZWN0TGVhdmVNYXhab29tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRnVGlsZUxheWVyLm9wdGlvbnMubWF4TmF0aXZlWm9vbSA9IGRnVGlsZUxheWVyLm9wdGlvbnMubWF4Wm9vbTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGdUaWxlTGF5ZXIub3B0aW9ucy5tYXhab29tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEFkZGVkIG1ldGEgbGF5ZXJzIGV2ZW50cyBwcm9jZXNzaW5nIGJlZm9yZSBtYXAgZXZlbnRzXG4gICAgX2ZpcmVET01FdmVudDogZnVuY3Rpb24oZSwgdHlwZSwgdGFyZ2V0cykge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvNTQ5OVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgIC8vIEZpcmUgYSBzeW50aGV0aWMgJ3ByZWNsaWNrJyBldmVudCB3aGljaCBwcm9wYWdhdGVzIHVwIChtYWlubHkgZm9yIGNsb3NpbmcgcG9wdXBzKS5cbiAgICAgICAgICAgIC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcbiAgICAgICAgICAgIC8vIHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbiBjbGljayBiZWZvcmUgYW55IGV4aXN0aW5nIGNsaWNrXG4gICAgICAgICAgICAvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cbiAgICAgICAgICAgIHZhciBzeW50aCA9IEwuVXRpbC5leHRlbmQoe30sIGUpO1xuICAgICAgICAgICAgc3ludGgudHlwZSA9ICdwcmVjbGljayc7XG4gICAgICAgICAgICB0aGlzLl9maXJlRE9NRXZlbnQoc3ludGgsIHN5bnRoLnR5cGUsIHRhcmdldHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUuX3N0b3BwZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgLy8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxuICAgICAgICB0YXJnZXRzID0gKHRhcmdldHMgfHwgW10pLmNvbmNhdCh0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpKTtcblxuICAgICAgICBpZiAoIXRhcmdldHMubGVuZ3RoKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51JyAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xuICAgICAgICAgICAgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycpIHtcbiAgICAgICAgICAgIHZhciBpc01hcmtlciA9IHRhcmdldCBpbnN0YW5jZW9mIEwuTWFya2VyO1xuICAgICAgICAgICAgZGF0YS5jb250YWluZXJQb2ludCA9IGlzTWFya2VyID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuICAgICAgICAgICAgZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcbiAgICAgICAgICAgIGRhdGEubGF0bG5nID0gaXNNYXJrZXIgPyB0YXJnZXQuZ2V0TGF0TG5nKCkgOiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhkYXRhLmxheWVyUG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBtZXRhbGF5ZXJzIGJlZm9yZSBkaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIG1hcFxuICAgICAgICAgICAgaWYgKHRhcmdldHNbaV0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFMYXllcnMuZm9yRWFjaChmdW5jdGlvbihtZXRhTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbWV0YUxheWVyLm1hcEV2ZW50c1t0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKG1ldGFMYXllciwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgd2Fzbid0IHN0b3BwZWQgaW4gbWV0YWxheWVycywgZGlzcGF0Y2ggaXQgdG8gdGhlIG1hcFxuICAgICAgICAgICAgICAgIGlmICghZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCB8fFxuICAgICAgICAgICAgICAgICh0YXJnZXRzW2ldLm9wdGlvbnMubm9uQnViYmxpbmdFdmVudHMgJiYgTC5VdGlsLmluZGV4T2YodGFyZ2V0c1tpXS5vcHRpb25zLm5vbkJ1YmJsaW5nRXZlbnRzLCB0eXBlKSAhPT0gLTEpKSB7IHJldHVybjsgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdsYXllcmFkZCBsYXllcnJlbW92ZScsIHRoaXMuX3VwZGF0ZVRpbGVMYXllcnMpO1xufSk7XG5cbi8vIFNldCBjc3MgcHJvcGVydHkgdG91Y2gtYWN0aW9uIHRvIGF1dG8gaWYgZHJhZ2dpbmcgaXMgZmFsc2UuXG4vLyBOZWVkIGZvciBzY3JvbGxpbmcgcGFnZSBpbiBtb2JpbGUgdXNpbmcgb3VyIG1hcCBkb20gZWxlbWVudC5cbi8vIHRvZG86IEkgbWFkZSBpc3N1ZSBpbiBsZWFmbGV0IGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzQ0MTVcbkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRyYWdnaW5nID09IGZhbHNlICYmIHRoaXMub3B0aW9ucy50YXAgPT0gZmFsc2UpIHtcbiAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdkZy1kcmFnZ2luZy1mYWxzZScpO1xuICAgIH1cbn0pO1xuIiwiREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uKCkge1xuICAgIHZhciBlcnJvclVybCA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVFBQUFBRUFBUU1BQUFCbXZEb2xBQUFBQTFCTVZFWDI4dDVSMGs1VUFBQUFIMGxFUVZSNFh1M0FBUWtBQUFEQ01QdW5Oc2RoV3h3QUFBQUFBQUFBd0FFaEFBQUJnMlVQNUFBQUFBQkpSVTVFcmtKZ2dnPT0nO1xuICAgIHZhciBlcnJvclJ1VXJsID0gREcuY29uZmlnLnByb3RvY29sICsgREcuY29uZmlnLmJhc2VVcmwgKyAnL2ltZy9ub21hcF9ydS5wbmcnO1xuXG4gICAgdmFyIFRpbGVMYXllciA9IERHLkJyb3dzZXIubW9iaWxlID8gREcuTW9iaWxlVGlsZUxheWVyIDogREcuVGlsZUxheWVyO1xuXG4gICAgdmFyIEJhc2VMYXllciA9IFRpbGVMYXllci5leHRlbmQoe1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRGcgPSB0cnVlO1xuICAgICAgICAgICAgVGlsZUxheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdXJsLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB0aWxlVXJsID0gREcuY29uZmlnLnByb3RvY29sICsgKERHLkJyb3dzZXIucmV0aW5hID8gREcuY29uZmlnLnJldGluYVRpbGVTZXJ2ZXIgOiBERy5jb25maWcudGlsZVNlcnZlcik7XG5cbiAgICB0aGlzLmJhc2VMYXllciA9IG5ldyBCYXNlTGF5ZXIodGlsZVVybCwge1xuICAgICAgICBzdWJkb21haW5zOiAnMDEyMycsXG4gICAgICAgIGVycm9yVGlsZVVybDogdGhpcy5nZXRMYW5nKCkgPT09ICdydScgPyBlcnJvclJ1VXJsIDogZXJyb3JVcmwsXG4gICAgICAgIGRldGVjdFJldGluYTogREcuY29uZmlnLmRldGVjdFJldGluYSxcbiAgICAgICAgbWF4Wm9vbTogMTksXG4gICAgICAgIG1heE5hdGl2ZVpvb206IDE5LFxuICAgICAgICB6SW5kZXg6IDBcbiAgICB9KS5hZGRUbyh0aGlzKTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUVycm9yVGlsZVVybCgpIHtcbiAgICAgICAgdmFyIGxhbmcgPSB0aGlzLmdldExhbmcoKTtcbiAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLnByb2plY3REZXRlY3RvciAmJiB0aGlzLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCk7XG5cbiAgICAgICAgaWYgKGxhbmcgPT09ICdydScgJiYgIXByb2plY3QpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyLm9wdGlvbnMuZXJyb3JUaWxlVXJsID0gZXJyb3JSdVVybDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyLm9wdGlvbnMuZXJyb3JUaWxlVXJsID0gZXJyb3JVcmw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9uKHtcbiAgICAgICAgbGFuZ2NoYW5nZTogdXBkYXRlRXJyb3JUaWxlVXJsLFxuICAgICAgICBwcm9qZWN0Y2hhbmdlOiB1cGRhdGVFcnJvclRpbGVVcmwsXG4gICAgICAgIHByb2plY3RsZWF2ZTogdXBkYXRlRXJyb3JUaWxlVXJsXG4gICAgfSwgdGhpcyk7XG59KTtcbiIsIkRHLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIHRpbGVzQ2hlY2s6IHRydWVcbn0pO1xuXG5ERy5NYXAuVGlsZXNDaGVjayA9IERHLkhhbmRsZXIuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9sYXllciA9IG1hcC5iYXNlTGF5ZXI7XG5cbiAgICAgICAgdGhpcy5fbW92ZVN0YXJ0RXZlbnRDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fbW92ZUVuZEV2ZW50Q291bnRlciA9IDA7XG5cbiAgICAgICAgdGhpcy5fbG9hZGluZ0V2ZW50Q291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX2xvYWRFdmVudENvdW50ZXIgPSAwO1xuICAgIH0sXG5cbiAgICBhZGRIb29rczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX21hcC5vbih0aGlzLl9tYXBFdmVudHMsIHRoaXMpO1xuICAgICAgICB0aGlzLl9sYXllci5vbih0aGlzLl9sYXllckV2ZW50cywgdGhpcyk7XG4gICAgfSxcblxuICAgIHJlbW92ZUhvb2tzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbWFwLm9mZih0aGlzLl9tYXBFdmVudHMsIHRoaXMpO1xuICAgICAgICB0aGlzLl9sYXllci5vZmYodGhpcy5fbGF5ZXJFdmVudHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfbWFwRXZlbnRzOiB7XG4gICAgICAgIGxheWVyYWRkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS5sYXllciA9PSB0aGlzLl9sYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGF5ZXJyZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmxheWVyID09IHRoaXMuX2xheWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZXN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BXYWl0aW5nKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX21vdmVTdGFydEV2ZW50Q291bnRlcisrO1xuICAgICAgICAgICAgdGhpcy5faXNXYWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdmVFbmRFdmVudENvdW50ZXIrKztcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1dhaXRpbmcgJiYgdGhpcy5fbW92ZVN0YXJ0RXZlbnRDb3VudGVyICE9PSB0aGlzLl9tb3ZlRW5kRXZlbnRDb3VudGVyKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICB0aGlzLl9pc01vdmVFbmQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9jaGVja1dhaXRpbmcoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfbGF5ZXJFdmVudHM6IHtcbiAgICAgICAgbG9hZGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkaW5nRXZlbnRDb3VudGVyKys7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkRXZlbnRDb3VudGVyKys7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNXYWl0aW5nICYmIHRoaXMuX2xvYWRpbmdFdmVudENvdW50ZXIgIT09IHRoaXMuX2xvYWRFdmVudENvdW50ZXIpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrV2FpdGluZygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zdG9wV2FpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2lzV2FpdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc01vdmVFbmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNMb2FkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9jaGVja1dhaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5faXNXYWl0aW5nICYmIHRoaXMuX2lzTG9hZCAmJiB0aGlzLl9pc01vdmVFbmQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BXYWl0aW5nKCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNldENvdW50ZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1RpbGVzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NoZWNrVGlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbWFwLmdldFRpbGVMYXllcnNOdW1iZXIoKSAhPT0gMCB8fCAhdGhpcy5fbWFwLl9sb2FkZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICB2YXIgZXJyb3JVcmwgPSB0aGlzLl9sYXllci5vcHRpb25zLmVycm9yVGlsZVVybDtcbiAgICAgICAgdmFyIHRpbGVzID0gdGhpcy5fbGF5ZXIuZ2V0VGlsZXMoKTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIHRpbGVzKSB7XG4gICAgICAgICAgICBpZiAodGlsZXNbaV0uY29vcmRzLnogPT09IHpvb20gJiYgdGlsZXNbaV0uZWwuc3JjICE9PSBlcnJvclVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hcC56b29tT3V0KCk7XG4gICAgfSxcblxuICAgIF9yZXNldENvdW50ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW92ZVN0YXJ0RXZlbnRDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fbW92ZUVuZEV2ZW50Q291bnRlciA9IDA7XG5cbiAgICAgICAgdGhpcy5fbG9hZGluZ0V2ZW50Q291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX2xvYWRFdmVudENvdW50ZXIgPSAwO1xuICAgIH1cbn0pO1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndGlsZXNDaGVjaycsIERHLk1hcC5UaWxlc0NoZWNrKTtcbiIsIi8qKlxuICogVGhpcyBjdXN0b21pemF0aW9uIGZpeGVzIHVud2FudGVkIGluZXJ0aWEgbW92ZW1lbnQgYWZ0ZXIgc3VkZGVuIGRyYWcgc3RvcHNcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L3B1bGwvNDA0OC5cbiAqIElmIHRoaXMgUFIgZXZlciBnZXRzIG1lcmdlZCwgdGhpcyBmaWxlIGNhbiBiZSByZW1vdmVkLlxuICovXG52YXIgb25EcmFnRW5kID0gREcuTWFwLkRyYWcucHJvdG90eXBlLl9vbkRyYWdFbmQ7XG5cbkRHLk1hcC5EcmFnLmluY2x1ZGUoe1xuICAgIF9yZW1lbWJlclRpbWVBbmRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aW1lID0gdGhpcy5fbGFzdFRpbWUgPSArbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuICAgICAgICB0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuICAgICAgICB0aGlzLl90aW1lcy5wdXNoKHRpbWUpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgZGF0YSBwb2ludHMgb2xkZXIgdGhhbiA1MCBtc1xuICAgICAgICB3aGlsZSAodGltZSAtIHRoaXMuX3RpbWVzWzBdID4gNTApIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5fdGltZXMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25EcmFnOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1lbWJlclRpbWVBbmRQb3NpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAuZmlyZSgnbW92ZScsIGUpXG4gICAgICAgICAgICAuZmlyZSgnZHJhZycsIGUpO1xuICAgIH0sXG5cbiAgICBfb25EcmFnRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcC5vcHRpb25zLmluZXJ0aWEgJiYgIURHLkJyb3dzZXIudG91Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbWVtYmVyVGltZUFuZFBvc2l0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBvbkRyYWdFbmQuY2FsbCh0aGlzKTtcbiAgICB9XG59KTtcbiIsIi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1R1cmZqcy90dXJmLWluc2lkZS9ibG9iL21hc3Rlci9pbmRleC5qc1xuREcuUG9seVV0aWwuaW5zaWRlID0gZnVuY3Rpb24ocG9pbnQsIHBvbHlnb24sIHBvaW50UmVkdWNlKSB7XG4gICAgcG9pbnRSZWR1Y2UgPSBwb2ludFJlZHVjZSB8fCBERy5Qb2x5VXRpbC5fZGVmYXVsdFBvaW50UmVkdWNlO1xuICAgIHZhciBwb2x5cyA9IHBvbHlnb24uY29vcmRpbmF0ZXM7XG4gICAgdmFyIHB0ID0gcG9pbnRSZWR1Y2UocG9pbnQpO1xuXG4gICAgLy8gbm9ybWFsaXplIHRvIG11bHRpcG9seWdvblxuICAgIGlmIChwb2x5Z29uLnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICBwb2x5cyA9IFtwb2x5c107XG4gICAgfVxuXG4gICAgdmFyIGluc2lkZVBvbHkgPSBmYWxzZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBwb2x5cy5sZW5ndGggJiYgIWluc2lkZVBvbHkpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgaXQgaXMgaW4gdGhlIG91dGVyIHJpbmcgZmlyc3RcbiAgICAgICAgaWYgKHRoaXMuX2luUmluZyhwdCwgcG9seXNbaV1bMF0sIHBvaW50UmVkdWNlKSkge1xuICAgICAgICAgICAgdmFyIGluSG9sZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGsgPSAxO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHRoZSBwb2ludCBpbiBhbnkgb2YgdGhlIGhvbGVzXG4gICAgICAgICAgICB3aGlsZSAoayA8IHBvbHlzW2ldLmxlbmd0aCAmJiAhaW5Ib2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luUmluZyhwdCwgcG9seXNbaV1ba10sIHBvaW50UmVkdWNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbkhvbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluSG9sZSkgIHtcbiAgICAgICAgICAgICAgICBpbnNpZGVQb2x5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBpbnNpZGVQb2x5O1xufTtcblxuLy8gcHQgaXMgW3gseV0gYW5kIHJpbmcgaXMgW1t4LHldLCBbeCx5XSwuLl1cbkRHLlBvbHlVdGlsLl9pblJpbmcgPSBmdW5jdGlvbihwdCwgcmluZywgcG9pbnRSZWR1Y2UpIHtcbiAgICB2YXIgaXNJbnNpZGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJpbmcubGVuZ3RoIC0gMTsgaSA8IHJpbmcubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciBwaSA9IHBvaW50UmVkdWNlKHJpbmdbaV0pO1xuICAgICAgICB2YXIgcGogPSBwb2ludFJlZHVjZShyaW5nW2pdKTtcbiAgICAgICAgdmFyIHhpID0gcGlbMF0sIHlpID0gcGlbMV07XG4gICAgICAgIHZhciB4aiA9IHBqWzBdLCB5aiA9IHBqWzFdO1xuICAgICAgICB2YXIgaW50ZXJzZWN0ID0gKCh5aSA+IHB0WzFdKSAhPT0gKHlqID4gcHRbMV0pKSAmJlxuICAgICAgICAgICAgKHB0WzBdIDwgKHhqIC0geGkpICogKHB0WzFdIC0geWkpIC8gKHlqIC0geWkpICsgeGkpO1xuXG4gICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIGlzSW5zaWRlID0gIWlzSW5zaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc0luc2lkZTtcbn07XG5cbkRHLlBvbHlVdGlsLl9kZWZhdWx0UG9pbnRSZWR1Y2UgPSBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBwb2ludDtcbn07XG4iLCIvKipcbiAqINCSINGE0LDQudC70LUg0YHQvtC00LXQttCw0YLRgdGPINC40LfQvNC10L3QtdC90LjRjyDQtNC70Y8g0YPRgdC60L7RgNC10L3QuNGPINC70LjRhNC70LXRgtCwINC90LAg0LzQvtCx0LjQu9GM0L3Ri9GFINC00LXQstCw0LnRgdCw0YVcbiAqL1xuXG5pZiAoREcuQnJvd3Nlci5tb2JpbGUpIHtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDQpdCw0LrQsNC10LwgYWRkQ2xhc3Mg0LggcmVtb3ZlQ2xhc3MsINGH0YLQvtCx0Ysg0L7QvdC4INC90LUg0YDQsNCx0L7RgtCw0LvQuCDQtNC70Y8g0L7Qv9GA0LXQtNC10LvRkdC90L3Ri9GFINC60LvQsNGB0YHQvtCyXG4gICAgICAgICAqINCh0LTQtdC70LDQvdC+INGC0LDQuiwg0YfRgtC+0LHRiyDQvdC1INC80LXQvdGP0YLRjCDQutGD0YfRgyDQvNC10YLQvtC00L7QsiDQsiDQutC40YjQutCw0YUg0LvQuNGE0LvQtdGC0LBcbiAgICAgICAgICogXG4gICAgICAgICAqIGxlYWZsZXQtZHJhZ2dpbmcg0LggbGVhZmxldC1kcmFnLXRhcmdldCDQstGL0LfRi9Cy0LDQtdGCINC00LvQuNC90L3Ri9C5IHJlY2FsY3VsYXRlIHN0eWxlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYWRkQ2xhc3MgPSBMLkRvbVV0aWwuYWRkQ2xhc3M7XG4gICAgICAgIEwuRG9tVXRpbC5hZGRDbGFzcyA9IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2xlYWZsZXQtZHJhZ2dpbmcnIHx8XG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2xlYWZsZXQtZHJhZy10YXJnZXQnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFkZENsYXNzKGVsLCBuYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVtb3ZlQ2xhc3MgPSBMLkRvbVV0aWwucmVtb3ZlQ2xhc3M7XG4gICAgICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2xlYWZsZXQtZHJhZ2dpbmcnIHx8XG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2xlYWZsZXQtZHJhZy10YXJnZXQnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEwuRHJhZ2dhYmxlLmluY2x1ZGUoe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDQlNC+0LHQsNCy0LvQtdC90L4g0L7QutGA0YPQs9C70LXQvdC40LUg0L/QvtC30LjRhtC40LggdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCkuX3JvdW5kKClcbiAgICAgICAgICAgICAqINCYINGB0YDQsNCy0L3QtdC90LjQtSDRgSDQv9GA0LXQtNGD0LTRi9GJ0LXQuSBpZiAodGhpcy5fbmV3UG9zICYmIHRoaXMuX25ld1Bvcy54ID09IHBvcy54ICYmIHRoaXMuX25ld1Bvcy55ID09IHBvcy55KSB7XG4gICAgICAgICAgICAgKiDQp9GC0L7QsdGLINC+0LHQvdC+0LLQu9C10L3QuNC1IGRvbSDQv9GA0L7QuNGB0YXQvtC00LjQu9C+INGC0L7Qu9GM0LrQviDQv9GA0Lgg0YDQtdCw0LvRjNC90L7QvCDQuNC30LzQtdC90LXQvdC40LhcbiAgICAgICAgICAgICAqINCj0LHRgNCw0L3RiyDQutC70LDRgdGB0YsgbGVhZmxldC1kcmFnZ2luZyDQuCBsZWFmbGV0LWRyYWctdGFyZ2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vbk1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXG4gICAgICAgICAgICAgICAgLy8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXG4gICAgICAgICAgICAgICAgLy8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxuICAgICAgICAgICAgICAgIC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxuICAgICAgICAgICAgICAgIGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxuICAgICAgICAgICAgICAgICAgICBuZXdQb2ludCA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBuZXdQb2ludC5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcblxuICAgICAgICAgICAgICAgIGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9tb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0UG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQpLnN1YnRyYWN0KG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgYW5kIEVkZ2UgZG8gbm90IGdpdmUgdGhlIDx1c2U+IGVsZW1lbnQsIHNvIGZldGNoIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpICYmICh0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudEluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCkuX3JvdW5kKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RFdmVudCA9IGU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV3UG9zICYmIHRoaXMuX25ld1Bvcy54ID09IHBvcy54ICYmIHRoaXMuX25ld1Bvcy55ID09IHBvcy55KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9uZXdQb3MgPSBwb3M7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbVJlcXVlc3QgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVQb3NpdGlvbiwgdGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDQlNC70LjRgtC10LvRjNC90L7RgdGC0Ywg0LLRgdC10YUg0LjQvdC10YDRhtC40Lkg0L/RgNC4INC00LLQuNC20LXQvdC40Lgg0LrQsNGA0YLRiyDRgtC10L/QtdGA0YwgMSDRgdC10LrRg9C90LTQsFxuICAgICAgICAgKi9cbiAgICAgICAgTC5NYXAuRHJhZy5pbmNsdWRlKHtcbiAgICAgICAgICAgIF9vbkRyYWdFbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cbiAgICAgICAgICAgICAgICAgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG4gICAgICAgICAgICAgICAgbWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuICAgICAgICAgICAgICAgIGlmIChub0luZXJ0aWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gMSwgLy8gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5wYW5CeShvZmZzZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGRlY2VsZXJhdGlvbkR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXNlTGluZWFyaXR5OiBlYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub01vdmVTdGFydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSkoKTtcbn1cblxuTC5Nb2JpbGVUaWxlTGF5ZXIgPSBMLlRpbGVMYXllci5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgICAgICBMLlRpbGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHVybCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fcHJldmlld1VybCA9IERHLmNvbmZpZy5wcm90b2NvbCArXG4gICAgICAgICAgICAoREcuQnJvd3Nlci5yZXRpbmEgPyBERy5jb25maWcucHJldmlld1JldGluYVRpbGVTZXJ2ZXIgOiBERy5jb25maWcucHJldmlld1RpbGVTZXJ2ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQkdGL0YHRgtGA0L7QtSDQvdCw0LLQtdGI0LjQstCw0L3QuNC1INGB0L7QsdGL0YLQuNC5LCDQstC80LXRgdGC0L4gTC5Eb21VdGlsLm9uINC40YHQv9C+0LvRjNC30YPQtdC8INC/0YDQvtGB0YLQvtC1INC/0YDQuNGB0LLQsNC40LLQsNC90LjQtVxuICAgICAqL1xuICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSwgdXJsKSB7XG4gICAgICAgIHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIHRpbGUub25sb2FkID0gTC5iaW5kKHRoaXMuX3RpbGVPbkxvYWQsIHRoaXMsIGRvbmUsIHRpbGUpO1xuICAgICAgICB0aWxlLm9uZXJyb3IgPSBMLmJpbmQodGhpcy5fdGlsZU9uRXJyb3IsIHRoaXMsIGRvbmUsIHRpbGUpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgICAgIHRpbGUuY3Jvc3NPcmlnaW4gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXG4gICAgICAgICBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvSDY3XG4gICAgICAgICovXG4gICAgICAgIHRpbGUuYWx0ID0gJyc7XG4gICAgICAgIHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3JkcywgdXJsKTtcblxuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog0KPQsdGA0LDQvSDQutC70LDRgdGBIGxlYWZsZXQtdGlsZVxuICAgICAqINCU0L7QsdCw0LLQu9C10L0g0YXQsNC6INC00LvRjyDQv9GA0LXQstGM0Y4g0YLQsNC50LvQvtCyXG4gICAgICovXG4gICAgX2luaXRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgICAgIHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgICAgICAgdGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuICAgICAgICB0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG4gICAgICAgIHRpbGUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgICAgIHRpbGUub25zZWxlY3RzdGFydCA9IEwuVXRpbC5mYWxzZUZuO1xuICAgICAgICB0aWxlLm9ubW91c2Vtb3ZlID0gTC5VdGlsLmZhbHNlRm47XG5cbiAgICAgICAgLy8gd2l0aG91dCB0aGlzIGhhY2ssIHRpbGVzIGRpc2FwcGVhciBhZnRlciB6b29tIG9uIENocm9tZSBmb3IgQW5kcm9pZFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDc4XG4gICAgICAgIGlmIChMLkJyb3dzZXIuYW5kcm9pZCAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMykge1xuICAgICAgICAgICAgdGlsZS5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQo9Cx0YDQsNC9INC60LvQsNGB0YEgbGVhZmxldC10aWxlLWNvbnRhaW5lclxuICAgICAqL1xuICAgIF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG4gICAgICAgICAgICBtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XG5cbiAgICAgICAgaWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICAgICAgZm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG4gICAgICAgICAgICBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgaWYgKCFsZXZlbCkge1xuICAgICAgICAgICAgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuICAgICAgICAgICAgbGV2ZWwuZWwgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcblxuICAgICAgICAgICAgbGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuICAgICAgICAgICAgbGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG4gICAgICAgICAgICBsZXZlbC56b29tID0gem9vbTtcblxuICAgICAgICAgICAgdGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuICAgICAgICAgICAgLy8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cbiAgICAgICAgICAgIEwuVXRpbC5mYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XG5cbiAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQo9Cx0YDQsNC90L4g0LTQvtCx0LDQstC70LXQvdC40LUg0YLQsNC50LvQvtCyINGH0LXRgNC10LcgZG9jdW1lbnRGcmFnbWVudFxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICBpZiAoIW1hcCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG4gICAgICAgIGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkgeyBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7IH1cbiAgICAgICAgaWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cbiAgICAgICAgdmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuICAgICAgICAgICAgdGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShwaXhlbEJvdW5kcyksXG4gICAgICAgICAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuICAgICAgICAgICAgcXVldWUgPSBbXSxcbiAgICAgICAgICAgIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLFxuICAgICAgICAgICAgbm9QcnVuZVJhbmdlID0gbmV3IEwuQm91bmRzKHRpbGVSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG4gICAgICAgICAgICBpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKEwucG9pbnQoYy54LCBjLnkpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuICAgICAgICAvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuICAgICAgICBpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX3RpbGVab29tKSA+IDEpIHsgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pOyByZXR1cm47IH1cblxuICAgICAgICAvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cbiAgICAgICAgZm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBuZXcgTC5Qb2ludChpLCBqKTtcbiAgICAgICAgICAgICAgICBjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXTtcbiAgICAgICAgICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWxlLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goY29vcmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcbiAgICAgICAgcXVldWUuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzLlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbG9hZGluZycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCB0aGlzLl9sZXZlbC5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog0JTQu9GPINGC0LDQudC70LAg0L3QtSDQvdGD0LbQvdC+INCz0YDRg9C30LjRgtGMINC/0YDQtdCy0YzRjiwg0LXRgdC70Lgg0YPQttC1INC/0L7QutCw0LfRi9Cy0LDQtdGC0YHRjyDRgtCw0LnQuyDRgSDQvNC10L3RjNGI0LXQs9C+INC30YPQvNCwXG4gICAgICovXG4gICAgX25lZWRQcmV2aWV3VGlsZTogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgIHZhciBjb29yZHMyID0gTC5wb2ludChcbiAgICAgICAgICAgIGNvb3Jkcy54IC8gMixcbiAgICAgICAgICAgIGNvb3Jkcy55IC8gMlxuICAgICAgICApLl9mbG9vcigpO1xuXG4gICAgICAgIGNvb3JkczIueiA9IGNvb3Jkcy56IC0gMTtcblxuICAgICAgICB2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpXG5cbiAgICAgICAgcmV0dXJuICF0aGlzLl90aWxlc1trZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQlNC+0LHQsNCy0LvQtdC90LAg0LvQvtCz0LjQutCwINGBINC/0YDQtdCy0YzRjiDRgtCw0LnQu9Cw0LzQuFxuICAgICAqL1xuICAgIF9hZGRUaWxlOiBmdW5jdGlvbihjb29yZHMsIGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcbiAgICAgICAgICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG4gICAgICAgIHZhciB3cmFwQ29vcmRzID0gdGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpO1xuICAgICAgICB2YXIgbmVlZFByZXZpZXcgPSB0aGlzLl9uZWVkUHJldmlld1RpbGUod3JhcENvb3Jkcyk7XG5cbiAgICAgICAgdmFyIHVybCA9IG5lZWRQcmV2aWV3ID8gdGhpcy5fcHJldmlld1VybCA6IHRoaXMuX3VybDtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUod3JhcENvb3JkcywgTC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSwgdXJsKTtcblxuICAgICAgICB0aGlzLl9pbml0VGlsZSh0aWxlLCBuZWVkUHJldmlldyk7XG5cbiAgICAgICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG4gICAgICAgIC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuICAgICAgICB0aGlzLl90aWxlc1trZXldID0ge1xuICAgICAgICAgICAgZWw6IHRpbGUsXG4gICAgICAgICAgICBwcmV2aWV3OiBuZWVkUHJldmlldyxcbiAgICAgICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICAgICAgY3VycmVudDogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcbiAgICAgICAgLy8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuICAgICAgICAvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuICAgICAgICB0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG4gICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgY29vcmRzOiBjb29yZHNcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqINCj0LHRgNCw0L0gZmFkZUFuaW1hdGVkINC4INC60LvQsNGB0YEgbGVhZmxldC10aWxlLWxvYWRlZFxuICAgICAqL1xuICAgIF90aWxlUmVhZHk6IGZ1bmN0aW9uKGNvb3JkcywgZXJyLCB0aWxlKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuICAgICAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgICAgICAgaWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG4gICAgICAgIC8vINCV0YHQu9C4INGDINGC0LDQudC70LAg0YPQttC1INC10YHRgtGMINC+0YDQuNCz0LjQvdCw0LvRjNC90LDRjyAo0L3QtSDQv9C+0LbQsNGC0LDRjykg0LrQsNGA0YLQuNC90LrQsCxcbiAgICAgICAgLy8g0YLQviDQt9Cw0LzQtdC90LjQvCDQv9GA0LXQstGM0Y4g0L3QsCDQvdC10LVcbiAgICAgICAgaWYgKHRpbGUub3JpZ2luYWxFbCAmJiB0aWxlLmVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRpbGUuZWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGlsZS5vcmlnaW5hbEVsLCB0aWxlLmVsKTtcbiAgICAgICAgICAgIHRpbGUuZWwgPSB0aWxlLm9yaWdpbmFsRWw7XG5cbiAgICAgICAgICAgIHRpbGUub3JpZ2luYWxFbCA9IG51bGw7XG4gICAgICAgICAgICB0aWxlLnByZXZpZXcgPSBmYWxzZTtcblxuICAgICAgICAvLyDQldGB0LvQuCDRgyDRgtCw0LnQu9CwINC10YHRgtGMINGC0L7Qu9GM0LrQviDQv9GA0LXQstGM0Y4sINGC0L4g0LTQvtCx0LDQstC40Lwg0LXQs9C+INC90LAg0LrQsNGA0YLRg1xuICAgICAgICAvLyDQmCDQvdCw0YfQvdC10Lwg0LPRgNGD0LfQuNGC0Ywg0L7RgNC40LPQuNC90LDQu9GM0L3Ri9C5XG4gICAgICAgIH0gZWxzZSBpZiAodGlsZS5wcmV2aWV3KSB7XG4gICAgICAgICAgICB0aWxlLm9yaWdpbmFsRWwgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBMLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpLCB0aGlzLl91cmwpO1xuICAgICAgICAgICAgdGhpcy5faW5pdFRpbGUodGlsZS5vcmlnaW5hbEVsKTtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLm9yaWdpbmFsRWwsIHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSk7XG5cbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgdGlsZS5lbC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG4gICAgICAgIHRpbGUuYWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgdGlsZS5lbC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG5cbiAgICAgICAgICAgIC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG4gICAgICAgICAgICAgICAgdGlsZTogdGlsZS5lbCxcbiAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3Jkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBAZXZlbnQgbG9hZDogRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuICAgICAgICAgICAgdGhpcy5maXJlKCdsb2FkJyk7XG5cbiAgICAgICAgICAgIGlmIChMLkJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcbiAgICAgICAgICAgICAgICAvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQkiDQvtGC0LvQuNGH0LjQtSDQvtGCINC+0YDQuNCz0LjQvdCw0LvRjNC90L7Qs9C+INC80LXRgtC+0LTQsCwg0LfQtNC10YHRjCB1cmwg0L/RgNC+0LrQuNC00YvQstCw0LXRgtGB0Y8g0L/QsNGA0LDQvNC10YLRgNC+0LxcbiAgICAgKi9cbiAgICBnZXRUaWxlVXJsOiBmdW5jdGlvbihjb29yZHMsIHVybCkge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIHI6IEwuQnJvd3Nlci5yZXRpbmEgPyAnQDJ4JyA6ICcnLFxuICAgICAgICAgICAgczogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXG4gICAgICAgICAgICB4OiBjb29yZHMueCxcbiAgICAgICAgICAgIHk6IGNvb3Jkcy55LFxuICAgICAgICAgICAgejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xuICAgICAgICAgICAgdmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50bXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhWyd5J10gPSBpbnZlcnRlZFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEwuVXRpbC50ZW1wbGF0ZSh1cmwsIEwuZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xuICAgIH0sXG59KTtcbiIsIkRHLkNvbnRyb2wuWm9vbS5pbmNsdWRlKERHLkxvY2FsZSk7XG5ERy5Db250cm9sLlpvb20uRGljdGlvbmFyeSA9IHt9O1xuXG5ERy5Db250cm9sLlpvb20uaW5jbHVkZSh7XG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgem9vbU5hbWUgPSAnZGctem9vbScsXG4gICAgICAgICAgICBidXR0b25UZW1wbGF0ZSA9ICc8ZGl2IGNsYXNzPVwiZGctY29udHJvbC1yb3VuZF9faWNvbiAnICsgem9vbU5hbWUgKyAnX19jb250cm9sICcgKyB6b29tTmFtZSArICdfX2J1dHRvbiAnICsgem9vbU5hbWUgKyAnX19idXR0b25fdHlwZV97dHlwZX1cIj48L2Rpdj4nLFxuICAgICAgICAgICAgY29udGFpbmVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lKTtcblxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG5cbiAgICAgICAgdGhpcy5fem9vbUluQnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKERHLlV0aWwudGVtcGxhdGUoYnV0dG9uVGVtcGxhdGUsIHt0eXBlIDogJ2luJ30pLCB0aGlzLnQoJ3pvb21faW4nKSwgJ2RnLWNvbnRyb2wtcm91bmQgJyArIHpvb21OYW1lICsgJ19faW4nLCBjb250YWluZXIsIHRoaXMuX3pvb21JbiwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oREcuVXRpbC50ZW1wbGF0ZShidXR0b25UZW1wbGF0ZSwge3R5cGUgOiAnb3V0J30pLCB0aGlzLnQoJ3pvb21fb3V0JyksICdkZy1jb250cm9sLXJvdW5kICcgKyB6b29tTmFtZSArICdfX291dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcbiAgICAgICAgbWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX29yaWdpbmFsQ3JlYXRlQnV0dG9uOiBERy5Db250cm9sLlpvb20ucHJvdG90eXBlLl9jcmVhdGVCdXR0b24sXG5cbiAgICAvLyBzZXQgYWN0aXZlIHN0YXRlIGNvbnRyb2wgb24gbW9iaWxlIGRldmljZXNcbiAgICBfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuX29yaWdpbmFsQ3JlYXRlQnV0dG9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgIHZhciBpY29uID0gbGluay5jaGlsZHJlblswXTtcbiAgICAgICAgdmFyIGxpbmtBY3RpdmVDbGFzcyA9ICdkZy1jb250cm9sLXJvdW5kX3N0YXRlX2FjdGl2ZSc7XG4gICAgICAgIHZhciBpY29uQWN0aXZlQ2xhc3MgPSAnZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUnO1xuXG4gICAgICAgIERHLkRvbUV2ZW50XG4gICAgICAgICAgICAub24obGluaywgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKGxpbmssIGxpbmtBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhpY29uLCBpY29uQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihsaW5rLCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKGxpbmssIGxpbmtBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyhpY29uLCBpY29uQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfSxcblxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fem9vbUluQnV0dG9uIHx8ICF0aGlzLl96b29tT3V0QnV0dG9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl96b29tSW5CdXR0b24udGl0bGUgPSB0aGlzLnQoJ3pvb21faW4nKTtcbiAgICAgICAgdGhpcy5fem9vbU91dEJ1dHRvbi50aXRsZSA9IHRoaXMudCgnem9vbV9vdXQnKTtcbiAgICB9XG59KTtcbiIsIkRHLkNvbnRyb2wuWm9vbS5EaWN0aW9uYXJ5LnJ1ID0ge1xuICAgIHpvb21faW4gOiAn0J/RgNC40LHQu9C40LfQuNGC0YwnLFxuICAgIHpvb21fb3V0IDogJ9Ce0YLQtNCw0LvQuNGC0YwnXG59OyIsIkRHLkNvbnRyb2wuWm9vbS5EaWN0aW9uYXJ5Lml0ID0ge1xuICAgIHpvb21faW4gOiAnWm9vbSBhdmFudGknLFxuICAgIHpvb21fb3V0IDogJ1pvb20gaW5kaWV0cm8nXG59OyIsIkRHLkNvbnRyb2wuWm9vbS5EaWN0aW9uYXJ5LmNzID0ge1xuICAgIHpvb21faW4gOiAnUMWZaWJsw63Fvml0JyxcbiAgICB6b29tX291dCA6ICdPZGTDoWxpdCdcbn07IiwiREcuQ29udHJvbC5ab29tLkRpY3Rpb25hcnkuZW4gPSB7XG4gICAgem9vbV9pbiA6ICdab29tIGluJyxcbiAgICB6b29tX291dCA6ICdab29tIG91dCdcbn07IiwiREcuQ29udHJvbC5ab29tLkRpY3Rpb25hcnkuZXMgPSB7XG4gICAgem9vbV9pbiA6ICdBY2VyY2FyJyxcbiAgICB6b29tX291dCA6ICdBbGVqYXInXG59O1xuIiwidmFyIGR1c3QgPSByZXF1aXJlKCdkdXN0anMtbGlua2VkaW4nKTtcbnJlcXVpcmUoJ2R1c3Rqcy1oZWxwZXJzJyk7XG5cbkRHLmR1c3QgPSBmdW5jdGlvbihuYW1lLCBkYXRhKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIC8vIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgc3luY2hyb25vdXNseSwgc28gdGhpcyB3b3Jrc1xuICAgIGR1c3QucmVuZGVyKG5hbWUsIGRhdGEsIGZ1bmN0aW9uKGVyciwgaHRtbCkge1xuICAgICAgICByZXN1bHQgPSBodG1sO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJERy5Db250cm9sLkF0dHJpYnV0aW9uLmluY2x1ZGUoREcuTG9jYWxlKTtcbkRHLkNvbnRyb2wuQXR0cmlidXRpb24uRGljdGlvbmFyeSA9IHt9O1xuREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5pbmNsdWRlKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnXG4gICAgfSxcblxuICAgIF9nZXRMaW5rOiBmdW5jdGlvbihsaW5rVHlwZSkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgICAgdmFyIGRpY3Rpb25hcnkgPSB7XG4gICAgICAgICAgICBydToge1xuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9sb2dvOiAnaHR0cDovL2luZm8uMmdpcy5ydS8/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfYXBpbGluazogJ2h0dHA6Ly9hcGkuMmdpcy5ydS8/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbGljZW5zZTogJ2h0dHA6Ly9sYXcuMmdpcy5ydS9hcGktcnVsZXMvJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXQ6IHtcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbG9nbzogJ2h0dHA6Ly8yZ2lzLml0Lz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9hcGlsaW5rOiAnaHR0cDovLzJnaXMuaXQvP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xpY2Vuc2U6ICdodHRwOi8vbGF3LjJnaXMuaXQvbGljZW5zaW5nLWFncmVlbWVudC8nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjejoge1xuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9sb2dvOiAnaHR0cDovL3ByYWhhLjJnaXMuY3ovP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2FwaWxpbms6ICdodHRwOi8vcHJhaGEuMmdpcy5jei8/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbGljZW5zZTogJ2h0dHA6Ly9sYXcuMmdpcy5jei9hcGktcnVsZXMvJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2w6IHtcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbG9nbzogJ2h0dHA6Ly9zYW50aWFnby4yZ2lzLmNsLz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9hcGlsaW5rOiAnaHR0cDovL3NhbnRpYWdvLjJnaXMuY2wvP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xpY2Vuc2U6ICdodHRwOi8vbGF3LjJnaXMuY2wvYXBpLXJ1bGVzLydcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGN5OiB7XG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xvZ286ICdodHRwOi8vaW5mby4yZ2lzLmNvbS5jeS9sZW1lc29zP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2FwaWxpbms6ICdodHRwOi8vaW5mby4yZ2lzLmNvbS5jeS9sZW1lc29zP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xpY2Vuc2U6ICdodHRwOi8vbGF3LjJnaXMuY29tLmN5L2FwaS1ydWxlcy8nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhZToge1xuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9sb2dvOiAnaHR0cDovL2luZm8uMmdpcy5hZS9kdWJhaT91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9hcGlsaW5rOiAnaHR0cDovL2luZm8uMmdpcy5hZS9kdWJhaT91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9saWNlbnNlOiAnaHR0cDovL2xhdy4yZ2lzLmFlL2FwaS1ydWxlcy8nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG5cbiAgICAgICAgdmFyIGNvdW50cnlDb2RlID0gKHRoaXMuX2NvdW50cnlDb2RlIGluIGRpY3Rpb25hcnkpID8gdGhpcy5fY291bnRyeUNvZGUgOiAncnUnO1xuXG4gICAgICAgIHJldHVybiBkaWN0aW9uYXJ5W2NvdW50cnlDb2RlXVtsaW5rVHlwZV07XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgaWYgKCFtYXAuX2NvcHlyaWdodCkge1xuICAgICAgICAgICAgbWFwLl9jb3B5cmlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctYXR0cmlidXRpb24nKTtcbiAgICAgICAgREcuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XG4gICAgICAgICAgICBpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24obGFuZywgb3NtLCBjb3VudHJ5Q29kZSkge1xuICAgICAgICBpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAodHlwZW9mIG9zbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX29zbSA9IG9zbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY291bnRyeUNvZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3VudHJ5Q29kZSA9IGNvdW50cnlDb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJpYnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW10sXG4gICAgICAgICAgICBjb3B5cmlnaHQgPSAnJztcblxuICAgICAgICBpZiAodGhpcy5fZmlyc3QpIHtcbiAgICAgICAgICAgIGNvcHlyaWdodCA9IHRoaXMuX2dldEF0dHJpYnV0aW9uSFRNTChsYW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XG4gICAgICAgICAgICBwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBjb3B5cmlnaHQgKyBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xuICAgIH0sXG4gICAgX2dldERhdGE6IGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdvc20nOiB0aGlzLl9vc20sXG4gICAgICAgICAgICAnd29ya19vbic6IHRoaXMudCgnd29ya19vbicpLFxuICAgICAgICAgICAgJ2xhbmcnOiBsYW5nIHx8IHRoaXMuX21hcC5nZXRMYW5nKCksXG4gICAgICAgICAgICAnY29weXJpZ2h0X2FwaWxpbmsnOiB0aGlzLl9nZXRMaW5rKCdjb3B5cmlnaHRfYXBpbGluaycpLFxuICAgICAgICAgICAgJ2NvcHlyaWdodF9saWNlbnNlJzogdGhpcy5fZ2V0TGluaygnY29weXJpZ2h0X2xpY2Vuc2UnKSxcbiAgICAgICAgICAgICdjb3B5cmlnaHRfbG9nbyc6IHRoaXMuX2dldExpbmsoJ2NvcHlyaWdodF9sb2dvJyksXG4gICAgICAgICAgICAnbGljZW5zZV9hZ3JlZW1lbnQnOiB0aGlzLnQoJ2xpY2Vuc2VfYWdyZWVtZW50JyksXG4gICAgICAgICAgICAnQVBJXzJHSVMnOiB0aGlzLnQoJ0FQSV8yR0lTJylcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIF9nZXRBdHRyaWJ1dGlvbkhUTUw6IGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgICAgcmV0dXJuIERHLmR1c3QoJ0RHQXR0cmlidXRpb24vY29weXJpZ2h0JywgdGhpcy5fZ2V0RGF0YShsYW5nKSk7XG4gICAgfSxcbiAgICBfcmVuZGVyVHJhbnNsYXRpb246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKGUubGFuZyk7XG4gICAgfVxufSk7XG5cbkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2NvcHlyaWdodCkge1xuICAgICAgICBERy5jb250cm9sLmF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XG4gICAgfVxufSk7XG4iLCJERy5Db250cm9sLkF0dHJpYnV0aW9uLkRpY3Rpb25hcnkucnUgPSB7XG4gICAgbGljZW5zZV9hZ3JlZW1lbnQ6ICfQm9C40YbQtdC90LfQuNC+0L3QvdC+0LUg0YHQvtCz0LvQsNGI0LXQvdC40LUnLFxuICAgIHdvcmtfb246ICfQoNCw0LHQvtGC0LDQtdGCINC90LAnLFxuICAgIEFQSV8yR0lTOiAnQVBJIDLQk9CY0KEnXG59O1xuIiwiREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5EaWN0aW9uYXJ5Lml0ID0ge1xuXHRsaWNlbnNlX2FncmVlbWVudCA6ICdBY2NvcmRvIGRpIGxpY2VuemEnLFxuICAgIHdvcmtfb246ICcgJyxcblx0QVBJXzJHSVM6ICcyR0lTIEFQSSdcbn07XG4iLCJERy5Db250cm9sLkF0dHJpYnV0aW9uLkRpY3Rpb25hcnkuY3MgPSB7XG5cdGxpY2Vuc2VfYWdyZWVtZW50OiAnTGljZW7EjW7DrSBzbWxvdXZhJyxcblx0d29ya19vbjogJ1ByYWN1amUgbmEnLFxuICAgIEFQSV8yR0lTOiAnQVBJIDJHSVMnXG59O1xuIiwiREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5EaWN0aW9uYXJ5LmVuID0ge1xuICAgIGxpY2Vuc2VfYWdyZWVtZW50OiAnTGljZW5zZSBhZ3JlZW1lbnQnLFxuICAgIHdvcmtfb246ICdVc2VzJyxcbiAgICBBUElfMkdJUzogJzJHSVMgQVBJJ1xufTtcbiIsIkRHLkNvbnRyb2wuQXR0cmlidXRpb24uRGljdGlvbmFyeS5lcyA9IHtcblx0bGljZW5zZV9hZ3JlZW1lbnQgOiAnQWN1ZXJkbyBkZSBsaWNlbmNpYScsXG4gICAgd29ya19vbjogJyAnLFxuXHRBUElfMkdJUzogJzJHSVMgQVBJJ1xufTtcbiIsIkRHLkNvbnRyb2wuTG9jYXRpb24gPSBERy5Sb3VuZENvbnRyb2wuZXh0ZW5kKHtcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgRGljdGlvbmFyeToge31cbiAgICB9LFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBpY29uQ2xhc3M6ICdsb2NhdGUnLFxuICAgICAgICBwb3NpdGlvbjogREcuQnJvd3Nlci5tb2JpbGUgPyAnYm90dG9tcmlnaHQnIDogJ3RvcGxlZnQnLFxuICAgICAgICBkcmF3Q2lyY2xlOiB0cnVlLFxuICAgICAgICBmb2xsb3c6IHRydWUsICAvLyBmb2xsb3cgd2l0aCB6b29tIGFuZCBwYW4gdGhlIHVzZXIncyBsb2NhdGlvblxuICAgICAgICBzdG9wRm9sbG93aW5nT25EcmFnOiBmYWxzZSwgLy8gaWYgZm9sbG93IGlzIHRydWUsIHN0b3AgZm9sbG93aW5nIHdoZW4gbWFwIGlzIGRyYWdnZWRcbiAgICAgICAgbWV0cmljOiB0cnVlLFxuICAgICAgICBvbkxvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uKC8qZXJyKi8pIHtcbiAgICAgICAgICAgIC8vIHRoaXMgZXZlbnQgaXMgY2FsbGVkIGluIGNhc2Ugb2YgYW55IGxvY2F0aW9uIGVycm9yXG4gICAgICAgICAgICAvLyB0aGF0IGlzIG5vdCBhIHRpbWUgb3V0IGVycm9yLlxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBvbkxvY2F0aW9uT3V0c2lkZU1hcEJvdW5kczogZnVuY3Rpb24oLypjb250ZXh0Ki8pIHtcbiAgICAgICAgICAgIC8vIHRoaXMgZXZlbnQgaXMgcmVwZWF0ZWRseSBjYWxsZWQgd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlc1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY29udGV4dC50KCdvdXRzaWRlTWFwQm91bmRzTXNnJykpO1xuICAgICAgICB9LFxuICAgICAgICBsb2NhdGVPcHRpb25zOiB7fVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIERHLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoIW5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ldmVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0aGlzLl9sb2NhdGVPcHRpb25zID0ge1xuICAgICAgICAgICAgd2F0Y2g6IHRydWUsICAvLyBpZiB5b3Ugb3ZlcndyaXRlIHRoaXMsIHZpc3VhbGl6YXRpb24gY2Fubm90IGJlIHVwZGF0ZWRcbiAgICAgICAgICAgIHNldFZpZXc6IHRydWUsXG4gICAgICAgICAgICBtYXhpbXVtQWdlOiBJbmZpbml0eSxcbiAgICAgICAgICAgIG1heFpvb206IEluZmluaXR5XG4gICAgICAgIH07XG4gICAgICAgIERHLmV4dGVuZCh0aGlzLl9sb2NhdGVPcHRpb25zLCB0aGlzLm9wdGlvbnMubG9jYXRlT3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fcmVzZXRWYXJpYWJsZXMoKTtcblxuICAgICAgICB0aGlzLm9uKHtcbiAgICAgICAgICAgICdjbGljayc6IHRoaXMuX2hhbmRsZUxvY2F0ZSxcbiAgICAgICAgICAgICdhZGQnOiB0aGlzLl9pbml0TG9jYXRlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfaW5pdExvY2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xheWVyID0gbmV3IERHLkxheWVyR3JvdXAoKTtcbiAgICAgICAgdGhpcy5fbGF5ZXIuYWRkVG8odGhpcy5fbWFwKTtcblxuICAgICAgICAvLyBldmVudCBob29rc1xuICAgICAgICB0aGlzLl9tYXAub24oe1xuICAgICAgICAgICAgJ2xvY2F0aW9uZm91bmQnOiB0aGlzLl9vbkxvY2F0aW9uRm91bmQsXG4gICAgICAgICAgICAnbG9jYXRpb25lcnJvcic6IHRoaXMuX29uTG9jYXRpb25FcnJvclxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZUxvY2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgKCF0aGlzLl9ldmVudCB8fFxuICAgICAgICAgICAgKHRoaXMuX21hcC5nZXRCb3VuZHMoKS5jb250YWlucyh0aGlzLl9ldmVudC5sYXRsbmcpIHx8XG4gICAgICAgICAgICB0aGlzLl9pc091dHNpZGVNYXBCb3VuZHMoKSkpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wTG9jYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhdGVPbk5leHRMb2NhdGlvbkZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAubG9jYXRlKHRoaXMuX2xvY2F0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvbGxvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Rm9sbG93aW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyRXJyb3IoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzdWFsaXplTG9jYXRpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgncmVxdWVzdGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9vbkxvY2F0aW9uRm91bmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBkbyBhbnl0aGluZyBpZiB0aGUgbG9jYXRpb24gaGFzIG5vdCBjaGFuZ2VkXG4gICAgICAgIGlmICh0aGlzLl9ldmVudCAmJlxuICAgICAgICAgICAgKHRoaXMuX2V2ZW50LmxhdGxuZy5sYXQgPT09IGUubGF0bG5nLmxhdCAmJlxuICAgICAgICAgICAgIHRoaXMuX2V2ZW50LmxhdGxuZy5sbmcgPT09IGUubGF0bG5nLmxuZyAmJlxuICAgICAgICAgICAgIHRoaXMuX2V2ZW50LmFjY3VyYWN5ID09PSBlLmFjY3VyYWN5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V2ZW50ID0gZTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvbGxvdyAmJiB0aGlzLl9mb2xsb3dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2F0ZU9uTmV4dExvY2F0aW9uRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlzdWFsaXplTG9jYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX3N0YXJ0Rm9sbG93aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZm9sbG93aW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdG9wRm9sbG93aW5nT25EcmFnKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAub24oJ2RyYWdzdGFydCcsIHRoaXMuX3N0b3BGb2xsb3dpbmcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zdG9wRm9sbG93aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZm9sbG93aW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RvcEZvbGxvd2luZ09uRHJhZykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignZHJhZ3N0YXJ0JywgdGhpcy5fc3RvcEZvbGxvd2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzdWFsaXplTG9jYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX2lzT3V0c2lkZU1hcEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJlxuICAgICAgICAgICAgIXRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcy5jb250YWlucyh0aGlzLl9ldmVudC5sYXRsbmcpO1xuICAgIH0sXG5cbiAgICBfdmlzdWFsaXplTG9jYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnQuYWNjdXJhY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnQuYWNjdXJhY3kgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuX2V2ZW50LmFjY3VyYWN5O1xuXG4gICAgICAgIGlmICh0aGlzLl9sb2NhdGVPbk5leHRMb2NhdGlvbkZvdW5kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNPdXRzaWRlTWFwQm91bmRzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25Mb2NhdGlvbk91dHNpZGVNYXBCb3VuZHModGhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0Vmlldykge1xuICAgICAgICAgICAgICAgIHZhciB6b29tID0gdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkubWF4Wm9vbSB8fCBERy5jb25maWcucHJvamVjdExlYXZlTWF4Wm9vbTtcbiAgICAgICAgICAgICAgICB6b29tID0gTWF0aC5taW4odGhpcy5fbG9jYXRlT3B0aW9ucy5tYXhab29tLCB6b29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuc2V0Vmlldyh0aGlzLl9ldmVudC5sYXRsbmcsIHpvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9jYXRlT25OZXh0TG9jYXRpb25Gb3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2lyY2xlIHdpdGggdGhlIHJhZGl1cyBvZiB0aGUgbG9jYXRpb24ncyBhY2N1cmFjeVxuICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICBjbGlja2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29sb3I6ICcjRkZGJyxcbiAgICAgICAgICAgIGZpbGxDb2xvcjogJyNGRkYnLFxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNCxcbiAgICAgICAgICAgIHdlaWdodDogMCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuM1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyYXdDaXJjbGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2lyY2xlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlID0gREcuY2lyY2xlKHRoaXMuX2V2ZW50LmxhdGxuZywgcmFkaXVzLCBzdHlsZSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRvKHRoaXMuX2xheWVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLnNldExhdExuZyh0aGlzLl9ldmVudC5sYXRsbmcpLnNldFJhZGl1cyhyYWRpdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcmtlckNsYXNzID0gJ2RnLWxvY2F0aW9uX19waW4nO1xuXG4gICAgICAgIG1hcmtlckNsYXNzICs9IHRoaXMuX2ZvbGxvd2luZyA/ICgnICcgKyBtYXJrZXJDbGFzcyArICdzdGF0ZV9mb2xsb3dpbmcnKSA6ICcnO1xuICAgICAgICAvLyBzbWFsbCBpbm5lciBtYXJrZXJcbiAgICAgICAgdmFyIG0gPSB7XG4gICAgICAgICAgICBpY29uOiBERy5kaXZJY29uKHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IG1hcmtlckNsYXNzLFxuICAgICAgICAgICAgICAgIGljb25TaXplOiBbMjAsIDIwXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRoaXMuX21hcmtlcikge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyID0gREcubWFya2VyKHRoaXMuX2V2ZW50LmxhdGxuZywgbSlcbiAgICAgICAgICAgICAgICAuYmluZExhYmVsKHRoaXMudCgneW91X2FyZV9oZXJlJykpXG4gICAgICAgICAgICAgICAgLmFkZFRvKHRoaXMuX2xheWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlci5zZXRMYXRMbmcodGhpcy5fZXZlbnQubGF0bG5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIERHLkRvbUV2ZW50Lm9uKHRoaXMuX21hcmtlciwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZmlyZUV2ZW50KCdkZ0xvY2F0ZUNsaWNrJyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhpcy5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKCdhY3RpdmUnKTtcbiAgICB9LFxuXG4gICAgX3Jlc2V0VmFyaWFibGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZvbGxvd2luZyA9IGZhbHNlO1xuICAgIH0sXG5cblxuICAgIF9zdG9wTG9jYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbWFwLnN0b3BMb2NhdGUoKTtcbiAgICAgICAgdGhpcy5fbWFwLm9mZignZHJhZ3N0YXJ0JywgdGhpcy5fc3RvcEZvbGxvd2luZyk7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgpO1xuICAgICAgICB0aGlzLl9yZXNldFZhcmlhYmxlcygpO1xuXG4gICAgICAgIHRoaXMuX2xheWVyLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgIHRoaXMuX21hcmtlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY2lyY2xlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9ldmVudCA9IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgX29uTG9jYXRpb25FcnJvcjogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vIGlnbm9yZSB0aW1lIG91dCBlcnJvciBpZiB0aGUgbG9jYXRpb24gaXMgd2F0Y2hlZFxuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDMgJiYgdGhpcy5fbG9jYXRlT3B0aW9ucy53YXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RvcExvY2F0ZSgpO1xuICAgICAgICB0aGlzLl9lcnJvciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctbGFiZWwgZGctbGFiZWxfbmFtZV9sb2NhdGlvbi1lcnJvcicsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2Vycm9yVGV4dCA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctbGFiZWxfX2NvbnRlbnQnLCB0aGlzLl9lcnJvcik7XG4gICAgICAgIHRoaXMuX2Vycm9yVGV4dC5pbm5lckhUTUwgPSB0aGlzLnQoJ2NhbnRfZmluZCcpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX2NsZWFyRXJyb3IoKTtcbiAgICAgICAgfSwgMzAwMCk7XG5cbiAgICAgICAgLy9zaG93IGxvY2F0aW9uIGVycm9yXG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkxvY2F0aW9uRXJyb3IoZXJyKTtcbiAgICB9LFxuXG4gICAgX2NsZWFyRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9lcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yVGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVuZGVyVHJhbnNsYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluaykge1xuICAgICAgICAgICAgdGhpcy5fbGluay50aXRsZSA9IHRoaXMudCgnYnV0dG9uX3RpdGxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21hcmtlcikge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyLmJpbmRMYWJlbCh0aGlzLnQoJ3lvdV9hcmVfaGVyZScpKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5ERy5jb250cm9sLmxvY2F0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuQ29udHJvbC5Mb2NhdGlvbihvcHRpb25zKTtcbn07XG5cbkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9uQ29udHJvbCkge1xuICAgICAgICB0aGlzLmxvY2F0aW9uQ29udHJvbCA9IERHLmNvbnRyb2wubG9jYXRpb24odGhpcy5vcHRpb25zLmxvY2F0aW9uQ29udHJvbCk7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbCh0aGlzLmxvY2F0aW9uQ29udHJvbCk7XG4gICAgfVxufSk7XG4iLCJERy5Db250cm9sLkxvY2F0aW9uLkRpY3Rpb25hcnkucnUgPSB7XG5cdCBjYW50X2ZpbmQgOiAn0JzRiyDQvdC1INGB0LzQvtCz0LvQuCDQktCw0YEg0L3QsNC50YLQuCcsXG5cdCB5b3VfYXJlX2hlcmUgOiAn0JLRiyDQt9C00LXRgdGMJyxcblx0IGJ1dHRvbl90aXRsZSA6ICfQndCw0LnRgtC4INCS0LDRgSDQvdCwINC60LDRgNGC0LUnXG59OyIsIkRHLkNvbnRyb2wuTG9jYXRpb24uRGljdGlvbmFyeS5pdCA9IHtcblx0IGNhbnRfZmluZCA6ICdOb24gc2lhbW8gcml1c2NpdGkgYSBsb2NhbGl6emFydGknLFxuXHQgeW91X2FyZV9oZXJlIDogJ1ZvaSBzaWV0ZSBxdWknLFxuXHQgYnV0dG9uX3RpdGxlIDogJ1Ryb3ZhIGxhIHR1YSBwb3NpemlvbmUgc3VsbGEgbWFwcGEnXG59OyIsIkRHLkNvbnRyb2wuTG9jYXRpb24uRGljdGlvbmFyeS5jcyA9IHtcblx0IGNhbnRfZmluZCA6ICdOZXBvZGHFmWlsbyBzZSBuw6FtIHVyxI1pdCBWYcWhaSBwb2xvaHUnLFxuXHQgeW91X2FyZV9oZXJlIDogJ0pzdGUgdGFkeScsXG5cdCBidXR0b25fdGl0bGUgOiAnVXLEjWl0IFZhxaFpIHBvbG9odSBuYSBtYXDEmydcbn07IiwiREcuQ29udHJvbC5Mb2NhdGlvbi5EaWN0aW9uYXJ5LmVuID0ge1xuXHQgY2FudF9maW5kIDogJ1dlIGNhblxcJ3QgZmluZCB5b3UnLFxuXHQgeW91X2FyZV9oZXJlIDogJ1lvdSBhcmUgaGVyZScsXG5cdCBidXR0b25fdGl0bGUgOiAnU2hvdyB5b3VyIGxvY2F0aW9uJ1xufTsiLCJERy5Db250cm9sLkxvY2F0aW9uLkRpY3Rpb25hcnkuZXMgPSB7XG5cdCBjYW50X2ZpbmQgOiAnTm8gcHVkaW1vcyBlbmNvbnRyYXJ0ZScsXG5cdCB5b3VfYXJlX2hlcmUgOiAnVMO6IGVzdMOhcyBhcXXDrScsXG5cdCBidXR0b25fdGl0bGUgOiAnRW5jb250cmFydGUgZW4gZWwgbWFwYSdcbn07IiwiLy8gSW5zcGlyZWQgYnkgU2luZHJlIFNvcmh1cyBzY3JlZW5mdWxsXG4vKmdsb2JhbCBFbGVtZW50ICovXG5ERy5TY3JlZW5mdWxsID0gREcuQ2xhc3MuZXh0ZW5kKHtcbiAgICBfYXBpTWFwOiBbXG4gICAgICAgIFtcbiAgICAgICAgICAgICdyZXF1ZXN0RnVsbHNjcmVlbicsXG4gICAgICAgICAgICAnZXhpdEZ1bGxzY3JlZW4nLFxuICAgICAgICAgICAgJ2Z1bGxzY3JlZW5FbGVtZW50JyxcbiAgICAgICAgICAgICdmdWxsc2NyZWVuRW5hYmxlZCcsXG4gICAgICAgICAgICAnZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgICAgICAgICAnZnVsbHNjcmVlbmVycm9yJ1xuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICAgICAgICAgJ3dlYmtpdEV4aXRGdWxsc2NyZWVuJyxcbiAgICAgICAgICAgICd3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCcsXG4gICAgICAgICAgICAnd2Via2l0RnVsbHNjcmVlbkVuYWJsZWQnLFxuICAgICAgICAgICAgJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLFxuICAgICAgICAgICAgJ3dlYmtpdGZ1bGxzY3JlZW5lcnJvcidcblxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnbW96UmVxdWVzdEZ1bGxTY3JlZW4nLFxuICAgICAgICAgICAgJ21vekNhbmNlbEZ1bGxTY3JlZW4nLFxuICAgICAgICAgICAgJ21vekZ1bGxTY3JlZW5FbGVtZW50JyxcbiAgICAgICAgICAgICdtb3pGdWxsU2NyZWVuRW5hYmxlZCcsXG4gICAgICAgICAgICAnbW96ZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgICAgICAgICAnbW96ZnVsbHNjcmVlbmVycm9yJ1xuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnbXNSZXF1ZXN0RnVsbHNjcmVlbicsXG4gICAgICAgICAgICAnbXNFeGl0RnVsbHNjcmVlbicsXG4gICAgICAgICAgICAnbXNGdWxsc2NyZWVuRWxlbWVudCcsXG4gICAgICAgICAgICAnbXNGdWxsc2NyZWVuRW5hYmxlZCcsXG4gICAgICAgICAgICAnTVNGdWxsc2NyZWVuQ2hhbmdlJyxcbiAgICAgICAgICAgICdNU0Z1bGxzY3JlZW5FcnJvcidcbiAgICAgICAgXVxuICAgIF0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hcGkgPSB0aGlzLl9hcGkoKTtcbiAgICB9LFxuXG4gICAgcmVxdWVzdDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMuYXBpLnJlcXVlc3RGdWxsc2NyZWVuO1xuXG4gICAgICAgIGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgZWxlbVtyZXF1ZXN0XShFbGVtZW50LkFMTE9XX0tFWUJPQVJEX0lOUFVUKTtcbiAgICB9LFxuXG4gICAgZXhpdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50W3RoaXMuYXBpLmV4aXRGdWxsc2NyZWVuXSgpO1xuICAgIH0sXG5cbiAgICBpc0Z1bGxzY3JlZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISFkb2N1bWVudFt0aGlzLmFwaS5mdWxsc2NyZWVuRWxlbWVudF07XG4gICAgfSxcblxuICAgIGlzQXZhaWxhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5hcGkpO1xuICAgIH0sXG5cbiAgICBfYXBpOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFwaSA9IHt9LFxuICAgICAgICAgICAgYXBpTWFwID0gdGhpcy5fYXBpTWFwO1xuXG4gICAgICAgIGFwaU1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWxbMV0gaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbihtZXRob2QsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpW2FwaU1hcFswXVtpXV0gPSBtZXRob2Q7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcGkucmVxdWVzdEZ1bGxzY3JlZW4gPyBhcGkgOiBmYWxzZTtcbiAgICB9XG59KTtcblxuREcuc2NyZWVuZnVsbCA9IG5ldyBERy5TY3JlZW5mdWxsKCk7XG4iLCJERy5Db250cm9sLkZ1bGxzY3JlZW4gPSBERy5Sb3VuZENvbnRyb2wuZXh0ZW5kKHtcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgRGljdGlvbmFyeToge31cbiAgICB9LFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcbiAgICAgICAgaWNvbkNsYXNzOiAnZnVsbHNjcmVlbidcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBERy5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2lzRnVsbHNjcmVlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uKCdjbGljaycsIHRoaXMuX3RvZ2dsZUZ1bGxzY3JlZW4pO1xuICAgIH0sXG5cbiAgICBfdG9nZ2xlRnVsbHNjcmVlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUodHJ1ZSwgJ3JlcXVlc3QnLCAnb24nLCAncmVxdWVzdGZ1bGxzY3JlZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZShmYWxzZSwgJ2V4aXQnLCAnb24nLCAnY2FuY2VsZnVsbHNjcmVlbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyVHJhbnNsYXRpb24oKTtcbiAgICAgICAgdGhpcy5fbWFwLmludmFsaWRhdGVTaXplKCk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xpbmsudGl0bGUgPSB0aGlzLnQodGhpcy5faXNGdWxsc2NyZWVuID8gJ3RpdGxlX21pbicgOiAndGl0bGVfbWF4Jyk7XG4gICAgfSxcblxuICAgIF90b2dnbGU6IGZ1bmN0aW9uKGlzRW5hYmxlZCwgbWV0aG9kLCBsaXN0LCBldmVudCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5faXNGdWxsc2NyZWVuID0gaXNFbmFibGVkO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGlzRW5hYmxlZCA/ICdhY3RpdmUnIDogJycpO1xuXG4gICAgICAgIERHLnNjcmVlbmZ1bGxbbWV0aG9kXShjb250YWluZXIpO1xuICAgICAgICBERy5Eb21FdmVudFtsaXN0XShkb2N1bWVudCwgREcuc2NyZWVuZnVsbC5hcGkuZnVsbHNjcmVlbmNoYW5nZSwgdGhpcy5fb25GdWxsU2NyZWVuU3RhdGVDaGFuZ2UsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYXAuZmlyZShldmVudCk7XG4gICAgfSxcblxuICAgIF9vbkZ1bGxTY3JlZW5TdGF0ZUNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghREcuc2NyZWVuZnVsbC5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKGZhbHNlLCAnZXhpdCcsICdvbicsICdjYW5jZWxmdWxsc2NyZWVuJyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuREcuY29udHJvbC5mdWxsc2NyZWVuID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuQ29udHJvbC5GdWxsc2NyZWVuKG9wdGlvbnMpO1xufTtcblxuREcuTWFwLm1lcmdlT3B0aW9ucyh7XG4gICAgZnVsbHNjcmVlbkNvbnRyb2w6IHRydWVcbn0pO1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5mdWxsc2NyZWVuQ29udHJvbCkge1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW5Db250cm9sID0gREcuY29udHJvbC5mdWxsc2NyZWVuKHRoaXMub3B0aW9ucy5mdWxsc2NyZWVuQ29udHJvbCk7XG5cbiAgICAgICAgaWYgKERHLnNjcmVlbmZ1bGwuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRDb250cm9sKHRoaXMuZnVsbHNjcmVlbkNvbnRyb2wpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCJERy5Db250cm9sLkZ1bGxzY3JlZW4uRGljdGlvbmFyeS5ydSA9IHtcbiAgICB0aXRsZV9tYXggOiAn0KDQsNC30LLQtdGA0L3Rg9GC0YwnLFxuICAgIHRpdGxlX21pbiA6ICfQktC+0YHRgdGC0LDQvdC+0LLQuNGC0YwnXG59O1xuIiwiREcuQ29udHJvbC5GdWxsc2NyZWVuLkRpY3Rpb25hcnkuaXQgPSB7XG4gICAgdGl0bGVfbWF4IDogJ0VzcGFuZGknLFxuICAgIHRpdGxlX21pbiA6ICdSaXByaXN0aW5hJ1xufTtcbiIsIkRHLkNvbnRyb2wuRnVsbHNjcmVlbi5EaWN0aW9uYXJ5LmNzID0ge1xuICAgICB0aXRsZV9tYXggOiAnUm96YmFsaXQnLFxuICAgICB0aXRsZV9taW4gOiAnT2Jub3ZpdCdcbn07XG4iLCJERy5Db250cm9sLkZ1bGxzY3JlZW4uRGljdGlvbmFyeS5lbiA9IHtcbiAgICB0aXRsZV9tYXggOiAnRXhwYW5kJyxcbiAgICB0aXRsZV9taW4gOiAnUmVzdG9yZSdcbn07XG4iLCJERy5Db250cm9sLkZ1bGxzY3JlZW4uRGljdGlvbmFyeS5lcyA9IHtcbiAgICB0aXRsZV9tYXggOiAnTWF4aW1pemFyJyxcbiAgICB0aXRsZV9taW4gOiAnUmVzdGF1cmFyJ1xufTtcbiIsIkRHLk1ldGEgPSB7fTtcblxuREcuTWV0YS5MYXllciA9IERHLkxheWVyLmV4dGVuZCh7XG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHRpbGVTaXplOiAyNTYsXG5cbiAgICAgICAgbWluWm9vbTogMCxcbiAgICAgICAgbWF4Wm9vbTogMTksXG4gICAgICAgIHpvb21PZmZzZXQ6IDAsXG4gICAgICAgIGV2ZW50QnViYmxpbmc6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgLy8gbWF4TmF0aXZlWm9vbTogPE51bWJlcj4sXG4gICAgICAgIC8vIGRldGVjdFJldGluYTogPE51bWJlcj4sXG4gICAgICAgIC8vIHpvb21SZXZlcnNlOiA8TnVtYmVyPlxuICAgICAgICAvLyBhdHRyaWJ1dGlvbjogPFN0cmluZz4sXG4gICAgICAgIC8vIHpJbmRleDogPE51bWJlcj4sXG4gICAgICAgIC8vIGJvdW5kczogPExhdExuZ0JvdW5kcz5cbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oc291cmNlLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIE9iamVjdClcbiAgICAgICAgREcuVGlsZUxheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl91cmw7XG5cbiAgICAgICAgdGhpcy5fY3VycmVudFRpbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbGVEYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudHMgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX29yaWdpbiA9IERHLk1ldGEub3JpZ2luKHNvdXJjZSwge1xuICAgICAgICAgICAgZGF0YUZpbHRlcjogdGhpcy5vcHRpb25zLmRhdGFGaWx0ZXJcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldE9yaWdpbjogZnVuY3Rpb24oKSB7IC8vICgpIC0+IE9iamVjdFxuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0VmlldygpO1xuXG4gICAgICAgIG1hcC5tZXRhTGF5ZXJzLnB1c2godGhpcyk7XG5cbiAgICAgICAgbWFwLm9uKCdydWxlcnN0YXJ0JywgdGhpcy5fZGlzYWJsZURpc3BhdGNoTW91c2VFdmVudHMsIHRoaXMpO1xuICAgICAgICBtYXAub24oJ3J1bGVyZW5kJywgdGhpcy5fZW5hYmxlRGlzcGF0Y2hNb3VzZUV2ZW50cywgdGhpcyk7XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fdGlsZVpvb20gPSBudWxsO1xuXG4gICAgICAgIHZhciBpbmRleCA9IG1hcC5tZXRhTGF5ZXJzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG1hcC5tZXRhTGF5ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXAub2ZmKCdydWxlcnN0YXJ0JywgdGhpcy5fZGlzYWJsZURpc3BhdGNoTW91c2VFdmVudHMsIHRoaXMpO1xuICAgICAgICBtYXAub2ZmKCdydWxlcmVuZCcsIHRoaXMuX2VuYWJsZURpc3BhdGNoTW91c2VFdmVudHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBnZXRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuICAgICAgICAgICAgdmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG4gICAgICAgICAgICB6b29tOiB0aGlzLl9yZXNldFZpZXcsXG4gICAgICAgICAgICBtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUFsbFRpbGVzOiBERy5HcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVBbGxUaWxlcyxcbiAgICBfZ2V0Wm9vbUZvclVybDogREcuVGlsZUxheWVyLnByb3RvdHlwZS5fZ2V0Wm9vbUZvclVybCxcbiAgICBnZXRUaWxlU2l6ZTogREcuVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlU2l6ZSxcbiAgICBfaXNWYWxpZFRpbGU6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX2lzVmFsaWRUaWxlLFxuICAgIF93cmFwQ29vcmRzOiBERy5HcmlkTGF5ZXIucHJvdG90eXBlLl93cmFwQ29vcmRzLFxuICAgIF9yZXNldFZpZXc6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX3Jlc2V0VmlldyxcbiAgICBfcmVzZXRHcmlkOiBERy5HcmlkTGF5ZXIucHJvdG90eXBlLl9yZXNldEdyaWQsXG4gICAgX2ludmFsaWRhdGVBbGw6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX2ludmFsaWRhdGVBbGwsXG4gICAgX3B4Qm91bmRzVG9UaWxlUmFuZ2U6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX3B4Qm91bmRzVG9UaWxlUmFuZ2UsXG5cbiAgICAvLyBGaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvY29tcGFyZS8wNzI2ZjEyYmJmMzNmY2IxOGZlOGJiNTQxZDVlMzIxMmJiMWY1YWIyLi4uYzI2M2YyZDhiMWJkOTYyYjYwNDc0Mzc2Y2M0ODE2YTY4ODA1MjUxMyNkaWZmLWYxZTZiZTY3NTk5YzU5NDczMWZmZjYxOTFjNzEwNDIwTDU3OVxuICAgIF9vbk1vdmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdGhpcy5fcmVzZXRWaWV3KCk7XG4gICAgfSxcblxuICAgIF9lbmFibGVEaXNwYXRjaE1vdXNlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgfSxcblxuICAgIF9kaXNhYmxlRGlzcGF0Y2hNb3VzZUV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgbWFwRXZlbnRzOiB7XG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcbiAgICAgICAgICAgICAgICBsYXllclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXZlbnQub3JpZ2luYWxFdmVudCksXG4gICAgICAgICAgICAgICAgdGlsZU9yaWdpblBvaW50ID0gdGhpcy5fbWFwLmdldFBpeGVsT3JpZ2luKCkuYWRkKGxheWVyUG9pbnQpLFxuICAgICAgICAgICAgICAgIHRpbGVDb29yZCA9IHRpbGVPcmlnaW5Qb2ludC51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG4gICAgICAgICAgICAgICAgbW91c2VUaWxlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRpbGVLZXksXG4gICAgICAgICAgICAgICAgaG92ZXJlZE9iamVjdCxcbiAgICAgICAgICAgICAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblxuICAgICAgICAgICAgaWYgKHpvb20gPiAodGhpcy5vcHRpb25zLm1heFpvb20gKyB0aGlzLm9wdGlvbnMuem9vbU9mZnNldCkgfHxcbiAgICAgICAgICAgICAgICB6b29tIDwgKHRoaXMub3B0aW9ucy5taW5ab29tIC0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQpIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMuX2lzVmFsaWRUaWxlKHRpbGVDb29yZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3dyYXBDb29yZHModGlsZUNvb3JkKTtcblxuICAgICAgICAgICAgdGlsZUNvb3JkLnogPSB0aGlzLl9nZXRab29tRm9yVXJsKCk7XG4gICAgICAgICAgICB0aWxlQ29vcmQua2V5ID0gdGlsZVNpemUueCArICd4JyArIHRpbGVTaXplLnk7XG4gICAgICAgICAgICB0aWxlS2V5ID0gdGhpcy5fb3JpZ2luLmdldFRpbGVLZXkodGlsZUNvb3JkKTtcblxuICAgICAgICAgICAgaWYgKHRpbGVLZXkgIT09IHRoaXMuX2N1cnJlbnRUaWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbGUgPSB0aWxlS2V5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFRpbGVEYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlRGF0YSA9IHRoaXMuX29yaWdpbi5nZXRUaWxlRGF0YSh0aWxlQ29vcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3VzZVRpbGVPZmZzZXQgPSBERy5wb2ludCh0aWxlT3JpZ2luUG9pbnQueCAlIHRpbGVTaXplLngsIHRpbGVPcmlnaW5Qb2ludC55ICUgdGlsZVNpemUueSk7XG4gICAgICAgICAgICAgICAgaG92ZXJlZE9iamVjdCA9IHRoaXMuX2dldEhvdmVyZWRPYmplY3QodGlsZUNvb3JkLCBtb3VzZVRpbGVPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hvdmVyZWRFbnRpdHkgIT09IGhvdmVyZWRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ21vdXNlb3V0JywgZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hvdmVyZWRFbnRpdHkgPSBob3ZlcmVkT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnbW91c2VvdmVyJywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVNb3VzZUV2ZW50KCdtb3VzZW1vdmUnLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5faG92ZXJlZEVudGl0eSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGlsZSA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnY2xpY2snLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGJsY2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnZGJsY2xpY2snLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVNb3VzZUV2ZW50KCdtb3VzZWRvd24nLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGV4dG1lbnU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnY29udGV4dG1lbnUnLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZpcmVNb3VzZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBtb3VzZUV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5faG92ZXJlZEVudGl0eSB8fCAhdGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyZSh0eXBlLCB7XG4gICAgICAgICAgICBtZXRhOiB0aGlzLl9ob3ZlcmVkRW50aXR5LFxuICAgICAgICAgICAgbGF0bG5nOiB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF0TG5nKG1vdXNlRXZlbnQub3JpZ2luYWxFdmVudClcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpc0RyYWdnaW5nID0gdHlwZSA9PT0gJ21vdXNlZG93bicgfHwgKHRoaXMuX21vdXNlRG93biAmJiB0eXBlID09PSAnbW91c2Vtb3ZlJyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXZlbnRCdWJibGluZyA9PT0gJ2xheWVyJyAmJiAhaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgREcuRG9tRXZlbnQuc3RvcChtb3VzZUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0SG92ZXJlZE9iamVjdDogZnVuY3Rpb24oY29vcmRzLCBtb3VzZVRpbGVPZmZzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jdXJyZW50VGlsZURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChERy5Qb2x5VXRpbC5pbnNpZGUobW91c2VUaWxlT2Zmc2V0LCB0aGlzLl9jdXJyZW50VGlsZURhdGFbaV0uZ2VvbWV0cnksIHRoaXMuX3BvaW50UmVkdWNlSGVscGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGlsZURhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgX3BvaW50UmVkdWNlSGVscGVyOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xuICAgIH0sXG5cbiAgICBfc2V0VmlldzogZnVuY3Rpb24oY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuICAgICAgICB2YXIgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHpvb20pLFxuICAgICAgICAgICAgdGlsZVpvb21DaGFuZ2VkID0gdGhpcy5fdGlsZVpvb20gIT09IHRpbGVab29tO1xuXG4gICAgICAgIGlmICghbm9VcGRhdGUgJiYgdGlsZVpvb21DaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRHcmlkKCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuREcuTWV0YS5sYXllciA9IGZ1bmN0aW9uKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuTWV0YS5MYXllcihzb3VyY2UsIG9wdGlvbnMpO1xufTtcbiIsIkRHLk1ldGEuT3JpZ2luID0gREcuQ2xhc3MuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc3ViZG9tYWluczogJzAxMjMnLFxuICAgICAgICBkYXRhRmlsdGVyOiBudWxsXG4gICAgfSxcblxuICAgIF91cmw6IGZhbHNlLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIE9iamVjdClcbiAgICAgICAgdGhpcy5fdXJsID0gdXJsO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0cyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3RpbGVTdG9yYWdlID0ge307XG5cbiAgICAgICAgb3B0aW9ucyA9IERHLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFRpbGVEYXRhOiBmdW5jdGlvbihjb29yZCkgeyAvLyAoT2JqZWN0KSAtPiBPYmplY3RcbiAgICAgICAgdmFyIHRpbGVLZXkgPSB0aGlzLmdldFRpbGVLZXkoY29vcmQpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl90aWxlU3RvcmFnZVt0aWxlS2V5XSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMuX3JlcXVlc3RzW3RpbGVLZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0b3JhZ2VbdGlsZUtleV0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzW3RpbGVLZXldID0gdGhpcy5fcmVxdWVzdERhdGEoY29vcmQpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0VGlsZURhdGEodGlsZUtleSwgc2VsZi5vcHRpb25zLmRhdGFGaWx0ZXIgPyBzZWxmLm9wdGlvbnMuZGF0YUZpbHRlcihkYXRhLCBjb29yZCkgOiBkYXRhKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5fcmVxdWVzdHNbdGlsZUtleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlU3RvcmFnZVt0aWxlS2V5XTtcbiAgICB9LFxuXG4gICAgc2V0VGlsZURhdGE6IGZ1bmN0aW9uKGtleSwgZGF0YSkgeyAvLyAoT2JqZWN0L1N0cmluZywgT2JqZWN0KSAtPiBPYmplY3RcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmdldFRpbGVLZXkoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihlbnRpdHkpIHtcbiAgICAgICAgICAgIGlmIChlbnRpdHkuZ2VvbWV0cnkuY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGVudGl0eS5nZW9tZXRyeSA9IERHLldrdC50b0dlb0pTT04oZW50aXR5Lmdlb21ldHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fdGlsZVN0b3JhZ2Vba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVTdG9yYWdlW2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RpbGVTdG9yYWdlW2tleV0ucHVzaChlbnRpdHkpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZmx1c2g6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBPYmplY3RcbiAgICAgICAgdGhpcy5fdGlsZVN0b3JhZ2UgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcmVxdWVzdHMpLmZvckVhY2goZnVuY3Rpb24odGlsZUtleSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbdGlsZUtleV0uYWJvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RpbGVLZXldLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuX3JlcXVlc3RzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0VVJMOiBmdW5jdGlvbih1cmwsIGZsdXNoKSB7IC8vIChTdHJpbmcsIEJvb2xlYW4pIC0+IE9iamVjdFxuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgICAgIGlmIChmbHVzaCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldFRpbGVLZXk6IGZ1bmN0aW9uKGNvb3JkKSB7IC8vIChPYmplY3QpLT4gU3RyaW5nXG4gICAgICAgIHJldHVybiBbY29vcmQueCwgY29vcmQueSwgY29vcmQueiwgY29vcmQua2V5XS5qb2luKCc6Jyk7XG4gICAgfSxcblxuICAgIF9yZXF1ZXN0RGF0YTogZnVuY3Rpb24oa2V5KSB7IC8vIChTdHJpbmcpXG4gICAgICAgIGlmICh0aGlzLl91cmwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZXJmb3JtUmVxdWVzdChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BlcmZvcm1SZXF1ZXN0OiBmdW5jdGlvbihjb29yZHMpIHsgLy8gKE9iamVjdCkgLT4gUHJvbWlzZVxuICAgICAgICByZXR1cm4gREcuYWpheCh0aGlzLl9wcmVwYXJlVVJMKGNvb3JkcyksIHtcbiAgICAgICAgICAgIHR5cGU6ICdnZXQnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3ByZXBhcmVVUkw6IGZ1bmN0aW9uKGNvb3JkcykgeyAvLyAoT2JqZWN0KSAtPiBTdHJpbmdcbiAgICAgICAgcmV0dXJuIERHLlV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCB7XG4gICAgICAgICAgICB4OiBjb29yZHMueCxcbiAgICAgICAgICAgIHk6IGNvb3Jkcy55LFxuICAgICAgICAgICAgejogY29vcmRzLnosXG4gICAgICAgICAgICBzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldFN1YmRvbWFpbjogREcuVGlsZUxheWVyLnByb3RvdHlwZS5fZ2V0U3ViZG9tYWluXG5cbn0pO1xuXG5ERy5NZXRhLm9yaWdpbiA9IGZ1bmN0aW9uKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuTWV0YS5PcmlnaW4oc291cmNlLCBvcHRpb25zKTtcbn07XG4iLCJERy5NYXAubWVyZ2VPcHRpb25zKHtcbiAgICBwb2k6ICFERy5Ccm93c2VyLm1vYmlsZVxufSk7XG5cbkRHLlBvaSA9IERHLkhhbmRsZXIuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZGlzYWJsZUxhYmVsOiBmYWxzZVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtYXAsIG9wdGlvbnMpIHsgLy8gKE9iamVjdClcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICBERy5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHVybCA9IERHLmNvbmZpZy5wcm90b2NvbCArIChERy5Ccm93c2VyLnJldGluYSA/IERHLmNvbmZpZy5yZXRpbmFQb2lNZXRhU2VydmVyIDogREcuY29uZmlnLnBvaU1ldGFTZXJ2ZXIpO1xuXG4gICAgICAgIHRoaXMuX21ldGFMYXllciA9IERHLk1ldGEubGF5ZXIodXJsLCB7XG4gICAgICAgICAgICBtaW5ab29tOiBERy5jb25maWcucG9pTGF5ZXJNaW5ab29tLFxuICAgICAgICAgICAgbWF4TmF0aXZlWm9vbTogMTksXG4gICAgICAgICAgICBkZXRlY3RSZXRpbmE6IERHLmNvbmZpZy5kZXRlY3RSZXRpbmEsXG4gICAgICAgICAgICBldmVudEJ1YmJsaW5nOiAnbGF5ZXInLFxuICAgICAgICAgICAgZGF0YUZpbHRlcjogREcuYmluZCh0aGlzLl9wcm9jZXNzRGF0YSwgdGhpcylcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZEhvb2tzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX21ldGFMYXllcik7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXIgPSBERy5sYWJlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21ldGFMYXllci5vbih0aGlzLl9sYXllckV2ZW50c0xpc3RlbmVycywgdGhpcyk7XG4gICAgfSxcblxuICAgIHJlbW92ZUhvb2tzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX21ldGFMYXllcik7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xhYmVsSGVscGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsSGVscGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZXRhTGF5ZXIub2ZmKHRoaXMuX2xheWVyRXZlbnRzTGlzdGVuZXJzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0TWV0YUxheWVyIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRhTGF5ZXI7XG4gICAgfSxcblxuICAgIF9wcm9jZXNzRGF0YSA6IGZ1bmN0aW9uKGRhdGEsIGNvb3JkKSB7XG4gICAgICAgIHZhciB0aWxlT3JpZ2luUG9pbnQgPSBjb29yZC5zY2FsZUJ5KHRoaXMuX21ldGFMYXllci5nZXRUaWxlU2l6ZSgpKTtcbiAgICAgICAgdmFyIHBvbHlnb25MbmdMYXRUb1BvaW50cyA9IERHLmJpbmQodGhpcy5fcG9seWdvbkxuZ0xhdFRvUG9pbnRzLCB0aGlzLCB0aWxlT3JpZ2luUG9pbnQpO1xuXG4gICAgICAgIGlmIChkYXRhLnJlc3BvbnNlVGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhLnJlc3VsdC5wb2lcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICBoaW50OiBpdGVtLmxpbmtzWzBdLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGxpbmtlZDogaXRlbS5saW5rc1swXSxcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IERHLldrdC50b0dlb0pTT04oaXRlbS5ob3ZlcilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmdlb21ldHJ5LnR5cGUgPT0gJ1BvbHlnb24nIHx8XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZ2VvbWV0cnkudHlwZSA9PSAnTXVsdGlQb2x5Z29uJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2VvSnNvbiA9IGl0ZW0uZ2VvbWV0cnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2VvSnNvbi50eXBlID09ICdQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICBnZW9Kc29uLmNvb3JkaW5hdGVzID0gcG9seWdvbkxuZ0xhdFRvUG9pbnRzKGdlb0pzb24uY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvSnNvbi50eXBlID09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb0pzb24uY29vcmRpbmF0ZXMgPSBnZW9Kc29uLmNvb3JkaW5hdGVzLm1hcChwb2x5Z29uTG5nTGF0VG9Qb2ludHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9wb2x5Z29uTG5nTGF0VG9Qb2ludHM6IGZ1bmN0aW9uKG9yaWdpblBvaW50LCBwb2x5Z29uKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgcmV0dXJuIHBvbHlnb24ubWFwKGZ1bmN0aW9uKGNvbnRvdXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250b3VyLm1hcChmdW5jdGlvbihsbmdMYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwXG4gICAgICAgICAgICAgICAgICAgIC5wcm9qZWN0KFtsbmdMYXRbMV0sIGxuZ0xhdFswXV0pLnJvdW5kKClcbiAgICAgICAgICAgICAgICAgICAgLnN1YnRyYWN0KG9yaWdpblBvaW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2xheWVyRXZlbnRzTGlzdGVuZXJzIDoge1xuICAgICAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uKGUpIHsgLy8gKE9iamVjdClcbiAgICAgICAgICAgIHRoaXMuX3NldEN1cnNvcigncG9pbnRlcicpO1xuICAgICAgICAgICAgaWYgKGUubWV0YS5oaW50ICYmIGUubWV0YS5oaW50Lmxlbmd0aCAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVMYWJlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsSGVscGVyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRQb3NpdGlvbihlLmxhdGxuZylcbiAgICAgICAgICAgICAgICAgICAgLnNldENvbnRlbnQoZS5tZXRhLmhpbnQpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRaSW5kZXhPZmZzZXQoMzAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fbGFiZWxIZWxwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3BvaWhvdmVyJywge1xuICAgICAgICAgICAgICAgIGxhdGxuZzogZS5sYXRsbmcsXG4gICAgICAgICAgICAgICAgbWV0YTogZS5tZXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKCcnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVMYWJlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbEhlbHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXAuZmlyZSgncG9pbGVhdmUnLCB7XG4gICAgICAgICAgICAgICAgbGF0bG5nOiBlLmxhdGxuZyxcbiAgICAgICAgICAgICAgICBtZXRhOiBlLm1ldGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24oZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUxhYmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXIuc2V0UG9zaXRpb24oZS5sYXRsbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRDdXJzb3I6IGZ1bmN0aW9uKGN1cnNvcikgeyAvLyAoU3RyaW5nKVxuICAgICAgICB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgIH1cblxufSk7XG5cbkRHLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdwb2knLCBERy5Qb2kpO1xuIiwiREcuTWFwLm1lcmdlT3B0aW9ucyh7XG4gICAgZ2VvY2xpY2tlcjogZmFsc2Vcbn0pO1xuXG5ERy5HZW9jbGlja2VyID0gREcuSGFuZGxlci5leHRlbmQoe1xuICAgIGNsaWNrQ291bnQ6IDAsXG4gICAgcGVuZGluZ0NsaWNrOiAwLFxuICAgIHRpbWVvdXQ6IDI1MCwgLy8gc2hvdWxkIGJlIGVxdWFsIHRvICdkZWxheScgdmFsdWUgaW4gRG91YmxlVGFwIGV2ZW50XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtYXAsIG9wdGlvbnMpIHsgLy8gKE9iamVjdClcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9jb250cm9sbGVyID0gbmV3IERHLkdlb2NsaWNrZXIuQ29udHJvbGxlcihtYXAsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBhZGRIb29rczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50cyh0cnVlKTtcblxuICAgICAgICB0aGlzLl9tYXBcbiAgICAgICAgICAgIC5vbigncnVsZXJzdGFydCcsIHRoaXMuX3BhdXNlLCB0aGlzKVxuICAgICAgICAgICAgLm9uKCdydWxlcmVuZCcsIHRoaXMuX3VucGF1c2UsIHRoaXMpO1xuICAgIH0sXG5cbiAgICByZW1vdmVIb29rczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50cygpO1xuXG4gICAgICAgIHRoaXMuX21hcFxuICAgICAgICAgICAgLm9mZigncnVsZXJzdGFydCcsIHRoaXMuX3BhdXNlLCB0aGlzKVxuICAgICAgICAgICAgLm9mZigncnVsZXJlbmQnLCB0aGlzLl91bnBhdXNlLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2NoZWNrT3BlblBvcHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERHLkJyb3dzZXIubW9iaWxlICYmIHRoaXMuX21hcC5fcG9wdXAgJiZcbiAgICAgICAgICAgICh0aGlzLl9tYXAuX3BvcHVwLm9wdGlvbnMuY2xvc2VPbkNsaWNrIHx8XG4gICAgICAgICAgICB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBXYXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl90b2dnbGVFdmVudHMoKTtcbiAgICB9LFxuXG4gICAgX3VucGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBSZWVuYWJsZSBldmVudCBoYW5kbGluZyBvbmx5IGluIGNhc2UgZ2VvY2xpY2tlciBpcyBlbmFibGVkXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRzKHRydWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF90b2dnbGVFdmVudHM6IGZ1bmN0aW9uKGZsYWcpIHtcbiAgICAgICAgdGhpcy5fbWFwW2ZsYWcgPyAnb24nIDogJ29mZiddKHRoaXMuX21hcEV2ZW50c0xpc3RlbmVycywgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9tYXAucG9pKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAucG9pLmdldE1ldGFMYXllcigpW2ZsYWcgPyAnb24nIDogJ29mZiddKCdjbGljaycsIHRoaXMuX29uTWV0YUNsaWNrLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRDb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xsZXI7XG4gICAgfSxcblxuICAgIF9vbk1ldGFDbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmNsaWNrQ291bnQgPSAwO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wZW5kaW5nQ2xpY2spO1xuICAgICAgICB0aGlzLnBvcHVwV2FzT3BlbiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX21hcEV2ZW50c0xpc3RlbmVycy5jbGljay5jYWxsKHRoaXMsIGUpO1xuICAgIH0sXG5cbiAgICBfbWFwRXZlbnRzTGlzdGVuZXJzOiB7XG4gICAgICAgIGxhbmdjaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlci5yZWludm9rZUhhbmRsZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb3B1cGNsb3NlOiBmdW5jdGlvbihlKSB7IC8vIChPYmplY3QpXG4gICAgICAgICAgICB0aGlzLl9jb250cm9sbGVyLmhhbmRsZVBvcHVwQ2xvc2UoZS5wb3B1cCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKGUpIHsgLy8gKE9iamVjdClcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWNrQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpbmdsZUNsaWNrKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdDbGljayk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cFdhc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkYmxjbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoREcuQnJvd3Nlci5pZWx0OSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cFdhc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wZW5kaW5nQ2xpY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zaW5nbGVDbGljazogZnVuY3Rpb24oZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGVuZGluZ0NsaWNrKTtcblxuICAgICAgICB0aGlzLnBlbmRpbmdDbGljayA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZS5tZXRhKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2hlY2tPcGVuUG9wdXAoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9tYXAuY2xvc2VQb3B1cCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgREdQb3B1cCdzICdfY2xvc2UnIG1ldGhvZCBpcyB0aGUgb25seSBwbGFjZSB3aGVyZSAucG9wdXBXYXNPcGVuIGlzIG1vZGlmaWVkXG4gICAgICAgICAgICAvLyAgSXQgc2lnbmFscyBnZW9jbGlja2VyIHRoYXQgcG9wdXAgd2FzIG9wZW4gYmVmb3JlIHVzZXIgZG8gYSAnY2xpY2snIG9uIG1hcFxuICAgICAgICAgICAgLy8gIE11bHRpc3RhZ2UgYmVoYXZpb3IgaXMgbmVlZGVkIGFzIHRoaXMgcHJvY2Vzc2luZyBvY2N1cnMgYWZ0ZXIgcG9wdXAgd2FzIGFscmVhZHkgY2xvc2VkXG4gICAgICAgICAgICBpZiAoIXNlbGYucG9wdXBXYXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHpvb20gPSBzZWxmLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2NvbnRyb2xsZXIuaGFuZGxlQ2xpY2soZS5sYXRsbmcsIHpvb20sIGUubWV0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICBzZWxmLnBvcHVwV2FzT3BlbiA9IGZhbHNlO1xuICAgICAgICB9LCB0aGlzLnRpbWVvdXQpO1xuICAgIH1cbn0pO1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZ2VvY2xpY2tlcicsIERHLkdlb2NsaWNrZXIpO1xuIiwiREcuR2VvY2xpY2tlci5jbGFtcEhlbHBlciA9IGZ1bmN0aW9uKGVsLCBsaW5lQ2xhbXApIHtcbiAgICB2YXIgbWVhc3VyZSwgdGV4dCwgbGluZVdpZHRoLFxuICAgICAgICBsaW5lU3RhcnQsIGxpbmVDb3VudCwgd29yZFN0YXJ0LFxuICAgICAgICBsaW5lLCBsaW5lVGV4dCwgd2FzTmV3TGluZSxcbiAgICAgICAgY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmJpbmQoZG9jdW1lbnQpLFxuICAgICAgICBjdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZS5iaW5kKGRvY3VtZW50KTtcblxuICAgIC8vIG1lYXN1cmVtZW50IGVsZW1lbnQgaXMgbWFkZSBhIGNoaWxkIG9mIHRoZSBjbGFtcGVkIGVsZW1lbnQgdG8gZ2V0IGl0J3Mgc3R5bGVcbiAgICBtZWFzdXJlID0gY2UoJ3NwYW4nKTtcblxuICAgIChmdW5jdGlvbihzKSB7XG4gICAgICAgIHMucG9zaXRpb24gPSAnYWJzb2x1dGUnOyAvLyBwcmV2ZW50IHBhZ2UgcmVmbG93XG4gICAgICAgIHMud2hpdGVTcGFjZSA9ICdwcmUnOyAvLyBjcm9zcy1icm93c2VyIHdpZHRoIHJlc3VsdHNcbiAgICAgICAgcy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7IC8vIHByZXZlbnQgZHJhd2luZ1xuICAgICAgICBzLm1hcmdpbiA9ICcwIDE4cHggOHB4IDAnO1xuICAgIH0pKG1lYXN1cmUuc3R5bGUpO1xuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBlbGVtZW50IGJlbG9uZ3MgdG8gdGhlIGRvY3VtZW50XG4gICAgaWYgKCFlbC5vd25lckRvY3VtZW50IHx8IGVsLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcmVzZXQgdG8gc2FmZSBzdGFydGluZyB2YWx1ZXNcbiAgICBsaW5lU3RhcnQgPSB3b3JkU3RhcnQgPSAwO1xuICAgIGxpbmVDb3VudCA9IDE7XG4gICAgd2FzTmV3TGluZSA9IGZhbHNlO1xuICAgIGxpbmVXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgIC8vIGdldCBhbGwgdGhlIHRleHQsIHJlbW92ZSBhbnkgbGluZSBjaGFuZ2VzXG4gICAgdGV4dCA9IChlbC50ZXh0Q29udGVudCB8fCBlbC5pbm5lclRleHQpLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgIC8vIHJlbW92ZSBhbGwgY29udGVudFxuICAgIHdoaWxlIChlbC5maXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICAvLyBhZGQgbWVhc3VyZW1lbnQgZWxlbWVudCB3aXRoaW4gc28gaXQgaW5oZXJpdHMgc3R5bGVzXG4gICAgZWwuYXBwZW5kQ2hpbGQobWVhc3VyZSk7XG4gICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL3NlYXJjaC1hbmQtZG9udC1yZXBsYWNlL1xuICAgIHRleHQucmVwbGFjZSgvIHwtL2csIGZ1bmN0aW9uKG0sIHBvcykge1xuICAgICAgICAvLyBpZ25vcmUgYW55IGZ1cnRoZXIgcHJvY2Vzc2luZyBpZiB3ZSBoYXZlIHRvdGFsIGxpbmVzXG4gICAgICAgIGlmIChsaW5lQ291bnQgPT09IGxpbmVDbGFtcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBhIHRleHQgbm9kZSBhbmQgcGxhY2UgaXQgaW4gdGhlIG1lYXN1cmVtZW50IGVsZW1lbnRcbiAgICAgICAgbWVhc3VyZS5hcHBlbmRDaGlsZChjdG4odGV4dC5zdWJzdHIobGluZVN0YXJ0LCBwb3MgLSBsaW5lU3RhcnQpKSk7XG4gICAgICAgIC8vIGhhdmUgd2UgZXhjZWVkZWQgYWxsb3dlZCBsaW5lIHdpZHRoP1xuICAgICAgICBpZiAobGluZVdpZHRoIDwgbWVhc3VyZS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgaWYgKHdhc05ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgbG9uZyB3b3JkIHNvIGl0IGdldHMgYSBsaW5lIG9mIGl0J3Mgb3duXG4gICAgICAgICAgICAgICAgbGluZVRleHQgPSB0ZXh0LnN1YnN0cihsaW5lU3RhcnQsIHBvcyArIDEgLSBsaW5lU3RhcnQpO1xuICAgICAgICAgICAgICAgIC8vIG5leHQgbGluZSBzdGFydCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IHBvcyArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdyYWIgdGhlIHRleHQgdW50aWwgdGhpcyB3b3JkXG4gICAgICAgICAgICAgICAgbGluZVRleHQgPSB0ZXh0LnN1YnN0cihsaW5lU3RhcnQsIHdvcmRTdGFydCAtIGxpbmVTdGFydCk7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBsaW5lIHN0YXJ0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gd29yZFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbGluZSBlbGVtZW50XG4gICAgICAgICAgICBsaW5lID0gY2UoJ3NwYW4nKTtcbiAgICAgICAgICAgIC8vIGFkZCB0ZXh0IHRvIHRoZSBsaW5lIGVsZW1lbnRcbiAgICAgICAgICAgIGxpbmUuYXBwZW5kQ2hpbGQoY3RuKGxpbmVUZXh0KSk7XG4gICAgICAgICAgICAvLyBhZGQgdGhlIGxpbmUgZWxlbWVudCB0byB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChsaW5lKTtcbiAgICAgICAgICAgIGxpbmUuY2xhc3NOYW1lID0gJ2RnLW1hcC1nZW9jbGlja2VyX19jbGFtcGVkLWxpbmUnO1xuICAgICAgICAgICAgLy8geWVzLCB3ZSBjcmVhdGVkIGEgbmV3IGxpbmVcbiAgICAgICAgICAgIHdhc05ld0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgbGluZUNvdW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkaWQgbm90IGNyZWF0ZSBhIG5ldyBsaW5lXG4gICAgICAgICAgICB3YXNOZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtZW1iZXIgbGFzdCB3b3JkIHN0YXJ0IHBvc2l0aW9uXG4gICAgICAgIHdvcmRTdGFydCA9IHBvcyArIDE7XG4gICAgICAgIC8vIGNsZWFyIG1lYXN1cmVtZW50IGVsZW1lbnRcbiAgICAgICAgbWVhc3VyZS5yZW1vdmVDaGlsZChtZWFzdXJlLmZpcnN0Q2hpbGQpO1xuICAgIH0pO1xuICAgIC8vIHJlbW92ZSB0aGUgbWVhc3VyZW1lbnQgZWxlbWVudCBmcm9tIHRoZSBjb250YWluZXJcbiAgICBlbC5yZW1vdmVDaGlsZChtZWFzdXJlKTtcbiAgICAvLyBjcmVhdGUgdGhlIGxhc3QgbGluZSBlbGVtZW50XG4gICAgbGluZSA9IGNlKCdzcGFuJyk7XG4gICAgLy8gZ2l2ZSBzdHlsZXMgcmVxdWlyZWQgZm9yIHRleHQtb3ZlcmZsb3cgdG8ga2ljayBpblxuICAgIGxpbmUuY2xhc3NOYW1lID0gJ2RnLW1hcC1nZW9jbGlja2VyX19jbGFtcGVkLWxpbmUgZGctbWFwLWdlb2NsaWNrZXJfX2NsYW1wZWQtbGluZV9sYXN0JztcbiAgICAvLyBhZGQgYWxsIHJlbWFpbmluZyB0ZXh0IHRvIHRoZSBsaW5lIGVsZW1lbnRcbiAgICBsaW5lLmFwcGVuZENoaWxkKGN0bih0ZXh0LnN1YnN0cihsaW5lU3RhcnQpKSk7XG4gICAgLy8gYWRkIHRoZSBsaW5lIGVsZW1lbnQgdG8gdGhlIGNvbnRhaW5lclxuICAgIGVsLmFwcGVuZENoaWxkKGxpbmUpO1xufTtcbiIsIkRHLkdlb2NsaWNrZXIuUHJvdmlkZXIgPSB7fTtcbiIsIkRHLkdlb2NsaWNrZXIuUHJvdmlkZXIuQ2F0YWxvZ0FwaSA9IERHLkNsYXNzLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obWFwKSB7IC8vIChPYmplY3QpXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcblxuICAgICAgICB2YXIgYXBpVXJsID0gREcuY29uZmlnLnByb3RvY29sICtcbiAgICAgICAgICAgIERHLmNvbmZpZy53ZWJBcGlTZXJ2ZXIgKyAnLycgK1xuICAgICAgICAgICAgREcuY29uZmlnLndlYkFwaVZlcnNpb24gKyAnLyc7XG5cbiAgICAgICAgdGhpcy5fdXJsR2VvU2VhcmNoID0gYXBpVXJsICsgJ2dlby9zZWFyY2gnO1xuICAgICAgICB0aGlzLl91cmxHZW9HZXQgPSBhcGlVcmwgKyAnZ2VvL2dldCc7XG4gICAgICAgIHRoaXMuX3VybERldGFpbHMgPSBhcGlVcmwgKyAnY2F0YWxvZy9icmFuY2gvZ2V0JztcbiAgICAgICAgdGhpcy5fdXJsRmlybXNJbkhvdXNlID0gYXBpVXJsICsgJ2NhdGFsb2cvYnJhbmNoL2xpc3QnO1xuXG4gICAgICAgIHRoaXMuX2tleSA9IERHLmNvbmZpZy5nZW9jbGlja2VyQ2F0YWxvZ0FwaUtleTtcbiAgICAgICAgdGhpcy5fZ2VvRmllbGRzID0gREcuY29uZmlnLmdlb0FkZGl0aW9uYWxGaWVsZHM7XG4gICAgICAgIHRoaXMuX2Zpcm1JbmZvRmllbGRzID0gREcuY29uZmlnLmZpcm1JbmZvRmllbGRzO1xuICAgIH0sXG5cbiAgICBnZXRMb2NhdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHsgLy8gKE9iamVjdClcbiAgICAgICAgLy8gQ2FsbGJhY2sgd2lsbCByZWNlaXZlIGFycmF5IG9mIGZvdW5kIHJlc3VsdHMgb3Igdm9pZCBpZiBlcnJvcnMgb2NjdXJyZWQgb3Igbm90aGluZyB3YXMgZm91bmQuXG4gICAgICAgIHZhciB6b29tID0gb3B0aW9ucy56b29tLFxuICAgICAgICAgICAgbGF0bG5nID0gb3B0aW9ucy5sYXRsbmcsXG4gICAgICAgICAgICBiZWZvcmVSZXF1ZXN0ID0gb3B0aW9ucy5iZWZvcmVSZXF1ZXN0IHx8IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICB0eXBlcyA9IHRoaXMuZ2V0VHlwZXNCeVpvb20oem9vbSksXG4gICAgICAgICAgICBxID0gbGF0bG5nLmxuZyArICcsJyArIGxhdGxuZy5sYXQ7XG5cbiAgICAgICAgaWYgKCF0eXBlcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdubyB0eXBlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBiZWZvcmVSZXF1ZXN0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvU2VhcmNoKHEsIHR5cGVzLCB6b29tKS50aGVuKERHLmJpbmQoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyUmVzcG9uc2UocmVzdWx0LCB0eXBlcyk7XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICB9LFxuXG4gICAgZmlybXNJbkhvdXNlOiBmdW5jdGlvbihob3VzZUlkLCBwYXJhbWV0ZXJzKSB7IC8vIChTdHJpbmcsIEZ1bmN0aW9uLCBOdW1iZXIpXG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgYnVpbGRpbmdfaWQ6IGhvdXNlSWQsXG4gICAgICAgICAgICBwYWdlOiBwYXJhbWV0ZXJzLnBhZ2UgfHwgMVxuICAgICAgICB9O1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJmb3JtUmVxdWVzdChwYXJhbXMsIHRoaXMuX3VybEZpcm1zSW5Ib3VzZSk7XG4gICAgfSxcblxuICAgIGdldEZpcm1JbmZvOiBmdW5jdGlvbihmaXJtSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdmaWxpYWwnLFxuICAgICAgICAgICAgaWQ6IGZpcm1JZCxcbiAgICAgICAgICAgIGZpZWxkczogdGhpcy5fZmlybUluZm9GaWVsZHNcbiAgICAgICAgfSwgdGhpcy5fdXJsRGV0YWlscyk7XG4gICAgfSxcblxuICAgIGdlb1NlYXJjaDogZnVuY3Rpb24ocSwgdHlwZXMsIHpvb21sZXZlbCkgeyAvLyAoU3RyaW5nLCBTdHJpbmcsIE51bWJlcilcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBwb2ludDogcSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVzLFxuICAgICAgICAgICAgem9vbV9sZXZlbDogem9vbWxldmVsLFxuICAgICAgICAgICAgZmllbGRzOiB0aGlzLl9nZW9GaWVsZHNcbiAgICAgICAgfTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cblxuICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybVJlcXVlc3QocGFyYW1zLCB0aGlzLl91cmxHZW9TZWFyY2gpO1xuICAgIH0sXG5cbiAgICBnZW9HZXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBmaWVsZHM6IHRoaXMuX2dlb0ZpZWxkc1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJmb3JtUmVxdWVzdChwYXJhbXMsIHRoaXMuX3VybEdlb0dldCk7XG4gICAgfSxcblxuICAgIGNhbmNlbExhc3RSZXF1ZXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RSZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0UmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFR5cGVzQnlab29tOiBmdW5jdGlvbih6b29tKSB7IC8vIChOdW1iZXIpIC0+IFN0cmluZ3xOdWxsXG4gICAgICAgIHZhciB0eXBlcyA9IHtcbiAgICAgICAgICAgICAgICAnYWRtX2Rpdi5zZXR0bGVtZW50JzogICA4LFxuICAgICAgICAgICAgICAgICdhZG1fZGl2LmNpdHknOiAgICAgICAgIDgsXG4gICAgICAgICAgICAgICAgJ2FkbV9kaXYuZGl2aXNpb24nOiAgICAgMTEsXG4gICAgICAgICAgICAgICAgJ2FkbV9kaXYuZGlzdHJpY3QnOiAgICAgMTIsXG4gICAgICAgICAgICAgICAgJ3N0cmVldCc6ICAgICAgICAgICAgICAgMTQsXG4gICAgICAgICAgICAgICAgJ2J1aWxkaW5nJzogICAgICAgICAgICAgMTQsXG4gICAgICAgICAgICAgICAgJ2FkbV9kaXYucGxhY2UnOiAgICAgICAgMTUsXG4gICAgICAgICAgICAgICAgJ3BvaSc6ICAgICAgICAgICAgICAgICAgMTUsXG4gICAgICAgICAgICAgICAgJ2F0dHJhY3Rpb24nOiAgICAgICAgICAgMTdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3RlZFR5cGVzID0gW107XG5cbiAgICAgICAgT2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgaWYgKHpvb20gPj0gdHlwZXNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZFR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVHlwZXMuam9pbignLCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BlcmZvcm1SZXF1ZXN0OiBmdW5jdGlvbihwYXJhbXMsIHVybCkgeyAvLyAoT2JqZWN0LCBTdHJpbmcsIEZ1bmN0aW9uLCBGdW5jdGlvbilcbiAgICAgICAgdmFyIGRhdGEgPSBERy5leHRlbmQoe2tleTogdGhpcy5fa2V5fSwgcGFyYW1zKTtcbiAgICAgICAgdmFyIHR5cGUgPSAnZ2V0JztcblxuICAgICAgICB0aGlzLmNhbmNlbExhc3RSZXF1ZXN0KCk7XG5cbiAgICAgICAgaWYgKCFERy5hamF4LmNvcnNTdXBwb3J0KSB7XG4gICAgICAgICAgICB0eXBlID0gZGF0YS5mb3JtYXQgPSAnanNvbnAnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdFJlcXVlc3QgPSBERy5hamF4KHVybCwge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB0aW1lb3V0OiB0aGlzLl90aW1lb3V0TXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RSZXF1ZXN0O1xuICAgIH0sXG5cbiAgICBfZmlsdGVyUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlLCBhbGxvd2VkVHlwZXMpIHsgLy8gKE9iamVjdCwgQXJyYXkpIC0+IEJvb2xlYW58T2JqZWN0XG4gICAgICAgIHZhciByZXN1bHQgPSB7fSwgaSwgaXRlbSwgZm91bmQsIGRhdGEsIHR5cGU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzTm90Rm91bmQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gcmVzcG9uc2UucmVzdWx0Lml0ZW1zO1xuXG4gICAgICAgIGZvciAoaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSBkYXRhW2ldO1xuXG4gICAgICAgICAgICB0eXBlID0gaXRlbS50eXBlO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3VidHlwZSkge1xuICAgICAgICAgICAgICAgIHR5cGUgKz0gJy4nICsgaXRlbS5zdWJ0eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dlZFR5cGVzICYmIGFsbG93ZWRUeXBlcy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRbdHlwZV0gPSBpdGVtO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pc05vdEZvdW5kOiBmdW5jdGlvbihyZXNwb25zZSkgeyAvLyAoT2JqZWN0KSAtPiBCb29sZWFuXG4gICAgICAgIHJldHVybiAhcmVzcG9uc2UgfHxcbiAgICAgICAgICAgICAgICEhcmVzcG9uc2UubWV0YSAmJiAhIXJlc3BvbnNlLm1ldGEuZXJyb3IgfHxcbiAgICAgICAgICAgICAgICFyZXNwb25zZS5yZXN1bHQgfHxcbiAgICAgICAgICAgICAgICFyZXNwb25zZS5yZXN1bHQuaXRlbXMgfHxcbiAgICAgICAgICAgICAgICFyZXNwb25zZS5yZXN1bHQuaXRlbXMubGVuZ3RoO1xuICAgIH1cblxufSk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIgPSB7fTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0ID0gREcuQ2xhc3MuZXh0ZW5kKHtcblxuICAgIGluY2x1ZGVzOiBERy5Mb2NhbGUsXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIF9ldmVudEhhbmRsZXJzOiB7fSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbnRyb2xsZXIsIHZpZXcsIG1hcCkgeyAvLyAoT2JqZWN0LCBPYmplY3QsIE9iamVjdClcbiAgICAgICAgdGhpcy5fY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgfSxcblxuICAgIGhhbmRsZTogZnVuY3Rpb24oKSB7IC8vICgpIC0+IFByb21pc2VcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0bXBsOiAncG9wdXBIZWFkZXInLFxuICAgICAgICAgICAgZGF0YTogeyd0aXRsZSc6IHRoaXMudCgnd2VfaGF2ZV9ub3QnKX1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZENsaWNrRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl92aWV3Ll9wb3B1cC5vbignY2xpY2snLCB0aGlzLl9ydW5FdmVudEhhbmRsZXJzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbWFwLm9uY2UoJ3BvcHVwY2xvc2UnLCB0aGlzLl9yZW1vdmVDbGlja0V2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUNsaWNrRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl92aWV3Ll9wb3B1cC5vZmYoJ2NsaWNrJywgdGhpcy5fcnVuRXZlbnRIYW5kbGVycywgdGhpcyk7XG4gICAgfSxcblxuICAgIF9hZGRFdmVudEhhbmRsZXI6IGZ1bmN0aW9uKGVsLCBoYW5kbGVyKSB7IC8vIChTdHJpbmcsIEZ1bmN0aW9uKVxuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzW2VsXSA9IGhhbmRsZXI7XG4gICAgfSxcblxuICAgIF9ydW5FdmVudEhhbmRsZXJzOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuXG4gICAgICAgIGZvciAodmFyIGV2ZW50Q2xhc3MgaW4gdGhpcy5fZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50SGFuZGxlcnMuaGFzT3duUHJvcGVydHkoZXZlbnRDbGFzcykgJiYgdGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKGV2ZW50Q2xhc3MpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnNbZXZlbnRDbGFzc10uY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYXJFdmVudEhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVycyA9IHt9O1xuICAgIH0sXG5cbiAgICBfZ2V0RGlyZWN0aW9uc1VybDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gREcuVXRpbC50ZW1wbGF0ZShERy5jb25maWcucHBub3RMaW5rLCB7XG4gICAgICAgICAgICAnZG9tYWluJzogdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkuZG9tYWluLFxuICAgICAgICAgICAgJ3Byb2plY3RDb2RlJzogdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkuY29kZSxcbiAgICAgICAgICAgICdjZW50ZXInOiB0aGlzLl9tYXAuZ2V0Q2VudGVyKCkubG5nICsgJywnICsgdGhpcy5fbWFwLmdldENlbnRlcigpLmxhdCxcbiAgICAgICAgICAgICd6b29tJzogdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICAgICduYW1lJzogZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpLFxuICAgICAgICAgICAgJ3JzVHlwZSc6IHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLnRyYW5zcG9ydCA/ICdidXMnIDogJ2NhcicsXG4gICAgICAgICAgICAncG9pbnQnOiB0aGlzLl9wb3B1cC5fbGF0bG5nLmxuZyArICcsJyArIHRoaXMuX3BvcHVwLl9sYXRsbmcubGF0XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0RHJpbGxkb3duOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIGFkbURpdnMgPSBbXSxcbiAgICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgICBpZiAob2JqZWN0LmFkbV9kaXYpIHtcbiAgICAgICAgICAgIGFkbURpdnMgPSBvYmplY3QuYWRtX2RpdlxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oYWRtRGl2cywgYWRtRGl2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZG1EaXYubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRtRGl2cy5wdXNoKGFkbURpdi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZG1EaXZzO1xuICAgICAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICAgICAgICAgIC5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRtRGl2cy5sZW5ndGggJiYgb2JqZWN0LmFkZHJlc3MgJiYgb2JqZWN0LmFkZHJlc3MucG9zdGNvZGUpIHtcbiAgICAgICAgICAgIGFkbURpdnMucHVzaChvYmplY3QuYWRkcmVzcy5wb3N0Y29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBhZG1EaXZzLmpvaW4oJywgJyk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbn0pO1xuXG5cbkRHLkdlb2NsaWNrZXIuSGFuZGxlci5IYW5kbGVyRXhhbXBsZSA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LmV4dGVuZCh7XG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uKHJlc3VsdHMsIHR5cGUpIHsgLy8gKE9iamVjdCwgU3RyaW5nKSAtPiBQcm9taXNlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdG1wbDogdHlwZSArICc6PGJyLz4nICsgcmVzdWx0c1t0eXBlXS5pZFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5BcGlFcnJvciA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LmV4dGVuZCh7XG4gICAgaGFuZGxlOiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gUHJvbWlzZVxuICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5fdmlldy5yZW5kZXIoe1xuICAgICAgICAgICAgdG1wbDogJ3BvcHVwSGVhZGVyJyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy50KCdhcGlFcnJvclRpdGxlJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgICAgIHRtcGw6IHRoaXMudCgnYXBpRXJyb3JCb2R5JylcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuQ2l0eUFyZWEgPSBERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5leHRlbmQoe1xuXG4gICAgX3BvbHlsaW5lU3R5bGVEZWZhdWx0IDoge1xuICAgICAgICBmaWxsQ29sb3I6ICcjZmY5Mzg3JyxcbiAgICAgICAgY29sb3I6ICcjZmY5Mzg3JyxcbiAgICAgICAgbm9DbGlwOiB0cnVlLFxuICAgICAgICBvcGFjaXR5OiAxXG4gICAgfSxcblxuICAgIF9wb2x5bGluZVN0eWxlcyA6IHtcbiAgICAgICAgMTEgOiB7XG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogMC4xOCxcbiAgICAgICAgICAgIHdlaWdodDogMVxuICAgICAgICB9LFxuICAgICAgICAxMiA6IHtcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjEyLFxuICAgICAgICAgICAgd2VpZ2h0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIDEzIDoge1xuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuMDgsXG4gICAgICAgICAgICB3ZWlnaHQ6IDJcbiAgICAgICAgfSxcbiAgICAgICAgMTggOiB7XG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogMCxcbiAgICAgICAgICAgIHdlaWdodDogM1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZTogZnVuY3Rpb24ocmVzdWx0cywgdHlwZSkgeyAvLyAoT2JqZWN0LCBTdHJpbmcpIC0+IFByb21pc2VcbiAgICAgICAgaWYgKCFyZXN1bHRzW3R5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3N0eWxlc0luaXRlZCkge1xuICAgICAgICAgICAgdGhpcy5faW5pdFN0eWxlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHByZXZpb3VzIGdlb21ldHJ5IHNlZSBodHRwczovL2dpdGh1Yi5jb20vMmdpcy9tYXBzYXBpL2lzc3Vlcy8yMTNcbiAgICAgICAgaWYgKHRoaXMuX2dlb21ldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fZ2VvbWV0cnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wdXAgPSB0aGlzLl92aWV3LmdldFBvcHVwKCk7XG5cbiAgICAgICAgdGhpcy5fZ2VvbWV0cnlab29tU3R5bGUgPSB0aGlzLl9nZXRQb2x5U3R5bGVOdW0oKTtcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBERy5Xa3QuZ2VvSnNvbkxheWVyKHJlc3VsdHNbdHlwZV0uZ2VvbWV0cnkuc2VsZWN0aW9uLCB7XG4gICAgICAgICAgICBzdHlsZTogdGhpcy5fcG9seWxpbmVTdHlsZXNbdGhpcy5fZ2VvbWV0cnlab29tU3R5bGVdLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlXG4gICAgICAgIH0pLmFkZFRvKHRoaXMuX21hcCk7XG5cbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAub24oJ3pvb21lbmQnLCB0aGlzLl91cGRhdGVHZW9tZXRyeSwgdGhpcylcbiAgICAgICAgICAgIC5vbmNlKCdwb3B1cGNsb3NlJywgdGhpcy5fY2xlYXJQb3B1cCwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9maWxsQ2l0eUFyZWFPYmplY3QocmVzdWx0cywgdHlwZSkpO1xuICAgIH0sXG5cbiAgICBfZmlsbENpdHlBcmVhT2JqZWN0OiBmdW5jdGlvbihyZXN1bHRzLCB0eXBlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy50KCdub25hbWUnKSxcbiAgICAgICAgICAgIGRyaWxsZG93bjogJycsXG4gICAgICAgICAgICBwdXJwb3NlOiB0aGlzLnQodHlwZSksXG4gICAgICAgICAgICB0eXBlOiB0eXBlLnNwbGl0KCcuJykuam9pbignXycpXG4gICAgICAgIH07XG5cbiAgICAgICAgZGF0YS5kcmlsbGRvd24gPSB0aGlzLl9nZXREcmlsbGRvd24ocmVzdWx0c1t0eXBlXSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdHNbdHlwZV0ubmFtZSkge1xuICAgICAgICAgICAgZGF0YS5uYW1lID0gcmVzdWx0c1t0eXBlXS5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRtcGw6ICdjaXR5YXJlYScsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgaGVhZGVyOiB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICAgICAgdG1wbDogJ3BvcHVwSGVhZGVyJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7J3RpdGxlJzogZGF0YS5uYW1lfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2luaXRTdHlsZXMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc3R5bGVzSW5pdGVkID0gdHJ1ZTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9wb2x5bGluZVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbih6b29tKSB7XG4gICAgICAgICAgICBERy5leHRlbmQodGhpcy5fcG9seWxpbmVTdHlsZXNbem9vbV0sIHRoaXMuX3BvbHlsaW5lU3R5bGVEZWZhdWx0KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9nZXRQb2x5U3R5bGVOdW06IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWFwWm9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3BvbHlsaW5lU3R5bGVzKS5maWx0ZXIoZnVuY3Rpb24oem9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcFpvb20gPD0gem9vbTtcbiAgICAgICAgfSlbMF0gfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIF91cGRhdGVHZW9tZXRyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdTdHlsZSA9IHRoaXMuX2dldFBvbHlTdHlsZU51bSgpO1xuXG4gICAgICAgIGlmIChuZXdTdHlsZSAmJiBuZXdTdHlsZSAhPT0gdGhpcy5fZ2VvbWV0cnlab29tU3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5Wm9vbVN0eWxlID0gbmV3U3R5bGU7XG4gICAgICAgICAgICB0aGlzLl9nZW9tZXRyeS5zZXRTdHlsZSh0aGlzLl9wb2x5bGluZVN0eWxlc1tuZXdTdHlsZV0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jbGVhclBvcHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAgICAgLnJlbW92ZUxheWVyKHRoaXMuX2dlb21ldHJ5KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3pvb21lbmQnLCB0aGlzLl91cGRhdGVHZW9tZXRyeSwgdGhpcyk7XG4gICAgfVxuXG59KTtcbiIsIi8qZ2xvYmFsIEZpcm1DYXJkICovXG5ERy5HZW9jbGlja2VyLkhhbmRsZXIuSG91c2UgPSBERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5leHRlbmQoe1xuXG4gICAgX2Zpcm1zT25QYWdlOiAyMCxcbiAgICBfc2Nyb2xsVGhyb3R0bGVJbnRlcnZhbDogNDAwLFxuICAgIF9zY3JvbGxIZWlnaHRSZXNlcnZlOiA2MCxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgJ3Nob3dCb29rbGV0JzogdHJ1ZSxcbiAgICAgICAgJ3Nob3dQaG90b3MnOiB0cnVlLFxuICAgICAgICAnc2hvd1JvdXRlU2VhcmNoJzogdHJ1ZVxuICAgIH0sXG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uKHJlc3VsdHMpIHsgLy8gKE9iamVjdCkgLT4gUHJvbWlzZVxuICAgICAgICBpZiAoIXJlc3VsdHMuYnVpbGRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpYWxpemF0aW9uIHNldHVwXG4gICAgICAgIHRoaXMuZmlybUNhcmQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWdlID0gMTtcbiAgICAgICAgdGhpcy5faG91c2VPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXJtTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Zpcm1MaXN0T2JqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlybUNhcmRPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9vblNjcm9sbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0Zpcm1saXN0T3BlbiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2lkID0gcmVzdWx0cy5idWlsZGluZy5pZDtcbiAgICAgICAgdGhpcy5fdG90YWxQYWdlcyA9IDE7XG4gICAgICAgIHRoaXMuX2FwaSA9IHRoaXMuX2NvbnRyb2xsZXIuZ2V0Q2F0YWxvZ0FwaSgpO1xuICAgICAgICB0aGlzLl9wb3B1cCA9IHRoaXMuX3ZpZXcuZ2V0UG9wdXAoKTtcbiAgICAgICAgdGhpcy5faW5pdGVkUG9wdXBDbG9zZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb25zVXJsID0gdGhpcy5fZ2V0RGlyZWN0aW9uc1VybChyZXN1bHRzLmJ1aWxkaW5nLm5hbWUpO1xuICAgICAgICB0aGlzLl9maXJtTGlzdExvYWRlciA9IHRoaXMuX3ZpZXcuaW5pdExvYWRlcih0cnVlKTtcblxuICAgICAgICB0aGlzLl9ob3VzZU9iamVjdCA9IHRoaXMuX2ZpbGxIb3VzZU9iamVjdChyZXN1bHRzLmJ1aWxkaW5nKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2hvdXNlT2JqZWN0KTtcbiAgICB9LFxuXG4gICAgX2lzUm91dGVTZWFyY2hBbGxvd2VkOiBmdW5jdGlvbigpIHsgLy8oKSAtPiBCb29sZWFuXG4gICAgICAgIHZhciBwcm9qZWN0ID0gdGhpcy5fY29udHJvbGxlci5nZXRNYXAoKS5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpO1xuICAgICAgICByZXR1cm4gcHJvamVjdC50cmFuc3BvcnQgfHwgcHJvamVjdC5yb2FkcztcbiAgICB9LFxuXG4gICAgX2Zpcm1DYXJkU2V0dXA6IGZ1bmN0aW9uKCkgeyAvLygpIC0+IE9iamVjdFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVuZGVyOiB0aGlzLl92aWV3LnJlbmRlclRlbXBsYXRlLFxuICAgICAgICAgICAgbGFuZzogdGhpcy5fbWFwLmdldExhbmcoKSxcbiAgICAgICAgICAgIGRvbWFpbjogdGhpcy5fY29udHJvbGxlci5nZXRNYXAoKS5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLmRvbWFpbixcbiAgICAgICAgICAgIGFqYXg6IERHLmJpbmQodGhpcy5fYXBpLmdldEZpcm1JbmZvLCB0aGlzLl9hcGkpLFxuICAgICAgICAgICAgdGltZXpvbmVPZmZzZXQ6IHRoaXMuX2NvbnRyb2xsZXIuZ2V0TWFwKCkucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKS50aW1lT2Zmc2V0LFxuICAgICAgICAgICAgbWFwOiB0aGlzLl9tYXAsXG4gICAgICAgICAgICBwb3B1cDogdGhpcy5fcG9wdXAsXG4gICAgICAgICAgICBpc01vYmlsZTogREcuQnJvd3Nlci5tb2JpbGUsXG4gICAgICAgICAgICBzaG93RW50cmFuY2U6IERHLkVudHJhbmNlLFxuICAgICAgICAgICAgZ290b1VybDogdGhpcy5fZGlyZWN0aW9uc1VybCxcbiAgICAgICAgICAgIG9uRmlybVJlYWR5OiBERy5iaW5kKHRoaXMuX29uRmlybVJlYWR5LCB0aGlzKSxcbiAgICAgICAgICAgIG9uVG9nZ2xlOiBERy5iaW5kKHRoaXMuX3BvcHVwLnJlc2l6ZSwgdGhpcy5fcG9wdXApLFxuICAgICAgICAgICAgc2hvd0Jvb2tsZXQ6IHRoaXMub3B0aW9ucy5zaG93Qm9va2xldCxcbiAgICAgICAgICAgIHNob3dQaG90b3M6IHRoaXMub3B0aW9ucy5zaG93UGhvdG9zLFxuICAgICAgICAgICAgc2hvd1JvdXRlU2VhcmNoOiB0aGlzLm9wdGlvbnMuc2hvd1JvdXRlU2VhcmNoICYmIHRoaXMuX2lzUm91dGVTZWFyY2hBbGxvd2VkKCksXG4gICAgICAgICAgICB0OiBERy5iaW5kKHRoaXMudCwgdGhpcylcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gaW5pdCBzaW5nbGUgZmlybSBjYXJkIGluIGNhc2Ugb2YgcG9pXG4gICAgX2ZpbGxGaXJtQ2FyZE9iamVjdDogZnVuY3Rpb24oZmlybUlkKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fZmlybUNhcmRTZXR1cCgpO1xuXG4gICAgICAgIHRoaXMuZmlybUNhcmQgPSBuZXcgRmlybUNhcmQoZmlybUlkLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5pdFBvcHVwQ2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlybUNhcmQuZ2V0Q29udGFpbmVyKCk7XG4gICAgfSxcblxuICAgIF9maXJtTGlzdFNldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9maXJtQ2FyZFNldHVwKCk7XG5cbiAgICAgICAgREcuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGJhY2tCdG46IERHLmJpbmQodGhpcy5fc2hvd0hvdXNlUG9wdXAsIHRoaXMpLFxuICAgICAgICAgICAgb25GaXJtQ2xpY2s6IERHLmJpbmQodGhpcy5fb25GaXJtTGlzdENsaWNrLCB0aGlzKSxcbiAgICAgICAgICAgIG9uU2hvd0xlc3M6IERHLmJpbmQodGhpcy5fc2hvd0hvdXNlUG9wdXAsIHRoaXMpLFxuICAgICAgICAgICAgcGFzdGVMb2FkZXI6IERHLmJpbmQodGhpcy5fcGFzdGVMb2FkZXIsIHRoaXMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJtQ2FyZDogb3B0aW9ucyxcbiAgICAgICAgICAgIGZpcm1saXN0SXRlbVRtcGw6ICdmaXJtbGlzdEl0ZW0nLFxuICAgICAgICAgICAgb25MaXN0UmVhZHk6IERHLmJpbmQodGhpcy5fcmVuZGVyRmlybUxpc3QsIHRoaXMpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9pbml0U2hvcnRGaXJtTGlzdDogZnVuY3Rpb24oZmlybXMpIHsgLy8oT2JqZWN0KSAtPiBET01FbGVtZW50XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fZmlybUxpc3RTZXR1cCgpO1xuXG4gICAgICAgIHRoaXMuX3Nob3J0RmlybUxpc3QgPSBuZXcgRmlybUNhcmQuTGlzdChmaXJtcywgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3J0RmlybUxpc3QucmVuZGVyTGlzdCgpO1xuICAgIH0sXG5cbiAgICBfaW5pdEZpcm1MaXN0OiBmdW5jdGlvbihyZXMpIHsgLy8oT2JqZWN0KSAtPiBQcm9taXNlXG4gICAgICAgIGlmICghcmVzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgIHZhciByZXN1bHRzID0gcmVzLnJlc3VsdC5pdGVtcyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLl9maXJtTGlzdFNldHVwKCk7XG5cbiAgICAgICAgb3B0aW9ucy5maXJtQ2FyZC5iYWNrQnRuID0gREcuYmluZCh0aGlzLl9zaG93TGlzdFBvcHVwLCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9zaG9ydEZpcm1MaXN0Ll90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuXG4gICAgICAgIHRoaXMuX2Zpcm1MaXN0ID0gbmV3IEZpcm1DYXJkLkxpc3QocmVzdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fZmlybUxpc3RPYmplY3QgPSB0aGlzLl9maWxsRmlybUxpc3RPYmplY3QodGhpcy5fZmlybUxpc3QucmVuZGVyTGlzdCgpKTtcbiAgICAgICAgdGhpcy5fY2xlYXJBbmRSZW5kZXJQb3B1cCh0aGlzLl9maXJtTGlzdE9iamVjdCk7XG4gICAgfSxcblxuICAgIF9maWxsRmlybUxpc3RPYmplY3Q6IGZ1bmN0aW9uKGZpcm1MaXN0KSB7IC8vKERPTUVsZW1lbnQpIC0+IE9iamVjdFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRtcGw6IGZpcm1MaXN0LFxuICAgICAgICAgICAgaGVhZGVyOiB0aGlzLl9oZWFkZXIsXG4gICAgICAgICAgICBmb290ZXI6IHRoaXMuX3ZpZXcucmVuZGVyKHtcbiAgICAgICAgICAgICAgICB0bXBsOiAncG9wdXBGb290ZXJCdG5zJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGJ0bnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYmFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMudCgnYmFja19idXR0b24nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFmdGVyUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0UG9wdXBDbG9zZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3RvdGFsUGFnZXMgPiAxICYmIHNlbGYuX2Zpcm1MaXN0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFwidGhpc1wiIGhlcmUgaXMgc2VsZi5fZmlybUxpc3RPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50bXBsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoc2VsZi5fZmlybUxpc3RMb2FkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX29uRmlybVJlYWR5OiBmdW5jdGlvbihmaXJtQ29udGVudE9iamVjdCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZpcm1Db250ZW50T2JqZWN0LmFmdGVyUmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyVGl0bGUgPSBzZWxmLl9wb3B1cC5fcG9wdXBTdHJ1Y3R1cmUuaGVhZGVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIURHLkJyb3dzZXIuaWVsdDkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyVGl0bGUub2Zmc2V0SGVpZ2h0ID4gNzIpIHsgLy9UT0RPOiBtYWdpYyBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhoZWFkZXJUaXRsZSwgJ2RnLXBvcHVwX19oZWFkZXItdGVhc2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghREcuQnJvd3Nlci53ZWJraXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIERHLkdlb2NsaWNrZXIuY2xhbXBIZWxwZXIoaGVhZGVyVGl0bGUsIDMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jbGVhckFuZFJlbmRlclBvcHVwKGZpcm1Db250ZW50T2JqZWN0KTtcbiAgICB9LFxuXG4gICAgX3Nob3dIb3VzZVBvcHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcG9wdXAub2ZmKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCk7XG4gICAgICAgIHRoaXMuX2NsZWFyQW5kUmVuZGVyUG9wdXAodGhpcy5faG91c2VPYmplY3QpO1xuICAgICAgICB0aGlzLl9zaG9ydEZpcm1MaXN0Ll90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgfSxcblxuICAgIF9vbkZpcm1MaXN0Q2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9wb3B1cC5vZmYoJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsKTtcbiAgICB9LFxuXG4gICAgX3Bhc3RlTG9hZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxvYWRlcldyYXBwZXIgID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1tYXAtZ2VvY2xpY2tlcl9fcHJlbG9hZGVyLXdyYXBwZXInKSxcbiAgICAgICAgICAgIGxvYWRlciA9IHRoaXMuX3ZpZXcuaW5pdExvYWRlcigpO1xuXG4gICAgICAgIGxvYWRlcldyYXBwZXIuaW5zZXJ0QmVmb3JlKGxvYWRlciwgbG9hZGVyV3JhcHBlci5maXJzdENoaWxkKTtcbiAgICAgICAgbG9hZGVyV3JhcHBlci5zdHlsZS5oZWlnaHQgPSB0aGlzLl9wb3B1cC5fY29udGVudE5vZGUub2Zmc2V0SGVpZ2h0IC0gMSArICdweCc7IC8vIE1BR0lDXG4gICAgICAgIGxvYWRlcldyYXBwZXIuc3R5bGUud2lkdGggPSB0aGlzLl9wb3B1cC5fY29udGVudE5vZGUub2Zmc2V0V2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLl9jbGVhckFuZFJlbmRlclBvcHVwKHt0bXBsOiBsb2FkZXJXcmFwcGVyfSk7XG4gICAgfSxcblxuICAgIF9pbml0UG9wdXBDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0ZWRQb3B1cENsb3NlKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRyb2xsZXIuZ2V0TWFwKCkub25jZSgncG9wdXBjbG9zZScsIERHLmJpbmQodGhpcy5fb25Qb3B1cENsb3NlLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfc2hvd0xpc3RQb3B1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaXJtTGlzdCA9IHRoaXMuX2Zpcm1MaXN0T2JqZWN0O1xuXG4gICAgICAgIHRoaXMuX3Bhc3RlTG9hZGVyKCk7XG5cbiAgICAgICAgaWYgKCFmaXJtTGlzdCkge1xuICAgICAgICAgICAgZmlybUxpc3QgPSB0aGlzLl9hcGkuZmlybXNJbkhvdXNlKHRoaXMuX2lkKS50aGVuKERHLmJpbmQodGhpcy5faW5pdEZpcm1MaXN0LCB0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhckFuZFJlbmRlclBvcHVwKGZpcm1MaXN0KTtcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1MaXN0Ll90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX29uU2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLl9vblNjcm9sbCA9IERHLlV0aWwudGhyb3R0bGUodGhpcy5faGFuZGxlUG9wdXBTY3JvbGwsIHRoaXMuX3Njcm9sbFRocm90dGxlSW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wdXAub24oJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsKTtcbiAgICB9LFxuXG4gICAgX3JlbmRlckZpcm1MaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0Zpcm1saXN0T3Blbikge1xuICAgICAgICAgICAgdGhpcy5fcG9wdXAucmVzaXplKCk7XG4gICAgICAgICAgICB0aGlzLl9pc0Zpcm1saXN0T3BlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uUG9wdXBDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2Zpcm1MaXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJtTGlzdC5jbGVhckxpc3QoKTtcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1MaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwLm9mZignc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Zpcm1JZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZpcm1DYXJkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcm1DYXJkLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5maXJtQ2FyZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlybUxpc3RMb2FkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWdlID0gMTtcbiAgICAgICAgdGhpcy5fY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgfSxcblxuICAgIF9pbml0U2hvd01vcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuX3BvcHVwLmZpbmRFbGVtZW50KCcuZGctcG9wdXBfX2J1dHRvbl9uYW1lX2FsbCcpO1xuXG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoJ2RnLXBvcHVwX19idXR0b25fbmFtZV9hbGwnLCBERy5iaW5kKHRoaXMuX3Nob3dMaXN0UG9wdXAsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYXJBbmRSZW5kZXJQb3B1cDogZnVuY3Rpb24ocG9wdXBPYmplY3QpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuX3BvcHVwLmNsZWFyKCdoZWFkZXInLCAnZm9vdGVyJyk7XG4gICAgICAgIHRoaXMuX3ZpZXcucmVuZGVyUG9wdXAocG9wdXBPYmplY3QpO1xuICAgIH0sXG5cbiAgICBfYXBwZW5kRmlybUxpc3Q6IGZ1bmN0aW9uKHJlcykgeyAvLyAoT2JqZWN0KVxuICAgICAgICB0aGlzLl9maXJtTGlzdC5hZGRGaXJtcyhyZXMucmVzdWx0Lml0ZW1zKTtcbiAgICAgICAgdGhpcy5fcG9wdXAuX3VwZGF0ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVQb3B1cFNjcm9sbDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgc2Nyb2xsZXIgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0IHx8IGUudGFyZ2V0Ll9zY3JvbGxlcjtcblxuICAgICAgICBERy5Eb21FdmVudC5zdG9wKGUpO1xuXG4gICAgICAgIGlmICh0aGlzLl90b3RhbFBhZ2VzIDw9IDEpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChzY3JvbGxlciAmJiBzY3JvbGxlci5zY3JvbGxIZWlnaHQgPD0gc2Nyb2xsZXIuc2Nyb2xsVG9wICsgc2Nyb2xsZXIub2Zmc2V0SGVpZ2h0ICsgdGhpcy5fc2Nyb2xsSGVpZ2h0UmVzZXJ2ZSkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlUGFnaW5nKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2hhbmRsZVBhZ2luZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3BhZ2UrKztcblxuICAgICAgICBpZiAodGhpcy5fdG90YWxQYWdlcyAmJiB0aGlzLl9wYWdlIDw9IHRoaXMuX3RvdGFsUGFnZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwaS5maXJtc0luSG91c2UodGhpcy5faWQsIHtwYWdlOiB0aGlzLl9wYWdlfSkudGhlbihERy5iaW5kKHRoaXMuX2FwcGVuZEZpcm1MaXN0LCB0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcGFnZSA9PT0gdGhpcy5fdG90YWxQYWdlcykge1xuICAgICAgICAgICAgdmFyIGxvYWRlciA9IHRoaXMuX2Zpcm1MaXN0TG9hZGVyO1xuXG4gICAgICAgICAgICBpZiAobG9hZGVyICYmIGxvYWRlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobG9hZGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fcG9wdXAub2ZmKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5Ib3VzZS5pbmNsdWRlKHtcbiAgICBfZ2V0QWRkcmVzc1N0cmluZzogZnVuY3Rpb24oaG91c2UpIHtcbiAgICAgICAgaWYgKCFob3VzZS5hZGRyZXNzIHx8ICFob3VzZS5hZGRyZXNzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBob3VzZS5hZGRyZXNzLmNvbXBvbmVudHNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC50eXBlID09PSAnc3RyZWV0X251bWJlcic7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50LnN0cmVldCArICcsICcgKyBjb21wb25lbnQubnVtYmVyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcgLyAnKTtcbiAgICB9LFxuXG4gICAgX2ZpbGxCb2R5OiBmdW5jdGlvbihob3VzZSkgeyAvLyAvLyAoT2JqZWN0KSAtPiAoRE9NRWxlbWVudClcbiAgICAgICAgdmFyIGRhdGEgPSB7fSxcbiAgICAgICAgICAgIHdyYXBwZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLWJ1aWxkaW5nLWNhbGxvdXRfX2JvZHknKSxcbiAgICAgICAgICAgIGZpbGlhbHMgPSBob3VzZS5saW5rcyAmJiBob3VzZS5saW5rcy5icmFuY2hlcztcblxuICAgICAgICB2YXIgZHJpbGxkb3duID0gdGhpcy5fZ2V0RHJpbGxkb3duKGhvdXNlKTtcblxuICAgICAgICBpZiAoaG91c2UuYnVpbGRpbmdfbmFtZSkge1xuICAgICAgICAgICAgZGF0YS5hZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcjogdGhpcy5fZ2V0QWRkcmVzc1N0cmluZyhob3VzZSksXG4gICAgICAgICAgICAgICAgZHJpbGxkb3duOiBkcmlsbGRvd25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHJpbGxkb3duKSB7XG4gICAgICAgICAgICBkYXRhLmFkZHJlc3MgPSB7XG4gICAgICAgICAgICAgICAgZHJpbGxkb3duOiBkcmlsbGRvd25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnB1cnBvc2UgPSBob3VzZS5wdXJwb3NlX25hbWUgK1xuICAgICAgICAgICAgKGhvdXNlLmZsb29ycyA/ICcsICcgKyB0aGlzLnQoJ25fZmxvb3JzJywgaG91c2UuZmxvb3JzLmdyb3VuZF9jb3VudCkgOiAnJyk7XG5cbiAgICAgICAgaWYgKGZpbGlhbHMgJiYgZmlsaWFscy5jb3VudCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsUGFnZXMgPSBNYXRoLmNlaWwoaG91c2UubGlua3MuYnJhbmNoZXMuY291bnQgLyB0aGlzLl9maXJtc09uUGFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG91c2UubGlua3MgJiYgaG91c2UubGlua3MuYXR0cmFjdGlvbnMgJiYgaG91c2UubGlua3MuYXR0cmFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhLmF0dHJhY3Rpb25zID0gaG91c2UubGlua3MuYXR0cmFjdGlvbnMucmVkdWNlKGZ1bmN0aW9uKGF0dHJhY3Rpb25zLCBhdHRyYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJhY3Rpb24ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyYWN0aW9ucy5wdXNoKGF0dHJhY3Rpb24ubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJhY3Rpb25zO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgd3JhcHBlci5pbm5lckhUTUwgPSB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICB0bXBsOiAnaG91c2UnLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZmlsaWFscyAmJiBmaWxpYWxzLml0ZW1zKSB7XG4gICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuX2luaXRTaG9ydEZpcm1MaXN0KGZpbGlhbHMuaXRlbXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH0sXG5cbiAgICBfZmlsbEhlYWRlcjogZnVuY3Rpb24oaG91c2UpIHsgLy8gKE9iamVjdCkgLT4gKEhUTUxTdHJpbmcpXG4gICAgICAgIHZhciBoZWFkZXIgPSB7fTtcblxuICAgICAgICBpZiAoaG91c2UuYnVpbGRpbmdfbmFtZSkge1xuICAgICAgICAgICAgaGVhZGVyLnRpdGxlID0gaG91c2UuYnVpbGRpbmdfbmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChob3VzZS5hZGRyZXNzICYmIGhvdXNlLmFkZHJlc3MuY29tcG9uZW50cykge1xuICAgICAgICAgICAgaGVhZGVyLnRpdGxlID0gdGhpcy5fZ2V0QWRkcmVzc1N0cmluZyhob3VzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXIudGl0bGUgPSBob3VzZS5wdXJwb3NlX25hbWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oZWFkZXIgPSB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICB0bXBsOiAncG9wdXBIZWFkZXInLFxuICAgICAgICAgICAgZGF0YTogaGVhZGVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfSxcblxuICAgIF9maWxsRm9vdGVyOiBmdW5jdGlvbihob3VzZSkgeyAvLyAoT2JqZWN0KSAtPiAoSFRNTFN0cmluZylcbiAgICAgICAgdmFyIGJ0bnMgPSBbXTtcbiAgICAgICAgdmFyIGhvdXNlRmlsaWFscyA9IGhvdXNlLmxpbmtzICYmIGhvdXNlLmxpbmtzLmJyYW5jaGVzO1xuXG4gICAgICAgIC8vIERlY2lkZSBpZiB3ZSBuZWVkIHRvIGRpc3BsYXkgJ21vcmUgb3JnYW5pc2F0aW9ucycgYnV0dG9uXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGhvdXNlRmlsaWFscyAmJlxuICAgICAgICAgICAgaG91c2VGaWxpYWxzLml0ZW1zICYmXG4gICAgICAgICAgICBob3VzZUZpbGlhbHMuaXRlbXMubGVuZ3RoICYmXG4gICAgICAgICAgICBob3VzZUZpbGlhbHMuY291bnQgPiBob3VzZUZpbGlhbHMuaXRlbXMubGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAgICAgYnRucy5wdXNoKHRoaXMuX2dldFNob3dBbGxEYXRhKGhvdXNlRmlsaWFscy5jb3VudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzUm91dGVTZWFyY2hBbGxvd2VkKCkpIHtcbiAgICAgICAgICAgIGJ0bnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2dvdG8nLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLnQoJ2dvX3RvJyksXG4gICAgICAgICAgICAgICAgaWNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBocmVmOiB0aGlzLl9kaXJlY3Rpb25zVXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICB0bXBsOiAncG9wdXBGb290ZXJCdG5zJyxcbiAgICAgICAgICAgIGRhdGE6IHsnYnRucyc6IGJ0bnN9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0U2hvd0FsbERhdGE6IGZ1bmN0aW9uKGZpbGlhbHNDb3VudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ2FsbCcsXG4gICAgICAgICAgICBsYWJlbDogdGhpcy50KCdzaG93X29yZ2FuaXphdGlvbl9pbl9idWlsZGluZycsIGZpbGlhbHNDb3VudClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2ZpbGxIb3VzZU9iamVjdDogZnVuY3Rpb24oaG91c2UpIHsgLy8gKE9iamVjdCkgLT4gKE9iamVjdClcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXI6IHRoaXMuX2ZpbGxIZWFkZXIoaG91c2UpLFxuICAgICAgICAgICAgdG1wbDogdGhpcy5fZmlsbEJvZHkoaG91c2UpLFxuICAgICAgICAgICAgZm9vdGVyOiB0aGlzLl9maWxsRm9vdGVyKGhvdXNlKSxcbiAgICAgICAgICAgIGFmdGVyUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0U2hvd01vcmUoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0UG9wdXBDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLlBvaSA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5Ib3VzZS5leHRlbmQoe1xuXG4gICAgaGFuZGxlOiBmdW5jdGlvbihyZXN1bHRzKSB7IC8vIChPYmplY3QpIC0+IFByb21pc2VcbiAgICAgICAgaWYgKCFyZXN1bHRzLnBvaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gc2V0dXBcbiAgICAgICAgdGhpcy5maXJtQ2FyZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhZ2UgPSAxO1xuICAgICAgICB0aGlzLl9ob3VzZU9iamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Zpcm1MaXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlybUxpc3RPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXJtQ2FyZE9iamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzRmlybWxpc3RPcGVuID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5faWQgPSByZXN1bHRzLnBvaS5yZWZlcmVuY2UuaWQ7XG4gICAgICAgIHRoaXMuX3RvdGFsUGFnZXMgPSAxO1xuICAgICAgICB0aGlzLl9hcGkgPSB0aGlzLl9jb250cm9sbGVyLmdldENhdGFsb2dBcGkoKTtcbiAgICAgICAgdGhpcy5fcG9wdXAgPSB0aGlzLl92aWV3LmdldFBvcHVwKCk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uc1VybCA9IHRoaXMuX2dldERpcmVjdGlvbnNVcmwocmVzdWx0cy5wb2kucmVmZXJlbmNlLm5hbWUpO1xuICAgICAgICB0aGlzLl9maXJtTGlzdExvYWRlciA9IHRoaXMuX3ZpZXcuaW5pdExvYWRlcih0cnVlKTtcblxuICAgICAgICAvLyBJZiB0aGUgUE9JIHJlZmVycyB0byBhIGJ1aWxkaW5nIChlLmcuIGdhbGxlcmllcyBpbiBTYW50aWFnbyksXG4gICAgICAgIC8vIHNob3cgYSBidWlsZGluZyBjYWxsb3V0XG4gICAgICAgIGlmIChyZXN1bHRzLnBvaS5yZWZlcmVuY2UudHlwZSA9PT0gJ2J1aWxkaW5nJykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fYXBpLmdlb0dldChyZXN1bHRzLnBvaS5yZWZlcmVuY2UuaWQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2hvdXNlT2JqZWN0ID0gc2VsZi5fZmlsbEhvdXNlT2JqZWN0KHJlc3VsdC5yZXN1bHQuaXRlbXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNlbGYuX2hvdXNlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2hvdyBhIGZpcm0gY2FsbG91dFxuICAgICAgICBpZiAocmVzdWx0cy5wb2kucmVmZXJlbmNlLnR5cGUgPT09ICdicmFuY2gnKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsRmlybUNhcmRPYmplY3QocmVzdWx0cy5wb2kucmVmZXJlbmNlLmlkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxufSk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuU2lnaHQgPSBERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5leHRlbmQoe1xuXG4gICAgaGFuZGxlOiBmdW5jdGlvbihyZXN1bHRzKSB7IC8vIChPYmplY3QsIFN0cmluZykgLT4gUHJvbWlzZVxuICAgICAgICBpZiAoIXJlc3VsdHMuYXR0cmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wdXAgPSB0aGlzLl92aWV3LmdldFBvcHVwKCk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2ZpbGxTaWdodE9iamVjdChyZXN1bHRzKSk7XG4gICAgfSxcblxuICAgIF9maWxsU2lnaHRPYmplY3Q6IGZ1bmN0aW9uKHJlc3VsdHMpIHsgLy8gKE9iamVjdCkgLT4gT2JqZWN0XG4gICAgICAgIHZhciBhdHRyYWN0aW9uID0gcmVzdWx0cy5hdHRyYWN0aW9uLFxuICAgICAgICAgICAgZGF0YSA9IHt9LFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBmb290ZXIgPSB7XG4gICAgICAgICAgICAgICAgYnRuczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZ290bycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy50KCdnb190bycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoYXR0cmFjdGlvbi5uYW1lKSB7XG4gICAgICAgICAgICBkYXRhLmJ1aWxkaW5nTmFtZSA9IGF0dHJhY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIGRhdGEucHVycG9zZSA9IGF0dHJhY3Rpb24uc3VidHlwZV9uYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5idWlsZGluZ05hbWUgPSBhdHRyYWN0aW9uLnN1YnR5cGVfbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuZGVzY3JpcHRpb24gPSBhdHRyYWN0aW9uLmRlc2NyaXB0aW9uO1xuXG4gICAgICAgIGRhdGEuZHJpbGxEb3duID0gdGhpcy5fZ2V0RHJpbGxkb3duKGF0dHJhY3Rpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLl9jaGVja0Rlc2NGaWVsZEhlaWdodChkYXRhLmRlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgZGF0YS5zaG93TW9yZVRleHQgPSB0aGlzLnQoJ3Nob3dfbW9yZV9hYm91dF9zaWdodCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9vdGVyLmJ0bnNbMF0uaHJlZiA9IHRoaXMuX2dldERpcmVjdGlvbnNVcmwoZGF0YS5idWlsZGluZ05hbWUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0bXBsOiAnc2lnaHQnLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGhlYWRlcjogdGhpcy5fdmlldy5yZW5kZXIoe1xuICAgICAgICAgICAgICAgIHRtcGw6ICdwb3B1cEhlYWRlcicsXG4gICAgICAgICAgICAgICAgZGF0YTogeyd0aXRsZSc6IGRhdGEuYnVpbGRpbmdOYW1lfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBmb290ZXI6IHRoaXMuX3ZpZXcucmVuZGVyKHtcbiAgICAgICAgICAgICAgICB0bXBsOiAncG9wdXBGb290ZXJCdG5zJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBmb290ZXJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9uZWVkU2hvd01vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5pdFNob3dNb3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuX2luaXRQb3B1cENsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9pbml0UG9wdXBDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0ZWRQb3B1cENsb3NlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250cm9sbGVyLmdldE1hcCgpLm9uY2UoJ3BvcHVwY2xvc2UnLCBERy5iaW5kKHRoaXMuX2NsZWFyUG9wdXAsIHRoaXMpKTtcbiAgICAgICAgdGhpcy5faW5pdGVkUG9wdXBDbG9zZSA9IHRydWU7XG4gICAgfSxcblxuICAgIF9jbGVhclBvcHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5faW5pdGVkUG9wdXBDbG9zZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jbGVhckV2ZW50SGFuZGxlcnMoKTtcbiAgICB9LFxuXG4gICAgX3Nob3dNb3JlVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Rlc2Muc3R5bGUubWF4SGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLl9saW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fbGluayk7XG4gICAgICAgIHRoaXMuX3BvcHVwLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICBfaW5pdFNob3dNb3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbGluayA9IHRoaXMuX3BvcHVwLmZpbmRFbGVtZW50KCcuZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGluaycpO1xuICAgICAgICB0aGlzLl9kZXNjID0gdGhpcy5fcG9wdXAuZmluZEVsZW1lbnQoJy5kZy1tYXAtZ2VvY2xpY2tlcl9fc2lnaHQtZGVzY3JpcHRpb24nKTtcblxuICAgICAgICBpZiAodGhpcy5fbGluayAmJiB0aGlzLl9kZXNjKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoJ2RnLW1hcC1nZW9jbGlja2VyX19zaG93LW1vcmUtc2lnaHRzLWxpbmsnLCBERy5iaW5kKHRoaXMuX3Nob3dNb3JlVGV4dCwgdGhpcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jaGVja0Rlc2NGaWVsZEhlaWdodDogZnVuY3Rpb24oZGVzYykge1xuICAgICAgICB2YXIgZWwgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJycpLFxuICAgICAgICAgICAgaGVpZ2h0O1xuXG4gICAgICAgIGVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gZGVzYztcblxuICAgICAgICB0aGlzLl9wb3B1cC5fY29udGVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHRoaXMuX3BvcHVwLl9jb250ZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIHRoaXMuX25lZWRTaG93TW9yZSA9IChoZWlnaHQgPiA0MCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX25lZWRTaG93TW9yZTtcbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuVmlldyA9IERHLkNsYXNzLmV4dGVuZCh7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtYXAsIG9wdGlvbnMpIHsgLy8gKE9iamVjdCwgT2JqZWN0KVxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuX3BvcHVwID0gREcucG9wdXAoe1xuICAgICAgICAgICAgbWF4SGVpZ2h0OiAzMDAsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IDUwLFxuICAgICAgICAgICAgbWF4V2lkdGg6IDM4NSxcbiAgICAgICAgICAgIG1pbldpZHRoOiAzMTAsXG4gICAgICAgICAgICBzcHJhd2xpbmc6IHRydWUsXG4gICAgICAgICAgICBjbG9zZU9uQ2xpY2s6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIERHLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0TG9hZGVyOiBmdW5jdGlvbihpc1NtYWxsKSB7XG4gICAgICAgIHZhciBsb2FkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbG9hZGVyLmlubmVySFRNTCA9IERHLmR1c3QoJ0RHR2VvY2xpY2tlci9sb2FkZXInLCB7XG4gICAgICAgICAgICBzbWFsbDogaXNTbWFsbCxcbiAgICAgICAgICAgIGFuaW06IHRoaXMuX2RldGVjdENzc0FuaW1hdGlvbigpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBsb2FkZXIuZmlyc3RDaGlsZDtcbiAgICB9LFxuXG4gICAgc2hvd1BvcHVwOiBmdW5jdGlvbihsYXRsbmcsIGNvbnRlbnQpIHsgLy8gKE9iamVjdClcbiAgICAgICAgdGhpcy5fcG9wdXBcbiAgICAgICAgICAgIC5zZXRDb250ZW50KGNvbnRlbnQpXG4gICAgICAgICAgICAuc2V0TGF0TG5nKGxhdGxuZylcbiAgICAgICAgICAgIC5vcGVuT24odGhpcy5fbWFwKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7IC8vIChPYmplY3QpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgaHRtbCxcbiAgICAgICAgICAgIGRhdGEgPSB7fTtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy50bXBsID0gb3B0aW9ucy50bXBsIHx8ICcnO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgIGh0bWwgPSB0aGlzLnJlbmRlclRlbXBsYXRlKG9wdGlvbnMudG1wbCwgb3B0aW9ucy5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWwgPSBvcHRpb25zLnRtcGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5iZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYmVmb3JlUmVuZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wb3B1cCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5oZWFkZXIgPSBvcHRpb25zLmhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZvb3Rlcikge1xuICAgICAgICAgICAgICAgIGRhdGEuZm9vdGVyID0gb3B0aW9ucy5mb290ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmJvZHkgPSBodG1sO1xuICAgICAgICAgICAgdGhpcy5fcG9wdXAuc2V0Q29udGVudChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hZnRlclJlbmRlcikge1xuICAgICAgICAgICAgb3B0aW9ucy5hZnRlclJlbmRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfSxcblxuICAgIHJlbmRlclRlbXBsYXRlOiBmdW5jdGlvbihuYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBERy5kdXN0KCdER0dlb2NsaWNrZXIvJyArIG5hbWUsIGRhdGEpO1xuICAgIH0sXG5cbiAgICByZW5kZXJQb3B1cDogZnVuY3Rpb24ob3B0aW9ucykgeyAvLyAoT2JqZWN0KSAtPiBTdHJpbmdcbiAgICAgICAgb3B0aW9ucy5wb3B1cCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcihvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZ2V0UG9wdXA6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBPYmplY3RcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVwO1xuICAgIH0sXG5cbiAgICBfZGV0ZWN0Q3NzQW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGZhbHNlLFxuICAgICAgICAgICAgZG9tUHJlZml4ZXMgPSAnV2Via2l0IE1veiBPIG1zIEtodG1sJy5zcGxpdCgnICcpLFxuICAgICAgICAgICAgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgaWYgKGVsbS5zdHlsZS5hbmltYXRpb25OYW1lKSB7IGFuaW1hdGlvbiA9IHRydWU7IH1cblxuICAgICAgICBpZiAoYW5pbWF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21QcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlbG0uc3R5bGVbZG9tUHJlZml4ZXNbaV0gKyAnQW5pbWF0aW9uTmFtZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgfVxufSk7XG4iLCJERy5HZW9jbGlja2VyLkNvbnRyb2xsZXIgPSBERy5DbGFzcy5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICAvLyBpZiBoYW5kbGVyIHdvcmtlZCBzdWNjZXNzZnVsbHksIGl0IHNob3VsZCByZXR1cm4gcmVuZGVyaW5nIG9iamVjdCB0aGF0IHdpbGwgYmUgcHJvY2Vzc2VkIGluIFZpZXcgLCBvdGhlcndpc2UgaXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgICAgICAvLyBkZWZhdWx0IGhhbmRsZXIgYWx3YXlzIHNob3VsZCByZXR1cm4gcmVuZGVyaW5nIG9iamVjdFxuICAgICAgICAnaGFuZGxlcnNTZXF1ZW5jZSc6IHtcbiAgICAgICAgICAgICdwb2knOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuUG9pLFxuICAgICAgICAgICAgJ2F0dHJhY3Rpb24nOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuU2lnaHQsXG4gICAgICAgICAgICAnYnVpbGRpbmcnOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuSG91c2UsXG4gICAgICAgICAgICAnc3RyZWV0JzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkNpdHlBcmVhLFxuICAgICAgICAgICAgJ2FkbV9kaXYucGxhY2UnOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuQ2l0eUFyZWEsXG4gICAgICAgICAgICAnYWRtX2Rpdi5kaXN0cmljdCc6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5DaXR5QXJlYSxcbiAgICAgICAgICAgICdhZG1fZGl2LmRpdmlzaW9uJzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkNpdHlBcmVhLFxuICAgICAgICAgICAgJ2FkbV9kaXYuc2V0dGxlbWVudCc6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5DaXR5QXJlYSxcbiAgICAgICAgICAgICdhZG1fZGl2LmNpdHknOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuQ2l0eUFyZWEsXG5cbiAgICAgICAgICAgICdkZWZhdWx0JzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkRlZmF1bHQsXG5cbiAgICAgICAgICAgICdhcGlFcnJvcic6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5BcGlFcnJvclxuXG4vLyAgICAgICAgICAgIHN0YXRpb25fcGxhdGZvcm1cbi8vICAgICAgICAgICAgcHJvamVjdFxuLy8gICAgICAgICAgICBzdGF0aW9uXG4vLyAgICAgICAgICAgIGNyb3NzYnJvYWRcbi8vICAgICAgICAgICAgbWV0cm9cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtYXAsIG9wdGlvbnMpIHsgLy8gKE9iamVjdCwgT2JqZWN0KVxuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fY2F0YWxvZ0FwaSA9IG5ldyBERy5HZW9jbGlja2VyLlByb3ZpZGVyLkNhdGFsb2dBcGkobWFwKTtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl92aWV3ID0gbmV3IERHLkdlb2NsaWNrZXIuVmlldyhtYXApO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlckhhbmRsZXJSZXN1bHQgPSBERy5iaW5kKHRoaXMuX3JlbmRlckhhbmRsZXJSZXN1bHQsIHRoaXMpO1xuICAgICAgICB0aGlzLl9sYXN0SGFuZGxlQ2xpY2tBcmd1bWVudHMgPSBudWxsO1xuICAgIH0sXG5cbiAgICBoYW5kbGVQb3B1cENsb3NlOiBmdW5jdGlvbihwb3B1cCkgeyAvLyAoT2JqZWN0KVxuICAgICAgICBpZiAocG9wdXAgPT09IHRoaXMuX3ZpZXcuZ2V0UG9wdXAoKSkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdEhhbmRsZUNsaWNrQXJndW1lbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NhdGFsb2dBcGkuY2FuY2VsTGFzdFJlcXVlc3QoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24obGF0bG5nLCB6b29tLCBtZXRhKSB7IC8vIChPYmplY3QsIE51bWJlciwgT2JqZWN0KVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICBmdW5jdGlvbiBiZWZvcmVSZXF1ZXN0KCkge1xuICAgICAgICAgICAgdmFyIGxvYWRlciA9IHNlbGYuX3ZpZXcuaW5pdExvYWRlcigpO1xuICAgICAgICAgICAgc2VsZi5fdmlldy5fcG9wdXAuY2xlYXIoKTtcbiAgICAgICAgICAgIHNlbGYuX3ZpZXcuc2hvd1BvcHVwKGxhdGxuZywgbG9hZGVyKTtcbiAgICAgICAgICAgIHNlbGYuX2xhc3RIYW5kbGVDbGlja0FyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0YSAmJiBtZXRhLmxpbmtlZCAmJiBtZXRhLmxpbmtlZC50eXBlICE9ICdzaWdodCcgJiYgbWV0YS5saW5rZWQudHlwZSAhPSAnYXR0cmFjdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChtZXRhLmxpbmtlZC50eXBlICE9ICdicmFuY2gnICYmIG1ldGEubGlua2VkLnR5cGUgIT0gJ2J1aWxkaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmVmb3JlUmVxdWVzdCgpO1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgcG9pOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogbWV0YS5saW5rZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhdGFsb2dBcGkuZ2V0TG9jYXRpb25zKHtcbiAgICAgICAgICAgICAgICBsYXRsbmc6IGxhdGxuZyxcbiAgICAgICAgICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICAgICAgICAgIGJlZm9yZVJlcXVlc3Q6IGJlZm9yZVJlcXVlc3RcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oYW5kbGVSZXNwb25zZShyZXN1bHQpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZVJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZVJlc3BvbnNlOiBmdW5jdGlvbihyZXN1bHQpIHsgLy8gKE9iamVjdClcbiAgICAgICAgdmFyIHR5cGU7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bkhhbmRsZXIoJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgPT09ICdubyB0eXBlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gJ2Fib3J0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9ydW5IYW5kbGVyKCdhcGlFcnJvcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSA9IHRoaXMuZmluZEhhbmRsZXIocmVzdWx0KTtcblxuICAgICAgICB3aGlsZSAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3J1bkhhbmRsZXIodHlwZSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbdHlwZV07XG5cbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLmZpbmRIYW5kbGVyKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcnVuSGFuZGxlcignZGVmYXVsdCcpO1xuICAgIH0sXG5cbiAgICBmaW5kSGFuZGxlcjogZnVuY3Rpb24ocmVzdWx0KSB7IC8vIChPYmplY3QpIC0+IFN0cmluZ3xOdWxsXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5vcHRpb25zLmhhbmRsZXJzU2VxdWVuY2UpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRDYXRhbG9nQXBpOiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gT2JqZWN0XG4gICAgICAgIHJldHVybiB0aGlzLl9jYXRhbG9nQXBpO1xuICAgIH0sXG5cbiAgICBnZXRNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwO1xuICAgIH0sXG5cbiAgICByZWludm9rZUhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdEhhbmRsZUNsaWNrQXJndW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrLmFwcGx5KHRoaXMsIHRoaXMuX2xhc3RIYW5kbGVDbGlja0FyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3J1bkhhbmRsZXI6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHsgLy8gKFN0cmluZywgT2JqZWN0KSAtPiBCb29sZWFuXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICB0aGlzLl9pbml0SGFuZGxlck9uY2UodHlwZSk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJzW3R5cGVdLmFkZENsaWNrRXZlbnQoKTtcblxuICAgICAgICB2YXIgaGFuZGxlclJlc3VsdCA9IHRoaXMuX2hhbmRsZXJzW3R5cGVdLmhhbmRsZShkYXRhLCB0eXBlKTtcblxuICAgICAgICByZXR1cm4gaGFuZGxlclJlc3VsdCAmJiBoYW5kbGVyUmVzdWx0LnRoZW4gP1xuICAgICAgICAgICAgaGFuZGxlclJlc3VsdC50aGVuKHRoaXMuX3JlbmRlckhhbmRsZXJSZXN1bHQpIDpcbiAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQ7XG4gICAgfSxcblxuICAgIF9yZW5kZXJIYW5kbGVyUmVzdWx0OiBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgdGhpcy5fdmlldy5yZW5kZXJQb3B1cChyZXN1bHQpO1xuICAgIH0sXG5cbiAgICBfaW5pdEhhbmRsZXJPbmNlOiBmdW5jdGlvbih0eXBlKSB7IC8vIChTdHJpbmcpXG4gICAgICAgIGlmICghdGhpcy5faGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW3R5cGVdID0gbmV3IHRoaXMub3B0aW9ucy5oYW5kbGVyc1NlcXVlbmNlW3R5cGVdKHRoaXMsIHRoaXMuX3ZpZXcsIHRoaXMuX21hcCwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LkRpY3Rpb25hcnkuaXQgPSBERy5leHRlbmQoe1xuICAgIGFwaUVycm9yVGl0bGU6ICdPaCBvaCwgY1xcJ8OoJm5ic3A7dW4mbmJzcDtlcnJvcmUnLFxuICAgIGFwaUVycm9yQm9keTogJ0kgbm9zdHJpIHNlcnZlciBzaSByaWZpdXRhbm8gZGkgcmlzcG9uZGVyZS4gU3RpYW1vIGZhY2VuZG8gZGVsIG5vc3RybyBtZWdsaW8gcGVyIGNvbnZpbmNlcmxpIGEmbmJzcDtjb21wb3J0YXJzaSBiZW5lLiBSaXRvcm5hIHRyYSBxdWFsY2hlIG1pbnV0by4nLFxuICAgIHdlX2hhdmVfbm90IDogJ05vbiBkaXNwb25pYW1vIGFuY29yYSBkaSBpbmZvcm1hemlvbmkgc3UgcXVlc3RvIHBvc3RvJyxcbiAgICBub25hbWUgOiAnTm9tZSBub24gaW5kaWNhdG8nLFxuICAgICdhZG1fZGl2LnBsYWNlJyA6ICdMdW9nbycsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nIDogJ1pvbmEnLFxuICAgICdhZG1fZGl2LnNldHRsZW1lbnQnIDogJ0NvbXVuZScsXG4gICAgc3RyZWV0IDogJ1ZpYScsXG4gICAgJ2FkbV9kaXYuZGlzdHJpY3QnIDogJ011bmljaXBhbGl0w6AnLFxuICAgICdhZG1fZGl2LmNpdHknIDogJ9ChaXR0w6AnLFxuICAgIGdvX3RvIDogJ0NvbWUgYXJyaXZhcmUnLFxuICAgIHNob3dfb3JnYW5pemF0aW9uX2luX2J1aWxkaW5nIDogWyd7bn0gYXppZW5kYSBpbiB0dXR0bycsICd7bn0gYXppZW5kZSBpbiB0dXR0byddLFxuICAgIHNob3dfbW9yZV9hYm91dF9zaWdodCA6ICdNYWdnaW9yaSBpbmZvcm1hemlvbmknLFxuICAgIGJhY2tfYnV0dG9uOiAnSW5kaWV0cm8nLFxuICAgIG5fZmxvb3JzIDogWyd7bn0gcGlhbm8nLCAne259IHBpYW5pJ11cbn0sIERHLkRpY3Rpb25hcnkuaXQpO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLkRlZmF1bHQuRGljdGlvbmFyeS5ydSA9IERHLmV4dGVuZCh7XG4gICAgYXBpRXJyb3JUaXRsZTogJ9Ce0YjQuNCx0L7Rh9C60LAg0LLRi9GI0LvQsCcsXG4gICAgYXBpRXJyb3JCb2R5OiAn0J3QsNGI0Lgg0YHQtdGA0LLQtdGA0Ysg0L7RgtC60LDQt9GL0LLQsNGO0YLRgdGPINC+0YLQstC10YfQsNGC0YwuINCc0Ysg0YPQttC1INC/0YDQuNC60LvQsNC00YvQstCw0LXQvCDQstGB0LUg0YHQuNC70YssINGH0YLQvtCx0Ysg0LLRgNCw0LfRg9C80LjRgtGMINC40YUuINCS0L7Qt9Cy0YDQsNGJ0LDQudGC0LXRgdGMINC6Jm5ic3A70L3QsNC8INGH0LXRgNC10LcmbmJzcDvQvdC10YHQutC+0LvRjNC60L4g0LzQuNC90YPRgi4nLFxuICAgIHdlX2hhdmVfbm90IDogJ9Ct0YLQviDQvNC10YHRgtC+INC80Ysg0LXRidGRINC90LUg0YPRgdC/0LXQu9C4INC40LfRg9GH0LjRgtGMJyxcbiAgICBub25hbWU6ICfQkdC10Lcg0L3QsNC30LLQsNC90LjRjycsXG4gICAgJ2FkbV9kaXYucGxhY2UnOiAn0JzQtdGB0YLQvicsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nOiAn0J7QutGA0YPQsycsXG4gICAgJ2FkbV9kaXYuc2V0dGxlbWVudCc6ICfQndCw0YHQtdC70LXQvdC90YvQuSDQv9GD0L3QutGCJyxcbiAgICBzdHJlZXQ6ICfQo9C70LjRhtCwJyxcbiAgICAnYWRtX2Rpdi5kaXN0cmljdCc6ICfQoNCw0LnQvtC9JyxcbiAgICAnYWRtX2Rpdi5jaXR5JzogJ9CT0L7RgNC+0LQnLFxuICAgIGdvX3RvOiAn0J/RgNC+0LXRhdCw0YLRjCDRgdGO0LTQsCcsXG4gICAgc2hvd19vcmdhbml6YXRpb25faW5fYnVpbGRpbmc6IFsn0JLRgdC10LPQviB7bn0g0L7RgNCz0LDQvdC40LfQsNGG0LjRjycsICfQktGB0LXQs9C+IHtufSDQvtGA0LPQsNC90LjQt9Cw0YbQuNC4JywgJ9CS0YHQtdCz0L4ge259INC+0YDQs9Cw0L3QuNC30LDRhtC40LknXSxcbiAgICBzaG93X21vcmVfYWJvdXRfc2lnaHQ6ICfQn9C+0LTRgNC+0LHQvdC10LUnLFxuICAgIGJhY2tfYnV0dG9uOiAn0J3QsNC30LDQtCcsXG4gICAgbl9mbG9vcnM6IFsne259INGN0YLQsNC2JywgJ3tufSDRjdGC0LDQttCwJywgJ3tufSDRjdGC0LDQttC10LknXVxufSwgREcuRGljdGlvbmFyeS5ydSk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5EaWN0aW9uYXJ5LmVuID0gREcuZXh0ZW5kKHtcbiAgICBhcGlFcnJvclRpdGxlOiAnT29wcyEgRXJyb3IgZGV0ZWN0ZWQuJyxcbiAgICBhcGlFcnJvckJvZHk6ICdPdXIgc2VydmVycyBhcmUgbm90IHJlc3BvbmRpbmcuIFdlIGFyZSBkb2luZyBvdXIgYmVzdCB0byBzdHJhaWdodGVuIHRoZW0gb3V0LiBQbGVhc2UgcmV0dXJuIHRvIHVzIGluIGEgZmV3IG1pbnV0ZXMuJyxcbiAgICB3ZV9oYXZlX25vdDogJ1dlIGhhdmVuXFwndCBjb2xsZWN0ZWQgaW5mbyBhYm91dCB0aGlzIHBsYWNlIHlldCcsXG4gICAgbm9uYW1lIDogJ05vIG5hbWUnLFxuICAgICdhZG1fZGl2LnBsYWNlJyA6ICdQbGFjZScsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nIDogJ0FyZWEnLFxuICAgICdhZG1fZGl2LnNldHRsZW1lbnQnIDogJ1ZpbGxhZ2UnLFxuICAgIHN0cmVldCA6ICdTdHJlZXQnLFxuICAgICdhZG1fZGl2LmRpc3RyaWN0JyA6ICdEaXN0cmljdCcsXG4gICAgJ2FkbV9kaXYuY2l0eScgOiAnQ2l0eScsXG4gICAgZ29fdG8gOiAnRGlyZWN0aW9ucyB0byBoZXJlJyxcbiAgICBzaG93X29yZ2FuaXphdGlvbl9pbl9idWlsZGluZyA6IFsne259IG9yZ2FuaXphdGlvbiB0b3RhbCcsICd7bn0gb3JnYW5pemF0aW9ucyB0b3RhbCddLFxuICAgIGJhY2tfYnV0dG9uIDogJ0JhY2snLFxuICAgIHNob3dfbW9yZV9hYm91dF9zaWdodCA6ICdNb3JlIGluZm9ybWF0aW9uJyxcbiAgICBuX2Zsb29ycyA6IFsne259IGZsb29yJywgJ3tufSBmbG9vcnMnXVxufSwgREcuRGljdGlvbmFyeS5lbik7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5EaWN0aW9uYXJ5LmNzID0gREcuZXh0ZW5kKHtcbiAgICBhcGlFcnJvclRpdGxlOiAnQ2h5YmnEjWthIHNlJm5ic3A7dmxvdWRpbGEnLFxuICAgIGFwaUVycm9yQm9keTogJ05hxaFlIHNlcnZlcnkgb2Rtw610YWrDrSByZWFnb3ZhdC4gSmnFviBueW7DrSB2eW5ha2zDoWTDoW1lIHZlxaFrZXLDqSDDunNpbMOtLCBhYnljaG9tIGplIHDFmWl2ZWRsaSBrIHJvenVtdS4gWmt1c3RlIGFrY2kgb3Bha292YXQgemEgbsSba29saWsgbWludXQuJyxcbiAgICB3ZV9oYXZlX25vdCA6ICdPIHRvbXRvIG3DrXN0xJsgemF0w61tIG5lbcOhbWUgaW5mb3JtYWNlJyxcbiAgICBub25hbWUgOiAnQmV6IG7DoXp2dScsXG4gICAgJ2FkbV9kaXYucGxhY2UnIDogJ03DrXN0bycsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nIDogJ1NwcsOhdm7DrSBvYnZvZCcsXG4gICAgJ2FkbV9kaXYuc2V0dGxlbWVudCcgOiAnT2JlYycsXG4gICAgc3RyZWV0IDogJ1VsaWNlJyxcbiAgICAnYWRtX2Rpdi5kaXN0cmljdCcgOiAnTcSbc3Rza8OhIMSNw6FzdCcsXG4gICAgJ2FkbV9kaXYuY2l0eScgOiAnTcSbc3RvJyxcbiAgICBnb190byA6ICdDZXN0YSBzZW0nLFxuICAgIHNob3dfb3JnYW5pemF0aW9uX2luX2J1aWxkaW5nIDogWydDZWxrZW0ge259IG9yZ2FuaXphY2UnLCAnQ2Vsa2VtIHtufSBvcmdhbml6YWNlJywgJ0NlbGtlbSB7bn0gb3JnYW5pemFjw60nXSxcbiAgICBiYWNrX2J1dHRvbiA6ICdacMSbdCcsXG4gICAgc2hvd19tb3JlX2Fib3V0X3NpZ2h0IDogJ1bDrWNlJyxcbiAgICBuX2Zsb29ycyA6IFsne259IHBhdHJvJywgJ3tufSBwYXRyYScsICd7bn0gcGF0ZXInXVxufSwgREcuRGljdGlvbmFyeS5jcyk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5EaWN0aW9uYXJ5LmVzID0gREcuZXh0ZW5kKHtcbiAgICBhcGlFcnJvclRpdGxlOiAnVmF5YSwgaGEgb2N1cnJpZG8gdW4gZXJyb3InLFxuICAgIGFwaUVycm9yQm9keTogJ051ZXN0cm9zIHNlcnZpZG9yZXMgc2UgbmllZ2FuIGEgcmVzcG9uZGVyLiBZYSBub3MgZXN0YW1vcyBlc2ZvcnphbmRvIHBvciBoYWNlcmxvcyBlbnRyYXIgZW4gcmF6w7NuLiBWdWVsdmEgY29uIG5vc290cm9zwqBwYXNhZG9zIHVub3MgbWludXRvcy4nLFxuICAgIHdlX2hhdmVfbm90IDogJ1RvZGF2w61hIG5vIGhlbW9zIHJlY29waWxhZG8gbGEgaW5mb3JtYWNpw7NuIHNvYnJlIGVzdGUgbHVnYXInLFxuICAgIG5vbmFtZSA6ICdTaW4gbm9tYnJlJyxcbiAgICAnYWRtX2Rpdi5wbGFjZScgOiAnTHVnYXInLFxuICAgICdhZG1fZGl2LmRpdmlzaW9uJyA6ICdDb211bmEnLFxuICAgICdhZG1fZGl2LnNldHRsZW1lbnQnIDogJ1BvYmxhY2nDs24nLFxuICAgIHN0cmVldCA6ICdDYWxsZScsXG4gICAgJ2FkbV9kaXYuZGlzdHJpY3QnIDogJ0NvbXVuYScsXG4gICAgJ2FkbV9kaXYuY2l0eScgOiAnQ2l1ZGFkJyxcbiAgICBnb190byA6ICdJciBwYXJhIGFsbMOhJyxcbiAgICBzaG93X29yZ2FuaXphdGlvbl9pbl9idWlsZGluZyA6IFsnVG90YWwge259IG9yZ2FuaXphY2nDs24nLCAnVG90YWwge259IG9yZ2FuaXphY2lvbmVzJywgJ1RvdGFsIHtufSBvcmdhbml6YWNpb25lcyddLFxuICAgIHNob3dfbW9yZV9hYm91dF9zaWdodCA6ICdSZWFkIG1vcmUnLFxuICAgIGJhY2tfYnV0dG9uOiAnQXRyw6FzJyxcbiAgICBuX2Zsb29ycyA6IFsne259IHBpc28nLCAne259IHBpc29zJ11cbn0sIERHLkRpY3Rpb25hcnkuZXMpO1xuIiwidmFyIEZpcm1DYXJkID0gZnVuY3Rpb24gKGZpcm0sIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0ID0ge307XG4gICAgdGhpcy5fc2NoZWR1bGUgPSBuZXcgRmlybUNhcmQuU2NoZWR1bGUoe1xuICAgICAgICBsb2NhbExhbmc6IHRoaXMub3B0aW9ucy5sYW5nLFxuICAgICAgICBkaWN0OiB0aGlzLmRpY3RcbiAgICB9KTtcblxuICAgIHRoaXMucmVuZGVyKGZpcm0pO1xufTtcblxuRmlybUNhcmQucHJvdG90eXBlID0ge1xuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoZmlybUlkKSB7XG4gICAgICAgIGlmICghZmlybUlkKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGlmIChmaXJtSWQgIT09IHRoaXMuX2Zpcm1JZCkge1xuICAgICAgICAgICAgdGhpcy5fZmlybUNvbnRlbnRPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNhcmRCeUlkKGZpcm1JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZmlybUNvbnRlbnRPYmplY3Q7XG4gICAgfSxcblxuICAgIGdldFNjaGVkdWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZTtcbiAgICB9LFxuXG4gICAgZ2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfSxcblxuICAgIF9yZW5kZXJDYXJkQnlJZDogZnVuY3Rpb24gKGZpcm1JZCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmFqYXgoZmlybUlkKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIGlmICghcmVzKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXMucmVzdWx0Lml0ZW1zO1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZmlybURhdGEgPSBkYXRhWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBmb3Igb2xkIFdlYkFQSSBmb3JtYXQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2FsbCBhZnRlciBXZWJBUEkgcmVsZWFzZVxuICAgICAgICAgICAgICAgIHNlbGYuX2NvbnZlcnRXZWJzaXRlKCk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLl9maXJtSWQgPSBmaXJtSWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVuZGVyRmlybUNhcmQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5fcmVuZGVyRXJyb3IoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9jcmVhdGVGaXJtQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaXJtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGZpcm0uc2V0QXR0cmlidXRlKCdpZCcsICdkZy1tYXAtZmlybS1mdWxsLScgKyB0aGlzLl9maXJtSWQpO1xuICAgICAgICBmaXJtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGctbWFwLWZpcm0tZnVsbCcpO1xuXG4gICAgICAgIHJldHVybiBmaXJtO1xuICAgIH0sXG5cbiAgICBfZ2V0UGF5bWVudFR5cGVzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBncm91cE5hbWUgPSAnZ2VuZXJhbF9wYXltZW50X3R5cGUnO1xuXG4gICAgICAgIGlmICghZGF0YS5hdHRyaWJ1dGVfZ3JvdXBzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5hdHRyaWJ1dGVfZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXAubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JvdXAuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIudGFnLnN1YnN0cmluZygwLCBncm91cE5hbWUubGVuZ3RoKSA9PT0gZ3JvdXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGF0dHIubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9ncm91cFJ1YnJpY3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBwcmltYXJ5OiBbXSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWw6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFkYXRhLnJ1YnJpY3MgfHwgIWRhdGEucnVicmljcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnJ1YnJpY3MuZm9yRWFjaChmdW5jdGlvbiAocnVicmljKSB7XG4gICAgICAgICAgICByZXN1bHRbcnVicmljLmtpbmRdLnB1c2gocnVicmljKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLy8gU3VwcG9ydCBmb3Igb2xkIFdlYkFQSSBmb3JtYXQuXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgV2ViQVBJIHJlbGVhc2VcbiAgICBfY29udmVydFdlYnNpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maXJtRGF0YS5jb250YWN0X2dyb3Vwcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmlybURhdGEuY29udGFjdF9ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGlmICghZ3JvdXAuY29udGFjdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmNvbnRhY3RzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdC50eXBlICE9ICd3ZWJzaXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWN0LnVybCkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWN0LnVybCA9IGNvbnRhY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyRmlybUNhcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpcm1DYXJkQm9keSwgc2NoZWR1bGUsIGZvcmVjYXN0LCBsaW5rcywgYnRucywgcGF5bWVudFR5cGVzLCBydWJyaWNzLFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2Zpcm1EYXRhLFxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5fY3JlYXRlRmlybUNvbnRhaW5lcigpO1xuXG4gICAgICAgIHNjaGVkdWxlID0gdGhpcy5fc2NoZWR1bGUudHJhbnNmb3JtKGRhdGEuc2NoZWR1bGUsIHtcbiAgICAgICAgICAgIHpvbmVPZmZzZXQ6IHRoaXMub3B0aW9ucy50aW1lem9uZU9mZnNldCxcbiAgICAgICAgICAgIGFwaUxhbmc6IHRoaXMub3B0aW9ucy5sYW5nLFxuICAgICAgICAgICAgbG9jYWxMYW5nOiB0aGlzLm9wdGlvbnMubGFuZ1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3JlY2FzdCA9IHRoaXMuX3NjaGVkdWxlLmZvcmVjYXN0KHNjaGVkdWxlKTtcblxuICAgICAgICBwYXltZW50VHlwZXMgPSB0aGlzLl9nZXRQYXltZW50VHlwZXMoZGF0YSk7XG4gICAgICAgIHJ1YnJpY3MgPSB0aGlzLl9ncm91cFJ1YnJpY3MoZGF0YSk7XG5cbiAgICAgICAgZmlybUNhcmRCb2R5ID0gdGhpcy5fYnVpbGRGaXJtQ2FyZEJvZHkoXG4gICAgICAgICAgICB0aGlzLl9nZXRDb25maWdGaXJtQ2FyZEJvZHkoZGF0YSwgc2NoZWR1bGUsIGZvcmVjYXN0LCBwYXltZW50VHlwZXMsIHJ1YnJpY3MpXG4gICAgICAgICk7XG5cbiAgICAgICAgbGlua3MgPSB0aGlzLl9maWxsSGVhZGVyTGlua3MoKTtcbiAgICAgICAgYnRucyA9IHRoaXMuX2ZpbGxGb290ZXJCdXR0b25zKCk7XG5cbiAgICAgICAgLy9maWxsIG9iamVjdCBmb3IgdmlldyByZW5kZXJcbiAgICAgICAgdGhpcy5fZmlybUNvbnRlbnRPYmplY3QuaGVhZGVyID0gdGhpcy5vcHRpb25zLnJlbmRlcignZmlybUNhcmRIZWFkZXInLCB7J2Zpcm1OYW1lJzogZGF0YS5uYW1lLCAnbGlua3MnOiBsaW5rc30pO1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gZmlybUNhcmRCb2R5O1xuICAgICAgICB0aGlzLl9maXJtQ29udGVudE9iamVjdC50bXBsID0gY29udGFpbmVyO1xuICAgICAgICBpZiAoYnRucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zvb3RlckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICB0aGlzLl9mb290ZXJDb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnJlbmRlcigncG9wdXBGb290ZXJCdG5zJywgeydidG5zJzogYnRuc30pO1xuICAgICAgICAgICAgdGhpcy5fZmlybUNvbnRlbnRPYmplY3QuZm9vdGVyID0gdGhpcy5fZm9vdGVyQ29udGFpbmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkZpcm1SZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRmlybVJlYWR5KHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVuZGVyRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9maXJtQ29udGVudE9iamVjdC5oZWFkZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyKCdwb3B1cEhlYWRlcicsIHtcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLm9wdGlvbnMudCgnYXBpRXJyb3JUaXRsZScpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0LnRtcGwgPSB0aGlzLm9wdGlvbnMudCgnYXBpRXJyb3JCb2R5Jyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkZpcm1SZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRmlybVJlYWR5KHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0Q29uZmlnRmlybUNhcmRCb2R5OiBmdW5jdGlvbiAoZGF0YSwgc2NoZWR1bGUsIGZvcmVjYXN0LCBhdHRyaWJ1dGVzLCBydWJyaWNzKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG1wbDogJ2Zpcm1DYXJkQWRkcicsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBkYXRhLmFkZHJlc3NfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudDogZGF0YS5hZGRyZXNzX2NvbW1lbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRtcGw6ICdmaXJtQ2FyZENvbnRhY3RzJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwczogZGF0YS5jb250YWN0X2dyb3Vwc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG1wbDogJ2Zpcm1DYXJkU2NoZWR1bGUnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGU6IHNjaGVkdWxlLFxuICAgICAgICAgICAgICAgICAgICBmb3JlY2FzdDogZm9yZWNhc3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRtcGw6ICdmcmltQ2FyZFBheW1lbnRzJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHBheW1lbnRzOiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bXBsOiAnZmlybUNhcmRSdWJyaWMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcnVicmljczogcnVicmljc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgX2J1aWxkRmlybUNhcmRCb2R5OiBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChib2R5LCBpdGVtKSB7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IHNlbGYub3B0aW9ucy5yZW5kZXIoaXRlbS50bXBsLCBpdGVtLmRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGJvZHkgKyBodG1sO1xuICAgICAgICB9LCAnJyk7XG4gICAgfSxcblxuICAgIF9maWxsRm9vdGVyQnV0dG9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnRucyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja0J0bikge1xuICAgICAgICAgICAgYnRucy5wdXNoKHsgbmFtZTogJ2Zpcm0tY2FyZC1iYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmRpY3QudCh0aGlzLm9wdGlvbnMubGFuZywgJ2J0bkJhY2snKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93Um91dGVTZWFyY2gpIHtcbiAgICAgICAgICAgIGJ0bnMucHVzaCh7IG5hbWU6ICdnb3RvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmRpY3QudCh0aGlzLm9wdGlvbnMubGFuZywgJ2J0bkZpbmRXYXknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB0aGlzLm9wdGlvbnMuZ290b1VybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLl9maXJtRGF0YS5saW5rcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2Zpcm1EYXRhLmxpbmtzLmVudHJhbmNlcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93RW50cmFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBidG5zLnB1c2goeyBuYW1lOiAnc2hvdy1lbnRyYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5kaWN0LnQodGhpcy5vcHRpb25zLmxhbmcsICdidG5FbnRyYW5jZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnRucztcbiAgICB9LFxuXG4gICAgX2ZpbGxIZWFkZXJMaW5rczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlua3MgPSBbXSxcbiAgICAgICAgICAgIHJldmlld0RhdGEgPSB0aGlzLl9maXJtRGF0YS5yZXZpZXdzLFxuICAgICAgICAgICAgYm9va2xldCxcbiAgICAgICAgICAgIGxpbms7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Zpcm1EYXRhLmV4dGVybmFsX2NvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1EYXRhLmV4dGVybmFsX2NvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgZWwudHlwZSA9PSAnYm9va2xldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9va2xldCA9IGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldmlld0RhdGEgJiYgcmV2aWV3RGF0YS5pc19yZXZpZXdhYmxlKSB7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnZmxhbXBfc3RhcnMnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiByZXZpZXdEYXRhLnJhdGluZyAqIDIwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdmbGFtcF9yZXZpZXdzJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5kaWN0LnQodGhpcy5vcHRpb25zLmxhbmcsICdsaW5rUmV2aWV3cycsIHJldmlld0RhdGEucmV2aWV3X2NvdW50ID8gcmV2aWV3RGF0YS5yZXZpZXdfY291bnQgOiAwKSxcbiAgICAgICAgICAgICAgICBocmVmOiBGaXJtQ2FyZC5EYXRhSGVscGVyLmdldEZsYW1wVXJsKHRoaXMuX2Zpcm1JZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0cmlldmUgcGhvdG8gZGF0YSBmcm9tIGV4dGVybmFsIGNvbnRlbnQgYmxvY2tcbiAgICAgICAgdmFyIHBob3RvcztcbiAgICAgICAgdmFyIGV4dGVybmFsQ29udGVudCA9IHRoaXMuX2Zpcm1EYXRhLmV4dGVybmFsX2NvbnRlbnQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRlcm5hbENvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBleHRlcm5hbENvbnRlbnRbaV0udHlwZSA9PSAncGhvdG9fYWxidW0nICYmXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxDb250ZW50W2ldLnN1YnR5cGUgPT0gJ2NvbW1vbidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHBob3RvcyA9IGV4dGVybmFsQ29udGVudFtpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlzTW9iaWxlICYmIHBob3RvcyAmJiBwaG90b3MuY291bnQgJiYgdGhpcy5vcHRpb25zLnNob3dQaG90b3MpIHtcbiAgICAgICAgICAgIGxpbmsgPSBMLlV0aWwudGVtcGxhdGUoREcuY29uZmlnLnBob3Rvc0xpbmssIHtcbiAgICAgICAgICAgICAgICAnaWQnOiB0aGlzLl9maXJtSWQsXG4gICAgICAgICAgICAgICAgJ2RvbWFpbic6IHRoaXMub3B0aW9ucy5kb21haW5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsaW5rcy5wdXNoKHtuYW1lOiAncGhvdG9zJyxcbiAgICAgICAgICAgICAgICBocmVmOiBsaW5rLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmRpY3QudCh0aGlzLm9wdGlvbnMubGFuZywgJ2xpbmtQaG90bycsIHBob3Rvcy5jb3VudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNNb2JpbGUgJiYgYm9va2xldCAmJiBib29rbGV0LnVybCAmJiB0aGlzLm9wdGlvbnMuc2hvd0Jvb2tsZXQpIHtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdib29rbGV0JyxcbiAgICAgICAgICAgICAgICBocmVmOiAgYm9va2xldC51cmwsXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZGljdC50KHRoaXMub3B0aW9ucy5sYW5nLCAnbGlua0Jvb2tsZXQnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBsaW5rcztcbiAgICB9LFxuXG4gICAgX2V2ZW50czoge1xuICAgICAgICAnZGctcG9wdXBfX2J1dHRvbl9uYW1lX2Zpcm0tY2FyZC1iYWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYmFja0J0bigpO1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2RnLXBvcHVwX19idXR0b25fbmFtZV9zaG93LWVudHJhbmNlJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZW50ID0gbmV3IHRoaXMub3B0aW9ucy5zaG93RW50cmFuY2Uoeyd2ZWN0b3JzJzogdGhpcy5fZmlybURhdGEubGlua3MuZW50cmFuY2VzWzBdLmdlb21ldHJ5LnZlY3RvcnN9KTtcbiAgICAgICAgICAgIGVudC5hZGRUbyh0aGlzLm9wdGlvbnMubWFwKTtcbiAgICAgICAgICAgIGVudC5maXRCb3VuZHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50SGFuZGxlcnModHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgICdkZy1zY2hlZHVsZV9fdG9kYXknOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX29uVG9nZ2xlU2NoZWR1bGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdG9nZ2xlRXZlbnRIYW5kbGVyczogZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvcHVwW2ZsYWcgPyAnb2ZmJyA6ICdvbiddKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMubWFwW2ZsYWcgPyAnb2ZmJyA6ICdvbiddKCdwb3B1cGNsb3NlJywgdGhpcy5fb25DbG9zZSwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS5vcmlnaW5hbEV2ZW50LnRhcmdldDtcblxuICAgICAgICBmb3IgKHZhciBldmVudENsYXNzIGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudENsYXNzKSAmJiB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoZXZlbnRDbGFzcykgPiAtMSkge1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50Q2xhc3NdLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uQ2xvc2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50SGFuZGxlcnModHJ1ZSk7XG4gICAgfSxcblxuICAgIF9vblRvZ2dsZVNjaGVkdWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY2hlZHVsZSA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZGctc2NoZWR1bGVfX3RhYmxlJyksXG4gICAgICAgICAgICBmb3JlY2FzdCA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZGctc2NoZWR1bGVfX25vdycpLFxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5kZy1zY2hlZHVsZV9fdG9kYXknKSxcbiAgICAgICAgICAgIHNob3dDbGFzcyA9ICcgZGctc2NoZWR1bGVfX3RvZGF5X3Nob3duX3RydWUnO1xuXG4gICAgICAgIGlmICghc2NoZWR1bGUpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKHNjaGVkdWxlLnN0eWxlLmRpc3BsYXkgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBmb3JlY2FzdC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRhcmdldC5jbGFzc05hbWUgPSB0YXJnZXQuY2xhc3NOYW1lLnJlcGxhY2Uoc2hvd0NsYXNzLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JlY2FzdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgc2NoZWR1bGUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NOYW1lICs9IHNob3dDbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Ub2dnbGUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uLFxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucy5sYW5nID0gb3B0aW9ucy5sYW5nIHx8ICdydSc7XG5cbiAgICAgICAgZm9yIChvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9oYXNUb3VjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8XG4gICAgICAgICAgICAgICAgKG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDApIHx8XG4gICAgICAgICAgICAgICAgKG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzID4gMCkpO1xuICAgIH1cbn07XG4iLCJGaXJtQ2FyZC5EYXRhSGVscGVyID0ge1xuXHRwYXlNZXRob2RzIDogW1xuXHRcdCdhbWVyaWNhbmV4cHJlc3MnLFxuXHRcdCdjYXNoJyxcblx0XHQnZGluZXJzY2x1YicsXG5cdFx0J2dvbGRjcm93bicsXG5cdFx0J2ludGVybmV0Jyxcblx0XHQnbWFzdGVyY2FyZCcsXG5cdFx0J25vbmNhc2gnLFxuXHRcdCd2aXNhJ1xuXHRdLFxuXG5cdF9tc2dzIDoge30sXG5cblx0Z2V0RmxhbXBVcmwgOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHJldHVybiBERy5jb25maWcuZmxhbXBVcmwuY29uY2F0KGlkLCAnPycsIERHLmNvbmZpZy5mbGFtcEdvb2dsZUFuYWx5dGljcyk7XG5cdH0sXG5cblx0bXNnIDogZnVuY3Rpb24gKG1zZykge1xuXHRcdGlmICh0aGlzLl9tc2dzLmhhc093blByb3BlcnR5KG1zZykpIHtcblx0XHRcdHJldHVybiB0aGlzLl9tc2dzW21zZ107XG5cdFx0fVxuXHRcdGNvbnNvbGUgJiYgY29uc29sZS5sb2coXCJDYW50J3QgZmluZCB0cmFuc2xhdGlvbiBmb3IgJ1wiICsgbXNnICsgXCInLlwiKTtcblx0XHRyZXR1cm4gbXNnLnRvU3RyaW5nKCkucmVwbGFjZSgnXycsICcgJyk7XG5cdH0sXG5cblx0Z2V0UHJvamVjdFRpbWU6IGZ1bmN0aW9uICh0aW1lem9uZU9mZnNldCwgdGltZSkge1xuICAgICAgICB2YXIgbm93LCB1dGM7XG5cbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIG5vdyA9IG5ldyBEYXRlKHRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lem9uZU9mZnNldCkge1xuICAgICAgICAgICAgdXRjID0gbm93LmdldFRpbWUoKSArIChub3cuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh1dGMgKyAoNjAwMDAgKiB0aW1lem9uZU9mZnNldCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vdztcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKiBnbG9iYWxcbiAgICBGaXJtQ2FyZDogZmFsc2VcbiovXG4oZnVuY3Rpb24gKCkge1xuICAgIEZpcm1DYXJkLkxpc3QgPSBmdW5jdGlvbiAoZmlybXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fZmlybXMgPSB7fTsgLy8geydmaXJtSUQnOiBmaXJtRG9tT2JqfVxuICAgICAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGctYnVpbGRpbmctY2FsbG91dF9fbGlzdCcpO1xuXG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnNJbml0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmlybUNhcmQgPSB0aGlzLl9jcmVhdGVGaXJtKCk7XG4gICAgICAgIHRoaXMucmVuZGVyTGlzdChmaXJtcyk7XG4gICAgfTtcblxuICAgIEZpcm1DYXJkLkxpc3QucHJvdG90eXBlID0ge1xuXG4gICAgICAgIHJlbmRlckxpc3Q6IGZ1bmN0aW9uIChmaXJtcykge1xuICAgICAgICAgICAgaWYgKGZpcm1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlybXMoZmlybXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkxpc3RSZWFkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkxpc3RSZWFkeSh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9wcm9jZXNzRmlybXM6IGZ1bmN0aW9uIChmaXJtcywgYWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWZpcm1zKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9ICdfJyArIGFjdGlvbiArICdGaXJtJztcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0FycmF5KGZpcm1zKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZmlybXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kXShmaXJtc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZF0oZmlybXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkRmlybXM6IGZ1bmN0aW9uKGZpcm1zKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzRmlybXMoZmlybXMsICdhZGQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVGaXJtczogZnVuY3Rpb24oZmlybXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NGaXJtcyhmaXJtcywgJ3JlbW92ZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldExhbmc6IGZ1bmN0aW9uIChuZXdMYW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlybUNhcmQubGFuZyA9IG5ld0xhbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGFuZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5sYW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckxpc3QgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJtcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyQ29udGFpbmVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbW92ZUZpcm06IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9maXJtc1tpZF0pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZmlybXNbaWRdKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9maXJtc1tpZF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZEZpcm06IGZ1bmN0aW9uIChmaXJtRGF0YSkge1xuICAgICAgICAgICAgdmFyIHRtcGwgPSB0aGlzLm9wdGlvbnMuZmlybWxpc3RJdGVtVG1wbCxcbiAgICAgICAgICAgICAgICBkb21GaXJtLCBmaXJtLCBjb250ZW50O1xuXG4gICAgICAgICAgICBmaXJtID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpcm1EYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgaWQ6IGZpcm1EYXRhLmlkLnNwbGl0KCdfJykuc2xpY2UoMCwgMSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghKGZpcm0uaWQgaW4gdGhpcy5fZmlybXMpKSB7XG5cbiAgICAgICAgICAgICAgICBkb21GaXJtID0gdGhpcy5fY3JlYXRlTGlzdEl0ZW0oKTtcblxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0bXBsID8gdGhpcy5vcHRpb25zLmZpcm1DYXJkLnJlbmRlcih0bXBsLCB7J2Zpcm0nOiBmaXJtfSkgOiBmaXJtLm5hbWU7XG5cbiAgICAgICAgICAgICAgICBkb21GaXJtLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgY29udGVudCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9maXJtc1tmaXJtLmlkXSA9IGRvbUZpcm07XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbUZpcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVMaXN0SXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2RnLWJ1aWxkaW5nLWNhbGxvdXRfX2xpc3QtaXRlbScpO1xuXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaXNBcnJheTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgICAgfSxcblxuICAgICAgICBfY3JlYXRlRmlybTogZnVuY3Rpb24gKGZpcm1EYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpcm1DYXJkKGZpcm1EYXRhLCB0aGlzLm9wdGlvbnMuZmlybUNhcmQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pc0VtcHR5T2JqOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2V2ZW50czoge1xuICAgICAgICAgICAgJ2RnLXBvcHVwX19saW5rJzogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9maXJtQ2FyZC5yZW5kZXIodGFyZ2V0LmlkKTtcblxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZFt0aGlzLl9pc0VtcHR5T2JqKHMpID8gJ3Bhc3RlTG9hZGVyJyA6ICdvbkZpcm1SZWFkeSddKHMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpcm1DYXJkLm9uRmlybUNsaWNrICYmIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5vbkZpcm1DbGljaygpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGctYnVpbGRpbmctY2FsbG91dF9fbGlzdC1pdGVtJzogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzWydkZy1wb3B1cF9fbGluayddLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGctcG9wdXBfX2J1dHRvbl9uYW1lX2JhY2snOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlybUNhcmQub25TaG93TGVzcygpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfdG9nZ2xlRXZlbnRIYW5kbGVycyA6IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlybUNhcmQucG9wdXBbZmxhZyA/ICdvZmYnIDogJ29uJ10oJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS5vcmlnaW5hbEV2ZW50LnRhcmdldDtcblxuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRDbGFzcyBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50Q2xhc3MpICYmIHRhcmdldC5jbGFzc05hbWUuaW5kZXhPZihldmVudENsYXNzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudENsYXNzXS5jYWxsKHRoaXMsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFyQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG4gICAgICAgICAgICB3aGlsZSAoY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZCB8fCAodGhpcy5vcHRpb25zLmZpcm1DYXJkID0ge30pO1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZmlybUNhcmQubGFuZykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5sYW5nID0gJ3J1JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuIiwiLypnbG9iYWxcbiAgICBGaXJtQ2FyZDpmYWxzZVxuKi9cbkZpcm1DYXJkLlNjaGVkdWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMubG9jYWxMYW5nID0gb3B0aW9ucy5sb2NhbExhbmcgfHwgJ3J1JztcbiAgICB0aGlzLmRpY3QgPSBvcHRpb25zLmRpY3Q7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5GaXJtQ2FyZC5TY2hlZHVsZS5wcm90b3R5cGUgPSB7XG5cbiAgICBzZXRMYW5nOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICB0aGlzLmxvY2FsTGFuZyA9IGxhbmcgfHwgJ3J1JztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKG1vZGVsLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgICAgICBmdW5jdGlvbiBiaW5kKGZuLCBvYmopIHsgLy8gKEZ1bmN0aW9uLCBPYmplY3QpIC0+IEZ1bmN0aW9uXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MgfHwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9kYXlLZXksIC8vIE1vbiwgVHVlIC4uLlxuICAgICAgICAgICAgdG9kYXksIC8vINCe0LHRitC10LrRgiDQvNC+0LTQtdC70LggLSDRgtC10LrRg9GJ0LjQuSDQtNC10L3RjCDQvdC10LTQtdC70LhcbiAgICAgICAgICAgIGZyb20sIC8vINCh0LDQvNC+0LUg0YDQsNC90L3QtdC1INCy0YDQtdC80Y8g0L7RgtC60YDRi9GC0LjRjyDQt9CwINC00LXQvdGMXG4gICAgICAgICAgICB0bywgLy8g0KHQsNC80L7QtSDQv9C+0LfQtNC90LXQtSDQstGA0LXQvNGPINC30LDQutGA0YvRgtC40Y8g0LfQsCDQtNC10L3RjFxuICAgICAgICAgICAgem9uZU9mZnNldCA9IHBhcmFtcy56b25lT2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBzY2hlZHVsZSA9IHt9LCAvLyDQntCx0YrQtdC60YIt0YDQsNGB0L/QuNGB0LDQvdC40LUsINGE0L7RgNC80LjRgNGD0LXQvNGL0Lkg0L/QvtC0INGI0LDQsdC70L7QvVxuICAgICAgICAgICAgbm93ID0gcGFyYW1zLm5vdyB8fCBGaXJtQ2FyZC5EYXRhSGVscGVyLmdldFByb2plY3RUaW1lKHpvbmVPZmZzZXQpLmdldFRpbWUoKSwgLy8gQ3VycmVudCB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICB3ZWVrS2V5cyA9IFtdLCAvLyDQmtC70Y7Rh9C4INC00L3QtdC5INC90LXQtNC10LvQuCwg0L7Qv9GA0LXQtNC10LvRj9GO0YIg0L/QvtGA0Y/QtNC+0Log0LTQvdC10Lkg0Lgg0L/QtdGA0LLRi9C5INC00LXQvdGMINC90LXQtNC10LvQuC4gMCAtINC/0LXRgNCy0YvQuSDQtNC10L3RjCDQvdC10LTQtdC70Lgg0LIg0YDQtdCz0LjQvtC90LUgKNC90LUg0L7QsdGP0LfQsNGC0LXQu9GM0L3QviBNb24pXG4gICAgICAgICAgICB3ZWVrS2V5c0xvY2FsID0gW10sXG4gICAgICAgICAgICB3ZWVrRnVsbEtleXNMb2NhbCA9IFtdLFxuICAgICAgICAgICAgd2Vla0tleXNTaG9ydCA9ICBbICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCcsICdTdW4nIF0sXG4gICAgICAgICAgICB3ZWVrS2V5c0Z1bGwgPSBbJ21vbmRheScsJ3R1ZXNkYXknLCd3ZWRuZXNkYXknLCd0aHVyc2RheScsJ2ZyaWRheScsJ3NhdHVyZGF5Jywnc3VuZGF5J10sXG4gICAgICAgICAgICBsb2NhbExhbmcgPSBwYXJhbXMubG9jYWxMYW5nIHx8IHRoaXMubG9jYWxMYW5nLFxuICAgICAgICAgICAgbG9jYWxXb3JraW5nRGF5cyA9IHBhcmFtcy5sb2NhbFdvcmtpbmdEYXlzIHx8IFswLCAxLCAxLCAxLCAxLCAxLCAwXSxcbiAgICAgICAgICAgIGZpcnN0ZGF5T2Zmc2V0ID0gcGFyYW1zLmZpcnN0ZGF5T2Zmc2V0IHx8IDEsXG4gICAgICAgICAgICBtaW5Ib3Vyc1RvRGlzcGxheUNsb3N1cmUgPSBwYXJhbXMubWluSG91cnNUb0Rpc3BsYXlDbG9zdXJlIHx8IDQsXG4gICAgICAgICAgICB0ID0gYmluZCh0aGlzLmRpY3QudCwgdGhpcy5kaWN0KTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIGNhcGl0YWxpc2VGaXJzdExldHRlcihzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRIb3VycyhzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWludXRlcyhzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDMsIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JrQvtC90LLQtdGA0YLQsNGG0LjRjyDQstGA0LXQvNC10L3QvdC+0Lkg0YLQvtGH0LrQuCDRhNC+0YDQvNCw0YLQsCDQsNC/0Lgg0LIg0YTQvtGA0LzQsNGCINC+0YLQvtCx0YDQsNC20LXQvdC40Y8gKDI1OjAwIC0+IDAxOjAwKVxuICAgICAgICBmdW5jdGlvbiBmb3JtYXRUaW1lKHN0cikge1xuICAgICAgICAgICAgdmFyIGhvdXJzID0gK2dldEhvdXJzKHN0cikgJSAyNCArICcnO1xuXG4gICAgICAgICAgICBpZiAoaG91cnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaG91cnMgPSAnMCcgKyBob3VycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhvdXJzICsgJzonICsgZ2V0TWludXRlcyhzdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JrQvtC90LLQtdGA0YLQsNGG0LjRjyBpbnQg0YfQuNGB0LvQsCDQsiDQvdC+0LzQtdGAINC00L3RjyDQvdC10LTQtdC70LggKNC00LjQsNC/0LDQt9C+0L0gMC02KVxuICAgICAgICBmdW5jdGlvbiBkYXlOdW0obikge1xuICAgICAgICAgICAgcmV0dXJuIG4gJSA3O1xuICAgICAgICB9XG5cblxuICAgICAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgICAgIC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdGCINC/0L7RgdC70LXQtNC90LjQuSDRjdC70LXQvNC10L3RgiDQvNCw0YHRgdC40LLQsFxuICAgICAgICAvLyDQktC30Y/RgtC+INC40LcgVW5kZXJzY29yZS5qcyBodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jbGFzdFxuICAgICAgICBmdW5jdGlvbiBnZXRBcnJheUxhc3QoYXJyLCBuKSB7XG4gICAgICAgICAgICBpZiAoIGFyciA9PSBudWxsICkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgIGlmICggICBuID09IG51bGwgKSByZXR1cm4gYXJyWyBhcnIubGVuZ3RoIC0gMSBdO1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoIGFyciwgTWF0aC5tYXgoYXJyLmxlbmd0aCAtIG4gLCAwKSApO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyDQktGL0L/QvtC70L3Rj9C10YIg0LPQu9GD0LHQvtC60L7QtSDRgdGA0LDQstC90LXQvdC40LUg0L7QsdGK0LXQutGC0L7QslxuICAgICAgICAvLyDQktC30Y/RgtC+INC40LcgVW5kZXJzY29yZS5qcyBodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jaXNFcXVhbFxuICAgICAgICAvLyDQo9C/0YDQvtGJ0LXQvdC+INC00LvRjyDRgtC10YUg0YLRgNGR0YUg0YHRgNCw0LLQvdC10L3QuNC5LCDQutC+0YLQvtGA0YvQtSDQstGL0L/QvtC70L3Rj9GO0YLRgdGPINCyIFNoZWR1bGUuanNcbiAgICAgICAgZnVuY3Rpb24gaXNFcXVhbChvYmoxLCBvYmoyKSB7XG4gICAgICAgICAgICBpZiAoIG9iajEgPT09IG9iajIgKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICggISAoIG9iajEgaW5zdGFuY2VvZiBPYmplY3QgKSB8fCAhICggb2JqMiBpbnN0YW5jZW9mIE9iamVjdCApICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCBvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICggdmFyIHByb3AgaW4gb2JqMSApIHtcbiAgICAgICAgICAgICAgICBpZiAoICEgb2JqMS5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCAhIG9iajIuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIG9iajFbIHByb3AgXSA9PT0gb2JqMlsgcHJvcCBdICkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YoIG9iajFbIHByb3AgXSApICE9PSBcIm9iamVjdFwiICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICggISBpc0VxdWFsKCBvYmoxWyBwcm9wIF0sICBvYmoyWyBwcm9wIF0gKSApIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoIHByb3AgaW4gb2JqMiApIHtcbiAgICAgICAgICAgIGlmICggb2JqMi5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICYmICEgb2JqMS5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgICAgICAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgICAgICAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgICAgICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCA9IGFyZ3VtZW50c1syXSB8fCAxO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUoaWR4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByYW5nZVtpZHgrK10gPSBzdGFydDtcbiAgICAgICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8v0JfQsNC/0L7Qu9C90Y/QtdGCINGB0LLQvtC50YHRgtCy0LAg0L7QsdGK0LXQutGC0LAg0LfQvdCw0YfQtdC90LjRj9C80Lgg0L/QviDRg9C80L7Qu9GH0LDQvdC40Y5cbiAgICAgICAgLy/QktC30Y/RgtC+INC40LcgVW5kZXJzY29yZS5qcyBodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZGVmYXVsdHNcbiAgICAgICAgZnVuY3Rpb24gZmlsbERlZmF1bHRzKG9iaikge1xuICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpbcHJvcF0gPT09IHZvaWQgMCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICAvL9Ch0L7RgNGC0LjRgNGD0LXRgiDQt9C90LDRh9C10L3QuNGPINGB0L7Qs9C70LDRgdC90L4g0YEg0LjRgtC10YDQsNGC0L7RgNC+0LxcbiAgICAgICAgLy/QktC30Y/RgtC+INGBIFVuZGVyc2NvcmUuanMgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI3NvcnRCeVxuICAgICAgICBmdW5jdGlvbiBzb3J0Qnkob2JqLCBpdGVyYXRvcil7XG4gICAgICAgICAgICByZXR1cm4gcGx1Y2sob2JqLm1hcCggZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhOiBpdGVyYXRvci5jYWxsKHRoaXMsIHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgICAgICAgICAgICAgIH0pLCAndmFsdWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgICAgICAgZnVuY3Rpb24gcGx1Y2soYXJyLCBrZXkpe1xuICAgICAgICAgICAgdmFyIGksIHJ2ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBydltpXSA9IGFycltpXVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyDQn9GA0LXQvtCx0YDQsNC30L7QstCw0YLRjCDRgNCw0YHQv9C40YHQsNC90LjQtSDQvdCwINC00LXQvdGMINCyINGD0L/QvtGA0Y/QtNC+0YfQtdC90L3Ri9C5INC80LDRgdGB0LjQsiDQstGA0LXQvNC10L3QvdGL0YUg0L7RgtGB0LXRh9C10LogKHN0cmluZylcbiAgICAgICAgLy8g0KHQtdC50YfQsNGBINC/0L7Qu9Cw0LPQsNC10YLRgdGPLCDRh9GC0L4gQVBJINGD0LbQtSDQstGL0LTQsNGR0YIg0YHQvtGA0YLQuNGA0L7QstCw0L3QvdGL0Lkg0LzQsNGB0YHQuNCyXG4gICAgICAgIGZ1bmN0aW9uIGdldFNvcnRlZFRpbWVQb2ludHMoZGF5KSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW10sXG4gICAgICAgICAgICAgICAgZnJvbSwgdG8sXG4gICAgICAgICAgICAgICAgZGVsdGFIb3VycywgZGVsdGFNaW51dGVzO1xuXG4gICAgICAgICAgICBpZiAoIWRheSB8fCAhZGF5LndvcmtpbmdfaG91cnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGRheS53b3JraW5nX2hvdXJzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgICAgIGZyb20gPSBkYXkud29ya2luZ19ob3Vyc1tpXS5mcm9tO1xuICAgICAgICAgICAgICAgIHRvID0gZGF5LndvcmtpbmdfaG91cnNbaV0udG87XG5cbiAgICAgICAgICAgICAgICBkZWx0YUhvdXJzID0gZ2V0SG91cnModG8pIC0gZ2V0SG91cnMoZnJvbSk7XG4gICAgICAgICAgICAgICAgZGVsdGFNaW51dGVzID0gZ2V0TWludXRlcyh0bykgLSBnZXRNaW51dGVzKGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YUhvdXJzIDwgMCB8fCAoZGVsdGFIb3VycyA9PT0gMCAmJiBkZWx0YU1pbnV0ZXMgPD0gMCkpIHsgLy8g0JXRgdC70LggXCLQtNC+XCIg0LzQtdC90YzRiNC1INC40LvQuCDRgNCw0LLQvdC+IFwi0L7RglwiIC0g0LfQvdCw0YfQuNGCINGD0LrQsNC30YvQstCw0LXRgiDQvdCwINC30LDQstGC0YDQsFxuICAgICAgICAgICAgICAgICAgICB0byA9ICgrZ2V0SG91cnModG8pICsgMjQpICsgJzonICsgZ2V0TWludXRlcyh0byk7IC8vICgwMTowMCAtPiAyNTowMClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb2ludHNbaSAqIDJdID0ge1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb3BlbidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvaW50c1tpICogMiArIDFdID0ge1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiB0byxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZGF5LndvcmtpbmdfaG91cnMubGVuZ3RoIC0gMSA9PT0gaSA/ICdjbG9zZScgOiAnbHVuY2gnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdGCINC80LDRgdGB0LjQsiB0aW1lc3RhbXAg0LLRgdC10YUg0YLQvtGH0LXQuiwg0LLRgdC10YUg0LTQvdC10Lkg0L3QtdC00LXQu9C4LCDQvtGCINGB0LXQs9C+0LTQvdGP0YjQvdC10LPQviDQuCDQsiDQsdGD0LTRg9GJ0LXQtVxuICAgICAgICAvLyDQndCw0L/RgNC40LzQtdGALCDRgdC10LPQvtC00L3RjyDRgdGA0LXQtNCwLCDQvtGC0YHQtdGH0LrQuCDQsdGD0LTRg9GCINCy0LfRj9GC0Ysg0LTQu9GPINC00LDRgiDRgdC+INGB0YDQtdC00YsgKNGB0LXQs9C+0LTQvdGPKSDQv9C+INGB0LvQtdC00YPRjtGJ0LjQuSDQstGC0L7RgNC90LjQuiDQstC60LvRjtGH0LjRgtC10LvRjNC90L5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VGltZVN0YW1wcyhtb2RlbCkge1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcHMgPSBbXSxcbiAgICAgICAgICAgICAgICBvdXQgPSBbXSxcbiAgICAgICAgICAgICAgICB0aW1lUG9pbnRzLFxuICAgICAgICAgICAgICAgIG51bSA9IHdlZWtLZXlzLmluZGV4T2YodG9kYXlLZXkpOyAvLyDQndC+0LzQtdGAINGB0LXQs9C+0LTQvdGP0YjQvdC10LPQviDQtNC90Y8g0L3QtdC00LXQu9C4ICjQtNC70Y8g0LTQsNC90L3QvtCz0L4g0YDQtdCz0LjQvtC90LApXG5cblxuICAgICAgICAgICAgLy8g0KbQuNC60Lsg0L/QviDQtNC90Y/QvCDQvdC10LTQtdC70Lgg0L3QsNGH0LjQvdCw0Y8g0YEg0YHQtdCz0L7QtNC90Y/RiNC90LXQs9C+XG4gICAgICAgICAgICB2YXIgajsgLy8g0J3QvtC80LXRgCDRgtC10LrRg9GJ0LXQs9C+INC00L3RjyDQsiDQvNCw0YHRgdC40LLQtSB3ZWVrS2V5c1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgNyA7IGkrKykge1xuICAgICAgICAgICAgICAgIGogPSBkYXlOdW0obnVtICsgaSk7XG4gICAgICAgICAgICAgICAgdGltZVBvaW50cyA9IGdldFNvcnRlZFRpbWVQb2ludHMobW9kZWxbd2Vla0tleXNbal1dKTtcbiAgICAgICAgICAgICAgICAvLyDQptC40LrQuyDQv9C+INGC0L7Rh9C60LDQvCDQstGA0LXQvNC10L3QuCDRgSDQutC+0L3QstC10YDRgtCw0YbQuNC10Lkg0LIgdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgdGltZVBvaW50cy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwODMgKi9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyAtINC+0LHRj9C30LDRgtC10LvRjNC90L4hINC40L3QsNGH0LUg0LHRg9C00LXRgiDQsdGA0LDRgtGM0YHRjyDRgtC10LrRg9GJ0LjQuSB0aW1lc3RhbXAg0YfRgtC+INGH0YDQtdCy0LDRgtC+INC90LXRgdC+0LLQv9Cw0LTQtdC90LjRj9C80Lgg0L/RgNC4INC80LXQtNC70LXQvdC90L7QvCDQsdGL0YHRgtGA0L7QtNC10LnRgdGC0LLQuNC4XG4gICAgICAgICAgICAgICAgICAgIC8vINCS0YvRh9C40YHQu9C40YLRjCDRgtCw0LnQvNGB0YLQtdC80L8g0LTQu9GPINC00LDQvdC90L7Qs9C+INC00L3RjyDQvdC10LTQtdC70LgsINGH0LDRgdCwINC4INC80LjQvdGD0YLRiywg0LIg0LHRg9C00YPRidC10LwsINC90L4g0LHQu9C40LbQsNC50YjQuNC5INC6IG5vd1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHNwID0gbmV3IERhdGUobm93KTtcbiAgICAgICAgICAgICAgICAgICAgdHNwLnNldERhdGUodHNwLmdldERhdGUoKStpKTtcbiAgICAgICAgICAgICAgICAgICAgdHNwLnNldEhvdXJzKGdldEhvdXJzKHBvaW50LnRpbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgdHNwLnNldE1pbnV0ZXMoZ2V0TWludXRlcyhwb2ludC50aW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cyA9IHRzcC5nZXRUaW1lKCk7XG5cblxuXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0czogdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwb2ludC50eXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0gJiYgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDQn9Cw0YDQvdC+INGD0LTQsNC70Y/QtdC8INGB0L7QstC/0LDQtNCw0Y7RidC40LUg0YLQvtGH0LrQuCAo0L7QvdC4INC90LUg0LjQvNC10Y7RgiDRgdC80YvRgdC70LAgLSDRjdGC0L4g0YHQtdCz0L7QtNC90Y8gMjQ6MDAg0Lgg0LfQsNCy0YLRgNCwIDAwOjAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXS50cyA9PT0gdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdLnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSAmJiB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINCf0LDRgNC90L4g0L/QtdGA0LXQvdC+0YHQuNC8INGC0L7Rh9C60Lgg0LIg0LHRg9C00YPRidC10LUsINC10YHQu9C4INC+0L3QuCDQvtCx0LUg0LIg0L/RgNC+0YjQu9C+0LwgKNC/0LXRgNCy0LDRjyDRgtC+0YfQutCwIChbMF0pINC00L7Qu9C20L3QsCDQsdGL0YLRjCDQstGB0LXQs9C00LAg0L7RgtC60YDRi9GC0LjQtdC8ISlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0udHMgPD0gbm93ICYmIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXS50cyA8PSBub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0udHMgKz0gKDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0udHMgKz0gKDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgK1cwODMgKi9cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDQodC+0YDRgtC40YDRg9C10Lwg0L3QsCDQstC+0LfRgNCw0YHRgtCw0L3QuNC1LCDQstC10LTRjCDQstC+0LfQvNC+0LbQvdC+INCx0YvQu9C4INC/0LXRgNC10L3QvtGB0Ysg0LIg0LHRg9C00YPRidC10LVcbiAgICAgICAgICAgIHRpbWVzdGFtcHMgPSBzb3J0QnkodGltZXN0YW1wcywgZnVuY3Rpb24gKHRpbWVzdGFtcCkgeyByZXR1cm4gdGltZXN0YW1wLnRzOyB9KTtcblxuICAgICAgICAgICAgLy8g0KPQtNCw0LvRj9C10Lwg0L/QvtC/0LDRgNC90L4g0YHQvtCy0L/QsNC00LDRjtGJ0LjQtSDRgtC+0YfQutC4INCy0YDQtdC80LXQvdC4XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wc1tpICsgMV0gJiYgdGltZXN0YW1wc1tpXS50cyA9PT0gdGltZXN0YW1wc1tpICsgMV0udHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHRpbWVzdGFtcHNbaV0udHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vINCf0YDQvtCy0LXRgNC60LAg0L3QsCDQtdC20LXQtNC90LXQstC90L4t0LrRgNGD0LPQu9C+0YHRg9GC0L7Rh9C90L7RgdGC0YxcbiAgICAgICAgICAgIGlmIChvdXQubGVuZ3RoID09PSAyICYmIChvdXRbMV0gLSBvdXRbMF0pID09PSAoNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdoZW5PcGVuSW52ZXJzZShoLCBkLCBudW0pIHtcbiAgICAgICAgICAgIGlmIChkID09PSAxICYmIGggPiBtaW5Ib3Vyc1RvRGlzcGxheUNsb3N1cmUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQobG9jYWxMYW5nLCAndG9tbW9yb3cnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwMTUgKi9cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG51bSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiB0KGxvY2FsTGFuZywgJ25leHRTdW4nKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gdChsb2NhbExhbmcsICduZXh0TW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIHQobG9jYWxMYW5nLCAnbmV4dFR1ZScpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiB0KGxvY2FsTGFuZywgJ25leHRXZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gdChsb2NhbExhbmcsICduZXh0VGh1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHQobG9jYWxMYW5nLCAnbmV4dEZyaScpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiB0KGxvY2FsTGFuZywgJ25leHRTYXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyoganNoaW50ICtXMDE1ICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy/QktC+0LfQstGA0LDRidCw0LXRgiDQuNC90YLQtdGA0LLQsNC7INCyINGG0LXQu9GL0YUg0LTQvdGP0YUsINGBINC/0L7Qv9GA0LDQstC60L7QuSDQvdCwINGB0LzQtdC90YMg0LTQvdGPINCyINC/0L7Qu9C90L7Rh9GMLCDQvNC10LbQtNGDXG4gICAgICAgIC8vIEBwYXJhbSB0aW1lc3RhbXBFbmQg0LggQHBhcmFtIGRhdGVTdGFydFxuICAgICAgICBmdW5jdGlvbiBkYXlJbnRlcnZhbCh0aW1lc3RhbXBFbmQsIGRhdGVTdGFydCkge1xuXG4gICAgICAgICAgICB2YXIgb25lRGF5ID0gMTAwMCAqIDYwICogNjAgKiAyNCxcbiAgICAgICAgICAgICAgICBkYXRlRW5kID0gbmV3IERhdGUodGltZXN0YW1wRW5kLnRzKTtcblxuICAgICAgICAgICAgdmFyIGRpZmY7XG5cbiAgICAgICAgICAgIGRpZmYgPSBNYXRoLnJvdW5kKChkYXRlRW5kIC0gZGF0ZVN0YXJ0KSAvIG9uZURheSk7XG5cbiAgICAgICAgICAgIGlmKCB0aW1lc3RhbXBFbmQudHlwZT09PSdvcGVuJyAmJiBkYXRlRW5kLmdldEhvdXJzKCkgPCAxIClcbiAgICAgICAgICAgICAgICB7IGRpZmYgKys7IH1cblxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vINCf0L7QvNC10YHRgtC40YLRjCDQtNCw0L3QvdGL0LUg0LIg0L7QsdGK0LXQutGCINC00LvRjyDRiNCw0LHQu9C+0L3QsCDQviDRgdC10LPQvtC00L3Rj9GI0L3QtdC8INC00L3QtVxuICAgICAgICBmdW5jdGlvbiBzZXRUb2RheVN0cmluZyh0b2RheSkge1xuXG4gICAgICAgICAgICB2YXIgdGltZVBvaW50cyxcbiAgICAgICAgICAgICAgICBwZXJpb2RzID0gW10sXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wcztcblxuICAgICAgICAgICAgc2NoZWR1bGUubm93ID0ge307XG5cbiAgICAgICAgICAgIC8vIFRpbWVzdGFtcHMg0LLRgdC10YUg0L7RgtGB0LXRh9C10LpcbiAgICAgICAgICAgIHRpbWVzdGFtcHMgPSBnZXRUaW1lU3RhbXBzKG1vZGVsKTtcblxuICAgICAgICAgICAgaWYgKCF0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlLmFsd2F5cyA9IHRydWU7IC8vINCg0LDQsdC+0YLQsNC10YIg0LXQttC10LTQvdC10LLQvdC+INC60YDRg9Cz0LvQvtGB0YPRgtC+0YfQvdC+XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUubm93Lm9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHRpbWVzdGFtcHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8g0J/QvtC/0LDQu9C4INC80LXQttC00YMg0YLQvtGH0LrQsNC80LggaS0xINC4IGkgLy8g0JzRiyDQvdCw0YXQvtC00LjQvNGB0Y8g0LfQsNCy0LXQtNC+0LzQviDQsiDQsdGD0LTRg9GJ0LXQvCDQvtGC0L3QvtGB0LjRgtC10LvRjNC90L4gMVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gKHRpbWVzdGFtcHNbaSAtIDFdICYmIHRpbWVzdGFtcHNbaSAtIDFdLnRzIHx8IDApICYmIG5vdyA8IHRpbWVzdGFtcHNbaV0udHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBNYXRoLmZsb29yKCh0aW1lc3RhbXBzW2ldLnRzIC0gbm93KSAvICgxMDAwICogNjAgKiA2MCkpLCAvLyDQmtC+0LvQuNGH0LXRgdGC0LLQviDRh9Cw0YHQvtCyINC00L4g0YHQu9C10LTRg9GO0YnQtdCz0L4gdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gTWF0aC5mbG9vcigodGltZXN0YW1wc1tpXS50cyAtIG5vdykgLyAoMTAwMCAqIDYwKSAtIGggKiA2MCksIC8vINCa0L7Qu9C40YfQtdGB0YLQstC+INC80LjQvdGD0YIgKNCx0LXQtyDRh9Cw0YHQvtCyKSDQtNC+INGB0LvQtdC00YPRjtGJ0LXQs9C+IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5Tm93ID0gbmV3IERhdGUobm93KSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0L7RgtC60YDRi9GC0L4g0LXRgdC70Lgg0YHQu9C10LTRg9GO0YnQsNGPINC40YLQtdGA0LDRhtC40Y8g0L3QtSDQvtGC0LrRgNGL0YLQuNC1XG4gICAgICAgICAgICAgICAgICAgICAgICBub3dJc09wZW4gPSB0aW1lc3RhbXBzW2ldLnR5cGUgIT09ICdvcGVuJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgZCA9IGRheU9mWWVhcihkYXlUcykgLSBkYXlPZlllYXIoZGF5Tm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIGQgPSBkYXlJbnRlcnZhbChkYXlUcywgZGF5Tm93LCBub3dJc09wZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBkYXlJbnRlcnZhbCh0aW1lc3RhbXBzW2ldLCBkYXlOb3cpO1xuXG5cblxuICAgICAgICAgICAgICAgICAgICAvLyDQvtC60YDRg9Cz0LvRj9C10Lwg0LzQuNC90YPRgtGLINC00L4g0LrRgNCw0YLQvdGL0YUgNVxuICAgICAgICAgICAgICAgICAgICBtID0gTWF0aC5mbG9vcihtIC8gMTApICogMTAgPyBNYXRoLmZsb29yKG0gLyAxMCkgKiAxMCA6IDU7XG5cbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGUubm93Lm9wZW4gPSBub3dJc09wZW47XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlLm5vdy5sdW5jaCA9ICEhKHRpbWVzdGFtcHNbaSAtIDFdICYmIHRpbWVzdGFtcHNbaSAtIDFdLnR5cGUgPT09ICdsdW5jaCcgfHwgZ2V0QXJyYXlMYXN0KHRpbWVzdGFtcHMpLnR5cGUgPT09ICdsdW5jaCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlLndpbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWxsVHlwZTogdGltZXN0YW1wc1tpXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGg6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtOiBtXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8g0JrQvtCz0LTQsCDQt9Cw0LrRgNC+0LXRgtGB0Y8g0LjQu9C4INC+0YLQutGA0L7QtdGC0YHRj1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2lsbFdoZW4gPSBuZXcgRGF0ZSh0aW1lc3RhbXBzW2ldLnRzKTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGUud2lsbC53aGVuID0gd2hlbk9wZW5JbnZlcnNlKGgsIGQsIHdpbGxXaGVuLmdldERheSgpKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWxsVGlsbCA9IG5ldyBEYXRlKHRpbWVzdGFtcHNbaV0udHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RySG91cnMgPSB3aWxsVGlsbC5nZXRIb3VycygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyTWludXRlcyA9IHdpbGxUaWxsLmdldE1pbnV0ZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RySG91cnMgPCAxMCkgeyBzdHJIb3VycyA9ICcwJyArIHN0ckhvdXJzOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJNaW51dGVzIDwgMTApIHsgc3RyTWludXRlcyA9ICcwJyArIHN0ck1pbnV0ZXM7IH1cblxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZS53aWxsLnRpbGwgPSBzdHJIb3VycysnOicrc3RyTWludXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdG9kYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vINCd0LAg0YHQtdCz0L7QtNC90Y8g0YDQsNGB0L/QuNGB0LDQvdC40Y8g0L3QtdGCIC0g0YHQtdC50YfQsNGBINC30LDQutGA0YvRgtC+XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbWVQb2ludHMgPSBwbHVjayhnZXRTb3J0ZWRUaW1lUG9pbnRzKHRvZGF5KSwgJ3RpbWUnKTtcblxuICAgICAgICAgICAgLy8g0KbQuNC60Lsg0L/QviDQv9C10YDQuNC+0LTQsNC8INGA0LDQsdC+0YLRiyDQt9CwINC00LXQvdGMXG4gICAgICAgICAgICBmb3IgKGkgPSAyIDsgaSA8IHRpbWVQb2ludHMubGVuZ3RoIDsgaSA9IGkgKyAyKSB7XG4gICAgICAgICAgICAgICAgcGVyaW9kcy5wdXNoKHsgZnJvbTogdGltZVBvaW50c1tpIC0gMV0sIHRvOiB0aW1lUG9pbnRzW2ldIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcm9tID0gZm9ybWF0VGltZSh0aW1lUG9pbnRzWzBdKTtcbiAgICAgICAgICAgIHRvID0gZm9ybWF0VGltZSh0aW1lUG9pbnRzW3RpbWVQb2ludHMubGVuZ3RoIC0gMV0pO1xuXG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHsgLy8g0JrRgNGD0LPQu9C+0YHRg9GC0L7Rh9C90L5cbiAgICAgICAgICAgICAgICBzY2hlZHVsZS50b2RheSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWxsdGltZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsdGltZVN0cjogdChsb2NhbExhbmcsICd3b3Jrc0Fyb3VuZFRoZUNsb2NrJyksXG4gICAgICAgICAgICAgICAgICAgIGZyb206ICcwMDowMCcsXG4gICAgICAgICAgICAgICAgICAgIHRvOiAnMjQ6MDAnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vINCe0YIgZnJvbSDQtNC+IHRvXG4gICAgICAgICAgICAgICAgc2NoZWR1bGUudG9kYXkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0b1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwZXJpb2RzLmxlbmd0aCA+IDApIHsgLy8g0J/QtdGA0LXRgNGL0LLRiyDQvdCwINC+0LHQtdC0XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUubHVuY2ggPSBwZXJpb2RzO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlLmx1bmNoU3RyID0gdChsb2NhbExhbmcsICdsdW5jaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g0KTQvtGA0LzQuNGA0L7QstCw0L3QuNC1INC+0LHRitC10LrRgtCwLdGC0LDQsdC70LjRhtGLLdGA0LDRgdC/0LjRgdCw0L3QuNGPINC00LvRjyDRiNCw0LHQu9C+0L3QsFxuICAgICAgICBmdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gW10sXG4gICAgICAgICAgICAgICAgaGFzTHVuY2ggPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAgOyBqIDwgNyA7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBkYXlLZXkgPSB3ZWVrS2V5c1tqXSxcbiAgICAgICAgICAgICAgICAgICAgbHVuY2hNYXhMZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgY29sdW1uW2pdID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAobW9kZWxbZGF5S2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF5ID0gbW9kZWxbZGF5S2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVQb2ludHMgPSBwbHVjayhnZXRTb3J0ZWRUaW1lUG9pbnRzKGRheSksICd0aW1lJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBsdW5jaCA9IFtdOyAvLyDQntGC0YDQtdC30LrQuCDQstGA0LXQvNC10L3QuCAo0L7RgtGB0L7RgNGC0LjRgNC+0LLQsNC90L3Ri9C1INC80L7QvNC10L3RgtGLKSDQvdCwINC+0LHQtdC00YtcblxuICAgICAgICAgICAgICAgICAgICAvLyDQptC40LrQuyDQv9C+INC/0LXRgNC40L7QtNCw0Lwg0YDQsNCx0L7RgtGLINC30LAg0LTQtdC90YxcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDIgOyBpIDwgdGltZVBvaW50cy5sZW5ndGggOyBpID0gaSArIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0x1bmNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx1bmNoLnB1c2goeyBmcm9tOiB0aW1lUG9pbnRzW2kgLSAxXSwgdG86IHRpbWVQb2ludHNbaV0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbHVuY2hNYXhMZW5ndGggPSBNYXRoLm1heCh0aW1lUG9pbnRzLmxlbmd0aCAvIDIsIGx1bmNoTWF4TGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5bal0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBmb3JtYXRUaW1lKHRpbWVQb2ludHNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGZvcm1hdFRpbWUodGltZVBvaW50c1t0aW1lUG9pbnRzLmxlbmd0aCAtIDFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGx1bmNoOiBsdW5jaFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXlLZXkgPT09IHRvZGF5S2V5KSB7IC8vINCh0LXQs9C+0LTQvdGP0YjQvdC40Lkg0LTQtdC90Ywg0L3QsNC00L4g0L/QvtC00YHQstC10YLQuNGC0YxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uW2pdLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29sdW1uW2pdLmtleSA9IHdlZWtLZXlzTG9jYWxbal07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vINCU0L7Qv9C+0LvQvdC10L3QuNC1INC/0YPRgdGC0YvQvNC4INC+0LHRitC10LrRgtCw0LzQuCDQvNCw0YHRgdC40LLQvtCyIGx1bmNoXG4gICAgICAgICAgICBjb2x1bW4uZm9yRWFjaCggZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2wubHVuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbERlZmF1bHRzKGNvbC5sdW5jaCwgcmFuZ2UoMSwgbHVuY2hNYXhMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWJsZTogY29sdW1uLFxuICAgICAgICAgICAgICAgIGhhc0x1bmNoOiBoYXNMdW5jaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCh0LPQtdC90LXRgNC40YDQvtCy0LDRgtGMINGB0YLRgNC+0LrRgyDQtNC70Y8g0LLRgdC10YUg0LTQvdC10LkgbW9kZWwsINGB0L7QstC/0LDQtNCw0Y7RidC40YUg0YEgZGF5XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VTaW1wbGVTdHJpbmcoZGF5LCBtb2RlbCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyxcbiAgICAgICAgICAgICAgICBvdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRheUxpc3Q6IFtdLFxuICAgICAgICAgICAgICAgICAgICBsdW5jaDogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGx1bmNoZXNUaW1lID0gW107XG5cbiAgICAgICAgICAgIGlmIChkYXkgJiYgZGF5LndvcmtpbmdfaG91cnMgJiYgZGF5LndvcmtpbmdfaG91cnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gcGx1Y2soZ2V0U29ydGVkVGltZVBvaW50cyhkYXkpLCAndGltZScpO1xuICAgICAgICAgICAgICAgIHBvaW50cy5mb3JFYWNoKCBmdW5jdGlvbiAocG9pbnQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuZnJvbSA9IGZvcm1hdFRpbWUocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC50byA9IGZvcm1hdFRpbWUocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbHVuY2hlc1RpbWUucHVzaChmb3JtYXRUaW1lKHBvaW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGx1bmNoZXNUaW1lLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5sdW5jaC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGx1bmNoZXNUaW1lW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGx1bmNoZXNUaW1lW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGx1bmNoU3RyOiBjYXBpdGFsaXNlRmlyc3RMZXR0ZXIodChsb2NhbExhbmcsICdsdW5jaCcpKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3V0LmZyb20gPT0gJzAwOjAwJyAmJiBvdXQudG8gPT0gJzAwOjAwJykge1xuICAgICAgICAgICAgICAgICAgICBvdXQudG8gPSAnMjQ6MDAnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXkucm91bmRfdGhlX2Nsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5hbGx0aW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmFsbHRpbWVTdHIgPSB0KGxvY2FsTGFuZywgJ3dvcmtzQXJvdW5kVGhlQ2xvY2snKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyDQktGL0YXQvtC00L3QvtC5XG4gICAgICAgICAgICAgICAgb3V0LmhvbGlkYXkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDQpNC+0YDQvNC40YDRg9C10Lwg0YHQv9C40YHQvtC6INC00L3QtdC5INC90LAg0LvQvtC60LDQu9GM0L3QvtC8INGP0LfRi9C60LVcbiAgICAgICAgICAgIHZhciBncm91cFdvcmtpbmdEYXlzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDBdOyAvLyDQpNC70LDQs9C4INGA0LDQsdC+0YLRiyDRhNC40YDQvNGLINCyINC00L3QuCDRgtC10LrRg9GJ0LXQuSDQs9GA0YPQv9C/0YtcbiAgICAgICAgICAgIHZhciBmbG93ID0gMDtcblxuICAgICAgICAgICAgd2Vla0tleXMuZm9yRWFjaCggZnVuY3Rpb24gKGRheUtleSwgbnVtS2V5KSB7IC8vICdNb24nLCAwXG4gICAgICAgICAgICAgICAgaWYgKGlzRXF1YWwobW9kZWxbZGF5S2V5XSwgZGF5KSB8fCAoIW1vZGVsW2RheUtleV0gJiYgZGF5ID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQuZGF5TGlzdC5wdXNoKHdlZWtGdWxsS2V5c0xvY2FsW251bUtleV0pO1xuICAgICAgICAgICAgICAgICAgICBncm91cFdvcmtpbmdEYXlzW2RheU51bShudW1LZXkgKyBmaXJzdGRheU9mZnNldCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZmxvdysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbG93ID4gMikgeyAvLyDQkdC+0LvQtdC1IDIg0LTQvdC10Lkg0L/QvtC00YDRj9C0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdERheSA9IG91dC5kYXlMaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSA7IGkgPCBmbG93IC0gMSA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5kYXlMaXN0LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuZGF5TGlzdFtvdXQuZGF5TGlzdC5sZW5ndGggLSAxXSArPSAnIOKAlCAnICsgbGFzdERheTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZsb3cgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyDQodC/0LjRgdC+0Log0LTQvdC10Lkg0LIg0LTQsNC90L3QvtC5INCz0YDRg9C/0L/QtSDQuNC00LXQvdGC0LjRh9C10L0g0YHQv9C40YHQutGDINCx0YPQtNC90LjRhSDQtNC90LXQuSwg0LfQvdCw0YfQuNGCINC80L7QttC90L4g0LfQsNC80LXQvdC40YLRjCDRgdC70L7QstC+0LwgXCLQkdGD0LTQvdC4XCJcbiAgICAgICAgICAgIG91dC5idWRuaSA9IGlzRXF1YWwobG9jYWxXb3JraW5nRGF5cywgZ3JvdXBXb3JraW5nRGF5cyk7XG4gICAgICAgICAgICAvLyDQodC/0LjRgdC+0Log0YDQsNCx0L7Rh9C40YUg0LTQvdC10LkgLSDQstGB0LUg0LTQvdC4INC90LXQtNC10LvQuCwg0LfQvdCw0YfQuNGCINC90YPQttC90L4g0LLRi9Cy0L7QtNC40YLRjCDRhNGA0LDQt9GDIFwi0JXQttC10LTQvdC10LLQvdC+XCJcbiAgICAgICAgICAgIG91dC5ldmVyeWRheSA9ICggTWF0aC5taW4uYXBwbHkoTWF0aCwgZ3JvdXBXb3JraW5nRGF5cykgPT09IDEgKTtcblxuICAgICAgICAgICAgaWYgKCBvdXQuaG9saWRheSApIHsgb3V0LmhvbGlkYXlTdHIgPSB0KGxvY2FsTGFuZywgJ3Jlc3REYXknLCBvdXQuZGF5TGlzdC5sZW5ndGgpLnNsaWNlKDIpOyB9XG5cbiAgICAgICAgICAgIC8vINCU0LXQu9Cw0LXQvCDQuNC3INC80LDRgdGB0LjQstCwINGB0YLRgNC+0LrRgyDQuCDQv9C+0LTQvdC40LzQsNC10Lwg0L/QtdGA0LLRi9C5INGB0LjQvNCy0L7Qu1xuICAgICAgICAgICAgb3V0LmRheUxpc3QgPSBvdXQuZGF5TGlzdC5qb2luKCcsICcpO1xuICAgICAgICAgICAgb3V0LmRheUxpc3QgPSBvdXQuZGF5TGlzdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG91dC5kYXlMaXN0LnNsaWNlKDEpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQktC+0LfQstGA0LDRidCw0LXRgiDQvNCw0YHRgdC40LIgc2ltcGxlINGB0YLRgNC+0Log0L3QsCDQvtGB0L3QvtCy0LUg0LzQsNGB0YHQuNCy0LAg0LTQvdC10LkgZGF5c1xuICAgICAgICBmdW5jdGlvbiBtYWtlQWR2YW5jZWRTdHJpbmcoZGF5cywgbW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRheXMubGVuZ3RoIC0gMSA7IGkgPj0gMCA7IGktLSkge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKG1ha2VTaW1wbGVTdHJpbmcoZGF5c1tpXSwgbW9kZWwpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCX0LDQv9C+0LvQvdGP0LXQvCDQvdCw0LfQstCw0L3QuNGPINC00L3QtdC5INC90LXQtNC10LvQuCwgMSAtINC/0L7QvdC10LTQtdC70YzQvdC40LouINCSINC30LDQv9C+0LvQvdC10L3QvdGL0YUg0LzQsNGB0YHQuNCy0LDRhSDQv9C+0L3QtdC00LXQu9GM0L3QuNC6INGN0YLQviAwXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgNyA7IGkrKykge1xuICAgICAgICAgICAgd2Vla0tleXNbaV0gPSB3ZWVrS2V5c1Nob3J0W2ldO1xuICAgICAgICAgICAgd2Vla0tleXNMb2NhbFtpXSA9IHRoaXMuZGljdC50KGxvY2FsTGFuZywgd2Vla0tleXNTaG9ydFtpXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIHdlZWtGdWxsS2V5c0xvY2FsW2ldID0gdGhpcy5kaWN0LnQobG9jYWxMYW5nLCB3ZWVrS2V5c0Z1bGxbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JLRi9GH0LjRgdC70Y/QtdC8INGB0LXQs9C+0LTQvdGP0YjQvdC40Lkg0LTQtdC90Ywg0L3QtdC00LXQu9C4ICjRgdGB0YvQu9C60YMg0L3QsCDQvtCx0YrQtdC60YIg0LTQvdGPINCyINC80L7QtNC10LvQuClcbiAgICAgICAgdG9kYXlLZXkgPSB3ZWVrS2V5c1Nob3J0WyhuZXcgRGF0ZShub3cpLmdldERheSgpLWZpcnN0ZGF5T2Zmc2V0KSAlIDddO1xuICAgICAgICB0b2RheSA9IG1vZGVsW3RvZGF5S2V5XTsgLy8g0J7QsdGK0LXQutGCINGA0LDRgdC/0LjRgdCw0L3QuNGPIC0g0YLQtdC60YPRidC40Lkg0LTQtdC90Ywg0L3QtdC00LXQu9C4XG4gICAgICAgIHNldFRvZGF5U3RyaW5nKHRvZGF5KTsgLy8g0KHQtNC10LvQsNGC0Ywg0L7QsdGK0LXQutGCINC00LvRjyDRiNCw0LHQu9C+0L3QsCAtINGB0YLRgNC+0LrQsCwg0LrQvtGC0L7RgNCw0Y8g0L7Qv9C40YHRi9Cy0LDQtdGCINCy0YDQtdC80Y8g0YDQsNCx0L7RgtGLINGB0LXQs9C+0LTQvdGPXG5cbiAgICAgICAgLy8g0J3QsNGF0L7QtNC40Lwg0LrQvtC70LjRh9C10YHRgtCy0L4g0YDQsNC30L3Ri9GFINGA0LDRgdC/0LjRgdCw0L3QuNC5INC4INGB0L7RhdGA0LDQvdGP0LXQvCDQuNGFINCyINC80LDRgdGB0LjQslxuICAgICAgICB2YXIgYXBpRGlmZmVyZW50RGF5cyA9IFtdLCAvLyDQnNCw0YHRgdC40LIg0YDQsNC30LvQuNGH0LDRjtGJ0LjRhdGB0Y8g0LTQvdC10Lkg0LjQtyDQvNC+0LTQtdC70LhcbiAgICAgICAgICAgIGFwaVNjaGVkdWxlRGF5c0NvdW50ID0gMCwgLy8g0JrQvtC70LjRh9C10YHRgtCy0L4g0L7Qv9C40YHQsNC90L3Ri9GFINC00L3QtdC5INCyINGA0LDRgdC/0LjRgdCw0L3QuNC4INC80L7QtNC10LvQuFxuICAgICAgICAgICAgYXBpRGlmZmVyZW50RGF5c0NvdW50ID0gMCwgLy8g0JrQvtC70LjRh9C10YHRgtCy0L4g0YDQsNC30L3Ri9GFINC00L3QtdC5INCyINGA0LDRgdC/0LjRgdCw0L3QuNC4INC80L7QtNC10LvQuFxuICAgICAgICAgICAgZGlmZmVyZW50V29ya2luZ0hvdXJzQ291bnQgPSBbXTsgLy8g0JrQvtC70LjRh9C10YHRgtCy0L4g0YDQsNCx0L7Rh9C40YUg0YfQsNGB0L7QsiDQsiDRgNCw0LfQvdGL0YUg0LTQvdGP0YVcblxuICAgICAgICBPYmplY3Qua2V5cyhtb2RlbCkuZm9yRWFjaCggZnVuY3Rpb24oZGF5KSB7XG4gICAgICAgICAgICBpZiAobW9kZWxbZGF5XSAmJiBtb2RlbFtkYXldLndvcmtpbmdfaG91cnMpIHsgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8INGH0YLQviDRjdGC0L4g0LTQtdC90YwsINCwINC90LUg0LrQvtC80LzQtdC90YLQsNGA0LjQuSDQuNC70Lgg0YfRgtC+LdGC0L4g0LXRidGRXG4gICAgICAgICAgICAgICAgYXBpU2NoZWR1bGVEYXlzQ291bnQrKztcbiAgICAgICAgICAgICAgICBpZiAoIWlzRXF1YWwobW9kZWxbZGF5XSwgZ2V0QXJyYXlMYXN0KGFwaURpZmZlcmVudERheXMpKSkge1xuICAgICAgICAgICAgICAgICAgICBhcGlEaWZmZXJlbnREYXlzLnB1c2gobW9kZWxbZGF5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhcGlEaWZmZXJlbnREYXlzQ291bnQgPSBhcGlEaWZmZXJlbnREYXlzLmxlbmd0aDtcbiAgICAgICAgLy8g0JXRgdC70Lgg0L3QtSDQstGB0LUg0LTQvdC4INC+0L/QuNGB0LDQvdGLINCyINC80L7QtNC10LvQuCwg0LfQvdCw0YfQuNGCINC10YHRgtGMINC10YnRkSDQvtC00LjQvSDRgtC40L8g0LTQvdC10LkgLSDQstGL0YXQvtC00L3QvtC5ICjQvtGC0YHRg9GC0YHRgtCy0YPRidC40Lkg0LIg0LzQvtC00LXQu9C4KVxuICAgICAgICBpZiAoYXBpU2NoZWR1bGVEYXlzQ291bnQgPCA3KSB7XG4gICAgICAgICAgICBhcGlEaWZmZXJlbnREYXlzQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCV0YHQu9C4INGA0LDQt9C90YvRhSDQsdC+0LvQtdC1IDIsINGC0L4g0YPQv9GA0L7RgdGC0LjRgtGMINC90LUg0L/QvtC70YPRh9C40YLRgdGPIC0g0LTQtdC70LDQtdC8INGC0LDQsdC70LjRhtGDXG4gICAgICAgIGlmIChhcGlEaWZmZXJlbnREYXlzQ291bnQgPiAyKSB7XG4gICAgICAgICAgICBzY2hlZHVsZS53ZWVrID0gbWFrZVRhYmxlKG1vZGVsKTtcbiAgICAgICAgfSBlbHNlIHsgLy8g0JjQvdCw0YfQtSwg0YHQvtGB0YLQsNCy0LvRj9C10Lwg0LrQvtC80LzQtdC90YLQsNGA0LjQuSDQuNC3INC00LLRg9GFINGB0YLRgNC+0LpcblxuICAgICAgICAgICAgLy8g0KHQu9GD0YfQsNC5LCDQutC+0LPQtNCwINCy0YHQtSDQvtC00LjQvdCw0LrQvtCy0YvQtVxuICAgICAgICAgICAgaWYgKGFwaURpZmZlcmVudERheXNDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlLndlZWsgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50bHk6IFttYWtlU2ltcGxlU3RyaW5nKG1vZGVsW3dlZWtLZXlzWzBdXSwgbW9kZWwpXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyDQntGB0YLQsNGR0YLRgdGPINGB0LvRg9GH0LDQuSwg0LrQvtCz0LTQsCDQtdGB0YLRjCDQtNCy0LAg0YLQuNC/0LAg0LTQvdC10LlcbiAgICAgICAgICAgICAgICAvLyDQntC/0YDQtdC00LXQu9GP0LXQvCDQtNC10L3RjCDRgSDQvdCw0LjQsdC+0LvRjNGI0LjQvCDQutC+0LvQuNGH0LXRgdGC0LLQvtC8INGA0LDQsdC+0YfQuNGFINGH0LDRgdC+0LIg0LjQtyDRh9C40YHQu9CwINGA0LDQt9C90YvRhSDQtNC90LXQuVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAgOyBpIDwgYXBpRGlmZmVyZW50RGF5c0NvdW50IDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZlcmVudFdvcmtpbmdIb3Vyc0NvdW50W2ldID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXBpRGlmZmVyZW50RGF5c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHBsdWNrKGdldFNvcnRlZFRpbWVQb2ludHMoYXBpRGlmZmVyZW50RGF5c1tpXSksICd0aW1lJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwIDsgaiA8IHBvaW50cy5sZW5ndGggOyBqID0gaiArIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG91cnMgPSAoZ2V0SG91cnMocG9pbnRzW2ogKyAxXSkgKyBnZXRNaW51dGVzKHBvaW50c1tqICsgMV0pIC8gNjApIC0gKGdldEhvdXJzKHBvaW50c1tqXSkgKyBnZXRNaW51dGVzKHBvaW50c1tqXSkgLyA2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW50V29ya2luZ0hvdXJzQ291bnRbaV0gKz0gaG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vINCS0YvRhdC+0LTQvdC+0LlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaURpZmZlcmVudERheXNbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGFwaVNvcnRlZERpZmZlcmVudERheXMgPSBzb3J0QnkoYXBpRGlmZmVyZW50RGF5cywgZnVuY3Rpb24gKGRheSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWZmZXJlbnRXb3JraW5nSG91cnNDb3VudFtrZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc2NoZWR1bGUud2VlayA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRseTogbWFrZUFkdmFuY2VkU3RyaW5nKGFwaVNvcnRlZERpZmZlcmVudERheXMsIG1vZGVsKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlZHVsZS5jb21tZW50ID0gbW9kZWwuY29tbWVudDtcbiAgICAgICAgaWYgKHNjaGVkdWxlLndlZWsgJiYgc2NoZWR1bGUud2Vlay5ldmVudGx5ICYmIHNjaGVkdWxlLndlZWsuZXZlbnRseS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlLmV2ZXJ5ZGF5ID0gc2NoZWR1bGUud2Vlay5ldmVudGx5WzBdLmV2ZXJ5ZGF5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlZHVsZTtcbiAgICB9LFxuXG4gICAgZm9yZWNhc3Q6IGZ1bmN0aW9uIChzY2hlZHVsZSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9ICcnLFxuICAgICAgICBvcGVuLFxuICAgICAgICB0b2RheSA9IHt9LFxuICAgICAgICBub3dUZXh0LFxuICAgICAgICBtYXhIb3VycyA9IHBhcmFtcyAmJiBwYXJhbXMubWF4SG91cnMgfHwgMTtcblxuICAgICAgICBpZiAoIXNjaGVkdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NoZWR1bGUuYWx3YXlzKSB7IC8vINCa0YDRg9Cz0LvQvtGB0YPRgtC+0YfQvdC+INC10LbQtdC00L3QtdCy0L3QviAtINCx0L7Qu9C10LUg0L3QuNGH0LXQs9C+INCy0YvQstC+0LTQuNGC0Ywg0L3QtSDQvdGD0LbQvdC+XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvZGF5OiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnYXJvdW5kVGhlQ2xvY2snKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3BlbjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCk0L7RgNC80LjRgNGD0LXQvCDRgdGC0YDQvtC60YMgLSDRh9C10YDQtdC3INGB0LrQvtC70YzQutC+INC/0YDQvtC40LfQvtC50LTRkdGCINGB0LvQtdC00YPRjtGJ0LDRjyDQuNC90LLQtdGA0YHQuNGPINC+0YLQutGA0YvRgtC+0YHRgtC4XG4gICAgICAgIGlmIChzY2hlZHVsZS53aWxsICYmIHNjaGVkdWxlLndpbGwuaCA8IG1heEhvdXJzKSB7XG4gICAgICAgICAgICBpZiAoc2NoZWR1bGUud2lsbC5oKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgKz0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICduSG91cnMnLCBzY2hlZHVsZS53aWxsLmgpICsgJyAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZWR1bGUud2lsbC5tKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgKz0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICduTWlucycsIHNjaGVkdWxlLndpbGwubSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQlNCw0L3QvdGL0LUg0L3QsCDRgdC10LPQvtC00L3Rj1xuICAgICAgICBpZiAoc2NoZWR1bGUudG9kYXkpIHtcbiAgICAgICAgICAgIHRvZGF5LnRleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ3RvZGF5Jyk7XG4gICAgICAgICAgICBpZiAoc2NoZWR1bGUuZXZlcnlkYXkpIHtcbiAgICAgICAgICAgICAgICB0b2RheS50ZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdldmVyeWRheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9kYXkuZnJvbSA9IHNjaGVkdWxlLnRvZGF5LmZyb207XG4gICAgICAgICAgICB0b2RheS50byA9IHNjaGVkdWxlLnRvZGF5LnRvO1xuICAgICAgICAgICAgdG9kYXkubHVuY2ggPSBzY2hlZHVsZS5sdW5jaDtcbiAgICAgICAgICAgIGlmICh0b2RheS5sdW5jaCkge1xuICAgICAgICAgICAgICAgIHRvZGF5Lmx1bmNoU3RyID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdsdW5jaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9kYXkudGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAndG9kYXlJc1Jlc3REYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCi0LXQutGD0YnQuNC5INGB0YLQsNGC0YPRgSDQuCDQv9GA0L7Qs9C90L7Qt1xuICAgICAgICBpZiAoc2NoZWR1bGUuYWx3YXlzKSB7IC8vINCV0YHQu9C4INC60YDRg9Cz0LvQvtGB0YPRgtC+0YfQvdC+LCDQvdC40YfQtdCz0L4g0LrRgNC+0LzQtSBcItCa0YDRg9Cz0LvQvtGB0YPRgtC+0YfQvdC+XCIg0LLRi9Cy0L7QtNC40YLRjCDQvdC1INC90YPQttC90L5cbiAgICAgICAgICAgIHRvZGF5LnRleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ2Fyb3VuZFRoZUNsb2NrJyk7XG4gICAgICAgICAgICBvcGVuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2hlZHVsZS5ub3cpIHtcbiAgICAgICAgICAgIG9wZW4gPSBzY2hlZHVsZS5ub3cub3BlbjtcbiAgICAgICAgICAgIGlmIChvcGVuKSB7IC8vINC+0YLQutGA0YvRgtC+XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwgJiYgc2NoZWR1bGUud2lsbC53aWxsVHlwZSA9PT0gJ2x1bmNoJykge1xuICAgICAgICAgICAgICAgICAgICAvLyDQtNCw0LvQtdC1IC0g0LfQsNC60YDRi9GC0LjQtSDQvdCwINC+0LHQtdC0XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZS53aWxsICYmIHNjaGVkdWxlLndpbGwuaCA8IG1heEhvdXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDQvNC10L3QtdC1IG1heEhvdXJzINC00L4g0LfQsNC60YDRi9GC0LjRjyAg0L3QsCDQvtCx0LXQtFxuICAgICAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnX2luJykgKyAnICcgKyB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ25NaW5zJywgaW50ZXJ2YWwpICsgdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdpc0Nsb3NpbmdPbkRpbm5lcicpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LHQvtC70YzRiNC1IG1heEhvdXJzINC00L4g0LfQsNC60YDRi9GC0LjRjyAg0L3QsCDQvtCx0LXQtFxuICAgICAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnaXNPcGVuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vINC00LDQu9C10LUg0L/RgNC+0YHRgtC+INC30LDQutGA0YvRgtC40LVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwuaCA8IG1heEhvdXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDQvNC10L3QtdC1IG1heEhvdXJzINC00L4g0LfQsNC60YDRi9GC0LjRjyDQv9GA0L7RgdGC0L5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ2Nsb3NlSW4nKSArIHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnbk1pbnMnLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDQsdC+0LvRjNGI0LUgbWF4SG91cnMg0LTQviDQt9Cw0LrRgNGL0YLQuNGPINC/0YDQvtGB0YLQvlxuICAgICAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnaXNPcGVuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyDQt9Cw0LrRgNGL0YLQvlxuICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZS53aWxsICYmIHNjaGVkdWxlLndpbGwud2hlbikge1xuICAgICAgICAgICAgICAgICAgICAvLyDQvtGC0LrRgNC+0LXRgtGB0Y8g0L3QtSDRgdC10LPQvtC00L3Rj1xuICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdvcGVuJykgKyBzY2hlZHVsZS53aWxsLndoZW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g0L7RgtC60YDQvtC10YLRgdGPINGB0LXQs9C+0LTQvdGPXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZS5ub3cgJiYgc2NoZWR1bGUubm93Lmx1bmNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDRgdC10LnRh9Cw0YEg0L7QsdC10LRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZS53aWxsLmggPCBtYXhIb3Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vINC80LXQvdC10LUgbWF4SG91cnMg0LTQviDQvtGC0LrRgNGL0YLQuNGPINGBINC+0LHQtdC00LBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdMdW5jaCcpICsgdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdvcGVuSW4nKSArIHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnbk1pbnMnLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vINCx0L7Qu9GM0YjQtSBtYXhIb3VycyDQtNC+INC+0YLQutGA0YvRgtC40Y8g0YEg0L7QsdC10LTQsFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ0x1bmNoJykgKyB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ29wZW5BdCcpICsgc2NoZWR1bGUud2lsbC50aWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0L/RgNC+0YHRgtC+INC30LDQutGA0YvRgtC+XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGUud2lsbCAmJiBzY2hlZHVsZS53aWxsLmggPCBtYXhIb3Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vINC80LXQvdC10LUgbWF4SG91cnMg0LTQviDQvtGC0LrRgNGL0YLQuNGPINC/0YDQvtGB0YLQvlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ29wZW5JbicpICsgdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICduTWlucycsIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LHQvtC70YzRiNC1IG1heEhvdXJzINC00L4g0L7RgtC60YDRi9GC0LjRjyDQv9GA0L7RgdGC0L5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdvcGVuQXQnKSArIHNjaGVkdWxlLndpbGwudGlsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2RheTogdG9kYXksXG4gICAgICAgICAgICBub3c6IG5vd1RleHQsXG4gICAgICAgICAgICBvcGVuOiBvcGVuLFxuICAgICAgICAgICAgd2Vlazogc2NoZWR1bGUud2VlayxcbiAgICAgICAgICAgIGNvbW1lbnQ6IHNjaGVkdWxlLmNvbW1lbnQsXG4gICAgICAgICAgICBldmVyeWRheTogc2NoZWR1bGUuZXZlcnlkYXlcbiAgICAgICAgfTtcbiAgICB9XG59O1xuIiwiLypnbG9iYWxcbiAgICBGaXJtQ2FyZDpmYWxzZVxuKi9cbi8vIEZpcm1DYXJkLmRpY3Rpb25hcnkgPSB7fTtcblxuRmlybUNhcmQucHJvdG90eXBlLmRpY3QgPSB7XG5cbiAgICB0OiBmdW5jdGlvbiAobGFuZywgbXNnLCBhcmd1bWVudCkgeyAvLyAoU3RyaW5nLCBOdW1iZXIpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgbXNnSXNzZXQgPSBmYWxzZSxcbiAgICAgICAgICAgIGRpY3Rpb25hcnlNc2csXG4gICAgICAgICAgICBleHA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2xhbmddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGFuZyA9ICdydSc7XG4gICAgICAgIH1cbiAgICAgICAgZGljdGlvbmFyeU1zZyA9IHRoaXNbbGFuZ11bbXNnXTtcbiAgICAgICAgbXNnSXNzZXQgPSB0eXBlb2YgZGljdGlvbmFyeU1zZyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghbXNnSXNzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbXNnSXNzZXQgPyBkaWN0aW9uYXJ5TXNnIDogbXNnO1xuXG4gICAgICAgIGlmIChhcmd1bWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlSW50KGFyZ3VtZW50LCAxMCk7XG4gICAgICAgICAgICBhcmd1bWVudCA9IGlzTmFOKGFyZ3VtZW50KSA/IDAgOiBhcmd1bWVudDtcbiAgICAgICAgICAgIGV4cCA9IHRoaXNbbGFuZ10ucGx1cmFsUnVsZXMoYXJndW1lbnQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnQgKyAnICcgKyBkaWN0aW9uYXJ5TXNnW2V4cF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdCA6IG1zZztcbiAgICB9LFxuXG4gICAgcnU6IHtcbiAgICAgICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uIChuKSB7IC8vIChOdW1iZXIpXG4gICAgICAgICAgICBpZiAobiAlIDEwID09PSAxICYmIG4gJSAxMDAgIT09IDExKSB7IC8vIDEsIDIxXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmIChuICUgMTApICUgMSA9PT0gMCkgJiYgKG4gJSAxMDAgPCAxMiB8fCBuICUgMTAwID4gMTQpKSB7IC8vIDIsIDNcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChuICUgMTAgPT09IDApIHx8IChuICUgMTAgPj0gNSAmJiBuICUgMTAgPD0gOSAmJiAobiAlIDEwKSAlIDEgPT09IDApIHx8IChuICUgMTAwID49IDExICYmIChuICUgMTAwKSA8PSAxNCAmJiAobiAlIDEwMCkgJSAxID09PSAwKSkgeyAvLyAxMywgMTdcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBidG5CYWNrOiAn0J3QsNC30LDQtCcsXG4gICAgICAgIGJ0bkZpbmRXYXk6ICfQn9GA0L7QtdGF0LDRgtGMINGB0Y7QtNCwJyxcbiAgICAgICAgYnRuRW50cmFuY2U6ICfQndCw0LnRgtC4INCy0YXQvtC0JyxcbiAgICAgICAgbGlua1Jldmlld3M6IFsn0L7RgtC30YvQsicsICfQvtGC0LfRi9Cy0LAnLCAn0L7RgtC30YvQstC+0LInXSxcbiAgICAgICAgbGlua1Bob3RvOiBbJ9GE0L7RgtC+JywgJ9GE0L7RgtC+JywgJ9GE0L7RgtC+J10sXG4gICAgICAgIGxpbmtCb29rbGV0OiAn0JHRg9C60LvQtdGCJyxcbiAgICAgICAgdG9tbW9yb3c6ICfQt9Cw0LLRgtGA0LAnLFxuICAgICAgICBhZnRlclRvbW1vcm93OiAn0L/QvtGB0LvQtdC30LDQstGC0YDQsCcsXG4gICAgICAgIGFmdGVyV2VlazogJ9GH0LXRgNC10Lcg0L3QtdC00LXQu9GOJyxcbiAgICAgICAgbmV4dFN1bjogJ9CyINCy0L7RgdC60YDQtdGB0LXQvdGM0LUnLFxuICAgICAgICBuZXh0TW9uOiAn0LIg0L/QvtC90LXQtNC10LvRjNC90LjQuicsXG4gICAgICAgIG5leHRUdWU6ICfQstC+INCy0YLQvtGA0L3QuNC6JyxcbiAgICAgICAgbmV4dFdlZDogJ9CyINGB0YDQtdC00YMnLFxuICAgICAgICBuZXh0VGh1OiAn0LIg0YfQtdGC0LLQtdGA0LMnLFxuICAgICAgICBuZXh0RnJpOiAn0LIg0L/Rj9GC0L3QuNGG0YMnLFxuICAgICAgICBuZXh0U2F0OiAn0LIg0YHRg9Cx0LHQvtGC0YMnLFxuICAgICAgICB3aWxsT3BlbjogJ9C+0YLQutGA0L7QtdGC0YHRjycsXG4gICAgICAgIHdpbGxDbG9zZTogJ9C30LDQutGA0L7QtdGC0YHRjycsXG4gICAgICAgIGlzT3BlbjogJ9Ce0YLQutGA0YvRgtC+JyxcbiAgICAgICAgb3BlblRpbGw6ICfQntGC0LrRgNGL0YLQviDQtNC+ICcsXG4gICAgICAgIGNsb3NlSW46ICfQl9Cw0LrRgNC+0LXRgtGB0Y8g0YfQtdGA0LXQtyAnLFxuICAgICAgICBvcGVuQXQ6ICfQntGC0LrRgNC+0LXRgtGB0Y8g0LIgJyxcbiAgICAgICAgb3BlbkluOiAn0J7RgtC60YDQvtC10YLRgdGPINGH0LXRgNC10LcgJyxcbiAgICAgICAgb3BlbjogJ9Ce0YLQutGA0L7QtdGC0YHRjyAnLFxuICAgICAgICBuSG91cnM6IFsn0YfQsNGBJywgJ9GH0LDRgdCwJywgJ9GH0LDRgdC+0LInXSxcbiAgICAgICAgbk1pbnM6IFsn0LzQuNC90YPRgtGDJywgJ9C80LjQvdGD0YLRiycsICfQvNC40L3Rg9GCJ10sXG4gICAgICAgIGx1bmNoOiAn0L7QsdC10LQnLFxuICAgICAgICBMdW5jaDogJ9Ce0LHQtdC0LiAnLFxuICAgICAgICB3b3JraW5nRGF5czogJ9Cg0LDQsdC+0YfQuNC1INC00L3QuCcsXG4gICAgICAgIHdlZWtkYXlzOiAn0JHRg9C00L3QuNC1INC00L3QuCcsXG4gICAgICAgIHJlc3REYXk6IFsn0LLRi9GF0L7QtNC90L7QuScsICfQstGL0YXQvtC00L3Ri9C1Jywn0LLRi9GF0L7QtNC90YvQtSddLFxuICAgICAgICByZXZpZXdzT25GbGFtcDogJ9Ce0YLQt9GL0LLRiyDQvdCwINCk0LvQsNC80L/QtScsXG4gICAgICAgIHdyaXRlUmV2aWV3T25GbGFtcDogJ9Cd0LDQv9C40YHQsNGC0Ywg0L7RgtC30YvQsiDQvdCwINCk0LvQsNC80L/QtScsXG4gICAgICAgIHBheW1lbnQ6ICfQvtC/0LvQsNGC0LAnLFxuICAgICAgICBldmVyeWRheTogJ9CV0LbQtdC00L3QtdCy0L3QviBjJyxcbiAgICAgICAgd29ya3NBcm91bmRUaGVDbG9jazogJ9Cg0LDQsdC+0YLQsNC10YIg0LrRgNGD0LPQu9C+0YHRg9GC0L7Rh9C90L4nLFxuICAgICAgICBhcm91bmRUaGVDbG9jazogJ9Ca0YDRg9Cz0LvQvtGB0YPRgtC+0YfQvdC+JyxcbiAgICAgICAga25vd01vcmU6ICfRg9C30L3QsNGC0Ywg0LHQvtC70YzRiNC1JyxcbiAgICAgICAgdG9DbG9zZTogJ9C00L4g0LfQsNC60YDRi9GC0LjRjycsXG4gICAgICAgIG1vbmRheTogJ9C/0L7QvdC10LTQtdC70YzQvdC40LonLFxuICAgICAgICB0dWVzZGF5OiAn0LLRgtC+0YDQvdC40LonLFxuICAgICAgICB3ZWRuZXNkYXk6ICfRgdGA0LXQtNCwJyxcbiAgICAgICAgdGh1cnNkYXk6ICfRh9C10YLQstC10YDQsycsXG4gICAgICAgIGZyaWRheTogJ9C/0Y/RgtC90LjRhtCwJyxcbiAgICAgICAgc2F0dXJkYXk6ICfRgdGD0LHQsdC+0YLQsCcsXG4gICAgICAgIHN1bmRheTogJ9Cy0L7RgdC60YDQtdGB0LXQvdGM0LUnLFxuICAgICAgICBtb246ICfQv9C+0L0nLFxuICAgICAgICB0dWU6ICfQstGC0YAnLFxuICAgICAgICB3ZWQ6ICfRgdGA0LQnLFxuICAgICAgICB0aHU6ICfRh9GC0LInLFxuICAgICAgICBmcmk6ICfQv9GC0L0nLFxuICAgICAgICBzYXQ6ICfRgdCx0YInLFxuICAgICAgICBzdW46ICfQstGB0LonLFxuICAgICAgICB0b0x1bmNoOiAn0LTQviDQvtCx0LXQtNCwJyxcbiAgICAgICAgdG9kYXk6ICfQodC10LPQvtC00L3RjycsXG4gICAgICAgIGxlc3NUaGVuSG91cjogJ9C80LXQvdC10LUg0YfQsNGB0LAnLFxuICAgICAgICB5b3VDb3VsZExhdGU6ICfQstGLINC80L7QttC10YLQtSDQvdC1INGD0YHQv9C10YLRjCcsXG4gICAgICAgIHdvcmtpbmdUaW1lOiAn0YDQsNCx0L7Rh9C10LUg0LLRgNC10LzRjycsXG4gICAgICAgIHNob3dBbGxPcmdJblJ1YnJpYzogJ9Cf0L7QutCw0LfQsNGC0Ywg0LLRgdC1INC+0YDQs9Cw0L3QuNC30LDRhtC40Lgg0YDRg9Cx0YDQuNC60LgnLFxuICAgICAgICB0b2RheUlzUmVzdERheTogJ9Ch0LXQs9C+0LTQvdGPINCy0YvRhdC+0LTQvdC+0LknLFxuICAgICAgICBpbnRlcm5ldDogJ9Ce0L/Qu9Cw0YLQsCDRh9C10YDQtdC3INCY0L3RgtC10YDQvdC10YInLFxuICAgICAgICBub25jYXNoOiAn0JHQtdC30L3QsNC70LjRh9C90YvQuSDRgNCw0YHRh9C10YInLFxuICAgICAgICBnb2xkY3Jvd246ICfQl9C+0LvQvtGC0LDRjyDQmtC+0YDQvtC90LAnLFxuICAgICAgICBkaW5lcnNjbHViOiAnRGluZXJzIENsdWInLFxuICAgICAgICBtYXN0ZXJjYXJkOiAnTWFzdGVyY2FyZCcsXG4gICAgICAgIG1hZXN0cm9jYXJkOiAnTWFlc3Ryb0NhcmQnLFxuICAgICAgICB2aXNhOiAnVmlzYScsXG4gICAgICAgIGNhc2g6ICfQndCw0LvQuNGH0L3Ri9C5INGA0LDRgdGH0LXRgicsXG4gICAgICAgIGFtZXJpY2FuZXhwcmVzczogJ0FtZXJpY2FuIEV4cHJlc3MnLFxuICAgICAgICBob3VyIDogJ9GH0LDRgScsXG4gICAgICAgIGxlc3M6ICfQvNC10L3QtdC1JyxcbiAgICAgICAgX2luIDogJ9Cn0LXRgNC10LcnLFxuICAgICAgICBpc0Nsb3NpbmdPbkRpbm5lciA6ICcg0LfQsNC60YDRi9Cy0LDQtdGC0YHRjyDQvdCwINC+0LHQtdC0J1xuICAgIH0sXG5cbiAgICBpdDoge1xuICAgICAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24gKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgICAgIGlmIChuID09PSAxKSB7IC8vIDFcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7IC8vMCwgMiwgMywgNCAuLlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ0bkJhY2s6ICdJbmRpZXRybycsXG4gICAgICAgIGJ0bkZpbmRXYXk6ICdDb21lIGFycml2YXJlICcsXG4gICAgICAgIGJ0bkVudHJhbmNlOiAnVHJvdmEgbFxcJ2luZ3Jlc3NvJyxcbiAgICAgICAgbGlua1Jldmlld3M6IFsncmVjZW5zaW9uZScsICdyZWNlbnNpb25pJ10sXG4gICAgICAgIGxpbmtQaG90bzogWydmb3RvZ3JhZmlhJywgJ2ZvdG9ncmFmaWUnXSxcbiAgICAgICAgbGlua0Jvb2tsZXQ6ICdTdWxsXFwnYXppZW5kYScsXG4gICAgICAgIHRvbW1vcm93OiAnZG9tYW5pJyxcbiAgICAgICAgYWZ0ZXJUb21tb3JvdzogJ2RvcG9kb21hbmknLFxuICAgICAgICBhZnRlcldlZWs6ICd0cmEgdW5hIHNldHRpbWFuYScsXG4gICAgICAgIG5leHRTdW46ICdsYSBkb21lbmljYScsXG4gICAgICAgIG5leHRNb246ICdpbCBsdW5lZGknLFxuICAgICAgICBuZXh0VHVlOiAnaWwgbWFydGVkw6wnLFxuICAgICAgICBuZXh0V2VkOiAnaWwgbWVyY29sZWTDrCcsXG4gICAgICAgIG5leHRUaHU6ICdpbCBnaW92ZWRpJyxcbiAgICAgICAgbmV4dEZyaTogJ2lsIHZlbmVyZMOsJyxcbiAgICAgICAgbmV4dFNhdDogJ2lsIHNhYmF0bycsXG4gICAgICAgIHdpbGxPcGVuOiAnYXByZScsXG4gICAgICAgIHdpbGxDbG9zZTogJ2NpdXNvJyxcbiAgICAgICAgaXNPcGVuOiAnQXBlcnRvJyxcbiAgICAgICAgb3BlblRpbGw6ICdBcGVydG8gZmlubyBhbGxlICcsXG4gICAgICAgIGNsb3NlSW46ICdDaGl1ZGUgdHJhICcsXG4gICAgICAgIG9wZW5BdDogJ0FwcmUgYWxsZSAnLFxuICAgICAgICBvcGVuSW46ICdBcHJlIHRyYSAnLFxuICAgICAgICBvcGVuOiAnQXByZSAnLFxuICAgICAgICBuSG91cnM6IFsnb3JhJywgJ29yZSddLFxuICAgICAgICBuTWluczogWydtaW51dG8nLCAnbWludXRpJ10sXG4gICAgICAgIGx1bmNoOiAncGF1c2EgcHJhbnpvJyxcbiAgICAgICAgTHVuY2g6ICdQYXVzYSBwcmFuem8uICcsXG4gICAgICAgIHdvcmtpbmdEYXlzOiAnR2lvcm5pIGZlcmlhbGknLFxuICAgICAgICB3ZWVrZGF5czogJ0dpb3JuaSBmZXJpYWxpJyxcbiAgICAgICAgcmVzdERheTogWydjaGl1c3VyYScsJ2NoaXVzdXJhJ10sXG4gICAgICAgIHJldmlld3NPbkZsYW1wOiAnUmVjZW5zaW9uaSBzdSBGbGFtcCcsXG4gICAgICAgIHdyaXRlUmV2aWV3T25GbGFtcDogJ1Njcml2aSB1bmEgcmVjZW5zaW9uZSBzdSBGbGFtcCcsXG4gICAgICAgIHBheW1lbnQ6ICdwYWdhbWVudG8nLFxuICAgICAgICBldmVyeWRheTogJ09nbmkgZ2lvcm5vIGRhbG9sZScsXG4gICAgICAgIHdvcmtzQXJvdW5kVGhlQ2xvY2s6ICdPcGVyYXRpdm8gMjQgb3JlIHN1IDI0JyxcbiAgICAgICAgYXJvdW5kVGhlQ2xvY2s6ICcyNCBvcmUgc3UgMjQnLFxuICAgICAgICBrbm93TW9yZTogJ3VsdGVyaW9yaSBpbmZvcm1hemlvbmknLFxuICAgICAgICB0b0Nsb3NlOiAnZmlubyBhbGxhIGNoaXVzdXJhJyxcbiAgICAgICAgbW9uZGF5OiAnbHVuZWRpJyxcbiAgICAgICAgdHVlc2RheTogJ21hcnRlZMOsJyxcbiAgICAgICAgd2VkbmVzZGF5OiAnbWVyY29sZWTDrCcsXG4gICAgICAgIHRodXJzZGF5OiAnZ2lvdmVkaScsXG4gICAgICAgIGZyaWRheTogJ3ZlbmVyZMOsJyxcbiAgICAgICAgc2F0dXJkYXk6ICdzYWJhdG8nLFxuICAgICAgICBzdW5kYXk6ICdkb21lbmljYScsXG4gICAgICAgIG1vbjogJ2x1bicsXG4gICAgICAgIHR1ZTogJ21hcicsXG4gICAgICAgIHdlZDogJ21lcicsXG4gICAgICAgIHRodTogJ2dpbycsXG4gICAgICAgIGZyaTogJ3ZlbicsXG4gICAgICAgIHNhdDogJ3NhYicsXG4gICAgICAgIHN1bjogJ2RvbScsXG4gICAgICAgIHRvTHVuY2g6ICdmaW5vIGFsbGEgcGF1c2EgcHJhbnpvJyxcbiAgICAgICAgdG9kYXk6ICdPZ2dpJyxcbiAgICAgICAgbGVzc1RoZW5Ib3VyOiAnbWVubyBkaSB1blxcJ29yYScsXG4gICAgICAgIHlvdUNvdWxkTGF0ZTogJ2FmZnJldHRhcnNpLCBjaGl1c3VyYSBpbW1pbmVudGUnLFxuICAgICAgICB3b3JraW5nVGltZTogJ29yYXJpbyBkaSBsYXZvcm8nLFxuICAgICAgICBzaG93QWxsT3JnSW5SdWJyaWM6ICdWaXN1YWxpenphIHR1dHRlIGxlIGF6aWVuZGUgZGVsbGEgY2F0ZWdvcmlhJyxcbiAgICAgICAgdG9kYXlJc1Jlc3REYXk6ICdvZ2dpIGNoaXVzbycsXG4gICAgICAgIGludGVybmV0OiAnUGFnYW1lbnRvIG9uLWxpbmUnLFxuICAgICAgICBub25jYXNoOiAnUGFnYW1lbnRvIG5vbiBpbiBjb250YW50aScsXG4gICAgICAgIGdvbGRjcm93bjogJ1pvbG90YWphIEtvcm9uYScsXG4gICAgICAgIGRpbmVyc2NsdWI6ICdEaW5lcnMgQ2x1YicsXG4gICAgICAgIG1hc3RlcmNhcmQ6ICdNYXN0ZXJDYXJkJyxcbiAgICAgICAgbWFlc3Ryb2NhcmQ6ICdNYWVzdHJvQ2FyZCcsXG4gICAgICAgIHZpc2E6ICdWaXNhJyxcbiAgICAgICAgY2FzaDogJ1BhZ2FtZW50byBpbiBjb250YW50aScsXG4gICAgICAgIGFtZXJpY2FuZXhwcmVzczogJ0FtZXJpY2FuIEV4cHJlc3MnLFxuICAgICAgICBob3VyIDogJ3VuXFwnb3JhJyxcbiAgICAgICAgbGVzczogJ21lbm8gZGknLFxuICAgICAgICBfaW4gOiAnVHJhJyxcbiAgICAgICAgaXNDbG9zaW5nT25EaW5uZXIgOiAnY2hpdWRlIHBlciBwYXVzYSBwcmFuem8nXG4gICAgfSxcblxuICAgIGVuOiB7XG4gICAgICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbiAobikgeyAvLyAoTnVtYmVyKVxuICAgICAgICAgICAgaWYgKG4gPT09IDEpIHsgLy8gMVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTsgLy8wLCAyLCAzLCA0IC4uXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnRuQmFjazogJ0JhY2snLFxuICAgICAgICBidG5GaW5kV2F5OiAnR2V0IGhlcmUnLFxuICAgICAgICBidG5FbnRyYW5jZTogJ0ZpbmQgZW50cmFuY2UnLFxuICAgICAgICBsaW5rUmV2aWV3czogWydyZXZpZXcnLCAncmV2aWV3cyddLFxuICAgICAgICBsaW5rUGhvdG86IFsncGhvdG8nLCAncGhvdG9zJ10sXG4gICAgICAgIGxpbmtCb29rbGV0OiAnQWJvdXQgY29tcGFueScsXG4gICAgICAgIHRvbW1vcm93OiAndG9tb3Jyb3cnLFxuICAgICAgICBhZnRlclRvbW1vcm93OiAndGhlIGRheSBhZnRlciB0b21vcnJvdycsXG4gICAgICAgIGFmdGVyV2VlazogJ2luIGEgd2VlaycsXG4gICAgICAgIG5leHRTdW46ICdvbiBTdW5kYXknLFxuICAgICAgICBuZXh0TW9uOiAnb24gTW9uZGF5JyxcbiAgICAgICAgbmV4dFR1ZTogJ29uIFR1ZXNkYXknLFxuICAgICAgICBuZXh0V2VkOiAnb24gV2VkbmVzZGF5JyxcbiAgICAgICAgbmV4dFRodTogJ29uIFRodXJzZGF5JyxcbiAgICAgICAgbmV4dEZyaTogJ29uIEZyaWRheScsXG4gICAgICAgIG5leHRTYXQ6ICdvbiBTYXR1cmRheScsXG4gICAgICAgIHdpbGxPcGVuOiAnb3BlbnMgJyxcbiAgICAgICAgd2lsbENsb3NlOiAnY2xvc2VzJyxcbiAgICAgICAgaXNPcGVuOiAnT3BlbicsXG4gICAgICAgIG9wZW5UaWxsOiAnT3BlbiB0aWxsICcsXG4gICAgICAgIGNsb3NlSW46ICdDbG9zZXMgaW4gJyxcbiAgICAgICAgb3BlbkF0OiAnT3BlbnMgYXQgJyxcbiAgICAgICAgb3BlbkluOiAnT3BlbnMgaW4gJyxcbiAgICAgICAgb3BlbjogJ09wZW5zICcsXG4gICAgICAgIG5Ib3VyczogWydob3VyJywgJ2hvdXJzJ10sXG4gICAgICAgIG5NaW5zOiBbJ21pbnV0ZScsICdtaW51dGVzJ10sXG4gICAgICAgIGx1bmNoOiAnbHVuY2ggYnJlYWsnLFxuICAgICAgICBMdW5jaDogJ0x1bmNoIGJyZWFrLiAnLFxuICAgICAgICB3b3JraW5nRGF5czogJ1dvcmtpbmcgZGF5cycsXG4gICAgICAgIHdlZWtkYXlzOiAnV2Vla2RheXMnLFxuICAgICAgICByZXN0RGF5OiBbJ2RheSBvZmYnLCdkYXlzIG9mZiddLFxuICAgICAgICByZXZpZXdzT25GbGFtcDogJ1Jldmlld3Mgb24gRmxhbXAnLFxuICAgICAgICB3cml0ZVJldmlld09uRmxhbXA6ICdXcml0ZSBhIHJldmlldyBvbiBGbGFtcCcsXG4gICAgICAgIHBheW1lbnQ6ICdwYXltZW50JyxcbiAgICAgICAgZXZlcnlkYXk6ICdEYWlseSBmcm9tJyxcbiAgICAgICAgd29ya3NBcm91bmRUaGVDbG9jazogJ09wZW4gMjQgaG91cnMnLFxuICAgICAgICBhcm91bmRUaGVDbG9jazogJzI0aCcsXG4gICAgICAgIGtub3dNb3JlOiAnc2VlIGFsc28nLFxuICAgICAgICB0b0Nsb3NlOiAndW50aWwgY2xvc2luZycsXG4gICAgICAgIG1vbmRheTogJ01vbmRheScsXG4gICAgICAgIHR1ZXNkYXk6ICdUdWVzZGF5JyxcbiAgICAgICAgd2VkbmVzZGF5OiAnV2VkbmVzZGF5JyxcbiAgICAgICAgdGh1cnNkYXk6ICdUaHVyc2RheScsXG4gICAgICAgIGZyaWRheTogJ0ZyaWRheScsXG4gICAgICAgIHNhdHVyZGF5OiAnU2F0dXJkYXknLFxuICAgICAgICBzdW5kYXk6ICdTdW5kYXknLFxuICAgICAgICBtb246ICdNb24nLFxuICAgICAgICB0dWU6ICdUdWUnLFxuICAgICAgICB3ZWQ6ICdXZWQnLFxuICAgICAgICB0aHU6ICdUaHUnLFxuICAgICAgICBmcmk6ICdGcmknLFxuICAgICAgICBzYXQ6ICdTYXQnLFxuICAgICAgICBzdW46ICdTdW4nLFxuICAgICAgICB0b0x1bmNoOiAndW50aWwgbHVuY2gnLFxuICAgICAgICB0b2RheTogJ1RvZGF5JyxcbiAgICAgICAgbGVzc1RoZW5Ib3VyOiAnbGVzcyB0aGVuIG9uZSBob3VyJyxcbiAgICAgICAgeW91Q291bGRMYXRlOiAneW91IG1pZ2h0IGJlIGxhdGUnLFxuICAgICAgICB3b3JraW5nVGltZTogJ3dvcmtpbmcgaG91cnMnLFxuICAgICAgICBzaG93QWxsT3JnSW5SdWJyaWM6ICdTaG93IGFsbCBvcmdhbml6YXRpb25zIGluIHRoZSBjYXRlZ29yeScsXG4gICAgICAgIHRvZGF5SXNSZXN0RGF5OiAnY2xvc2VkIHRvZGF5JyxcbiAgICAgICAgaW50ZXJuZXQ6ICdPbmxpbmUnLFxuICAgICAgICBub25jYXNoOiAnIE5vLWNhc2gnLFxuICAgICAgICBnb2xkY3Jvd246ICdHb2xkZW4gQ3Jvd24nLFxuICAgICAgICBkaW5lcnNjbHViOiAnRGluZXJzIENsdWInLFxuICAgICAgICBtYXN0ZXJjYXJkOiAnTWFzdGVyY2FyZCcsXG4gICAgICAgIG1hZXN0cm9jYXJkOiAnTWFlc3Ryb0NhcmQnLFxuICAgICAgICB2aXNhOiAnVmlzYScsXG4gICAgICAgIGNhc2g6ICdDYXNoJyxcbiAgICAgICAgYW1lcmljYW5leHByZXNzOiAnQW1lcmljYW4gRXhwcmVzcycsXG4gICAgICAgIGhvdXIgOiAnaG91cicsXG4gICAgICAgIGxlc3M6ICdsZXNzJyxcbiAgICAgICAgX2luIDogJ0luJyxcbiAgICAgICAgaXNDbG9zaW5nT25EaW5uZXIgOiAnd2lsbCBiZSBjbG9zaW5nIGZvciBsdW5jaCdcbiAgICB9LFxuXG4gICAgY3M6IHtcbiAgICAgICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uIChuKSB7IC8vIChOdW1iZXIpXG4gICAgICAgICAgICByZXR1cm4gKG4gPT09IDEpID8gMCA6IChuID49IDIgJiYgbiA8PSA0KSA/IDEgOiAyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJ0bkJhY2s6ICdacMSbdCcsXG4gICAgICAgIGJ0bkZpbmRXYXk6ICdKZXQgc2VtJyxcbiAgICAgICAgYnRuRW50cmFuY2U6ICdIbGVkYXQgdnN0dXAnLFxuICAgICAgICBsaW5rUmV2aWV3czogWydyZWNlbnplJywgJ3JlY2VuemUnLCAncmVjZW56w60nXSxcbiAgICAgICAgbGlua1Bob3RvOiBbJ2ZvdG9ncmFmaWUnLCAnZm90b2dyYWZpZScsICdmb3RvZ3JhZmnDrSddLFxuICAgICAgICBsaW5rQm9va2xldDogJ0xldMOhaycsXG4gICAgICAgIHRvbW1vcm93OiAnesOtdHJhJyxcbiAgICAgICAgYWZ0ZXJUb21tb3JvdzogJ3BvesOtdMWZw60nLFxuICAgICAgICBhZnRlcldlZWs6ICd6YSB0w71kZW4nLFxuICAgICAgICBuZXh0U3VuOiAndiBuZWTEm2xpJyxcbiAgICAgICAgbmV4dE1vbjogJ3YgcG9uZMSbbMOtJyxcbiAgICAgICAgbmV4dFR1ZTogJ3Ygw7p0ZXLDvScsXG4gICAgICAgIG5leHRXZWQ6ICd2ZSBzdMWZZWR1JyxcbiAgICAgICAgbmV4dFRodTogJ3ZlIMSNdHZydGVrJyxcbiAgICAgICAgbmV4dEZyaTogJ3YgcMOhdGVrJyxcbiAgICAgICAgbmV4dFNhdDogJ3Ygc29ib3R1JyxcbiAgICAgICAgd2lsbE9wZW46ICdvdGV2xZllIHNlJyxcbiAgICAgICAgd2lsbENsb3NlOiAnemF2xZllIHNlJyxcbiAgICAgICAgaXNPcGVuOiAnT3RldsWZZW5vJyxcbiAgICAgICAgb3BlblRpbGw6ICdPdGV2xZllbm8gZG8gJyxcbiAgICAgICAgY2xvc2VJbjogJ1phdsWZZSBzZSB6YSAnLFxuICAgICAgICBvcGVuQXQ6ICdPdGV2xZllIHNlIHYgJyxcbiAgICAgICAgb3BlbkluOiAnT3RldsWZZSBzZSB6YSAnLFxuICAgICAgICBvcGVuOiAnT3RldsWZZSBzZSAnLFxuICAgICAgICBuSG91cnM6IFsgJ2hvZGludScgLCAnaG9kaW55JyAsICdob2RpbicgXSxcbiAgICAgICAgbk1pbnM6IFsgJ21pbnV0dScgLCAnbWludXR5JyAsICdtaW51dCcgXSxcbiAgICAgICAgbHVuY2g6ICdwb2xlZG7DrSBwxZllc3TDoXZrYScsXG4gICAgICAgIEx1bmNoOiAnUG9sZWRuw60gcMWZZXN0w6F2a2EuICcsXG4gICAgICAgIHdvcmtpbmdEYXlzOiAnVsWhZWRuw60gZG55JyxcbiAgICAgICAgd2Vla2RheXM6ICdWxaFlZG7DrSBkbnknLFxuICAgICAgICByZXN0RGF5OiBbJ3phdsWZZW5vJywgJ3phdsWZZW5vJ10sXG4gICAgICAgIHJldmlld3NPbkZsYW1wOiAnUmVjZW56ZSBuYSBGbGFtcHUnLFxuICAgICAgICB3cml0ZVJldmlld09uRmxhbXA6ICdOYXBzYXQgcmVjZW56aSBuYSBGbGFtcHUnLFxuICAgICAgICBwYXltZW50OiAncGxhdGJhJyxcbiAgICAgICAgZXZlcnlkYXk6ICdEZW5uxJsgb2QgJyxcbiAgICAgICAgd29ya3NBcm91bmRUaGVDbG9jazogJ1ByYWN1amUgbm9uc3RvcCcsXG4gICAgICAgIGFyb3VuZFRoZUNsb2NrOiAnTm9uc3RvcCcsXG4gICAgICAgIGtub3dNb3JlOiAnZG96dsSbZMSbdCBzZSB2w61jZScsXG4gICAgICAgIHRvQ2xvc2U6ICdkbyB1emF2xZllbsOtJyxcbiAgICAgICAgbW9uZGF5OiAncG9uZMSbbMOtJyxcbiAgICAgICAgdHVlc2RheTogJ8O6dGVyw70nLFxuICAgICAgICB3ZWRuZXNkYXk6ICdzdMWZZWRhJyxcbiAgICAgICAgdGh1cnNkYXk6ICfEjXR2cnRlaycsXG4gICAgICAgIGZyaWRheTogJ3DDoXRlaycsXG4gICAgICAgIHNhdHVyZGF5OiAnc29ib3RhJyxcbiAgICAgICAgc3VuZGF5OiAnbmVkxJtsZScsXG4gICAgICAgIG1vbjogJ3BvJyxcbiAgICAgICAgdHVlOiAnw7p0JyxcbiAgICAgICAgd2VkOiAnc3QnLFxuICAgICAgICB0aHU6ICfEjXQnLFxuICAgICAgICBmcmk6ICdww6EnLFxuICAgICAgICBzYXQ6ICdzbycsXG4gICAgICAgIHN1bjogJ25lJyxcbiAgICAgICAgdG9MdW5jaDogJ2RvIHBvbGVkbsOtIHDFmWVzdMOhdmt5JyxcbiAgICAgICAgdG9kYXk6ICdEbmVzJyxcbiAgICAgICAgbGVzc1RoZW5Ib3VyOiAnbcOpbsSbIG5lxb4gaG9kaW51JyxcbiAgICAgICAgeW91Q291bGRMYXRlOiAnbmVtdXPDrXRlIHRvIHN0aWhub3V0JyxcbiAgICAgICAgd29ya2luZ1RpbWU6ICdwcmFjb3Zuw60gZG9iYScsXG4gICAgICAgIHNob3dBbGxPcmdJblJ1YnJpYzogJ1pvYnJheml0IHbFoWVjaG55IG9yZ2FuaXphY2UgdiBydWJyaWNlJyxcbiAgICAgICAgdG9kYXlJc1Jlc3REYXk6ICdEbmVzIGplIHphdsWZZW5vJyxcbiAgICAgICAgaW50ZXJuZXQ6ICdQbGF0YmEgcHJvc3TFmWVkbmljdHbDrW0gSW50ZXJuZXR1JyxcbiAgICAgICAgbm9uY2FzaDogJ0JlemhvdG92b3N0bsOtIHBsYXRiYScsXG4gICAgICAgIGdvbGRjcm93bjogJ1pvbG90YWphIEtvcm9uYScsXG4gICAgICAgIGRpbmVyc2NsdWI6ICdEaW5lcnMgQ2x1YicsXG4gICAgICAgIG1hc3RlcmNhcmQ6ICdNYXN0ZXJjYXJkJyxcbiAgICAgICAgbWFlc3Ryb2NhcmQ6ICdNYWVzdHJvQ2FyZCcsXG4gICAgICAgIHZpc2E6ICdWaXNhJyxcbiAgICAgICAgY2FzaDogJ1BsYXRiYSBob3RvdsSbJyxcbiAgICAgICAgYW1lcmljYW5leHByZXNzOiAnQW1lcmljYW4gRXhwcmVzcycsXG4gICAgICAgIGhvdXIgOiAnaG9kaW51JyxcbiAgICAgICAgbGVzczogJ23DqW7EmycsXG4gICAgICAgIF9pbiA6ICdaYScsXG4gICAgICAgIGlzQ2xvc2luZ09uRGlubmVyIDogJ3phxI3DrW7DoSBwb2xlZG7DrSBwxZllc3TDoXZrYSdcbiAgICB9LFxuXG4gICAgZXM6IHtcbiAgICAgICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uIChuKSB7IC8vIChOdW1iZXIpXG4gICAgICAgICAgcmV0dXJuIChuID09PSAxKSA/IDAgOiAobiA+PSAyICYmIG4gPD0gNCkgPyAxIDogMjtcbiAgICAgICAgfSxcblxuICAgICAgICBidG5CYWNrOiAnQXRyw6FzJyxcbiAgICAgICAgYnRuRmluZFdheTogJ0lyIHBhcmEgYWxsw6EnLFxuICAgICAgICBidG5FbnRyYW5jZTogJ0J1c2NhciBhY2Nlc28nLFxuICAgICAgICBsaW5rUmV2aWV3czogWydjb21lbnRhcmlvJywgJ2NvbWVudGFyaW9zJywgJ2NvbWVudGFyaW9zJ10sXG4gICAgICAgIGxpbmtQaG90bzogWydmb3RvJywgJ2ZvdG9zJywgJ2ZvdG9zJ10sXG4gICAgICAgIGxpbmtCb29rbGV0OiAnRm9sbGV0bycsXG4gICAgICAgIHRvbW1vcm93OiAnbWHDsWFuYScsXG4gICAgICAgIGFmdGVyVG9tbW9yb3c6ICdwYXNhZG8gbWHDsWFuYScsXG4gICAgICAgIGFmdGVyV2VlazogJ2VuIHVuYSBzZW1hbmEgbcOhcycsXG4gICAgICAgIG5leHRTdW46ICdlbCBkb21pbmdvJyxcbiAgICAgICAgbmV4dE1vbjogJ2VsIGx1bmVzJyxcbiAgICAgICAgbmV4dFR1ZTogJ2VsIG1hcnRlcycsXG4gICAgICAgIG5leHRXZWQ6ICdlbCBtacOpcmNvbGVzJyxcbiAgICAgICAgbmV4dFRodTogJ2VsIGp1ZXZlcycsXG4gICAgICAgIG5leHRGcmk6ICdlbCB2aWVybmVzJyxcbiAgICAgICAgbmV4dFNhdDogJ2VsIHPDoWJhZG8nLFxuICAgICAgICB3aWxsT3BlbjogJ3NlIGFicmlyw6EnLFxuICAgICAgICB3aWxsQ2xvc2U6ICdzZSBjZXJyYXLDoScsXG4gICAgICAgIGlzT3BlbjogJ0FiaWVydG8nLFxuICAgICAgICBvcGVuVGlsbDogJ0FiaWVydG8gaGFzdGEgJyxcbiAgICAgICAgY2xvc2VJbjogJ1NlIGNlcnJhcsOhIGRlbnRybyBkZSAnLFxuICAgICAgICBvcGVuQXQ6ICdTZSBhYnJpcsOhIGVsICcsXG4gICAgICAgIG9wZW5JbjogJ1NlIGFicmlyw6EgZGVudHJvIGRlICcsXG4gICAgICAgIG9wZW46ICdTZSBhYnJpcsOhICcsXG4gICAgICAgIG5Ib3VyczogWydob3JhJywgJ2hvcmFzJywgJ2hvcmFzJ10sXG4gICAgICAgIG5NaW5zOiBbJ21pbnV0bycsICdtaW51dG9zJywgJ21pbnV0b3MnXSxcbiAgICAgICAgbHVuY2g6ICdob3JhIGRlIGNvbGFjacOzbicsXG4gICAgICAgIEx1bmNoOiAnSG9yYSBkZSBjb2xhY2nDs24uICcsXG4gICAgICAgIHdvcmtpbmdEYXlzOiAnRMOtYXMgbGFib3JhYmxlcycsXG4gICAgICAgIHdlZWtkYXlzOiAnRMOtYXMgbGFib3JhYmxlcycsXG4gICAgICAgIHJlc3REYXk6IFsnY2VycmFkbycsJ2NlcnJhZG8nXSxcbiAgICAgICAgcmV2aWV3c09uRmxhbXA6ICdDb21lbnRhcmlvcyBlbiBGbGFtcCcsXG4gICAgICAgIHdyaXRlUmV2aWV3T25GbGFtcDogJ0VzY3JpYmlyIHVuIGNvbWVudGFyaW8gZW4gRmxhbXAnLFxuICAgICAgICBwYXltZW50OiAncGFnbycsXG4gICAgICAgIGV2ZXJ5ZGF5OiAnQ2FkYSBkw61hIGRlc2RlJyxcbiAgICAgICAgd29ya3NBcm91bmRUaGVDbG9jazogJ0FiaWVydG8gbGFzIDI0IGhvcmFzJyxcbiAgICAgICAgYXJvdW5kVGhlQ2xvY2s6ICcyNCBob3JhcycsXG4gICAgICAgIGtub3dNb3JlOiAncGFyYSBzYWJlciBtw6FzJyxcbiAgICAgICAgdG9DbG9zZTogJ2hhc3RhIGVsIGNpZXJyZScsXG4gICAgICAgIG1vbmRheTogJ2x1bmVzJyxcbiAgICAgICAgdHVlc2RheTogJ21hcnRlcycsXG4gICAgICAgIHdlZG5lc2RheTogJ21pw6lyY29sZXMnLFxuICAgICAgICB0aHVyc2RheTogJ2p1ZXZlcycsXG4gICAgICAgIGZyaWRheTogJ3ZpZXJuZXMnLFxuICAgICAgICBzYXR1cmRheTogJ3PDoWJhZG8nLFxuICAgICAgICBzdW5kYXk6ICdkb21pbmdvJyxcbiAgICAgICAgbW9uOiAnbHVuJyxcbiAgICAgICAgdHVlOiAnbWFyJyxcbiAgICAgICAgd2VkOiAnbWnDqScsXG4gICAgICAgIHRodTogJ2p1ZScsXG4gICAgICAgIGZyaTogJ3ZpZScsXG4gICAgICAgIHNhdDogJ3PDoWInLFxuICAgICAgICBzdW46ICdkb20nLFxuICAgICAgICB0b0x1bmNoOiAnYW50ZXMgZGUgbGEgaG9yYSBkZSBjb2xhY2nDs24nLFxuICAgICAgICB0b2RheTogJ0hveScsXG4gICAgICAgIGxlc3NUaGVuSG91cjogJ21lbm9zIGRlIHVuYSBob3JhJyxcbiAgICAgICAgeW91Q291bGRMYXRlOiAncHVlZGUgc2VyIHF1ZSBubyBhbGNhbnphcyBhIGxsZWdhcicsXG4gICAgICAgIHdvcmtpbmdUaW1lOiAnaG9yYXJpbyBkZSB0cmFiYWpvJyxcbiAgICAgICAgc2hvd0FsbE9yZ0luUnVicmljOiAnTW9zdHJhciB0b2RhcyBsYXMgZW1wcmVzYXMgZGUgbGEgY2F0ZWdvcsOtYScsXG4gICAgICAgIHRvZGF5SXNSZXN0RGF5OiAnSG95IGNlcnJhZG8nLFxuICAgICAgICBpbnRlcm5ldDogJ1BhZ28gcG9yIEludGVybmV0JyxcbiAgICAgICAgbm9uY2FzaDogJ1BhZ28gc2luIGVmZWN0aXZvJyxcbiAgICAgICAgZ29sZGNyb3duOiAnWm9sb3RheWEgS29yb25hJyxcbiAgICAgICAgZGluZXJzY2x1YjogJ0RpbmVycyBDbHViJyxcbiAgICAgICAgbWFzdGVyY2FyZDogJ01hc3RlcmNhcmQnLFxuICAgICAgICBtYWVzdHJvY2FyZDogJ01hZXN0cm9DYXJkJyxcbiAgICAgICAgdmlzYTogJ1Zpc2EnLFxuICAgICAgICBjYXNoOiAnUGFnbyBlbiBlZmVjdGl2bycsXG4gICAgICAgIGFtZXJpY2FuZXhwcmVzczogJ0FtZXJpY2FuIEV4cHJlc3MnLFxuICAgICAgICBob3VyIDogJ2hvcmEnLFxuICAgICAgICBsZXNzOiAnbWVub3MgZGUnLFxuICAgICAgICBfaW4gOiAnRGVudHJvIGRlJyxcbiAgICAgICAgaXNDbG9zaW5nT25EaW5uZXIgOiAnc2UgY2llcnJhIHBvciBob3JhIGRlIGNvbGFjacOzbidcbiAgICB9XG59O1xuIiwiREcuVHJhZmZpYyA9IERHLlRpbGVMYXllci5leHRlbmQoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcGVyaW9kOiAwLFxuICAgICAgICBkaXNhYmxlTGFiZWw6IGZhbHNlXG4gICAgfSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgRGljdGlvbmFyeToge31cbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLl90aWxlVXJsID0gREcuY29uZmlnLnByb3RvY29sICsgKERHLkJyb3dzZXIucmV0aW5hID8gREcuY29uZmlnLnJldGluYVRyYWZmaWNUaWxlU2VydmVyIDogREcuY29uZmlnLnRyYWZmaWNUaWxlU2VydmVyKTtcbiAgICAgICAgdGhpcy5fbWV0YVVybCA9IERHLmNvbmZpZy5wcm90b2NvbCArIChERy5Ccm93c2VyLnJldGluYSA/IERHLmNvbmZpZy5yZXRpbmFUcmFmZmljTWV0YVNlcnZlciA6IERHLmNvbmZpZy50cmFmZmljTWV0YVNlcnZlcik7XG4gICAgICAgIHRoaXMuX3RpbWVVcmwgPSBERy5jb25maWcucHJvdG9jb2wgKyBERy5jb25maWcudHJhZmZpY1RpbWVzdGFtcFNlcnZlcjtcbiAgICAgICAgdGhpcy5fdXBkYXRlSW50ZXJ2YWwgPSBERy5jb25maWcudHJhZmZpY0xheWVyVXBkYXRlSW50ZXJ2YWw7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGVycm9yVGlsZVVybDogJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNycsXG4gICAgICAgICAgICBzdWJkb21haW5zOiAnMDEyMzQ1Njc5JyxcbiAgICAgICAgICAgIG1heE5hdGl2ZVpvb206IDE4LFxuICAgICAgICAgICAgZGV0ZWN0UmV0aW5hOiB0cnVlLFxuICAgICAgICAgICAgbWluWm9vbTogREcuY29uZmlnLnRyYWZmaWNMYXllck1pblpvb21cbiAgICAgICAgfTtcblxuICAgICAgICBvcHRpb25zID0gREcuc2V0T3B0aW9ucyh0aGlzLCBERy5leHRlbmQob3B0aW9ucyB8fCB7fSwgdGhpcy5fbGF5ZXJzT3B0aW9ucykpO1xuICAgICAgICBvcHRpb25zLnRpbWVzdGFtcFN0cmluZyA9IG9wdGlvbnMucGVyaW9kID8gJycgOiAoJz8nICsgIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpO1xuICAgICAgICB0aGlzLl9tZXRhTGF5ZXIgPSBERy5NZXRhLmxheWVyKG51bGwsIHtcbiAgICAgICAgICAgIGRldGVjdFJldGluYTogb3B0aW9ucy5kZXRlY3RSZXRpbmEsXG4gICAgICAgICAgICBtYXhOYXRpdmVab29tOiBvcHRpb25zLm1heE5hdGl2ZVpvb20sXG4gICAgICAgICAgICBkYXRhRmlsdGVyOiBERy5iaW5kKHRoaXMuX3Byb2Nlc3NEYXRhLCB0aGlzKSxcbiAgICAgICAgICAgIG1pblpvb206IG9wdGlvbnMubWluWm9vbVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faXNEZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX29uVGltZXIgPSBERy5iaW5kKHRoaXMuX29uVGltZXIsIHRoaXMpO1xuICAgICAgICBERy5UaWxlTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl90aWxlVXJsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gI3NldFRpbWUoZGF5IFswLTZdLCB0aW1lWzAtMjNdKSA/Pz8/XG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyUHJvamVjdCgpO1xuXG4gICAgICAgIG1hcFxuICAgICAgICAgICAgLmFkZExheWVyKHRoaXMuX21ldGFMYXllcilcbiAgICAgICAgICAgIC5vbigncHJvamVjdGNoYW5nZSBwcm9qZWN0bGVhdmUnLCB0aGlzLl9vbk1hcFByb2plY3RDaGFuZ2UsIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fbWV0YUxheWVyLm9uKHRoaXMuX2xheWVyRXZlbnRzTGlzdGVuZXJzLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsSGVscGVyID0gREcubGFiZWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLl9vblRpbWVyLCB0aGlzLl91cGRhdGVJbnRlcnZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBERy5UaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3VwZGF0ZVRpbWVyKTtcblxuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5yZW1vdmVMYXllcih0aGlzLl9tZXRhTGF5ZXIpXG4gICAgICAgICAgICAub2ZmKCdwcm9qZWN0Y2hhbmdlIHByb2plY3RsZWF2ZScsIHRoaXMuX29uTWFwUHJvamVjdENoYW5nZSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXRhTGF5ZXIub2ZmKHRoaXMuX2xheWVyRXZlbnRzTGlzdGVuZXJzLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbEhlbHBlcik7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBERy5UaWxlTGF5ZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl9nZXRUaW1lc3RhbXBTdHJpbmcoKS50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMudGltZXN0YW1wU3RyaW5nID0gJz8nICsgcmVzcG9uc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnRpbWVzdGFtcFN0cmluZyA9ICc/JyArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9KS50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlKCd1cGRhdGUnLCB7dGltZXN0YW1wOiBzZWxmLm9wdGlvbnMudGltZXN0YW1wU3RyaW5nfSk7XG4gICAgICAgICAgICAgICAgc2VsZi5fbGF5ZXJFdmVudHNMaXN0ZW5lcnMubW91c2VvdXQuY2FsbChzZWxmKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9tZXRhTGF5ZXIuZ2V0T3JpZ2luKCkuc2V0VVJMKHNlbGYuX3ByZXBhcmVNZXRhVVJMKCksIHNlbGYpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGdldFN1YmRvbWFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNPcHRpb25zLnN1YmRvbWFpbnNbXG4gICAgICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLl9sYXllcnNPcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBfZ2V0VGltZXN0YW1wU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERHLmFqYXgoXG4gICAgICAgICAgICBERy5VdGlsLnRlbXBsYXRlKFxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVVcmwsXG4gICAgICAgICAgICAgICAgREcuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgcyA6IHRoaXMuZ2V0U3ViZG9tYWluKCksXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RDb2RlOiB0aGlzLl9tYXAucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKS5jb2RlXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zIHx8IHt9KSksXG4gICAgICAgICAgICB7dHlwZTogJ2dldCd9XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIF9vblRpbWVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZXJpb2QgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Byb2Nlc3NEYXRhOiBmdW5jdGlvbih0cmFmZmljRGF0YSwgY29vcmQpIHtcbiAgICAgICAgdmFyIHRpbGVPcmlnaW5Qb2ludCA9IGNvb3JkLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKTtcbiAgICAgICAgdmFyIHBvbHlnb25MbmdMYXRUb1BvaW50cyA9IERHLmJpbmQodGhpcy5fcG9seWdvbkxuZ0xhdFRvUG9pbnRzLCB0aGlzLCB0aWxlT3JpZ2luUG9pbnQpO1xuICAgICAgICB2YXIgaGludHMgPSB7fTtcblxuICAgICAgICBpZiAoIURHLlV0aWwuaXNBcnJheSh0cmFmZmljRGF0YSkpIHsgICAgLy8gVE9ETyByZW1vdmVcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWZmaWNEYXRhWzFdLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdGhpc1tpdGVtLmdyYXBoX2lkXSA9IGl0ZW0uc3BlZWRfdGV4dDtcbiAgICAgICAgfSwgaGludHMpO1xuXG4gICAgICAgIHJldHVybiB0cmFmZmljRGF0YVswXVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uZ3JhcGhfaWQsXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkOiBoaW50c1tpdGVtLmdyYXBoX2lkXSxcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IERHLldrdC50b0dlb0pTT04oaXRlbS5nZW9tZXRyeVswXS5vYmplY3RbMF0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5nZW9tZXRyeS50eXBlID09ICdQb2x5Z29uJyB8fFxuICAgICAgICAgICAgICAgICAgICBpdGVtLmdlb21ldHJ5LnR5cGUgPT0gJ011bHRpUG9seWdvbic7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdlb0pzb24gPSBpdGVtLmdlb21ldHJ5O1xuXG4gICAgICAgICAgICAgICAgaWYgKGdlb0pzb24udHlwZSA9PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvSnNvbi5jb29yZGluYXRlcyA9IHBvbHlnb25MbmdMYXRUb1BvaW50cyhnZW9Kc29uLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdlb0pzb24udHlwZSA9PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICBnZW9Kc29uLmNvb3JkaW5hdGVzID0gZ2VvSnNvbi5jb29yZGluYXRlcy5tYXAocG9seWdvbkxuZ0xhdFRvUG9pbnRzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfcG9seWdvbkxuZ0xhdFRvUG9pbnRzOiBmdW5jdGlvbihvcmlnaW5Qb2ludCwgcG9seWdvbikge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIHJldHVybiBwb2x5Z29uLm1hcChmdW5jdGlvbihjb250b3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udG91ci5tYXAoZnVuY3Rpb24obG5nTGF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcFxuICAgICAgICAgICAgICAgICAgICAucHJvamVjdChbbG5nTGF0WzFdLCBsbmdMYXRbMF1dKS5yb3VuZCgpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJ0cmFjdChvcmlnaW5Qb2ludCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9wcmVwYXJlTWV0YVVSTDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBERy5VdGlsLnRlbXBsYXRlKHRoaXMuX21ldGFVcmwsIERHLmV4dGVuZCh7XG4gICAgICAgICAgICB4OiAne3h9JyxcbiAgICAgICAgICAgIHk6ICd7eX0nLFxuICAgICAgICAgICAgejogJ3t6fScsXG4gICAgICAgICAgICBzOiAne3N9J1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUxheWVyUHJvamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9qZWN0ID0gdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCk7XG4gICAgICAgIERHLnNldE9wdGlvbnModGhpcywgcHJvamVjdCAmJiBwcm9qZWN0LnRyYWZmaWMgPyB7XG4gICAgICAgICAgICBwcm9qZWN0Q29kZTogcHJvamVjdC5jb2RlLFxuICAgICAgICAgICAgYm91bmRzOiBwcm9qZWN0LmxhdExuZ0JvdW5kcyxcbiAgICAgICAgICAgIG1pblpvb206IE1hdGgubWF4KHByb2plY3QubWluWm9vbSwgdGhpcy5fbGF5ZXJzT3B0aW9ucy5taW5ab29tKSxcbiAgICAgICAgICAgIG1heFpvb206IHByb2plY3QubWF4Wm9vbVxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgbWF4Wm9vbTogMCxcbiAgICAgICAgICAgIG1pblpvb206IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21ldGFMYXllci5nZXRPcmlnaW4oKS5zZXRVUkwodGhpcy5fcHJlcGFyZU1ldGFVUkwoKSk7XG4gICAgfSxcblxuICAgIF9vbk1hcFByb2plY3RDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVMYXllclByb2plY3QoKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9LFxuXG4gICAgX2xheWVyRXZlbnRzTGlzdGVuZXJzOiB7XG4gICAgICAgIG1vdXNlb3ZlcjogZnVuY3Rpb24oZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKCdwb2ludGVyJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWxIZWxwZXIgJiYgZS5tZXRhLnNwZWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBvc2l0aW9uKGUubGF0bG5nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0Q29udGVudChlLm1ldGEuc3BlZWQgKyAnICcgKyB0aGlzLnQoJ3NwZWVkX3VuaXRfa21faCcpKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVG8odGhpcy5fbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKCcnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbEhlbHBlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbEhlbHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsSGVscGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXIuc2V0UG9zaXRpb24oZS5sYXRsbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRDdXJzb3I6IGZ1bmN0aW9uKGN1cnNvcikgeyAvLyAoU3RyaW5nKVxuICAgICAgICB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgIH1cblxufSk7XG5cbkRHLlRyYWZmaWMuaW5jbHVkZShERy5Mb2NhbGUpO1xuXG5ERy50cmFmZmljID0gZnVuY3Rpb24ob3B0aW9ucykgeyAvLyAoT2JqZWN0KVxuICAgIHJldHVybiBuZXcgREcuVHJhZmZpYyhvcHRpb25zKTtcbn07XG4iLCJERy5UcmFmZmljLkRpY3Rpb25hcnkucnUgPSB7XG4gICAgc3BlZWRfdW5pdF9rbV9oOiAn0LrQvC/Rhydcbn07IiwiREcuVHJhZmZpYy5EaWN0aW9uYXJ5Lml0ID0ge1xuICAgIHNwZWVkX3VuaXRfa21faDogJ2ttL2gnXG59OyIsIkRHLlRyYWZmaWMuRGljdGlvbmFyeS5jcyA9IHtcbiAgICBzcGVlZF91bml0X2ttX2g6ICdrbS9oJ1xufTsiLCJERy5UcmFmZmljLkRpY3Rpb25hcnkuZXMgPSB7XG4gICAgc3BlZWRfdW5pdF9rbV9oOiAna20vaCdcbn07IiwiREcuVHJhZmZpYy5EaWN0aW9uYXJ5LmVuID0ge1xuICAgIHNwZWVkX3VuaXRfa21faDogJ2ttL2gnXG59OyIsIkRHLkNvbnRyb2wuVHJhZmZpYyA9IERHLlJvdW5kQ29udHJvbC5leHRlbmQoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3ByaWdodCcsXG4gICAgICAgIGljb25DbGFzczogJ3RyYWZmaWMnXG4gICAgfSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgRGljdGlvbmFyeToge31cbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLl90cmFmZmljQ2xhc3MgPSAnZGctdHJhZmZpYy1jb250cm9sJztcbiAgICAgICAgdGhpcy5fY29udHJvbEhpZGVDbGFzcyA9ICdkZy1jb250cm9sLXJvdW5kX2lzLWhpZGRlbl90cnVlJztcblxuICAgICAgICBERy5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBERy5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgX2FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBfdHJhZmZpY0xheWVyOiBudWxsXG4gICAgICAgIH0pLm9uKHRoaXMuX2NvbnRyb2xFdmVudHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfY29udHJvbEV2ZW50czoge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhZmZpY0xheWVyID0gREcudHJhZmZpYygpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCd6b29tZW5kIHByb2plY3RjaGFuZ2UgcHJvamVjdGxlYXZlJywgdGhpcy5fdXBkYXRlQ29udHJvbFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBjbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSAhdGhpcy5fYWN0aXZlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1RyYWZmaWMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlkZVRyYWZmaWMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHRoaXMuX2NvbnRyb2xFdmVudHMsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignem9vbWVuZCBwcm9qZWN0Y2hhbmdlIHByb2plY3RsZWF2ZScsIHRoaXMuX3VwZGF0ZUNvbnRyb2xWaXNpYmlsaXR5LCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fdHJhZmZpY0xheWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RyYWZmaWNMYXllciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Nob3dUcmFmZmljOiBmdW5jdGlvbigpIHsgLy8gKClcbiAgICAgICAgdGhpcy5fdXBkYXRlVHJhZmZpY1Njb3JlKCk7XG4gICAgICAgIHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl90cmFmZmljTGF5ZXIpO1xuICAgIH0sXG5cbiAgICBfaGlkZVRyYWZmaWM6IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICB0aGlzLl9oYW5kbGVEb20oJ3JlbW92ZScpO1xuICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fdHJhZmZpY0xheWVyKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZURvbTogZnVuY3Rpb24obWV0aG9kLCBzY29yZSkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuX2xpbms7XG5cbiAgICAgICAgYS5pbm5lckhUTUwgPSBzY29yZSB8fCAnJztcbiAgICAgICAgREcuRG9tVXRpbFttZXRob2QgKyAnQ2xhc3MnXShhLCB0aGlzLl90cmFmZmljQ2xhc3MpO1xuICAgICAgICBERy5Eb21VdGlsW21ldGhvZCArICdDbGFzcyddKGEsIHRoaXMuX3RyYWZmaWNDbGFzcyArICdfY29sb3JfJyArIHRoaXMuX3Njb3JlUmF0ZSk7XG4gICAgfSxcblxuICAgIF9nZXRUcmFmZmljQ29sb3I6IGZ1bmN0aW9uKHNjb3JlKSB7IC8vIChOdW1iZXIpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ2dyZWVuJztcblxuICAgICAgICBpZiAoc2NvcmUgPiA3KSB7XG4gICAgICAgICAgICByZXN1bHQgPSAncmVkJztcbiAgICAgICAgfSBlbHNlIGlmIChzY29yZSA+IDQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICd5ZWxsb3cnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUNvbnRyb2xWaXNpYmlsaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLl9tYXAucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKSxcbiAgICAgICAgICAgIHByb2plY3RIYXNUcmFmZmljID0gcHJvamVjdCAmJiBwcm9qZWN0LnRyYWZmaWMsXG4gICAgICAgICAgICBtZXRob2QgPSAoKHRoaXMuX21hcC5nZXRab29tKCkgPCBERy5jb25maWcudHJhZmZpY0xheWVyTWluWm9vbSkgfHxcbiAgICAgICAgICAgICghcHJvamVjdEhhc1RyYWZmaWMpKSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnO1xuXG4gICAgICAgIERHLkRvbVV0aWxbbWV0aG9kXSh0aGlzLl9jb250YWluZXIsIHRoaXMuX2NvbnRyb2xIaWRlQ2xhc3MpO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlICYmIHByb2plY3RIYXNUcmFmZmljKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUcmFmZmljU2NvcmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlVHJhZmZpY1Njb3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2dldFRyYWZmaWNTY29yZSgpLnRoZW4oZnVuY3Rpb24oc2NvcmUpIHtcbiAgICAgICAgICAgIHNjb3JlID0gcGFyc2VJbnQoc2NvcmUsIDEwKTsgLy8gc29tZXRpbWVzIHdlYmFwaSByZXR1cm5zIHNvbWV0aGluZyBsaWtlICc1LCsnXG5cbiAgICAgICAgICAgIHNlbGYuX3Njb3JlUmF0ZSA9IHNlbGYuX2dldFRyYWZmaWNDb2xvcihzY29yZSk7XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVEb20oJ2FkZCcsIHNjb3JlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9nZXRUcmFmZmljU2NvcmU6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBQcm9taXNlXG4gICAgICAgIHZhciB1cmwgPSBERy5VdGlsLnRlbXBsYXRlKFxuICAgICAgICAgICAgREcuY29uZmlnLnByb3RvY29sICsgREcuY29uZmlnLnRyYWZmaWNTY29yZVNlcnZlcixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzOiB0aGlzLl90cmFmZmljTGF5ZXIuZ2V0U3ViZG9tYWluKCksXG4gICAgICAgICAgICAgICAgcHJvamVjdENvZGU6IHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLmNvZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gREcuYWpheCh1cmwsIHt0eXBlOiAnZ2V0J30pO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyVHJhbnNsYXRpb246IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICB0aGlzLl9saW5rLnRpdGxlID0gdGhpcy50KCdidXR0b25fdGl0bGUnKTtcbiAgICB9XG59KTtcblxuREcuY29udHJvbC50cmFmZmljID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuQ29udHJvbC5UcmFmZmljKG9wdGlvbnMpO1xufTtcblxuREcuTWFwLm1lcmdlT3B0aW9ucyh7XG4gICAgdHJhZmZpY0NvbnRyb2w6IGZhbHNlXG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudHJhZmZpY0NvbnRyb2wpIHtcbiAgICAgICAgdGhpcy50cmFmZmljQ29udHJvbCA9IERHLmNvbnRyb2wudHJhZmZpYyh0aGlzLm9wdGlvbnMudHJhZmZpY0NvbnRyb2wpO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2wodGhpcy50cmFmZmljQ29udHJvbCk7XG4gICAgfVxufSk7XG4iLCJERy5Db250cm9sLlRyYWZmaWMuRGljdGlvbmFyeS5ydSA9IHtcblx0YnV0dG9uX3RpdGxlOiAn0J/RgNC+0LHQutC4J1xufTtcbiIsIkRHLkNvbnRyb2wuVHJhZmZpYy5EaWN0aW9uYXJ5Lml0ID0ge1xuXHRidXR0b25fdGl0bGU6ICdDb2xvbm5hJ1xufTtcbiIsIkRHLkNvbnRyb2wuVHJhZmZpYy5EaWN0aW9uYXJ5LmNzID0ge1xuXHRidXR0b25fdGl0bGU6ICdaw6FjcHknXG59O1xuIiwiREcuQ29udHJvbC5UcmFmZmljLkRpY3Rpb25hcnkuZXMgPSB7XG5cdGJ1dHRvbl90aXRsZTogJ1RhY28nXG59O1xuIiwiREcuQ29udHJvbC5UcmFmZmljLkRpY3Rpb25hcnkuZW4gPSB7XG5cdGJ1dHRvbl90aXRsZTogJ1RyYWZmaWMnXG59O1xuIiwiREcuUnVsZXIgPSBERy5MYXllci5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBpbmNsdWRlczogW0RHLkxvY2FsZV0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGxhdGxuZ3MsIG9wdGlvbnMpIHsgLy8gKEFycmF5LCBPYmplY3QpXG4gICAgICAgIERHLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9sYXllcnMgPSB7XG4gICAgICAgICAgICBiYWNrIDogbnVsbCxcbiAgICAgICAgICAgIG1pZGRsZSA6IG51bGwsXG4gICAgICAgICAgICBmcm9udCA6IG51bGwsXG4gICAgICAgICAgICBtb3VzZSA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gW107XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJzQ29udGFpbmVyID0gREcuZmVhdHVyZUdyb3VwKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnNDb250YWluZXIuYWRkTGF5ZXIodGhpcy5fbGF5ZXJzW25hbWVdID0gREcuZmVhdHVyZUdyb3VwKCkpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9yZXNldCgpO1xuXG4gICAgICAgIGlmIChERy5Ccm93c2VyLm1vYmlsZSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpbmVNb3VzZUV2ZW50cy5tb3VzZW92ZXI7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGluZU1vdXNlRXZlbnRzLm1vdXNlb3V0O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpbmVNb3VzZUV2ZW50cy5tb3VzZW1vdmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGluZU1vdXNlRXZlbnRzLmNsaWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhdGxuZ3MgJiYgbGF0bG5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGF0TG5ncyhsYXRsbmdzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7IC8vIChNYXApXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcC5vbignbGFuZ2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc3RhbmNlLCB0aGlzKTtcblxuICAgICAgICAvLyAgUGFuZSBmb3IgcnVsZXIgTWFya2Vyc1xuICAgICAgICBpZiAoIXRoaXMuX21hcC5nZXRQYW5lKCdydWxlck1hcmtlclBhbmUnKSkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmNyZWF0ZVBhbmUoJ3J1bGVyTWFya2VyUGFuZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIE1haW4gcnVsZXIgcGFuZSAoc3ZnIG9iamVjdHMgYW5kIHJ1bm5lcilcbiAgICAgICAgaWYgKCF0aGlzLl9tYXAuZ2V0UGFuZSgncnVsZXJQYW5lJykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5jcmVhdGVQYW5lKCdydWxlclBhbmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xheWVyc0NvbnRhaW5lci5hZGRUbyh0aGlzLl9tYXApO1xuXG4gICAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnMubW91c2UuZmlyZSgnbGF5ZXJhZGQnKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpc3RhbmNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXllcnMubW91c2Uub24odGhpcy5fbGluZU1vdXNlRXZlbnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkgeyAvLyAoTWFwKVxuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5vZmYoJ2xhbmdjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXN0YW5jZSwgdGhpcylcbiAgICAgICAgICAgIC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNDb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMuX2xheWVycy5tb3VzZS5vZmYodGhpcy5fbGluZU1vdXNlRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICB9LFxuXG4gICAgZ2V0VG90YWxEaXN0YW5jZTogZnVuY3Rpb24oKSB7IC8vICgpIC0+IE51bWJlclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY0Rpc3RhbmNlKCk7XG4gICAgfSxcblxuICAgIHNwbGljZUxhdExuZ3M6IGZ1bmN0aW9uKGluZGV4KSB7IC8vIChOdW1iZXIsIE51bWJlciwgYXJncyAuLi4pIC0+IEFycmF5XG4gICAgICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLl9wb2ludHMubGVuZ3RoLFxuICAgICAgICAgICAgbXV0YXRpb25TdGFydCA9IGluZGV4ID49IDAgPyBNYXRoLm1pbihpbmRleCwgb2xkTGVuZ3RoKSA6IG9sZExlbmd0aCAtIGluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlZCA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkodGhpcy5fcG9pbnRzLCBhcmd1bWVudHMpLm1hcChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVycy5tb3VzZS5yZW1vdmVMYXllcihwb2ludCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50Lm9mZigpLmdldExhdExuZygpO1xuICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLl9wb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBtdXRhdGlvblN0YXJ0OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9wb2ludHNbaV0gaW5zdGFuY2VvZiBERy5SdWxlci5MYXllcmVkTWFya2VyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludHNbaV0gPSB0aGlzLl9jcmVhdGVQb2ludCh0aGlzLl9wb2ludHNbaV0sIHRoaXMub3B0aW9ucy5pY29uU3R5bGVzLmxhcmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKHRoaXMuX3BvaW50RXZlbnRzLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uY2UoJ2FkZCcsIHRoaXMuX2FkZENsb3NlSGFuZGxlciwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRUbyh0aGlzLl9sYXllcnMubW91c2UsIHRoaXMuX2xheWVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICYmICF0aGlzLl9wb2ludHNbaSAtIDFdLl9sZWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZExlZ3ModGhpcy5fcG9pbnRzW2kgLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1tpXS5zZXRQb2ludFN0eWxlKHRoaXMub3B0aW9ucy5pY29uU3R5bGVzW2kgJiYgaSA8IGxlbmd0aCAtIDEgPyAnc21hbGwnIDogJ2xhcmdlJ10pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1tpXS5fcG9zID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxlZ3ModGhpcy5fcG9pbnRzW2xlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGlmIChvbGRMZW5ndGggPiAwICYmIG9sZExlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1tvbGRMZW5ndGggLSAxXS5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BvaW50c1ttdXRhdGlvblN0YXJ0XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxlZ3ModGhpcy5fcG9pbnRzW211dGF0aW9uU3RhcnRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdXRhdGlvblN0YXJ0ID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1ttdXRhdGlvblN0YXJ0IC0gMV0uc2V0UG9pbnRTdHlsZSh0aGlzLm9wdGlvbnMuaWNvblN0eWxlcy5zbWFsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEaXN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplUnVsZXJQb2ludHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoREcuQnJvd3Nlci50b3VjaCAmJiB0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lTWFya2VySGVscGVyLmNvbGxhcHNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KCk7XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICBhZGRMYXRMbmc6IGZ1bmN0aW9uKGxhdGxuZykgeyAvLyAoTGF0TG5nKSAtPiBSdWxlclxuICAgICAgICB2YXIgbGFzdFBvaW50ID0gdGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgICBsYXRsbmcgPSBERy5sYXRMbmcobGF0bG5nKTtcblxuICAgICAgICBpZiAobGFzdFBvaW50KSB7XG4gICAgICAgICAgICBsYXRsbmcgPSB0aGlzLl9ub3JtYWxpemVMYXRMbmcobGF0bG5nLCBsYXN0UG9pbnQuZ2V0TGF0TG5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zcGxpY2VMYXRMbmdzKHRoaXMuX3BvaW50cy5sZW5ndGgsIDAsIGxhdGxuZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRMYXRMbmdzOiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gQXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50cy5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludC5nZXRMYXRMbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNldExhdExuZ3M6IGZ1bmN0aW9uKGxhdGxuZ3MpIHsgLy8gKEFycmF5KSAtPiBSdWxlclxuICAgICAgICB2YXIgYXJncyA9IGxhdGxuZ3Muc2xpY2UoKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KDAsIHRoaXMuX3BvaW50cy5sZW5ndGgpO1xuICAgICAgICB0aGlzLnNwbGljZUxhdExuZ3MuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICBERy5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgX2xpbmVNYXJrZXJIZWxwZXI6IG51bGwsXG4gICAgICAgICAgICBfbW9ycGhpbmdOb3c6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfbGluZU1vdXNlRXZlbnRzOiB7XG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LmxheWVyO1xuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIERHLk1hcmtlciAmJiB0YXJnZXQuX3BvcyAhPT0gdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGluZU1hcmtlckhlbHBlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lTWFya2VySGVscGVyLmNvbGxhcHNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UodGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlciA9IHRhcmdldDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgREcuUGF0aCAmJiB0aGlzLm9wdGlvbnMuZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF0bG5nID0gZXZlbnQubGF0bG5nLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRQb3MgPSB0YXJnZXQuX3BvaW50Ll9wb3MgKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BsaWNlTGF0TG5ncyhpbnNlcnRQb3MsIDAsIGxhdGxuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlb3ZlcjogZnVuY3Rpb24oZXZlbnQpIHsgLy8gKE1vdXNlRXZlbnQpXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQubGF5ZXI7XG5cbiAgICAgICAgICAgIHRhcmdldC5faG92ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9ycGhpbmdOb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgREcuTWFya2VyICYmIHRhcmdldC5fcG9zICE9PSB0aGlzLl9wb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UodGFyZ2V0KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIERHLlBhdGggJiYgIXRoaXMuX2xpbmVNYXJrZXJIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSB0YXJnZXQuX3BvaW50O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlciA9IHRoaXMuX2FkZFJ1bm5pbmdMYWJlbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVhcmVzdFBvaW50KHBvaW50Ll9sZWdzLm1pZGRsZSwgZXZlbnQubGF0bG5nKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24oZXZlbnQpIHsgLy8gKE1vdXNlRXZlbnQpXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQubGF5ZXIsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdiA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgICAgICAgIHRhcmdldC5faG92ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vcnBoaW5nTm93IHx8IHRhcmdldC5fcG9zID09PSB0aGlzLl9wb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBERy5NYXJrZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZSBvbmx5IHdoZW4gd2UgbW92ZSBvdXQgZnJvbSBsYWJlbCBjb250YWluZXIgKGlmIGJyb3dzZXIgc3VwcG9ydCByZWxhdGVkVGFyZ2V0KVxuICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxFdi5yZWxhdGVkVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgICAgIChvcmlnaW5hbEV2LnJlbGF0ZWRUYXJnZXQgIT09IHRhcmdldC5xdWVyeVNlbGVjdG9yKCdjb250YWluZXInKSAmJlxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2LnJlbGF0ZWRUYXJnZXQucGFyZW50Tm9kZSAhPT0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ2NvbnRhaW5lcicpKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY29sbGFwc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVJ1bm5pbmdMYWJlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vcnBoaW5nTm93IHx8ICF0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBldmVudC5sYXllci5fcG9pbnQsXG4gICAgICAgICAgICAgICAgbGF0bG5nID0gdGhpcy5fbmVhcmVzdFBvaW50KHBvaW50Ll9sZWdzLm1pZGRsZSwgZXZlbnQubGF0bG5nKTtcblxuICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlclxuICAgICAgICAgICAgICAgICAgICAuc2V0TGF0TG5nKGxhdGxuZylcbiAgICAgICAgICAgICAgICAgICAgLnNldFRleHQodGhpcy5fZ2V0Rm9ybWF0ZWREaXN0YW5jZShwb2ludCwgcG9pbnQuZ2V0TGF0TG5nKCkuZGlzdGFuY2VUbyhsYXRsbmcpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyYWRkOiBmdW5jdGlvbigpIHsgLy8gKClcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW25hbWVdLmJyaW5nVG9Gcm9udCgpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZpcmVDaGFuZ2VFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcsIHtsYXRsbmdzIDogdGhpcy5nZXRMYXRMbmdzKCl9KTtcbiAgICB9LFxuXG4gICAgX2FkZFJ1bm5pbmdMYWJlbDogZnVuY3Rpb24obGF0bG5nLCBwcmV2aW91c1BvaW50KSB7IC8vIChMYXRMbmcsIFJ1bGVyLkxheWVyZWRNYXJrZXIpXG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuX2NyZWF0ZVBvaW50KGxhdGxuZykuYWRkVG8odGhpcy5fbGF5ZXJzLm1vdXNlLCB0aGlzLl9sYXllcnMpO1xuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuX21hcC5nZXRQYW5lKCdydWxlclBhbmUnKTtcbiAgICAgICAgcGFuZS5pbnNlcnRCZWZvcmUocG9pbnQuX2ljb24sIHBhbmUubGFzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgIHJldHVybiBwb2ludC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UocHJldmlvdXNQb2ludCwgcHJldmlvdXNQb2ludC5nZXRMYXRMbmcoKS5kaXN0YW5jZVRvKGxhdGxuZykpKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVJ1bm5pbmdMYWJlbDogZnVuY3Rpb24oKSB7IC8vICgpXG4gICAgICAgIGlmICh0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnMubW91c2UucmVtb3ZlTGF5ZXIodGhpcy5fbGluZU1hcmtlckhlbHBlcik7XG4gICAgICAgICAgICB0aGlzLl9saW5lTWFya2VySGVscGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5zZXJ0UG9pbnRJbkxpbmU6IGZ1bmN0aW9uKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICB2YXIgbGF0bG5nID0gdGhpcy5fbGluZU1hcmtlckhlbHBlci5nZXRMYXRMbmcoKSxcbiAgICAgICAgICAgIGluc2VydFBvcyA9IGV2ZW50LnRhcmdldC5fcG9pbnQuX3BvcyArIDEsXG4gICAgICAgICAgICBwb2ludDtcblxuICAgICAgICBpZiAoTC5Ccm93c2VyLmllKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudGFyZ2V0IHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocGF0aCk7IC8vIElFIGNsaWNrIGV2ZW50IGxlYWtpbmcgcHJvYmxlbSBzb2x1dGlvbjogd2UgcmVhcHBlbmQgbW91c2Vkb3duIGV2ZW50IHRhcmdldCBlbGVtZW50XG4gICAgICAgIH1cblxuICAgICAgICBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldmVudC5vcmlnaW5hbEV2ZW50KTtcblxuICAgICAgICB0aGlzLnNwbGljZUxhdExuZ3MoaW5zZXJ0UG9zLCAwLCBsYXRsbmcpO1xuICAgICAgICBwb2ludCA9IHRoaXMuX3BvaW50c1tpbnNlcnRQb3NdO1xuICAgICAgICBwb2ludC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UocG9pbnQpKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgICAgICAgICAgICAgICBlLmluaXRNb3VzZUV2ZW50KCdtb3VzZXVwJywgZmFsc2UsIGZhbHNlLCBkb2N1bWVudC5kZWZhdWx0VmlldywgMSwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDEsIHBvaW50Ll9pY29uKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGUpO1xuXG4gICAgICAgICAgICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgICAgICAgICAgIGUuaW5pdE1vdXNlRXZlbnQoJ21vdXNlZG93bicsIGZhbHNlLCBmYWxzZSwgZG9jdW1lbnQuZGVmYXVsdFZpZXcsIDEsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAxLCBwb2ludC5faWNvbik7XG4gICAgICAgICAgICAgICAgcG9pbnQuX2ljb24uZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnQuX2ljb24uZmlyZUV2ZW50KCdvbk1vdXNlVXAnLCBERy5leHRlbmQoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKSwge1xuICAgICAgICAgICAgICAgICAgICBidXR0b246IDEsXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBwb2ludC5faWNvbi5maXJlRXZlbnQoJ29uTW91c2VEb3duJywgREcuZXh0ZW5kKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCksIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiAxLFxuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIHRoaXMuX3JlbW92ZVJ1bm5pbmdMYWJlbCgpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxlZ3MocG9pbnQpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSBwb2ludCBvbiBnaXZlbiBwb2x5bGluZSB3aGljaCBpcyBjbG9zZXN0IHRvIGdpdmVuIGxhdGxuZ1xuICAgIF9uZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKHBvbHlsaW5lLCBsYXRsbmcpIHsgLy8gKFBvbHlsaW5lLCBMYXRMbmcpIC0+IExhdExuZ1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gQ29udmVydCBldmVyeXRoaW5nIHRvIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuX3Byb2plY3QobGF0bG5nKTtcbiAgICAgICAgdmFyIGxpbmVQb2ludHMgPSBwb2x5bGluZS5nZXRMYXRMbmdzKCkubWFwKGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3Byb2plY3QobGF0bG5nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmlyc3QgbG9vayBmb3IgY2xvc2VzdCBwb2x5bGluZSBzZWdtZW50XG4gICAgICAgIHZhciBtaW5EaXN0YW5jZTtcbiAgICAgICAgdmFyIGNsb3Nlc3RTZWdtZW50SW5kZXg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IERHLkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UoXG4gICAgICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICAgICAgbGluZVBvaW50c1tpXSxcbiAgICAgICAgICAgICAgICBsaW5lUG9pbnRzW2kgKyAxXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKG1pbkRpc3RhbmNlID09PSB1bmRlZmluZWQgfHwgZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFNlZ21lbnRJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVuIGxvb2sgZm9yIGNsb3Nlc3QgcG9pbnQgb24gdGhhdCBzZWdtZW50XG4gICAgICAgIHZhciBjbG9zZXN0UG9pbnQgPSBERy5MaW5lVXRpbC5jbG9zZXN0UG9pbnRPblNlZ21lbnQoXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIGxpbmVQb2ludHNbY2xvc2VzdFNlZ21lbnRJbmRleF0sXG4gICAgICAgICAgICBsaW5lUG9pbnRzW2Nsb3Nlc3RTZWdtZW50SW5kZXggKyAxXVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENvbnZlcnQgYmFjayB0byBMYXRMbmdcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucHJvamVjdChjbG9zZXN0UG9pbnQpO1xuICAgIH0sXG5cbiAgICBfYWRkQ2xvc2VIYW5kbGVyOiBmdW5jdGlvbihldmVudCkgeyAvLyAoRXZlbnQpXG4gICAgICAgIGV2ZW50LnRhcmdldFxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCB0aGlzLl9kZWxldGVQb2ludCwgdGhpcylcbiAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvcigncmVtb3ZlLWxpbmsnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgfSxcblxuICAgIF9jcmVhdGVQb2ludDogZnVuY3Rpb24obGF0bG5nLCBzdHlsZSkgeyAvLyAoTGF0TG5nLCBPYmplY3QpIC0+IFJ1bGVyLkxheWVyZWRNYXJrZXJcbiAgICAgICAgdmFyIHBvaW50U3R5bGUgPSBzdHlsZSA/IHN0eWxlIDogdGhpcy5vcHRpb25zLmljb25TdHlsZXMubGFyZ2UsXG4gICAgICAgICAgICBsYXllcnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMocG9pbnRTdHlsZSkuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgbGF5ZXJzW2xheWVyXSA9IERHLmNpcmNsZU1hcmtlcihsYXRsbmcsIHBvaW50U3R5bGVbbGF5ZXJdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIERHLlJ1bGVyLmxheWVyZWRNYXJrZXIobGF0bG5nLCB7XG4gICAgICAgICAgICBsYXllcnMgOiBsYXllcnMsXG4gICAgICAgICAgICBkcmFnZ2FibGUgOiB0aGlzLm9wdGlvbnMuZWRpdGFibGVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIE1vdmVzIGN1cnIgTGF0TG5nIHRvIGNvcnJlY3Qgd29ybGQgaWYgbmVjZXNzYXJ5IHNvIHRoYXQgcnVsZXIgc2VjdGlvblxuICAgIC8vIGJldHdlZW4gY3VyciBhbmQgYmFzZSBjYW4gYmUgcGxvdHRlZCBjb3JyZWN0bHkuIFJldHVybnMgYSBuZXcgTGF0TG5nXG4gICAgLy8gb2JqZWN0LlxuICAgIF9ub3JtYWxpemVMYXRMbmc6IGZ1bmN0aW9uKGN1cnIsIGJhc2UpIHsgLy8gKExhdExuZywgTGF0TG5nKSAtPiBMYXRMbmdcbiAgICAgICAgdmFyIGRpZmYgPSAoY3Vyci5sbmcgPCBiYXNlLmxuZykgPyAzNjAgOiAtMzYwO1xuXG4gICAgICAgIHZhciBuZXdMbmcgPSBjdXJyLmxuZztcbiAgICAgICAgd2hpbGUgKE1hdGguYWJzKG5ld0xuZyAtIGJhc2UubG5nKSA+IDE4MCkge1xuICAgICAgICAgICAgbmV3TG5nICs9IGRpZmY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gREcubGF0TG5nKGN1cnIubGF0LCBuZXdMbmcpO1xuICAgIH0sXG5cbiAgICAvLyBSZWFycmFuZ2VzIHJ1bGVyIHBvaW50cyBiZXR3ZWVuIHdvcmxkcyBiYXNlZCBvbiBwb2ludCBwYXJhbSBzbyB0aGF0IGFsbFxuICAgIC8vIHJ1bGVyIHNlY3Rpb25zIGNhbiBiZSBwbG90dGVkIGNvcnJlY3RseS5cbiAgICBfbm9ybWFsaXplUnVsZXJQb2ludHM6IGZ1bmN0aW9uKHBvaW50KSB7IC8vIChSdWxlci5MYXllcmVkTWFya2VyKVxuICAgICAgICBwb2ludCA9IHBvaW50IHx8IHRoaXMuX3BvaW50c1swXTtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHBvaW50Ll9wb3M7XG4gICAgICAgIHZhciBjaGFuZ2VkUG9pbnRzID0gW107XG4gICAgICAgIHZhciBpLCBjdXJyUG9pbnQsIHByZXZQb2ludCwgbGF0bG5nLCBub3JtYWxpemVkO1xuXG4gICAgICAgIC8vIENoZWNrIHBvaW50cyB0byB0aGUgcmlnaHRcbiAgICAgICAgZm9yIChpID0gcG9zaXRpb24gKyAxOyBpIDwgdGhpcy5fcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyUG9pbnQgPSB0aGlzLl9wb2ludHNbaV07XG4gICAgICAgICAgICBwcmV2UG9pbnQgPSB0aGlzLl9wb2ludHNbaSAtIDFdO1xuXG4gICAgICAgICAgICBsYXRsbmcgPSBjdXJyUG9pbnQuZ2V0TGF0TG5nKCk7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdGhpcy5fbm9ybWFsaXplTGF0TG5nKGxhdGxuZywgcHJldlBvaW50LmdldExhdExuZygpKTtcblxuICAgICAgICAgICAgaWYgKCFub3JtYWxpemVkLmVxdWFscyhsYXRsbmcpKSB7XG4gICAgICAgICAgICAgICAgY3VyclBvaW50LnNldExhdExuZyhub3JtYWxpemVkKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkUG9pbnRzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBwb2ludHMgdG8gdGhlIGxlZnRcbiAgICAgICAgZm9yIChpID0gcG9zaXRpb24gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY3VyclBvaW50ID0gdGhpcy5fcG9pbnRzW2ldO1xuICAgICAgICAgICAgcHJldlBvaW50ID0gdGhpcy5fcG9pbnRzW2kgKyAxXTtcblxuICAgICAgICAgICAgbGF0bG5nID0gY3VyclBvaW50LmdldExhdExuZygpO1xuICAgICAgICAgICAgbm9ybWFsaXplZCA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhsYXRsbmcsIHByZXZQb2ludC5nZXRMYXRMbmcoKSk7XG5cbiAgICAgICAgICAgIGlmICghbm9ybWFsaXplZC5lcXVhbHMobGF0bG5nKSkge1xuICAgICAgICAgICAgICAgIGN1cnJQb2ludC5zZXRMYXRMbmcobm9ybWFsaXplZCk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZFBvaW50cy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGxlZ3Mgb2YgYWxsIHBvaW50cyB0aGF0IGNoYW5nZWQgcG9zaXRpb25cbiAgICAgICAgY2hhbmdlZFBvaW50cy5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgc2tpcFByZXZpb3VzID0gcHJldmlvdXMgJiYgcHJldmlvdXMgPT09IGN1cnJlbnQgLSAxO1xuXG4gICAgICAgICAgICBzZWxmLl91cGRhdGVMZWdzKHNlbGYuX3BvaW50c1tjdXJyZW50XSwgc2tpcFByZXZpb3VzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH0sIG51bGwpO1xuICAgIH0sXG5cbiAgICBfcG9pbnRFdmVudHM6IHtcbiAgICAgICAgZHJhZzogZnVuY3Rpb24oZXZlbnQpIHsgLy8gKEV2ZW50KVxuICAgICAgICAgICAgdmFyIHBvaW50ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVSdWxlclBvaW50cyhwb2ludCk7XG5cbiAgICAgICAgICAgIGlmICghREcuQnJvd3Nlci50b3VjaCAmJiBwb2ludCAhPT0gdGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHBvaW50LnNldFRleHQodGhpcy5fZ2V0Rm9ybWF0ZWREaXN0YW5jZShwb2ludCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMZWdzKHBvaW50KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpc3RhbmNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdlbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7IC8vIChFdmVudClcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuX21vcnBoaW5nTm93ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXBvaW50Ll9ob3ZlcmVkICYmIHBvaW50ICE9PSB0aGlzLl9wb2ludHNbdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQuY29sbGFwc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnc3RhcnQ6IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICAgICAgaWYgKERHLkJyb3dzZXIudG91Y2ggJiYgdGhpcy5fbGluZU1hcmtlckhlbHBlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVNYXJrZXJIZWxwZXIuY29sbGFwc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21vcnBoaW5nTm93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZGVsZXRlUG9pbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICB0YXJnZXQgPSBvcmlnaW5hbEV2ZW50LnRhcmdldCAgfHwgb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50O1xuXG4gICAgICAgIGlmICh0YXJnZXQuY2xhc3NOYW1lICE9PSAnZGctcnVsZXJfX2xhYmVsLXJlbW92ZS1saW5rJyAmJlxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTmFtZSAhPT0gJ2RnLXJ1bGVyX19yZW1vdmUtbGluay1vdmVybGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIERHLkRvbUV2ZW50LnN0b3AoZXZlbnQub3JpZ2luYWxFdmVudCk7XG4gICAgICAgIHRoaXMuc3BsaWNlTGF0TG5ncyhldmVudC50YXJnZXQuX3BvcywgMSk7XG4gICAgfSxcblxuICAgIF9kZWdUb1JhZDogZnVuY3Rpb24oZGVnKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5QSSAvIDE4MCkgKiBkZWc7XG4gICAgfSxcblxuICAgIF9yYWRUb0RlZzogZnVuY3Rpb24ocmFkKSB7XG4gICAgICAgIHJldHVybiAoMTgwIC8gTWF0aC5QSSkgKiByYWQ7XG4gICAgfSxcblxuICAgIC8vIE1hcC1pbmRlcGVuZGVudCBwcm9qZWN0IG1ldGhvZFxuICAgIF9wcm9qZWN0OiBmdW5jdGlvbihsYXRsbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5wcm9qZWN0KGxhdGxuZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gREcuQ1JTLkVQU0czODU3LmxhdExuZ1RvUG9pbnQobGF0bG5nLCAxKTtcbiAgICB9LFxuXG4gICAgLy8gTWFwLWluZGVwZW5kZW50IHVucHJvamVjdCBtZXRob2RcbiAgICBfdW5wcm9qZWN0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnVucHJvamVjdChwb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gREcuQ1JTLkVQU0czODU3LnBvaW50VG9MYXRMbmcocG9pbnQsIDEpO1xuICAgIH0sXG5cbiAgICAvLyBDYWxjdWxhdGVzIHRoZSBzaXplIG9mIGFuZ2xlIHBvaW50MS1wb2ludC1wb2ludDJcbiAgICBfY2FsY0FuZ2xlOiBmdW5jdGlvbihwb2ludCwgcG9pbnQxLCBwb2ludDIpIHsgLy8gKExhdExuZywgTGF0TG5nLCBMYXRMbmcpIC0+IE51bWJlclxuICAgICAgICBwb2ludDEgPSB0aGlzLl9ub3JtYWxpemVMYXRMbmcocG9pbnQxLCBwb2ludCk7XG4gICAgICAgIHBvaW50MiA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhwb2ludDIsIHBvaW50KTtcblxuICAgICAgICBwb2ludCA9IHRoaXMuX3Byb2plY3QocG9pbnQpO1xuICAgICAgICBwb2ludDEgPSB0aGlzLl9wcm9qZWN0KHBvaW50MSk7XG4gICAgICAgIHBvaW50MiA9IHRoaXMuX3Byb2plY3QocG9pbnQyKTtcblxuICAgICAgICB2YXIgeDEgPSBwb2ludDEueCAtIHBvaW50Lng7XG4gICAgICAgIHZhciB4MiA9IHBvaW50Mi54IC0gcG9pbnQueDtcbiAgICAgICAgdmFyIHkxID0gcG9pbnQxLnkgLSBwb2ludC55O1xuICAgICAgICB2YXIgeTIgPSBwb2ludDIueSAtIHBvaW50Lnk7XG5cbiAgICAgICAgdmFyIGRvdFByb2R1Y3QgPSB4MSAqIHgyICsgeTEgKiB5MjtcbiAgICAgICAgdmFyIG1hZzEgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpO1xuICAgICAgICB2YXIgbWFnMiA9IE1hdGguc3FydCh4MiAqIHgyICsgeTIgKiB5Mik7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhkb3RQcm9kdWN0IC8gKG1hZzEgKiBtYWcyKSk7XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZXMgdGhlIG1pZHBvaW50IG9uIHRoZSBncmVhdCBjaXJjbGUgYmV0d2VlbiB0d28gTGF0TG5nc1xuICAgIF9jYWxjTWlkUG9pbnQ6IGZ1bmN0aW9uKGxhdGxuZzEsIGxhdGxuZzIpIHsgLy8gKExhdExuZywgTGF0TG5nKSAtPiBMYXRMbmdcbiAgICAgICAgdmFyIGxvbjEgPSB0aGlzLl9kZWdUb1JhZChsYXRsbmcxLmxuZyk7XG4gICAgICAgIHZhciBsYXQxID0gdGhpcy5fZGVnVG9SYWQobGF0bG5nMS5sYXQpO1xuXG4gICAgICAgIHZhciBsb24yID0gdGhpcy5fZGVnVG9SYWQobGF0bG5nMi5sbmcpO1xuICAgICAgICB2YXIgbGF0MiA9IHRoaXMuX2RlZ1RvUmFkKGxhdGxuZzIubGF0KTtcblxuICAgICAgICAvLyBCYXNlZCBvbiBmb3JtdWxhZSBmcm9tXG4gICAgICAgIC8vIGh0dHA6Ly93aWxsaWFtcy5iZXN0LnZ3aC5uZXQvYXZmb3JtLmh0bSNJbnRlcm1lZGlhdGVcbiAgICAgICAgdmFyIGQgPSBNYXRoLmFjb3MoTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQyKSArXG4gICAgICAgICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG9uMSAtIGxvbjIpKTtcblxuICAgICAgICAvLyBTcGxpdCB0aGUgYXJjIGluIGhhbGZcbiAgICAgICAgdmFyIGYgPSAwLjU7XG5cbiAgICAgICAgdmFyIEEgPSBNYXRoLnNpbigoMSAtIGYpICogZCkgLyBNYXRoLnNpbihkKTtcbiAgICAgICAgdmFyIEIgPSBNYXRoLnNpbihmICogZCkgLyBNYXRoLnNpbihkKTtcblxuICAgICAgICB2YXIgeCA9IEEgKiBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxvbjEpICtcbiAgICAgICAgICAgIEIgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKGxvbjIpO1xuXG4gICAgICAgIHZhciB5ID0gQSAqIE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obG9uMSkgK1xuICAgICAgICAgICAgQiAqIE1hdGguY29zKGxhdDIpICogTWF0aC5zaW4obG9uMik7XG5cbiAgICAgICAgdmFyIHogPSBBICogTWF0aC5zaW4obGF0MSkgKyBCICogTWF0aC5zaW4obGF0Mik7XG5cbiAgICAgICAgdmFyIGxhdCA9IE1hdGguYXRhbjIoeiwgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKTtcbiAgICAgICAgdmFyIGxvbiA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgICAgICAgcmV0dXJuIERHLmxhdExuZyh0aGlzLl9yYWRUb0RlZyhsYXQpLCB0aGlzLl9yYWRUb0RlZyhsb24pKTtcbiAgICB9LFxuXG4gICAgLy8gQWRhcHRpdmUgc2FtcGxpbmcgYWxnb3JpdGhtIGJhc2VkIG9uXG4gICAgLy8gaHR0cDovL2FyaWVsLmNocm9ub3RleHQub3JnL2RkL2RlZmlndWVpcmVkbzkzYWRhcHRpdmUucGRmXG4gICAgX2FkYXB0aXZlU2FtcGxlOiBmdW5jdGlvbihsZWZ0LCByaWdodCwgZGVwdGgsIG1pZGRsZSkgeyAvLyAoTGF0TG5nLCBMYXRMbmcsIE51bWJlclssIExhdExuZ10pIC0+IExhdExuZ1tdXG4gICAgICAgIGlmIChkZXB0aCA+IDkpIHtcbiAgICAgICAgICAgIC8vIE1heCByZWN1cnNpb24gZGVwdGggcmVhY2hlZFxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgbWlkZGxlID0gbWlkZGxlIHx8IHRoaXMuX2NhbGNNaWRQb2ludChsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgdmFyIGxlZnRNaWRkbGUgPSB0aGlzLl9jYWxjTWlkUG9pbnQobGVmdCwgbWlkZGxlKTtcbiAgICAgICAgdmFyIHJpZ2h0TWlkZGxlID0gdGhpcy5fY2FsY01pZFBvaW50KG1pZGRsZSwgcmlnaHQpO1xuXG4gICAgICAgIHZhciBhbmdsZTEgPSB0aGlzLl9jYWxjQW5nbGUobGVmdE1pZGRsZSwgbWlkZGxlLCBsZWZ0KTtcbiAgICAgICAgdmFyIGFuZ2xlMiA9IHRoaXMuX2NhbGNBbmdsZShtaWRkbGUsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdmFyIGFuZ2xlMyA9IHRoaXMuX2NhbGNBbmdsZShyaWdodE1pZGRsZSwgbWlkZGxlLCByaWdodCk7XG5cbiAgICAgICAgLy8gbGVmdCAtLS0gbGVmdE1pZGRsZSAtLS0gbWlkZGxlIC0tLSByaWdodE1pZGRsZSAtLS0gcmlnaHRcbiAgICAgICAgLy8gICAgICAgICAgICBhbmdsZTEgICAgICAgYW5nbGUyICAgICAgIGFuZ2xlM1xuXG4gICAgICAgIHZhciBtaW5BbmdsZSA9IDMuMTtcbiAgICAgICAgaWYgKGFuZ2xlMSA+IG1pbkFuZ2xlICYmIGFuZ2xlMiA+IG1pbkFuZ2xlICYmIGFuZ2xlMyA+IG1pbkFuZ2xlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgc3RyYWlnaHQgZW5vdWdoLCBubyBpbnRlcm1lZGlhdGUgcG9pbnRzIG5lZWRlZC5cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFuZ2xlcyBhcmUgdG9vIHNtYWxsLiBSZWN1cnNpdmVseSBzYW1wbGUgaGFsdmVzIG9mIHRoaXMgc2VjdGlvbi5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5fYWRhcHRpdmVTYW1wbGUobGVmdCwgbWlkZGxlLCBkZXB0aCArIDEsIGxlZnRNaWRkbGUpKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1pZGRsZSk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuX2FkYXB0aXZlU2FtcGxlKG1pZGRsZSwgcmlnaHQsIGRlcHRoICsgMSwgcmlnaHRNaWRkbGUpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDYWxjdWxhdGVzIHRoZSBncmVhdCBjaXJjbGUgYXJjIGJldHdlZW4gdHdvIExhdExuZ3MuXG4gICAgX2NhbGNHcmVhdENpcmNsZTogZnVuY3Rpb24obGF0bG5nMSwgbGF0bG5nMikgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIC0+IExhdExuZ1tdXG4gICAgICAgIGxhdGxuZzIgPSB0aGlzLl9ub3JtYWxpemVMYXRMbmcobGF0bG5nMiwgbGF0bG5nMSk7XG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBwb2ludHMgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXIgKHdpdGhpbiAxIGRlZ3JlZSlcbiAgICAgICAgaWYgKGxhdGxuZzEuZXF1YWxzKGxhdGxuZzIsIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2xhdGxuZzEsIGxhdGxuZzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiB0aGUgZ3JlYXQgY2lyY2xlIGNyb3NzZXMgYSBwb2xlXG4gICAgICAgIGlmIChNYXRoLmFicyhsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSA9PSAxODApIHtcbiAgICAgICAgICAgIC8vIE5vcnRoIG9yIHNvdXRoIHBvbGU/XG4gICAgICAgICAgICB2YXIgbGF0aXR1ZGUgPSAobGF0bG5nMS5sYXQgKyBsYXRsbmcyLmxhdCA+IDApID8gOTAgOiAtOTA7XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbGF0bG5nMSxcbiAgICAgICAgICAgICAgICBERy5sYXRMbmcobGF0aXR1ZGUsIGxhdGxuZzEubG5nKSxcbiAgICAgICAgICAgICAgICBERy5sYXRMbmcobGF0aXR1ZGUsIGxhdGxuZzIubG5nKSxcbiAgICAgICAgICAgICAgICBsYXRsbmcyXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKGxhdGxuZzEpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuX2FkYXB0aXZlU2FtcGxlKGxhdGxuZzEsIGxhdGxuZzIsIDApKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobGF0bG5nMik7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBhcmMgZG9lc24ndCBqdW1wIGJldHdlZW4gd29ybGRzXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLl9ub3JtYWxpemVMYXRMbmcocmVzdWx0W2ldLCByZXN1bHRbaSAtIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9hZGRMZWdzOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB2YXIgcGF0aFN0eWxlcyA9IHRoaXMub3B0aW9ucy5wYXRoU3R5bGVzO1xuXG4gICAgICAgIHZhciBncmVhdENpcmNsZVBvaW50cyA9IHRoaXMuX2NhbGNHcmVhdENpcmNsZShcbiAgICAgICAgICAgIHBvaW50LmdldExhdExuZygpLFxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzW3BvaW50Ll9wb3MgKyAxXS5nZXRMYXRMbmcoKVxuICAgICAgICApO1xuXG4gICAgICAgIHBvaW50Ll9sZWdzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHBhdGhTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIHBvaW50Ll9sZWdzW2xheWVyXSA9IERHLnBvbHlsaW5lKGdyZWF0Q2lyY2xlUG9pbnRzLCBwYXRoU3R5bGVzW2xheWVyXSkuYWRkVG8odGhpcy5fbGF5ZXJzW2xheWVyXSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHBvaW50Ll9sZWdzLm1vdXNlLl9wb2ludCA9IHBvaW50Lm9uY2UoJ3JlbW92ZScsIHRoaXMuX2NsZWFyUmVtb3ZpbmdQb2ludExlZ3MsIHRoaXMpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdGFibGUgJiYgIURHLkJyb3dzZXIubW9iaWxlKSB7XG4gICAgICAgICAgICBwb2ludC5fbGVncy5tb3VzZS5vbignbW91c2Vkb3duJywgdGhpcy5faW5zZXJ0UG9pbnRJbkxpbmUsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLm1vdXNlLmFkZExheWVyKHBvaW50Ll9sZWdzLm1vdXNlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYXJSZW1vdmluZ1BvaW50TGVnczogZnVuY3Rpb24oZXZlbnQpIHsgLy8gKEV2ZW50KVxuICAgICAgICB0aGlzLl9yZW1vdmVMZWdzKGV2ZW50LnRhcmdldCk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVMZWdzOiBmdW5jdGlvbihwb2ludCkgeyAvLyAoUnVsZXIuTGF5ZXJlZE1hcmtlcilcbiAgICAgICAgaWYgKHBvaW50Ll9sZWdzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwb2ludC5fbGVncykuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyc1tsYXllcl0ucmVtb3ZlTGF5ZXIocG9pbnQuX2xlZ3NbbGF5ZXJdKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgcG9pbnQuX2xlZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGVMZWdzOiBmdW5jdGlvbihwb2ludCwgc2tpcFByZXZpb3VzKSB7IC8vIChSdWxlci5MYXllcmVkTWFya2VyLCBCb29sZWFuKVxuICAgICAgICB2YXIgbGF0bG5nID0gcG9pbnQuZ2V0TGF0TG5nKCksXG4gICAgICAgICAgICBwcmV2aW91c1BvaW50ID0gdGhpcy5fcG9pbnRzW3BvaW50Ll9wb3MgLSAxXSxcbiAgICAgICAgICAgIG5leHRQb2ludCA9IHRoaXMuX3BvaW50c1twb2ludC5fcG9zICsgMV0sXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIG5ld1BvaW50cztcblxuICAgICAgICBpZiAocHJldmlvdXNQb2ludCAmJiAhc2tpcFByZXZpb3VzKSB7XG4gICAgICAgICAgICBuZXdQb2ludHMgPSBzZWxmLl9jYWxjR3JlYXRDaXJjbGUocHJldmlvdXNQb2ludC5nZXRMYXRMbmcoKSwgbGF0bG5nKTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJldmlvdXNQb2ludC5fbGVncykuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9pbnQuX2xlZ3NbbGF5ZXJdLnNldExhdExuZ3MobmV3UG9pbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQb2ludCkge1xuICAgICAgICAgICAgbmV3UG9pbnRzID0gc2VsZi5fY2FsY0dyZWF0Q2lyY2xlKGxhdGxuZywgbmV4dFBvaW50LmdldExhdExuZygpKTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMocG9pbnQuX2xlZ3MpLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwb2ludC5fbGVnc1tsYXllcl0uc2V0TGF0TG5ncyhuZXdQb2ludHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NhbGNEaXN0YW5jZTogZnVuY3Rpb24oZmluaXNoUG9pbnQsIHRhaWwpIHsgLy8gKFJ1bGVyLkxheWVyZWRNYXJrZXIsIE51bWJlcikgLT4gTnVtYmVyXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHRhaWwgPyB0YWlsIDogMCxcbiAgICAgICAgICAgIGNhbGNUbyA9IGZpbmlzaFBvaW50ID8gZmluaXNoUG9pbnQuX3BvcyA6IHRoaXMuX3BvaW50cy5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsY1RvOyBpKyspIHtcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHRoaXMuX3BvaW50c1tpXS5nZXRMYXRMbmcoKS5kaXN0YW5jZVRvKHRoaXMuX3BvaW50c1tpICsgMV0uZ2V0TGF0TG5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xuICAgIH0sXG5cbiAgICBfZ2V0Rm9ybWF0ZWREaXN0YW5jZTogZnVuY3Rpb24oKSB7IC8vICgpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLl9jYWxjRGlzdGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHVuaXRzID0gJ20nO1xuXG4gICAgICAgIGlmIChkaXN0YW5jZSA+IDEwMDApIHtcbiAgICAgICAgICAgIGRpc3RhbmNlIC89IDEwMDA7XG4gICAgICAgICAgICB1bml0cyA9ICdrbSc7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAxMDAwKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZS50b0ZpeGVkKCk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZS5zbGljZSgwLCAtMykgKyAnICcgKyBkaXN0YW5jZS5zbGljZSgtMyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2UudG9GaXhlZCgyKS5zcGxpdCgnLicpLmpvaW4odGhpcy50KCdkZWxpbWl0ZXInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGgucm91bmQoZGlzdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtkaXN0YW5jZSB8fCAwLCAnICcsIHRoaXMudCh1bml0cyldLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlRGlzdGFuY2U6IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICBpZiAodGhpcy5fbWFwICYmIHRoaXMuX3BvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV0uc2V0VGV4dCh0aGlzLl9nZXRGb3JtYXRlZERpc3RhbmNlKCkpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLnJ1bGVyID0gZnVuY3Rpb24obGF0bG5ncywgb3B0aW9ucykgeyAvLyAoQXJyYXksIE9iamVjdClcbiAgICByZXR1cm4gbmV3IERHLlJ1bGVyKGxhdGxuZ3MsIG9wdGlvbnMpO1xufTtcbiIsIkRHLlJ1bGVyLkxheWVyZWRNYXJrZXIgPSBERy5NYXJrZXIuZXh0ZW5kKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICAgIGtleWJvYXJkOiBmYWxzZSxcbiAgICAgICAgcmlzZU9uSG92ZXI6IHRydWUsXG4gICAgICAgIHBhbmU6ICdydWxlck1hcmtlclBhbmUnLFxuICAgICAgICBpY29uSFRNTDogW1xuICAgICAgICAgICAgJzxpbWcgY2xhc3M9XCJkZy1ydWxlcl9fbGFiZWwtc3BhY2VyXCIgc3JjPVwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3XCIgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgLz4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJkZy1ydWxlcl9fbGFiZWwtY29udGFpbmVyXCI+JyxcbiAgICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cImRnLXJ1bGVyX19wb2ludFwiPjwvZGl2PicsXG4gICAgICAgICAgICAnICAgIDxzcGFuIGNsYXNzPVwiZGctcnVsZXJfX2xhYmVsLWRpc3RhbmNlXCI+MCDQutC8PC9zcGFuPicsXG4gICAgICAgICAgICAnICAgIDxzcGFuIGNsYXNzPVwiZGctcnVsZXJfX2xhYmVsLXJlbW92ZS1saW5rXCI+PC9zcGFuPicsXG4gICAgICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJkZy1ydWxlcl9fcmVtb3ZlLWxpbmstb3ZlcmxheVwiPjwvZGl2PicsXG4gICAgICAgICAgICAnPC9kaXY+J1xuICAgICAgICBdLmpvaW4oJ1xcbicpXG4gICAgfSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgZG9tQ2xhc3MgOiAnZGctcnVsZXJfX2xhYmVsJ1xuICAgIH0sXG5cbiAgICBhZGRUbyA6IGZ1bmN0aW9uKG1hcCwgbGF5ZXJzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBsYXllcnNbbmFtZV0uYWRkTGF5ZXIodGhpcy5fbGF5ZXJzW25hbWVdKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fdmlld3BvcnQgPSBsYXllcnM7XG4gICAgICAgIHJldHVybiBERy5NYXJrZXIucHJvdG90eXBlLmFkZFRvLmNhbGwodGhpcy5vbignbW92ZScsIHRoaXMuX29uTW92ZSksIG1hcCk7XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlIDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydFtuYW1lXS5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbbmFtZV0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5vZmYoJ21vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICB0aGlzLl92aWV3cG9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIERHLk1hcmtlci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgIH0sXG5cbiAgICBzZXRUZXh0IDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICBpZiAodGhpcy5faWNvbkNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pY29uTm9kZXMubGFiZWwuaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFBvaW50U3R5bGUgOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5fc3R5bGUgIT09IHN0eWxlKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zdHlsZSA9IHN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbbmFtZV0uc2V0U3R5bGUoc3R5bGVbbmFtZV0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGV4cGFuZCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9pY29uQ29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ljb25Ob2Rlcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuX2ljb25Ob2Rlcy5zcGFjZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNvbGxhcHNlIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2ljb25Db2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pY29uTm9kZXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2ljb25Ob2Rlcy5zcGFjZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBxdWVyeVNlbGVjdG9yIDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ljb24ucXVlcnlTZWxlY3RvcignLicgKyBERy5SdWxlci5MYXllcmVkTWFya2VyLmRvbUNsYXNzICsgJy0nICsgc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICBfb25Nb3ZlIDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGxhdGxuZyA9IGV2ZW50LmxhdGxuZztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbGF5ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tuYW1lXS5zZXRMYXRMbmcobGF0bG5nKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9pbml0SWNvbiA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBERy5NYXJrZXIucHJvdG90eXBlLl9pbml0SWNvbi5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9pY29uQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faWNvbi5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICB0aGlzLl9pY29uTm9kZXMgPSB7XG4gICAgICAgICAgICBsYWJlbCA6IHRoaXMucXVlcnlTZWxlY3RvcignZGlzdGFuY2UnKSxcbiAgICAgICAgICAgIHNwYWNlciA6IHRoaXMucXVlcnlTZWxlY3Rvcignc3BhY2VyJyksXG4gICAgICAgICAgICBjb250YWluZXIgOiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2NvbnRhaW5lcicpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIGRvbid0IGNoYW5nZSBpY29uIHpJbmRleFxuICAgIF9zZXRQb3M6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICBMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcblxuICAgICAgICBpZiAodGhpcy5fc2hhZG93KSB7XG4gICAgICAgICAgICBMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9hZnRlckluaXQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJzID0gdGhpcy5vcHRpb25zLmxheWVycyB8fCBudWxsO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaWNvbiA9IERHLmRpdkljb24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBERy5SdWxlci5MYXllcmVkTWFya2VyLmRvbUNsYXNzLFxuICAgICAgICAgICAgaWNvblNpemU6IFsyNiwgMjZdLFxuICAgICAgICAgICAgaWNvbkFuY2hvcjogWzEzLCAxM10sXG4gICAgICAgICAgICBodG1sOiB0aGlzLm9wdGlvbnMuaWNvbkhUTUxcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuREcuUnVsZXIuTGF5ZXJlZE1hcmtlci5hZGRJbml0SG9vaygnX2FmdGVySW5pdCcpO1xuXG5ERy5SdWxlci5sYXllcmVkTWFya2VyID0gZnVuY3Rpb24obGF0bG5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBERy5SdWxlci5MYXllcmVkTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59O1xuIiwidmFyIHJ1bGVyUmVuZGVyZXIgPSBERy5zdmcoe3BhbmU6ICdydWxlclBhbmUnfSk7XG52YXIgaG92ZXJSZW5kZXJlciA9IERHLnN2Zyh7cGFuZTogJ3J1bGVyUGFuZSd9KTtcblxuREcuUnVsZXIubWVyZ2VPcHRpb25zKHtcbiAgICBwYXRoU3R5bGVzOiB7XG4gICAgICAgIGJhY2s6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgd2VpZ2h0OiAxMixcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICAgIG5vQ2xpcDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyLFxuICAgICAgICAgICAgc21vb3RoRmFjdG9yOiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1pZGRsZToge1xuICAgICAgICAgICAgY29sb3I6ICcjMGRhNWQ1JyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB3ZWlnaHQ6IDQsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICBub0NsaXA6IHRydWUsXG4gICAgICAgICAgICByZW5kZXJlcjogcnVsZXJSZW5kZXJlcixcbiAgICAgICAgICAgIHNtb290aEZhY3RvcjogMFxuICAgICAgICB9LFxuICAgICAgICBtb3VzZToge1xuICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IERHLkJyb3dzZXIudm1sID8gMC4xIDogMCxcbiAgICAgICAgICAgIHdlaWdodDogREcuQnJvd3Nlci50b3VjaCA/IDQwIDogMjAsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAncGFpbnRlZCcsXG4gICAgICAgICAgICBub0NsaXA6IHRydWUsXG4gICAgICAgICAgICByZW5kZXJlcjogaG92ZXJSZW5kZXJlcixcbiAgICAgICAgICAgIHNtb290aEZhY3RvcjogMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBpY29uU3R5bGVzOiB7XG4gICAgICAgIGxhcmdlOiB7XG4gICAgICAgICAgICBiYWNrOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDEzLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWlkZGxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMGRhNWQ1JyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9udDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjMGRhNWQ1JyxcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IDQsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiA1LFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNtYWxsOiB7XG4gICAgICAgICAgICBiYWNrOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtaWRkbGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnIzBkYTVkNScsXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiAxLFxuICAgICAgICAgICAgICAgIHJhZGl1czogNSxcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogcnVsZXJSZW5kZXJlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb250OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogNCxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDIsXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiREcuUnVsZXIuRGljdGlvbmFyeS5ydSA9IHtcblx0a20gOiAn0LrQvCcsXG5cdG0gOiAn0LwnLFxuXHRkZWxpbWl0ZXIgOiAnLCdcbn07XG4iLCJERy5SdWxlci5EaWN0aW9uYXJ5Lml0ID0ge1xuXHRrbSA6ICdrbScsXG5cdG0gOiAnbScsXG5cdGRlbGltaXRlciA6ICcsJ1xufTsiLCJERy5SdWxlci5EaWN0aW9uYXJ5LmNzID0ge1xuXHRrbTogJ2ttJyxcblx0bTogJ20nLFxuXHRkZWxpbWl0ZXI6ICcsJ1xufTsiLCJERy5SdWxlci5EaWN0aW9uYXJ5LmVzID0ge1xuXHRrbSA6ICdrbScsXG5cdG0gOiAnbScsXG5cdGRlbGltaXRlciA6ICcsJ1xufTsiLCJERy5SdWxlci5EaWN0aW9uYXJ5LmVuID0ge1xuXHRrbSA6ICdrbScsXG5cdG0gOiAnbScsXG5cdGRlbGltaXRlciA6ICcuJ1xufTtcbiIsIkRHLkNvbnRyb2wuUnVsZXIgPSBERy5Sb3VuZENvbnRyb2wuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3ByaWdodCcsXG4gICAgICAgIGljb25DbGFzczogJ3J1bGVyJ1xuICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgREcuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgREcuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIF9hY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgX2RyYXdpbmdIZWxwZXI6IG51bGwsXG4gICAgICAgICAgICBfZ2VvY2xpY2tlck5lZWRSZXN0b3JlOiBmYWxzZVxuICAgICAgICB9KS5vbih0aGlzLl9jb250cm9sRXZlbnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2NvbnRyb2xFdmVudHM6IHtcbiAgICAgICAgYWRkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdpbmdIZWxwZXIgPSBERy5ydWxlcihbXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9ICF0aGlzLl9hY3RpdmU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydERyYXdpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluaXNoRHJhd2luZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5vZmYodGhpcy5fY29udHJvbEV2ZW50cywgdGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2RyYXdpbmdIZWxwZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZHJhd2luZ0hlbHBlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3N0YXJ0RHJhd2luZzogZnVuY3Rpb24oKSB7IC8vICgpXG4gICAgICAgIHRoaXMuX21hcFxuICAgICAgICAgICAgLmFkZExheWVyKHRoaXMuX2RyYXdpbmdIZWxwZXIpXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgdGhpcy5faGFuZGxlTWFwQ2xpY2ssIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX21hcC5maXJlKCdydWxlcnN0YXJ0Jyk7XG4gICAgfSxcblxuICAgIF9maW5pc2hEcmF3aW5nOiBmdW5jdGlvbigpIHsgLy8gKClcbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAub2ZmKCdjbGljaycsIHRoaXMuX2hhbmRsZU1hcENsaWNrLCB0aGlzKVxuICAgICAgICAgICAgLnJlbW92ZUxheWVyKHRoaXMuX2RyYXdpbmdIZWxwZXIpO1xuXG4gICAgICAgIHRoaXMuX2RyYXdpbmdIZWxwZXIuc2V0TGF0TG5ncyhbXSk7XG5cbiAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3J1bGVyZW5kJyk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVNYXBDbGljazogZnVuY3Rpb24oZXZlbnQpIHsgLy8gKE1vdXNlRXZlbnRzKVxuICAgICAgICB0aGlzLl9kcmF3aW5nSGVscGVyLmFkZExhdExuZyhldmVudC5sYXRsbmcpO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyVHJhbnNsYXRpb246IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICB0aGlzLl9saW5rLnRpdGxlID0gdGhpcy50KCdidXR0b25fdGl0bGUnKTtcbiAgICB9XG59KTtcblxuREcuY29udHJvbC5ydWxlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLkNvbnRyb2wuUnVsZXIob3B0aW9ucyk7XG59O1xuXG5ERy5NYXAubWVyZ2VPcHRpb25zKHtcbiAgICBydWxlckNvbnRyb2w6IGZhbHNlXG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucnVsZXJDb250cm9sKSB7XG4gICAgICAgIHRoaXMucnVsZXJDb250cm9sID0gREcuY29udHJvbC5ydWxlcih0aGlzLm9wdGlvbnMucnVsZXJDb250cm9sKTtcbiAgICAgICAgdGhpcy5hZGRDb250cm9sKHRoaXMucnVsZXJDb250cm9sKTtcbiAgICB9XG59KTtcbiIsIkRHLkNvbnRyb2wuUnVsZXIuRGljdGlvbmFyeS5ydSA9IHtcblx0YnV0dG9uX3RpdGxlOiAn0JvQuNC90LXQudC60LAnXG59OyIsIkRHLkNvbnRyb2wuUnVsZXIuRGljdGlvbmFyeS5pdCA9IHtcblx0YnV0dG9uX3RpdGxlIDogJ1JpZ2hlbGxvJ1xufTsiLCJERy5Db250cm9sLlJ1bGVyLkRpY3Rpb25hcnkuY3MgPSB7XG5cdGJ1dHRvbl90aXRsZTogJ1ByYXbDrXRrbydcbn07IiwiREcuQ29udHJvbC5SdWxlci5EaWN0aW9uYXJ5LmVzID0ge1xuXHRidXR0b25fdGl0bGUgOiAnUmVnbGEnXG59O1xuIiwiREcuQ29udHJvbC5SdWxlci5EaWN0aW9uYXJ5LmVuID0ge1xuXHRidXR0b25fdGl0bGUgOiAnUnVsZXInXG59OyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdBdHRyaWJ1dGlvblxcL2NvcHlyaWdodFwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLWF0dHJpYnV0aW9uX19jb3B5cmlnaHRcXFwiPjx1bCBjbGFzcz1cXFwiZGctYXR0cmlidXRpb25fX2xpbmtzXFxcIj48bGkgY2xhc3M9XFxcImRnLWF0dHJpYnV0aW9uX19saW5rLWl0ZW1cXFwiPlwiKS54KGN0eC5nZXQoW1wib3NtXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xfSx7fSkudyhcIjxhIGhyZWY9XFxcIlwiKS5mKGN0eC5nZXQoW1wiY29weXJpZ2h0X2FwaWxpbmtcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBjbGFzcz1cXFwiZGctYXR0cmlidXRpb25fX2xpbmtcXFwiPlwiKS5ueChjdHguZ2V0KFtcIm9zbVwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMn0se30pLmYoY3R4LmdldChbXCJBUElfMkdJU1wiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvYT48L2xpPjxsaSBjbGFzcz1cXFwiZGctYXR0cmlidXRpb25fX2xpbmstaXRlbVxcXCI+PGEgaHJlZj1cXFwiXCIpLmYoY3R4LmdldChbXCJjb3B5cmlnaHRfbGljZW5zZVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIlxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGNsYXNzPVxcXCJkZy1hdHRyaWJ1dGlvbl9fbGlua1xcXCI+XCIpLmYoY3R4LmdldChbXCJsaWNlbnNlX2FncmVlbWVudFwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvYT48L2xpPjwvdWw+PGEgaHJlZj1cXFwiXCIpLmYoY3R4LmdldChbXCJjb3B5cmlnaHRfbG9nb1wiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIlxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGNsYXNzPVxcXCJkZy1hdHRyaWJ1dGlvbl9fbG9nby11cmxcXFwiPjwvYT48L2Rpdj5cIik7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCLCqSA8YSBocmVmPVxcXCJodHRwOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGNsYXNzPVxcXCJkZy1hdHRyaWJ1dGlvbl9fbGlua1xcXCI+T3BlblN0cmVldE1hcCBjb250cmlidXRvcnM8L2E+LCBcIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLmYoY3R4LmdldChbXCJ3b3JrX29uXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiIFwiKTt9Ym9keV8yLl9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvY2l0eWFyZWFcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZSBkZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZV90eXBlX1wiKS5mKGN0eC5nZXQoW1widHlwZVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIlxcXCI+XCIpLmYoY3R4LmdldChbXCJwdXJwb3NlXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpLnMoY3R4LmdldChbXCJkcmlsbGRvd25cIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzF9LHt9KTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19kcmlsbGRvd25cXFwiPlwiKS5mKGN0eC5nZXQoW1wiZHJpbGxkb3duXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9maXJtQ2FyZEFkZHJcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8YWRkcmVzcyBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19hZGRyZXNzIGRnLWZpcm0tY2FyZF9faWNvblxcXCI+XCIpLmYoY3R4LmdldChbXCJhZGRyZXNzXCJdLCBmYWxzZSksY3R4LFwiaFwiKS5zKGN0eC5nZXQoW1wiY29tbWVudFwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMX0se30pLncoXCI8L2FkZHJlc3M+XCIpO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPHNwYW4gY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fY29tbWVudFxcXCI+Jm1kYXNoOyBcIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9zcGFuPlwiKTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvZmlybUNhcmRDb250YWN0c1wiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsucyhjdHguZ2V0KFtcImdyb3Vwc1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMX0se30pO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay5zKGN0eC5nZXQoW1wiY29udGFjdHNcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzJ9LHt9KTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsuaChcInNlbGVjdFwiLGN0eCx7XCJibG9ja1wiOmJvZHlfM30se1wia2V5XCI6Y3R4LmdldChbXCJ0eXBlXCJdLCBmYWxzZSksXCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJoXCIpO31ib2R5XzIuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMoY2hrLGN0eCl7cmV0dXJuIGNoay5oKFwiZXFcIixjdHgse1wiYmxvY2tcIjpib2R5XzR9LHtcInZhbHVlXCI6XCJwaG9uZVwiLFwidHlwZVwiOlwic3RyaW5nXCJ9LFwiaFwiKS5oKFwiZXFcIixjdHgse1wiYmxvY2tcIjpib2R5XzZ9LHtcInZhbHVlXCI6XCJmYXhcIixcInR5cGVcIjpcInN0cmluZ1wifSxcImhcIikuaChcImVxXCIsY3R4LHtcImJsb2NrXCI6Ym9keV84fSx7XCJ2YWx1ZVwiOlwid2Vic2l0ZVwiLFwidHlwZVwiOlwic3RyaW5nXCJ9LFwiaFwiKS5oKFwiZXFcIixjdHgse1wiYmxvY2tcIjpib2R5Xzl9LHtcInZhbHVlXCI6XCJlbWFpbFwiLFwidHlwZVwiOlwic3RyaW5nXCJ9LFwiaFwiKTt9Ym9keV8zLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV80KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fcGhvbmUgZGctZmlybS1jYXJkX19pY29uXFxcIj48c3BhbiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19waG9uZS1udW1cXFwiPlwiKS5mKGN0eC5nZXQoW1widGV4dFwiXSwgZmFsc2UpLGN0eCxcImhcIikucyhjdHguZ2V0KFtcImNvbW1lbnRcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzV9LHt9KS53KFwiPC9zcGFuPjwvZGl2PlwiKTt9Ym9keV80Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV81KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxzcGFuIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX2NvbW1lbnRcXFwiIHRpdGxlPVxcXCJcIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiXFxcIj4mbWRhc2g7Jm5ic3A7Jm5ic3A7XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvc3Bhbj5cIik7fWJvZHlfNS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX3Bob25lIGRnLWZpcm0tY2FyZF9faWNvblxcXCI+PHNwYW4gY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fcGhvbmUtbnVtXFxcIj5cIikuZihjdHguZ2V0KFtcInRleHRcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLnMoY3R4LmdldChbXCJjb21tZW50XCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV83fSx7fSkudyhcIjwvc3Bhbj48L2Rpdj5cIik7fWJvZHlfNi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNyhjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8c3BhbiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19jb21tZW50XFxcIiB0aXRsZT1cXFwiXCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIlxcXCI+Jm1kYXNoOyZuYnNwOyZuYnNwO1wiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L3NwYW4+XCIpO31ib2R5XzcuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzgoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19saW5rIGRnLWZpcm0tY2FyZF9fc2l0ZSBkZy1maXJtLWNhcmRfX2ljb25cXFwiPjxhIGhyZWY9XFxcIlwiKS5mKGN0eC5nZXQoW1widXJsXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImRnLWxpbmtfc2NoZW1lX2RhcmsgZGctZmlybS1jYXJkX19zaXRlbGlua1xcXCI+XCIpLmYoY3R4LmdldChbXCJ0ZXh0XCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9hPjwvZGl2PlwiKTt9Ym9keV84Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV85KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fbGluayBkZy1maXJtLWNhcmRfX2VtYWlsIGRnLWZpcm0tY2FyZF9faWNvblxcXCI+PGEgaHJlZj1cXFwibWFpbHRvOlwiKS5mKGN0eC5nZXQoW1widmFsdWVcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCJcXFwiPlwiKS5mKGN0eC5nZXQoW1widmFsdWVcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2E+PC9kaXY+XCIpO31ib2R5XzkuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9maXJtQ2FyZEhlYWRlclwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXBvcHVwX19oZWFkZXItdGl0bGUgZGctcG9wdXBfX2hlYWRlci10aXRsZV9mb3JfZmlybWNhcmRcXFwiIHRpdGxlPVxcXCJcIikuZihjdHguZ2V0KFtcImZpcm1OYW1lXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiXFxcIj5cIikuZihjdHguZ2V0KFtcImZpcm1OYW1lXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpLngoY3R4LmdldChbXCJsaW5rc1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMX0se30pO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctcG9wdXBfX2hlYWRlci1saW5rc1xcXCI+XCIpLnMoY3R4LmdldChbXCJsaW5rc1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMn0se30pLncoXCI8L2Rpdj5cIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLmgoXCJlcVwiLGN0eCx7XCJlbHNlXCI6Ym9keV8zLFwiYmxvY2tcIjpib2R5XzZ9LHtcImtleVwiOmJvZHlfNyxcInZhbHVlXCI6XCJmbGFtcF9zdGFyc1wiLFwidHlwZVwiOlwic3RyaW5nXCJ9LFwiaFwiKTt9Ym9keV8yLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxhIGNsYXNzPVxcXCJkZy1wb3B1cF9faGVhZGVyLWxpbmsgZGctcG9wdXBfX2xpbmsgZGctcG9wdXBfX2xpbmtfdHlwZV9cIikuZihjdHguZ2V0KFtcIm5hbWVcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCJcXFwiXCIpLngoY3R4LmdldChbXCJocmVmXCJdLCBmYWxzZSksY3R4LHtcImVsc2VcIjpib2R5XzQsXCJibG9ja1wiOmJvZHlfNX0se30pLncoXCI+XCIpLmYoY3R4LmdldChbXCJsYWJlbFwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvYT5cIik7fWJvZHlfMy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCJocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMClcXFwiXCIpO31ib2R5XzQuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzUoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiaHJlZj1cIikuZihjdHguZ2V0KFtcImhyZWZcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiXCIpO31ib2R5XzUuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzYoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctcG9wdXBfX3JhdGluZ1xcXCI+PGRpdiBjbGFzcz1cXFwiZGctcG9wdXBfX3JhdGluZy1zdGFyc1xcXCIgc3R5bGU9XFxcIndpZHRoOiBcIikuZihjdHguZ2V0KFtcIndpZHRoXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiJVxcXCI+PC9kaXY+PC9kaXY+XCIpO31ib2R5XzYuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzcoY2hrLGN0eCl7cmV0dXJuIGNoay5mKGN0eC5nZXQoW1wibmFtZVwiXSwgZmFsc2UpLGN0eCxcImhcIik7fWJvZHlfNy5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL2Zpcm1DYXJkUnVicmljXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay5zKGN0eC5nZXQoW1wicnVicmljc1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMX0se30pO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPHNlY3Rpb24gY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fcnVicmljc1xcXCI+XCIpLngoY3R4LmdldChbXCJwcmltYXJ5XCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8yfSx7fSkueChjdHguZ2V0KFtcImFkZGl0aW9uYWxcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzR9LHt9KS53KFwiPC9zZWN0aW9uPlwiKTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjx1bCBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19ydWJyaWNzLWxpc3QgZGctZmlybS1jYXJkX19ydWJyaWNzLWxpc3RfdHlwZV9wcmltYXJ5XFxcIj5cIikucyhjdHguZ2V0KFtcInByaW1hcnlcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzN9LHt9KS53KFwiPC91bD5cIik7fWJvZHlfMi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMyhjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8bGkgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0LWl0ZW1cXFwiPlwiKS5mKGN0eC5nZXQoW1wibmFtZVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvbGk+XCIpO31ib2R5XzMuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzQoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPHVsIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdCBkZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdF90eXBlX2FkZGl0aW9uYWxcXFwiPlwiKS5zKGN0eC5nZXQoW1wiYWRkaXRpb25hbFwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfNX0se30pLncoXCI8L3VsPlwiKTt9Ym9keV80Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV81KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxsaSBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19ydWJyaWNzLWxpc3QtaXRlbVxcXCI+XCIpLmYoY3R4LmdldChbXCJuYW1lXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9saT5cIik7fWJvZHlfNS5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL2Zpcm1DYXJkU2NoZWR1bGVcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX3NjaGVkdWxlIGRnLXNjaGVkdWxlIGRnLXNjaGVkdWxlX29wZW5fXCIpLngoY3R4LmdldFBhdGgoZmFsc2UsIFtcImZvcmVjYXN0XCIsXCJvcGVuXCJdKSxjdHgse1wiZWxzZVwiOmJvZHlfMSxcImJsb2NrXCI6Ym9keV8yfSx7fSkudyhcIiBkZy1zY2hlZHVsZV93b3Jrcy1ldmVyeWRheV9cIikueChjdHguZ2V0UGF0aChmYWxzZSwgW1wic2NoZWR1bGVcIixcImV2ZXJ5ZGF5XCJdKSxjdHgse1wiZWxzZVwiOmJvZHlfMyxcImJsb2NrXCI6Ym9keV80fSx7fSkudyhcIlxcXCI+XCIpLngoY3R4LmdldChbXCJzY2hlZHVsZVwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfNX0se30pLncoXCI8L2Rpdj5cIik7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCJmYWxzZVwiKTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsudyhcInRydWVcIik7fWJvZHlfMi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMyhjaGssY3R4KXtyZXR1cm4gY2hrLncoXCJmYWxzZVwiKTt9Ym9keV8zLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV80KGNoayxjdHgpe3JldHVybiBjaGsudyhcInRydWVcIik7fWJvZHlfNC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNShjaGssY3R4KXtyZXR1cm4gY2hrLngoY3R4LmdldFBhdGgoZmFsc2UsIFtcImZvcmVjYXN0XCIsXCJ0b2RheVwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV82fSx7fSkucyhjdHguZ2V0UGF0aChmYWxzZSwgW1wiZm9yZWNhc3RcIixcIm5vd1wiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8xMH0se30pLm54KGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJzY2hlZHVsZVwiLFwiZXZlcnlkYXlcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfMTJ9LHt9KTt9Ym9keV81Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV82KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX190b2RheVxcXCI+PGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3RvZGF5LWlubmVyXFxcIj5cIikuZihjdHguZ2V0UGF0aChmYWxzZSwgW1wiZm9yZWNhc3RcIixcInRvZGF5XCIsXCJ0ZXh0XCJdKSxjdHgsXCJoXCIpLncoXCImbmJzcDtcIikueChjdHguZ2V0UGF0aChmYWxzZSwgW1wiZm9yZWNhc3RcIixcInRvZGF5XCIsXCJmcm9tXCJdKSxjdHgse1wiYmxvY2tcIjpib2R5Xzd9LHt9KS54KGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJzY2hlZHVsZVwiLFwibHVuY2hcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfOH0se30pLncoXCI8L2Rpdj48L2Rpdj5cIik7fWJvZHlfNi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNyhjaGssY3R4KXtyZXR1cm4gY2hrLmYoY3R4LmdldFBhdGgoZmFsc2UsIFtcImZvcmVjYXN0XCIsXCJ0b2RheVwiLFwiZnJvbVwiXSksY3R4LFwiaFwiKS53KFwiJm5kYXNoO1wiKS5mKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJmb3JlY2FzdFwiLFwidG9kYXlcIixcInRvXCJdKSxjdHgsXCJoXCIpO31ib2R5XzcuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzgoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiLCZuYnNwO1wiKS5mKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJmb3JlY2FzdFwiLFwidG9kYXlcIixcImx1bmNoU3RyXCJdKSxjdHgsXCJoXCIpLncoXCImbmJzcDtcIikucyhjdHguZ2V0UGF0aChmYWxzZSwgW1wic2NoZWR1bGVcIixcImx1bmNoXCJdKSxjdHgse1wiYmxvY2tcIjpib2R5Xzl9LHt9KTt9Ym9keV84Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV85KGNoayxjdHgpe3JldHVybiBjaGsuZihjdHguZ2V0KFtcImZyb21cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCImbmRhc2g7XCIpLmYoY3R4LmdldChbXCJ0b1wiXSwgZmFsc2UpLGN0eCxcImhcIik7fWJvZHlfOS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMTAoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX25vd1xcXCI+PHNwYW4gY2xhc3M9XFxcImRnLXNjaGVkdWxlX19ub3ctdGV4dFxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikucyhjdHguZ2V0UGF0aChmYWxzZSwgW1wic2NoZWR1bGVcIixcImNvbW1lbnRcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfMTF9LHt9KS53KFwiPC9zcGFuPjwvZGl2PlwiKTt9Ym9keV8xMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMTEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiLCBcIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKTt9Ym9keV8xMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMTIoY2hrLGN0eCl7cmV0dXJuIGNoay54KGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJzY2hlZHVsZVwiLFwid2Vla1wiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8xM30se30pO31ib2R5XzEyLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xMyhjaGssY3R4KXtyZXR1cm4gY2hrLngoY3R4LmdldFBhdGgoZmFsc2UsIFtcInNjaGVkdWxlXCIsXCJ3ZWVrXCIsXCJldmVudGx5XCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzE0fSx7fSkueChjdHguZ2V0UGF0aChmYWxzZSwgW1wic2NoZWR1bGVcIixcIndlZWtcIixcInRhYmxlXCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzIyfSx7fSk7fWJvZHlfMTMuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzE0KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX190YWJsZVxcXCI+XCIpLnMoY3R4LmdldFBhdGgoZmFsc2UsIFtcInNjaGVkdWxlXCIsXCJ3ZWVrXCIsXCJldmVudGx5XCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzE1fSx7fSkudyhcIjwvZGl2PlwiKTt9Ym9keV8xNC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMTUoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3N0cmluZ1xcXCI+XCIpLngoY3R4LmdldChbXCJhbGx0aW1lXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xNn0se30pLngoY3R4LmdldChbXCJldmVyeWRheVwiXSwgZmFsc2UpLGN0eCx7XCJlbHNlXCI6Ym9keV8xNyxcImJsb2NrXCI6Ym9keV8xOH0se30pLngoY3R4LmdldChbXCJob2xpZGF5XCJdLCBmYWxzZSksY3R4LHtcImVsc2VcIjpib2R5XzE5LFwiYmxvY2tcIjpib2R5XzIxfSx7fSkudyhcIjwvZGl2PlwiKTt9Ym9keV8xNS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMTYoY2hrLGN0eCl7cmV0dXJuIGNoay5mKGN0eC5nZXQoW1wiYWxsdGltZVN0clwiXSwgZmFsc2UpLGN0eCxcImhcIik7fWJvZHlfMTYuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzE3KGNoayxjdHgpe3JldHVybiBjaGsuZihjdHguZ2V0KFtcImRheUxpc3RcIl0sIGZhbHNlKSxjdHgsXCJoXCIpO31ib2R5XzE3Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xOChjaGssY3R4KXtyZXR1cm4gY2hrLmYoY3R4LmdldFBhdGgoZmFsc2UsIFtcImZvcmVjYXN0XCIsXCJ0b2RheVwiLFwidGV4dFwiXSksY3R4LFwiaFwiKTt9Ym9keV8xOC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMTkoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPHNwYW4gY2xhc3M9XFxcInNjaGVkdWxlX19zdHJpbmctdGltZVxcXCI+Jm5ic3A7XCIpLmYoY3R4LmdldChbXCJmcm9tXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiJm5kYXNoO1wiKS5mKGN0eC5nZXQoW1widG9cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L3NwYW4+XCIpLnMoY3R4LmdldChbXCJsdW5jaFwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMjB9LHt9KTt9Ym9keV8xOS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMjAoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPHA+XCIpLmYoY3R4LmdldChbXCJsdW5jaFN0clwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiZtZGFzaDs8c3BhbiBjbGFzcz1cXFwic2NoZWR1bGVfX3N0cmluZy10aW1lXFxcIj5cIikuZihjdHguZ2V0KFtcImZyb21cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCImbmRhc2g7XCIpLmYoY3R4LmdldChbXCJ0b1wiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvc3Bhbj48L3A+XCIpO31ib2R5XzIwLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCImbmJzcDsmbWRhc2g7PHNwYW4gY2xhc3M9XFxcInNjaGVkdWxlX19zdHJpbmctdGltZVxcXCI+Jm5ic3A7XCIpLmYoY3R4LmdldChbXCJob2xpZGF5U3RyXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9zcGFuPlwiKTt9Ym9keV8yMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMjIoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdj48ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fdGFibGVcXFwiPjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX190YyBkZy1zY2hlZHVsZV9fdGNfcHJlXFxcIj48ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fZGF5LW5hbWVcXFwiPiZuYnNwOzwvZGl2PjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX190YWJsZS1jbG9jayBkZy1zY2hlZHVsZV9fdGRcXFwiPjwvZGl2PlwiKS54KGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJzY2hlZHVsZVwiLFwid2Vla1wiLFwiaGFzTHVuY2hcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfMjN9LHt9KS53KFwiPC9kaXY+XCIpLnMoY3R4LmdldFBhdGgoZmFsc2UsIFtcInNjaGVkdWxlXCIsXCJ3ZWVrXCIsXCJ0YWJsZVwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8yNH0se30pLncoXCI8L2Rpdj4gIDwvZGl2PlwiKTt9Ym9keV8yMi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMjMoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3RhYmxlLWx1bmNoIGRnLXNjaGVkdWxlX190ZFxcXCI+PC9kaXY+XCIpO31ib2R5XzIzLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yNChjaGssY3R4KXtyZXR1cm4gY2hrLmgoXCJpZlwiLGN0eCx7XCJibG9ja1wiOmJvZHlfMjV9LHtcImNvbmRcIjpib2R5XzI2fSxcImhcIikudyhcIjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX190Y1wiKS54KGN0eC5nZXQoW1wiYWN0aXZlXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8yN30se30pLncoXCJcXFwiPjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX19kYXktbmFtZVxcXCI+XCIpLmYoY3R4LmdldChbXCJrZXlcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj48ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fdGRcXFwiPlwiKS54KGN0eC5nZXQoW1wiZnJvbVwiXSwgZmFsc2UpLGN0eCx7XCJlbHNlXCI6Ym9keV8yOCxcImJsb2NrXCI6Ym9keV8yOX0se30pLncoXCI8L2Rpdj5cIikucyhjdHguZ2V0KFtcImx1bmNoXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8zMH0se30pLncoXCI8L2Rpdj4gXCIpLmgoXCJpZlwiLGN0eCx7XCJibG9ja1wiOmJvZHlfMzN9LHtcImNvbmRcIjpib2R5XzM0fSxcImhcIik7fWJvZHlfMjQuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzI1KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxzcGFuIGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fdGFibGUtY2VsbC1ncm91cFxcXCI+XCIpO31ib2R5XzI1Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yNihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCIoXCIpLmYoY3R4LmdldChbXCIkaWR4XCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiID09IFwiKS5mKGN0eC5nZXQoW1wiJGxlblwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiAtIDIpXCIpO31ib2R5XzI2Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yNyhjaGssY3R4KXtyZXR1cm4gY2hrLncoXCIgZGctc2NoZWR1bGVfX3RjX2FjdGl2ZV90cnVlXCIpO31ib2R5XzI3Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yOChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCImbmRhc2g7XCIpO31ib2R5XzI4Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yOShjaGssY3R4KXtyZXR1cm4gY2hrLmYoY3R4LmdldChbXCJmcm9tXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiIFwiKS5mKGN0eC5nZXQoW1widG9cIl0sIGZhbHNlKSxjdHgsXCJoXCIpO31ib2R5XzI5Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zMChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fdGRcXFwiPlwiKS54KGN0eC5nZXQoW1wiZnJvbVwiXSwgZmFsc2UpLGN0eCx7XCJlbHNlXCI6Ym9keV8zMSxcImJsb2NrXCI6Ym9keV8zMn0se30pLncoXCI8L2Rpdj5cIik7fWJvZHlfMzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMxKGNoayxjdHgpe3JldHVybiBjaGsudyhcIiZuZGFzaDtcIik7fWJvZHlfMzEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMyKGNoayxjdHgpe3JldHVybiBjaGsuZihjdHguZ2V0KFtcImZyb21cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCIgXCIpLmYoY3R4LmdldChbXCJ0b1wiXSwgZmFsc2UpLGN0eCxcImhcIik7fWJvZHlfMzIuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMzKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjwvc3Bhbj5cIik7fWJvZHlfMzMuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzM0KGNoayxjdHgpe3JldHVybiBjaGsudyhcIihcIikuZihjdHguZ2V0KFtcIiRpZHhcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCIgPT0gXCIpLmYoY3R4LmdldChbXCIkbGVuXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiKVwiKTt9Ym9keV8zNC5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL2Zpcm1saXN0SXRlbVwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxhIGlkPVxcXCJcIikuZihjdHguZ2V0UGF0aChmYWxzZSwgW1wiZmlybVwiLFwiaWRcIl0pLGN0eCxcImhcIikudyhcIlxcXCIgY2xhc3M9XFxcImRnLXBvcHVwX19saW5rXFxcIiBocmVmPVxcXCIjXFxcIj5cIikuZihjdHguZ2V0UGF0aChmYWxzZSwgW1wiZmlybVwiLFwibmFtZVwiXSksY3R4LFwiaFwiKS53KFwiPC9hPlwiKTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvZnJpbUNhcmRQYXltZW50c1wiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsueChjdHguZ2V0KFtcInBheW1lbnRzXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xfSx7fSk7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8c2VjdGlvbiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19hYVxcXCI+PHVsIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX2FhLWxpc3RcXFwiPlwiKS5zKGN0eC5nZXQoW1wicGF5bWVudHNcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzJ9LHt9KS53KFwiPC91bD48L3NlY3Rpb24+XCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGxpIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX2FhLWxpc3QtaXRlbVxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvbGk+XCIpO31ib2R5XzIuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9ob3VzZVwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsucyhjdHguZ2V0KFtcImFkZHJlc3NcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzF9LHt9KS5zKGN0eC5nZXQoW1wicHVycG9zZVwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfNH0se30pLnMoY3R4LmdldChbXCJhdHRyYWN0aW9uc1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfNX0se30pO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGFkZHJlc3MgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzXFxcIj5cIikucyhjdHguZ2V0UGF0aChmYWxzZSwgW1wiYWRkcmVzc1wiLFwiaGVhZGVyXCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzJ9LHt9KS5zKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJhZGRyZXNzXCIsXCJkcmlsbGRvd25cIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfM30se30pLncoXCI8L2FkZHJlc3M+XCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtaGVhZGVyXFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpO31ib2R5XzIuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtZHJpbGxkb3duXFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpO31ib2R5XzMuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzQoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2VcXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIik7fWJvZHlfNC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZSBkZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZV90eXBlX3NpZ2h0XFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpO31ib2R5XzUuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9sb2FkZXJcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1wcmVsb2FkZXIgZGctcHJlbG9hZGVyX3NjaGVtZV9yZWd1bGFyIGRnLXByZWxvYWRlcl9hbmltYXRpb25fXCIpLngoY3R4LmdldChbXCJhbmltXCJdLCBmYWxzZSksY3R4LHtcImVsc2VcIjpib2R5XzEsXCJibG9ja1wiOmJvZHlfMn0se30pLngoY3R4LmdldChbXCJzbWFsbFwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfM30se30pLncoXCJcXFwiPjwvZGl2PlwiKTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcImZhbHNlXCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwidHJ1ZVwiKTt9Ym9keV8yLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsudyhcIiBkZy1wcmVsb2FkZXJfc2l6ZV9zbWFsbFwiKTt9Ym9keV8zLl9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvcG9wdXBGb290ZXJcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1wb3B1cF9fZm9vdGVyLXRpdGxlXFxcIj48YSBjbGFzcz1cXFwiZGctcG9wdXBfX3Nob3ctbGVzcy1ob3VzZS1saW5rXFxcIiBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMClcXFwiPlwiKS5mKGN0eC5nZXQoW1wiaGlkZUZpcm1zVGV4dFwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvYT48L2Rpdj5cIik7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL3BvcHVwRm9vdGVyQnRuc1wiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsueChjdHguZ2V0KFtcImJ0bnNcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzF9LHt9KTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxmb290ZXIgY2xhc3M9XFxcImRnLXBvcHVwX19mb290ZXItYnV0dG9uc1xcXCI+XCIpLnMoY3R4LmdldChbXCJidG5zXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8yfSx7fSkudyhcIjwvZm9vdGVyPlwiKTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXBvcHVwX19mb290ZXItYnV0dG9uLXdyYXBwZXJcXFwiPjxhIGNsYXNzPVxcXCJkZy1wb3B1cF9fYnV0dG9uX25hbWVfXCIpLmYoY3R4LmdldChbXCJuYW1lXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiIGRnLXBvcHVwX19mb290ZXItYnV0dG9uXCIpLngoY3R4LmdldChbXCJpY29uXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8zfSx7fSkudyhcIlxcXCJcIikueChjdHguZ2V0KFtcImhyZWZcIl0sIGZhbHNlKSxjdHgse1wiZWxzZVwiOmJvZHlfNCxcImJsb2NrXCI6Ym9keV81fSx7fSkudyhcIj5cIikuZihjdHguZ2V0KFtcImxhYmVsXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9hPjwvZGl2PlwiKTt9Ym9keV8yLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsudyhcIiBkZy1wb3B1cF9fZm9vdGVyLWljb24tYnV0dG9uXCIpO31ib2R5XzMuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzQoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApXFxcIlwiKTt9Ym9keV80Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV81KGNoayxjdHgpe3JldHVybiBjaGsudyhcImhyZWY9XCIpLmYoY3R4LmdldChbXCJocmVmXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIlwiKTt9Ym9keV81Ll9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvcG9wdXBIZWFkZXJcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLnMoY3R4LmdldChbXCJ0aXRsZVwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMX0se30pO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctcG9wdXBfX2hlYWRlci10aXRsZVxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvc2lnaHRcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLnMoY3R4LmdldChbXCJwdXJwb3NlXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xfSx7fSkucyhjdHguZ2V0KFtcImFkZHJlc3NcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzJ9LHt9KS5zKGN0eC5nZXQoW1wiZGVzY3JpcHRpb25cIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzV9LHt9KTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlIGRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlX3R5cGVfc2lnaHRcXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8YWRkcmVzcyBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3NcXFwiPlwiKS5zKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJhZGRyZXNzXCIsXCJoZWFkZXJcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfM30se30pLnMoY3R4LmdldFBhdGgoZmFsc2UsIFtcImFkZHJlc3NcIixcImRyaWxsZG93blwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV80fSx7fSkudyhcIjwvYWRkcmVzcz5cIik7fWJvZHlfMi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMyhjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcy1oZWFkZXJcXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIik7fWJvZHlfMy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcy1kcmlsbGRvd25cXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIik7fWJvZHlfNC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fc2lnaHQtZGVzY3JpcHRpb25cXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIikucyhjdHguZ2V0KFtcInNob3dNb3JlVGV4dFwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfNn0se30pO31ib2R5XzUuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzYoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGEgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19zaG93LW1vcmUtc2lnaHRzLWxpbmtcXFwiIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKVxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvYT5cIik7fWJvZHlfNi5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIndXNlIHN0cmljdCc7XG4vLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBicm93c2VyIGZpZWxkLCBjaGVjayBvdXQgdGhlIGJyb3dzZXIgZmllbGQgYXQgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2Jyb3dzZXJpZnktaGFuZGJvb2sjYnJvd3Nlci1maWVsZC5cblxudmFyIHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhciBpbnNlcnRTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbihzdHlsZUVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICB2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuaW5zZXJ0QXQgPSBvcHRpb25zLmluc2VydEF0IHx8ICdib3R0b20nO1xuXG4gICAgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09ICd0b3AnKSB7XG4gICAgICAgIGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFxcJ2luc2VydEF0XFwnLiBNdXN0IGJlIFxcJ3RvcFxcJyBvciBcXCdib3R0b21cXCcuJyk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy8gQ3JlYXRlIGEgPGxpbms+IHRhZyB3aXRoIG9wdGlvbmFsIGRhdGEgYXR0cmlidXRlc1xuICAgIGNyZWF0ZUxpbms6IGZ1bmN0aW9uKGhyZWYsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuXG4gICAgICAgIGxpbmsuaHJlZiA9IGhyZWY7XG4gICAgICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoICEgYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnZGF0YS0nICsga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH0sXG4gICAgLy8gQ3JlYXRlIGEgPHN0eWxlPiB0YWcgd2l0aCBvcHRpb25hbCBkYXRhIGF0dHJpYnV0ZXNcbiAgICBjcmVhdGVTdHlsZTogZnVuY3Rpb24oY3NzVGV4dCwgYXR0cmlidXRlcywgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGV4dHJhT3B0aW9ucyA9IGV4dHJhT3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCAhIGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdkYXRhLScgKyBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHlsZS5zaGVldCkgeyAvLyBmb3IganNkb20gYW5kIElFOStcbiAgICAgICAgICAgIHN0eWxlLmlubmVySFRNTCA9IGNzc1RleHQ7XG4gICAgICAgICAgICBzdHlsZS5zaGVldC5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICAgICAgICAgIGluc2VydFN0eWxlRWxlbWVudChzdHlsZSwgeyBpbnNlcnRBdDogZXh0cmFPcHRpb25zLmluc2VydEF0IH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHsgLy8gZm9yIElFOCBhbmQgYmVsb3dcbiAgICAgICAgICAgIGluc2VydFN0eWxlRWxlbWVudChzdHlsZSwgeyBpbnNlcnRBdDogZXh0cmFPcHRpb25zLmluc2VydEF0IH0pO1xuICAgICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICAgICAgfSBlbHNlIHsgLy8gZm9yIENocm9tZSwgRmlyZWZveCwgYW5kIFNhZmFyaVxuICAgICAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzVGV4dCkpO1xuICAgICAgICAgICAgaW5zZXJ0U3R5bGVFbGVtZW50KHN0eWxlLCB7IGluc2VydEF0OiBleHRyYU9wdGlvbnMuaW5zZXJ0QXQgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAmJiBkZWZpbmUuYW1kLmR1c3QgPT09IHRydWUpIHtcbiAgICBkZWZpbmUoWydkdXN0LmNvcmUnXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2R1c3Rqcy1saW5rZWRpbicpKTtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3J5KHJvb3QuZHVzdCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oZHVzdCkge1xuXG5mdW5jdGlvbiBsb2coaGVscGVyLCBtc2csIGxldmVsKSB7XG4gIGxldmVsID0gbGV2ZWwgfHwgXCJJTkZPXCI7XG4gIGhlbHBlciA9IGhlbHBlciA/ICd7QCcgKyBoZWxwZXIgKyAnfTogJyA6ICcnO1xuICBkdXN0LmxvZyhoZWxwZXIgKyBtc2csIGxldmVsKTtcbn1cblxudmFyIF9kZXByZWNhdGVkQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIF9kZXByZWNhdGVkKHRhcmdldCkge1xuICBpZihfZGVwcmVjYXRlZENhY2hlW3RhcmdldF0pIHsgcmV0dXJuOyB9XG4gIGxvZyh0YXJnZXQsIFwiRGVwcmVjYXRpb24gd2FybmluZzogXCIgKyB0YXJnZXQgKyBcIiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBkdXN0anMtaGVscGVyc1wiLCBcIldBUk5cIik7XG4gIGxvZyhudWxsLCBcIkZvciBoZWxwIGFuZCBhIGRlcHJlY2F0aW9uIHRpbWVsaW5lLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2xpbmtlZGluL2R1c3Rqcy1oZWxwZXJzL3dpa2kvRGVwcmVjYXRlZC1GZWF0dXJlcyNcIiArIHRhcmdldC5yZXBsYWNlKC9cXFcrL2csIFwiXCIpLCBcIldBUk5cIik7XG4gIF9kZXByZWNhdGVkQ2FjaGVbdGFyZ2V0XSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzU2VsZWN0KGNvbnRleHQpIHtcbiAgcmV0dXJuIGNvbnRleHQuc3RhY2sudGFpbCAmJlxuICAgICAgICAgY29udGV4dC5zdGFjay50YWlsLmhlYWQgJiZcbiAgICAgICAgIHR5cGVvZiBjb250ZXh0LnN0YWNrLnRhaWwuaGVhZC5fX3NlbGVjdF9fICE9PSBcInVuZGVmaW5lZFwiO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3RTdGF0ZShjb250ZXh0KSB7XG4gIHJldHVybiBpc1NlbGVjdChjb250ZXh0KSAmJiBjb250ZXh0LmdldCgnX19zZWxlY3RfXycpO1xufVxuXG4vKipcbiAqIEFkZHMgYSBzcGVjaWFsIF9fc2VsZWN0X18ga2V5IGJlaGluZCB0aGUgaGVhZCBvZiB0aGUgY29udGV4dCBzdGFjay4gVXNlZCB0byBtYWludGFpbiB0aGUgc3RhdGVcbiAqIG9mIHtAc2VsZWN0fSBibG9ja3NcbiAqIEBwYXJhbSBjb250ZXh0IHtDb250ZXh0fSBhZGQgc3RhdGUgdG8gdGhpcyBDb250ZXh0XG4gKiBAcGFyYW0gb3B0cyB7T2JqZWN0fSBhZGQgdGhlc2UgcHJvcGVydGllcyB0byB0aGUgc3RhdGUgKGBrZXlgIGFuZCBgdHlwZWApXG4gKi9cbmZ1bmN0aW9uIGFkZFNlbGVjdFN0YXRlKGNvbnRleHQsIG9wdHMpIHtcbiAgdmFyIGhlYWQgPSBjb250ZXh0LnN0YWNrLmhlYWQsXG4gICAgICBuZXdDb250ZXh0ID0gY29udGV4dC5yZWJhc2UoKSxcbiAgICAgIGtleTtcblxuICBpZihjb250ZXh0LnN0YWNrICYmIGNvbnRleHQuc3RhY2sudGFpbCkge1xuICAgIG5ld0NvbnRleHQuc3RhY2sgPSBjb250ZXh0LnN0YWNrLnRhaWw7XG4gIH1cblxuICB2YXIgc3RhdGUgPSB7XG4gICAgaXNQZW5kaW5nOiBmYWxzZSxcbiAgICBpc1Jlc29sdmVkOiBmYWxzZSxcbiAgICBpc0RlZmVycmVkQ29tcGxldGU6IGZhbHNlLFxuICAgIGRlZmVycmVkczogW11cbiAgfTtcblxuICBmb3Ioa2V5IGluIG9wdHMpIHtcbiAgICBzdGF0ZVtrZXldID0gb3B0c1trZXldO1xuICB9XG5cbiAgcmV0dXJuIG5ld0NvbnRleHRcbiAgLnB1c2goeyBcIl9fc2VsZWN0X19cIjogc3RhdGUgfSlcbiAgLnB1c2goaGVhZCwgY29udGV4dC5zdGFjay5pbmRleCwgY29udGV4dC5zdGFjay5vZik7XG59XG5cbi8qKlxuICogQWZ0ZXIgYSB7QHNlbGVjdH0gb3Ige0BtYXRofSBibG9jayBpcyBjb21wbGV0ZSwgdGhleSBpbnZva2UgdGhpcyBmdW5jdGlvblxuICovXG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0RGVmZXJyZWRzKHN0YXRlKSB7XG4gIHZhciB4LCBsZW47XG4gIHN0YXRlLmlzRGVmZXJyZWRQZW5kaW5nID0gdHJ1ZTtcbiAgaWYoc3RhdGUuZGVmZXJyZWRzLmxlbmd0aCkge1xuICAgIHN0YXRlLmlzRGVmZXJyZWRDb21wbGV0ZSA9IHRydWU7XG4gICAgZm9yKHg9MCwgbGVuPXN0YXRlLmRlZmVycmVkcy5sZW5ndGg7IHg8bGVuOyB4KyspIHtcbiAgICAgIHN0YXRlLmRlZmVycmVkc1t4XSgpO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5pc0RlZmVycmVkUGVuZGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFVzZWQgYnkge0Bjb250ZXh0RHVtcH1cbiAqL1xuZnVuY3Rpb24ganNvbkZpbHRlcihrZXksIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpXG4gICAgICAucmVwbGFjZSgvKF5cXHMrfFxccyskKS9tZywgJycpXG4gICAgICAucmVwbGFjZSgvXFxuL21nLCAnJylcbiAgICAgIC5yZXBsYWNlKC8sXFxzKi9tZywgJywgJylcbiAgICAgIC5yZXBsYWNlKC9cXClcXHsvbWcsICcpIHsnKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSB0cnV0aCB0ZXN0IGhlbHBlclxuICovXG5mdW5jdGlvbiB0cnV0aFRlc3QobmFtZSwgdGVzdCkge1xuICByZXR1cm4gZnVuY3Rpb24oY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGZpbHRlcihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMsIG5hbWUsIHRlc3QpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgaW52b2tlZCBieSB0cnV0aCB0ZXN0IGhlbHBlcnNcbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcywgaGVscGVyTmFtZSwgdGVzdCkge1xuICB2YXIgYm9keSA9IGJvZGllcy5ibG9jayxcbiAgICAgIHNraXAgPSBib2RpZXNbJ2Vsc2UnXSxcbiAgICAgIHNlbGVjdFN0YXRlID0gZ2V0U2VsZWN0U3RhdGUoY29udGV4dCkgfHwge30sXG4gICAgICB3aWxsUmVzb2x2ZSwga2V5LCB2YWx1ZSwgdHlwZTtcblxuICAvLyBPbmNlIG9uZSB0cnV0aCB0ZXN0IGluIGEgc2VsZWN0IHBhc3Nlcywgc2hvcnQtY2lyY3VpdCB0aGUgcmVzdCBvZiB0aGUgdGVzdHNcbiAgaWYgKHNlbGVjdFN0YXRlLmlzUmVzb2x2ZWQgJiYgIXNlbGVjdFN0YXRlLmlzRGVmZXJyZWRQZW5kaW5nKSB7XG4gICAgcmV0dXJuIGNodW5rO1xuICB9XG5cbiAgLy8gRmlyc3QgY2hlY2sgZm9yIGEga2V5IG9uIHRoZSBoZWxwZXIgaXRzZWxmLCB0aGVuIGxvb2sgZm9yIGEga2V5IG9uIHRoZSB7QHNlbGVjdH1cbiAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHtcbiAgICBrZXkgPSBwYXJhbXMua2V5O1xuICB9IGVsc2UgaWYgKHNlbGVjdFN0YXRlLmhhc093blByb3BlcnR5KCdrZXknKSkge1xuICAgIGtleSA9IHNlbGVjdFN0YXRlLmtleTtcbiAgfSBlbHNlIHtcbiAgICBsb2coaGVscGVyTmFtZSwgXCJObyBrZXkgc3BlY2lmaWVkXCIsIFwiV0FSTlwiKTtcbiAgICByZXR1cm4gY2h1bms7XG4gIH1cblxuICB0eXBlID0gcGFyYW1zLnR5cGUgfHwgc2VsZWN0U3RhdGUudHlwZTtcblxuICBrZXkgPSBjb2VyY2UoY29udGV4dC5yZXNvbHZlKGtleSksIHR5cGUpO1xuICB2YWx1ZSA9IGNvZXJjZShjb250ZXh0LnJlc29sdmUocGFyYW1zLnZhbHVlKSwgdHlwZSk7XG5cbiAgaWYgKHRlc3Qoa2V5LCB2YWx1ZSkpIHtcbiAgICAvLyBPbmNlIGEgdHJ1dGggdGVzdCBwYXNzZXMsIHB1dCB0aGUgc2VsZWN0IGludG8gXCJwZW5kaW5nXCIgc3RhdGUuIE5vdyB3ZSBjYW4gcmVuZGVyIHRoZSBib2R5IG9mXG4gICAgLy8gdGhlIHRydXRoIHRlc3QgKHdoaWNoIG1heSBjb250YWluIHRydXRoIHRlc3RzKSB3aXRob3V0IGFsdGVyaW5nIHRoZSBzdGF0ZSBvZiB0aGUgc2VsZWN0LlxuICAgIGlmICghc2VsZWN0U3RhdGUuaXNQZW5kaW5nKSB7XG4gICAgICB3aWxsUmVzb2x2ZSA9IHRydWU7XG4gICAgICBzZWxlY3RTdGF0ZS5pc1BlbmRpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoYm9keSkge1xuICAgICAgY2h1bmsgPSBjaHVuay5yZW5kZXIoYm9keSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICh3aWxsUmVzb2x2ZSkge1xuICAgICAgc2VsZWN0U3RhdGUuaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNraXApIHtcbiAgICBjaHVuayA9IGNodW5rLnJlbmRlcihza2lwLCBjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSkge1xuICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuICt2YWx1ZTtcbiAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHZhbHVlID0gKHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZSk7XG4gICAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG4gICAgY2FzZSAnZGF0ZSc6IHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBoZWxwZXJzID0ge1xuXG4gIC8vIFV0aWxpdHkgaGVscGluZyB0byByZXNvbHZlIGR1c3QgcmVmZXJlbmNlcyBpbiB0aGUgZ2l2ZW4gY2h1bmtcbiAgLy8gdXNlcyBuYXRpdmUgRHVzdCBDb250ZXh0I3Jlc29sdmUgKGF2YWlsYWJsZSBzaW5jZSBEdXN0IDIuNi4yKVxuICBcInRhcFwiOiBmdW5jdGlvbihpbnB1dCwgY2h1bmssIGNvbnRleHQpIHtcbiAgICAvLyBkZXByZWNhdGVkIGZvciByZW1vdmFsIGluIDEuOFxuICAgIF9kZXByZWNhdGVkKFwidGFwXCIpO1xuICAgIHJldHVybiBjb250ZXh0LnJlc29sdmUoaW5wdXQpO1xuICB9LFxuXG4gIFwic2VwXCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMpIHtcbiAgICB2YXIgYm9keSA9IGJvZGllcy5ibG9jaztcbiAgICBpZiAoY29udGV4dC5zdGFjay5pbmRleCA9PT0gY29udGV4dC5zdGFjay5vZiAtIDEpIHtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHJldHVybiBib2R5KGNodW5rLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgfSxcblxuICBcImZpcnN0XCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMpIHtcbiAgICBpZiAoY29udGV4dC5zdGFjay5pbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJvZGllcy5ibG9jayhjaHVuaywgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjaHVuaztcbiAgfSxcblxuICBcImxhc3RcIjogZnVuY3Rpb24oY2h1bmssIGNvbnRleHQsIGJvZGllcykge1xuICAgIGlmIChjb250ZXh0LnN0YWNrLmluZGV4ID09PSBjb250ZXh0LnN0YWNrLm9mIC0gMSkge1xuICAgICAgcmV0dXJuIGJvZGllcy5ibG9jayhjaHVuaywgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjaHVuaztcbiAgfSxcblxuICAvKipcbiAgICoge0Bjb250ZXh0RHVtcH1cbiAgICogQHBhcmFtIGtleSB7U3RyaW5nfSBzZXQgdG8gXCJmdWxsXCIgdG8gdGhlIGZ1bGwgY29udGV4dCBzdGFjaywgb3RoZXJ3aXNlIHRoZSBjdXJyZW50IGNvbnRleHQgaXMgZHVtcGVkXG4gICAqIEBwYXJhbSB0byB7U3RyaW5nfSBzZXQgdG8gXCJjb25zb2xlXCIgdG8gbG9nIHRvIGNvbnNvbGUsIG90aGVyd2lzZSBvdXRwdXRzIHRvIHRoZSBjaHVua1xuICAgKi9cbiAgXCJjb250ZXh0RHVtcFwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICB2YXIgdG8gPSBjb250ZXh0LnJlc29sdmUocGFyYW1zLnRvKSxcbiAgICAgICAga2V5ID0gY29udGV4dC5yZXNvbHZlKHBhcmFtcy5rZXkpLFxuICAgICAgICB0YXJnZXQsIG91dHB1dDtcbiAgICBzd2l0Y2goa2V5KSB7XG4gICAgICBjYXNlICdmdWxsJzpcbiAgICAgICAgdGFyZ2V0ID0gY29udGV4dC5zdGFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0YXJnZXQgPSBjb250ZXh0LnN0YWNrLmhlYWQ7XG4gICAgfVxuICAgIG91dHB1dCA9IEpTT04uc3RyaW5naWZ5KHRhcmdldCwganNvbkZpbHRlciwgMik7XG4gICAgc3dpdGNoKHRvKSB7XG4gICAgICBjYXNlICdjb25zb2xlJzpcbiAgICAgICAgbG9nKCdjb250ZXh0RHVtcCcsIG91dHB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoLzwvZywgJ1xcXFx1MDAzYycpO1xuICAgICAgICBjaHVuayA9IGNodW5rLndyaXRlKG91dHB1dCk7XG4gICAgfVxuICAgIHJldHVybiBjaHVuaztcbiAgfSxcblxuICAvKipcbiAgICoge0BtYXRofVxuICAgKiBAcGFyYW0ga2V5IGZpcnN0IHZhbHVlXG4gICAqIEBwYXJhbSBtZXRob2Qge1N0cmluZ30gb3BlcmF0aW9uIHRvIHBlcmZvcm1cbiAgICogQHBhcmFtIG9wZXJhbmQgc2Vjb25kIHZhbHVlIChub3QgcmVxdWlyZWQgZm9yIG9wZXJhdGlvbnMgbGlrZSBgYWJzYClcbiAgICogQHBhcmFtIHJvdW5kIGlmIHRydXRoeSwgcm91bmQoKSB0aGUgcmVzdWx0XG4gICAqL1xuICBcIm1hdGhcIjogZnVuY3Rpb24gKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHZhciBrZXkgPSBwYXJhbXMua2V5LFxuICAgICAgICBtZXRob2QgPSBwYXJhbXMubWV0aG9kLFxuICAgICAgICBvcGVyYW5kID0gcGFyYW1zLm9wZXJhbmQsXG4gICAgICAgIHJvdW5kID0gcGFyYW1zLnJvdW5kLFxuICAgICAgICBvdXRwdXQsIHN0YXRlLCB4LCBsZW47XG5cbiAgICBpZighcGFyYW1zLmhhc093blByb3BlcnR5KCdrZXknKSB8fCAhcGFyYW1zLm1ldGhvZCkge1xuICAgICAgbG9nKFwibWF0aFwiLCBcImBrZXlgIG9yIGBtZXRob2RgIHdhcyBub3QgcHJvdmlkZWRcIiwgXCJFUlJPUlwiKTtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG5cbiAgICBrZXkgPSBwYXJzZUZsb2F0KGNvbnRleHQucmVzb2x2ZShrZXkpKTtcbiAgICBvcGVyYW5kID0gcGFyc2VGbG9hdChjb250ZXh0LnJlc29sdmUob3BlcmFuZCkpO1xuXG4gICAgc3dpdGNoKG1ldGhvZCkge1xuICAgICAgY2FzZSBcIm1vZFwiOlxuICAgICAgICBpZihvcGVyYW5kID09PSAwKSB7XG4gICAgICAgICAgbG9nKFwibWF0aFwiLCBcIkRpdmlzaW9uIGJ5IDBcIiwgXCJFUlJPUlwiKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgPSBrZXkgJSBvcGVyYW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgb3V0cHV0ID0ga2V5ICsgb3BlcmFuZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3VidHJhY3RcIjpcbiAgICAgICAgb3V0cHV0ID0ga2V5IC0gb3BlcmFuZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibXVsdGlwbHlcIjpcbiAgICAgICAgb3V0cHV0ID0ga2V5ICogb3BlcmFuZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGl2aWRlXCI6XG4gICAgICAgIGlmKG9wZXJhbmQgPT09IDApIHtcbiAgICAgICAgICBsb2coXCJtYXRoXCIsIFwiRGl2aXNpb24gYnkgMFwiLCBcIkVSUk9SXCIpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCA9IGtleSAvIG9wZXJhbmQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNlaWxcIjpcbiAgICAgIGNhc2UgXCJmbG9vclwiOlxuICAgICAgY2FzZSBcInJvdW5kXCI6XG4gICAgICBjYXNlIFwiYWJzXCI6XG4gICAgICAgIG91dHB1dCA9IE1hdGhbbWV0aG9kXShrZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b2ludFwiOlxuICAgICAgICBvdXRwdXQgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsb2coXCJtYXRoXCIsIFwiTWV0aG9kIGBcIiArIG1ldGhvZCArIFwiYCBpcyBub3Qgc3VwcG9ydGVkXCIsIFwiRVJST1JcIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvdXRwdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgb3V0cHV0ID0gTWF0aC5yb3VuZChvdXRwdXQpO1xuICAgICAgfVxuICAgICAgaWYgKGJvZGllcyAmJiBib2RpZXMuYmxvY2spIHtcbiAgICAgICAgY29udGV4dCA9IGFkZFNlbGVjdFN0YXRlKGNvbnRleHQsIHsga2V5OiBvdXRwdXQgfSk7XG4gICAgICAgIGNodW5rID0gY2h1bmsucmVuZGVyKGJvZGllcy5ibG9jaywgY29udGV4dCk7XG4gICAgICAgIHJlc29sdmVTZWxlY3REZWZlcnJlZHMoZ2V0U2VsZWN0U3RhdGUoY29udGV4dCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmsgPSBjaHVuay53cml0ZShvdXRwdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaHVuaztcbiAgfSxcblxuICAvKipcbiAgICoge0BzZWxlY3R9XG4gICAqIEdyb3VwcyBhIHNldCBvZiB0cnV0aCB0ZXN0cyBhbmQgb3V0cHV0cyB0aGUgZmlyc3Qgb25lIHRoYXQgcGFzc2VzLlxuICAgKiBBbHNvIGNvbnRhaW5zIHtAYW55fSBhbmQge0Bub25lfSBibG9ja3MuXG4gICAqIEBwYXJhbSBrZXkgYSB2YWx1ZSBvciByZWZlcmVuY2UgdG8gdXNlIGFzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBjb21wYXJpc29uc1xuICAgKiBAcGFyYW0gdHlwZSBjb2VyY2UgYWxsIHRydXRoIHRlc3Qga2V5cyB3aXRob3V0IGFuIGV4cGxpY2l0IHR5cGUgdG8gdGhpcyB0eXBlXG4gICAqL1xuICBcInNlbGVjdFwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICB2YXIgYm9keSA9IGJvZGllcy5ibG9jayxcbiAgICAgICAgc3RhdGUgPSB7fTtcblxuICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoJ2tleScpKSB7XG4gICAgICBzdGF0ZS5rZXkgPSBjb250ZXh0LnJlc29sdmUocGFyYW1zLmtleSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSkge1xuICAgICAgc3RhdGUudHlwZSA9IHBhcmFtcy50eXBlO1xuICAgIH1cblxuICAgIGlmIChib2R5KSB7XG4gICAgICBjb250ZXh0ID0gYWRkU2VsZWN0U3RhdGUoY29udGV4dCwgc3RhdGUpO1xuICAgICAgY2h1bmsgPSBjaHVuay5yZW5kZXIoYm9keSwgY29udGV4dCk7XG4gICAgICByZXNvbHZlU2VsZWN0RGVmZXJyZWRzKGdldFNlbGVjdFN0YXRlKGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nKFwic2VsZWN0XCIsIFwiTWlzc2luZyBib2R5IGJsb2NrXCIsIFwiV0FSTlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcnV0aCB0ZXN0IGhlbHBlcnNcbiAgICogQHBhcmFtIGtleSBhIHZhbHVlIG9yIHJlZmVyZW5jZSB0byB1c2UgYXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIGNvbXBhcmlzb25zXG4gICAqIEBwYXJhbSB2YWx1ZSBhIHZhbHVlIG9yIHJlZmVyZW5jZSB0byB1c2UgYXMgdGhlIHJpZ2h0LWhhbmQgc2lkZSBvZiBjb21wYXJpc29uc1xuICAgKiBAcGFyYW0gdHlwZSBpZiBzcGVjaWZpZWQsIGBrZXlgIGFuZCBgdmFsdWVgIHdpbGwgYmUgZm9yY2libHkgY2FzdCB0byB0aGlzIHR5cGVcbiAgICovXG4gIFwiZXFcIjogdHJ1dGhUZXN0KCdlcScsIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xuICB9KSxcbiAgXCJuZVwiOiB0cnV0aFRlc3QoJ25lJywgZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdCAhPT0gcmlnaHQ7XG4gIH0pLFxuICBcImx0XCI6IHRydXRoVGVzdCgnbHQnLCBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0IDwgcmlnaHQ7XG4gIH0pLFxuICBcImx0ZVwiOiB0cnV0aFRlc3QoJ2x0ZScsIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQgPD0gcmlnaHQ7XG4gIH0pLFxuICBcImd0XCI6IHRydXRoVGVzdCgnZ3QnLCBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0ID4gcmlnaHQ7XG4gIH0pLFxuICBcImd0ZVwiOiB0cnV0aFRlc3QoJ2d0ZScsIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQgPj0gcmlnaHQ7XG4gIH0pLFxuXG4gIC8qKlxuICAgKiB7QGFueX1cbiAgICogT3V0cHV0cyBhcyBsb25nIGFzIGF0IGxlYXN0IG9uZSB0cnV0aCB0ZXN0IGluc2lkZSBhIHtAc2VsZWN0fSBoYXMgcGFzc2VkLlxuICAgKiBNdXN0IGJlIGNvbnRhaW5lZCBpbnNpZGUgYSB7QHNlbGVjdH0gYmxvY2suXG4gICAqIFRoZSBwYXNzaW5nIHRydXRoIHRlc3QgY2FuIGJlIGJlZm9yZSBvciBhZnRlciB0aGUge0Bhbnl9IGJsb2NrLlxuICAgKi9cbiAgXCJhbnlcIjogZnVuY3Rpb24oY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zKSB7XG4gICAgdmFyIHNlbGVjdFN0YXRlID0gZ2V0U2VsZWN0U3RhdGUoY29udGV4dCk7XG5cbiAgICBpZighc2VsZWN0U3RhdGUpIHtcbiAgICAgIGxvZyhcImFueVwiLCBcIk11c3QgYmUgdXNlZCBpbnNpZGUgYSB7QHNlbGVjdH0gYmxvY2tcIiwgXCJFUlJPUlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoc2VsZWN0U3RhdGUuaXNEZWZlcnJlZENvbXBsZXRlKSB7XG4gICAgICAgIGxvZyhcImFueVwiLCBcIk11c3Qgbm90IGJlIG5lc3RlZCBpbnNpZGUge0Bhbnl9IG9yIHtAbm9uZX0gYmxvY2tcIiwgXCJFUlJPUlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNodW5rID0gY2h1bmsubWFwKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgc2VsZWN0U3RhdGUuZGVmZXJyZWRzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZihzZWxlY3RTdGF0ZS5pc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgIGNodW5rID0gY2h1bmsucmVuZGVyKGJvZGllcy5ibG9jaywgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVuay5lbmQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaHVuaztcbiAgfSxcblxuICAvKipcbiAgICoge0Bub25lfVxuICAgKiBPdXRwdXRzIGlmIG5vIHRydXRoIHRlc3RzIGluc2lkZSBhIHtAc2VsZWN0fSBwYXNzLlxuICAgKiBNdXN0IGJlIGNvbnRhaW5lZCBpbnNpZGUgYSB7QHNlbGVjdH0gYmxvY2suXG4gICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgaGVscGVyIGRvZXMgbm90IG1hdHRlci5cbiAgICovXG4gIFwibm9uZVwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICB2YXIgc2VsZWN0U3RhdGUgPSBnZXRTZWxlY3RTdGF0ZShjb250ZXh0KTtcblxuICAgIGlmKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgbG9nKFwibm9uZVwiLCBcIk11c3QgYmUgdXNlZCBpbnNpZGUgYSB7QHNlbGVjdH0gYmxvY2tcIiwgXCJFUlJPUlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoc2VsZWN0U3RhdGUuaXNEZWZlcnJlZENvbXBsZXRlKSB7XG4gICAgICAgIGxvZyhcIm5vbmVcIiwgXCJNdXN0IG5vdCBiZSBuZXN0ZWQgaW5zaWRlIHtAYW55fSBvciB7QG5vbmV9IGJsb2NrXCIsIFwiRVJST1JcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVuayA9IGNodW5rLm1hcChmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgIHNlbGVjdFN0YXRlLmRlZmVycmVkcy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYoIXNlbGVjdFN0YXRlLmlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5yZW5kZXIoYm9kaWVzLmJsb2NrLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rLmVuZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIC8qKlxuICAqIHtAc2l6ZX1cbiAgKiBXcml0ZSB0aGUgc2l6ZSBvZiB0aGUgdGFyZ2V0IHRvIHRoZSBjaHVua1xuICAqIEZhbHN5IHZhbHVlcyBhbmQgdHJ1ZSBoYXZlIHNpemUgMFxuICAqIE51bWJlcnMgYXJlIHJldHVybmVkIGFzLWlzXG4gICogQXJyYXlzIGFuZCBTdHJpbmdzIGhhdmUgc2l6ZSBlcXVhbCB0byB0aGVpciBsZW5ndGhcbiAgKiBPYmplY3RzIGhhdmUgc2l6ZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGtleXMgdGhleSBjb250YWluXG4gICogRHVzdCBib2RpZXMgYXJlIGV2YWx1YXRlZCBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGlzIHJldHVybmVkXG4gICogRnVuY3Rpb25zIGFyZSBldmFsdWF0ZWQgYW5kIHRoZSBsZW5ndGggb2YgdGhlaXIgcmV0dXJuIHZhbHVlIGlzIGV2YWx1YXRlZFxuICAqIEBwYXJhbSBrZXkgZmluZCB0aGUgc2l6ZSBvZiB0aGlzIHZhbHVlIG9yIHJlZmVyZW5jZVxuICAqL1xuICBcInNpemVcIjogZnVuY3Rpb24oY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zKSB7XG4gICAgdmFyIGtleSA9IHBhcmFtcy5rZXksXG4gICAgICAgIHZhbHVlLCBrO1xuXG4gICAga2V5ID0gY29udGV4dC5yZXNvbHZlKHBhcmFtcy5rZXkpO1xuICAgIGlmICgha2V5IHx8IGtleSA9PT0gdHJ1ZSkge1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH0gZWxzZSBpZihkdXN0LmlzQXJyYXkoa2V5KSkge1xuICAgICAgdmFsdWUgPSBrZXkubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoIWlzTmFOKHBhcnNlRmxvYXQoa2V5KSkgJiYgaXNGaW5pdGUoa2V5KSkge1xuICAgICAgdmFsdWUgPSBrZXk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgICBmb3IoayBpbiBrZXkpe1xuICAgICAgICBpZihrZXkuaGFzT3duUHJvcGVydHkoaykpe1xuICAgICAgICAgIHZhbHVlKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSAoa2V5ICsgJycpLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rLndyaXRlKHZhbHVlKTtcbiAgfVxuXG59O1xuXG5mb3IodmFyIGtleSBpbiBoZWxwZXJzKSB7XG4gIGR1c3QuaGVscGVyc1trZXldID0gaGVscGVyc1trZXldO1xufVxuXG5yZXR1cm4gZHVzdDtcblxufSkpO1xuIiwiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lLmFtZC5kdXN0ID09PSB0cnVlKSB7XG4gICAgZGVmaW5lKCdkdXN0LmNvcmUnLCBbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5kdXN0ID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuICB2YXIgZHVzdCA9IHtcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiMi43LjVcIlxuICAgICAgfSxcbiAgICAgIE5PTkUgPSAnTk9ORScsIEVSUk9SID0gJ0VSUk9SJywgV0FSTiA9ICdXQVJOJywgSU5GTyA9ICdJTkZPJywgREVCVUcgPSAnREVCVUcnLFxuICAgICAgRU1QVFlfRlVOQyA9IGZ1bmN0aW9uKCkge307XG5cbiAgZHVzdC5jb25maWcgPSB7XG4gICAgd2hpdGVzcGFjZTogZmFsc2UsXG4gICAgYW1kOiBmYWxzZSxcbiAgICBjanM6IGZhbHNlLFxuICAgIGNhY2hlOiB0cnVlXG4gIH07XG5cbiAgLy8gRGlyZWN0aXZlIGFsaWFzZXMgdG8gbWluaWZ5IGNvZGVcbiAgZHVzdC5fYWxpYXNlcyA9IHtcbiAgICBcIndyaXRlXCI6IFwid1wiLFxuICAgIFwiZW5kXCI6IFwiZVwiLFxuICAgIFwibWFwXCI6IFwibVwiLFxuICAgIFwicmVuZGVyXCI6IFwiclwiLFxuICAgIFwicmVmZXJlbmNlXCI6IFwiZlwiLFxuICAgIFwic2VjdGlvblwiOiBcInNcIixcbiAgICBcImV4aXN0c1wiOiBcInhcIixcbiAgICBcIm5vdGV4aXN0c1wiOiBcIm54XCIsXG4gICAgXCJibG9ja1wiOiBcImJcIixcbiAgICBcInBhcnRpYWxcIjogXCJwXCIsXG4gICAgXCJoZWxwZXJcIjogXCJoXCJcbiAgfTtcblxuICAoZnVuY3Rpb24gaW5pdExvZ2dpbmcoKSB7XG4gICAgLypnbG9iYWwgcHJvY2VzcywgY29uc29sZSovXG4gICAgdmFyIGxvZ2dpbmdMZXZlbHMgPSB7IERFQlVHOiAwLCBJTkZPOiAxLCBXQVJOOiAyLCBFUlJPUjogMywgTk9ORTogNCB9LFxuICAgICAgICBjb25zb2xlTG9nLFxuICAgICAgICBsb2c7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUubG9nKSB7XG4gICAgICBjb25zb2xlTG9nID0gY29uc29sZS5sb2c7XG4gICAgICBpZih0eXBlb2YgY29uc29sZUxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlTG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlTG9nKEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpLmpvaW4oJyAnKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZyA9IEVNUFRZX0ZVTkM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsdGVycyBtZXNzYWdlcyBiYXNlZCBvbiBgZHVzdC5kZWJ1Z0xldmVsYC5cbiAgICAgKiBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbCBwcmludCB0byB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RXJyb3J9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gcHJpbnQvdGhyb3dcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgc2V2ZXJpdHkgb2YgdGhlIG1lc3NhZ2UoRVJST1IsIFdBUk4sIElORk8sIG9yIERFQlVHKVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBkdXN0LmxvZyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICAgIHR5cGUgPSB0eXBlIHx8IElORk87XG4gICAgICBpZiAobG9nZ2luZ0xldmVsc1t0eXBlXSA+PSBsb2dnaW5nTGV2ZWxzW2R1c3QuZGVidWdMZXZlbF0pIHtcbiAgICAgICAgbG9nKCdbRFVTVDonICsgdHlwZSArICddJywgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGR1c3QuZGVidWdMZXZlbCA9IE5PTkU7XG4gICAgaWYodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIC9cXGJkdXN0XFxiLy50ZXN0KHByb2Nlc3MuZW52LkRFQlVHKSkge1xuICAgICAgZHVzdC5kZWJ1Z0xldmVsID0gREVCVUc7XG4gICAgfVxuXG4gIH0oKSk7XG5cbiAgZHVzdC5oZWxwZXJzID0ge307XG5cbiAgZHVzdC5jYWNoZSA9IHt9O1xuXG4gIGR1c3QucmVnaXN0ZXIgPSBmdW5jdGlvbihuYW1lLCB0bXBsKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRtcGwudGVtcGxhdGVOYW1lID0gbmFtZTtcbiAgICBpZiAoZHVzdC5jb25maWcuY2FjaGUgIT09IGZhbHNlKSB7XG4gICAgICBkdXN0LmNhY2hlW25hbWVdID0gdG1wbDtcbiAgICB9XG4gIH07XG5cbiAgZHVzdC5yZW5kZXIgPSBmdW5jdGlvbihuYW1lT3JUZW1wbGF0ZSwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgICB2YXIgY2h1bmsgPSBuZXcgU3R1YihjYWxsYmFjaykuaGVhZDtcbiAgICB0cnkge1xuICAgICAgbG9hZChuYW1lT3JUZW1wbGF0ZSwgY2h1bmssIGNvbnRleHQpLmVuZCgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2h1bmsuc2V0RXJyb3IoZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgZHVzdC5zdHJlYW0gPSBmdW5jdGlvbihuYW1lT3JUZW1wbGF0ZSwgY29udGV4dCkge1xuICAgIHZhciBzdHJlYW0gPSBuZXcgU3RyZWFtKCksXG4gICAgICAgIGNodW5rID0gc3RyZWFtLmhlYWQ7XG4gICAgZHVzdC5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvYWQobmFtZU9yVGVtcGxhdGUsIGNodW5rLCBjb250ZXh0KS5lbmQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjaHVuay5zZXRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGEgdGVtcGxhdGUgZnVuY3Rpb24gKGJvZHlfMCkgZnJvbSB3aGF0ZXZlciBpcyBwYXNzZWQuXG4gICAqIEBwYXJhbSBuYW1lT3JUZW1wbGF0ZSB7Kn0gQ291bGQgYmU6XG4gICAqICAgLSB0aGUgbmFtZSBvZiBhIHRlbXBsYXRlIHRvIGxvYWQgZnJvbSBjYWNoZVxuICAgKiAgIC0gYSBDb21tb25KUy1jb21waWxlZCB0ZW1wbGF0ZSAoYSBmdW5jdGlvbiB3aXRoIGEgYHRlbXBsYXRlYCBwcm9wZXJ0eSlcbiAgICogICAtIGEgdGVtcGxhdGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIGxvYWRGcm9tQ2FjaGUge0Jvb2xlYW59IGlmIGZhbHNlLCBkb24ndCBsb29rIGluIHRoZSBjYWNoZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSB0ZW1wbGF0ZSBmdW5jdGlvbiwgaWYgZm91bmRcbiAgICovXG4gIGZ1bmN0aW9uIGdldFRlbXBsYXRlKG5hbWVPclRlbXBsYXRlLCBsb2FkRnJvbUNhY2hlLyo9dHJ1ZSovKSB7XG4gICAgaWYoIW5hbWVPclRlbXBsYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmKHR5cGVvZiBuYW1lT3JUZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBuYW1lT3JUZW1wbGF0ZS50ZW1wbGF0ZSkge1xuICAgICAgLy8gU3VnYXIgYXdheSBDb21tb25KUyBtb2R1bGUgdGVtcGxhdGVzXG4gICAgICByZXR1cm4gbmFtZU9yVGVtcGxhdGUudGVtcGxhdGU7XG4gICAgfVxuICAgIGlmKGR1c3QuaXNUZW1wbGF0ZUZuKG5hbWVPclRlbXBsYXRlKSkge1xuICAgICAgLy8gVGVtcGxhdGUgZnVuY3Rpb25zIHBhc3NlZCBkaXJlY3RseVxuICAgICAgcmV0dXJuIG5hbWVPclRlbXBsYXRlO1xuICAgIH1cbiAgICBpZihsb2FkRnJvbUNhY2hlICE9PSBmYWxzZSkge1xuICAgICAgLy8gVHJ5IGxvYWRpbmcgYSB0ZW1wbGF0ZSB3aXRoIHRoaXMgbmFtZSBmcm9tIGNhY2hlXG4gICAgICByZXR1cm4gZHVzdC5jYWNoZVtuYW1lT3JUZW1wbGF0ZV07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9hZChuYW1lT3JUZW1wbGF0ZSwgY2h1bmssIGNvbnRleHQpIHtcbiAgICBpZighbmFtZU9yVGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiBjaHVuay5zZXRFcnJvcihuZXcgRXJyb3IoJ05vIHRlbXBsYXRlIG9yIHRlbXBsYXRlIG5hbWUgcHJvdmlkZWQgdG8gcmVuZGVyJykpO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGdldFRlbXBsYXRlKG5hbWVPclRlbXBsYXRlLCBkdXN0LmNvbmZpZy5jYWNoZSk7XG5cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZShjaHVuaywgQ29udGV4dC53cmFwKGNvbnRleHQsIHRlbXBsYXRlLnRlbXBsYXRlTmFtZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHVzdC5vbkxvYWQpIHtcbiAgICAgICAgcmV0dXJuIGNodW5rLm1hcChmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgIC8vIEFsaWFzIGp1c3Qgc28gaXQncyBlYXNpZXIgdG8gcmVhZCB0aGF0IHRoaXMgd291bGQgYWx3YXlzIGJlIGEgbmFtZVxuICAgICAgICAgIHZhciBuYW1lID0gbmFtZU9yVGVtcGxhdGU7XG4gICAgICAgICAgLy8gVGhyZWUgcG9zc2libGUgc2NlbmFyaW9zIGZvciBhIHN1Y2Nlc3NmdWwgY2FsbGJhY2s6XG4gICAgICAgICAgLy8gICAtIGByZXF1aXJlKG5hbWVPclRlbXBsYXRlKShkdXN0KTsgY2IoKWBcbiAgICAgICAgICAvLyAgIC0gYHNyYyA9IHJlYWRGaWxlKCdzcmMuZHVzdCcpOyBjYihudWxsLCBzcmMpYFxuICAgICAgICAgIC8vICAgLSBgY29tcGlsZWRUZW1wbGF0ZSA9IHJlcXVpcmUobmFtZU9yVGVtcGxhdGUpKGR1c3QpOyBjYihudWxsLCBjb21waWxlZFRlbXBsYXRlKWBcbiAgICAgICAgICBmdW5jdGlvbiBkb25lKGVyciwgc3JjT3JUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gY2h1bmsuc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByZWZlciBhIHRlbXBsYXRlIHRoYXQgaXMgcGFzc2VkIHZpYSBjYWxsYmFjayBvdmVyIHRoZSBjYWNoZWQgdmVyc2lvbi5cbiAgICAgICAgICAgIHRlbXBsYXRlID0gZ2V0VGVtcGxhdGUoc3JjT3JUZW1wbGF0ZSwgZmFsc2UpIHx8IGdldFRlbXBsYXRlKG5hbWUsIGR1c3QuY29uZmlnLmNhY2hlKTtcbiAgICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgLy8gSXQncyBhIHRlbXBsYXRlIHN0cmluZywgY29tcGlsZSBpdCBhbmQgcmVnaXN0ZXIgdW5kZXIgYG5hbWVgXG4gICAgICAgICAgICAgIGlmKGR1c3QuY29tcGlsZSkge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gZHVzdC5sb2FkU291cmNlKGR1c3QuY29tcGlsZShzcmNPclRlbXBsYXRlLCBuYW1lKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rLnNldEVycm9yKG5ldyBFcnJvcignRHVzdCBjb21waWxlciBub3QgYXZhaWxhYmxlJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wbGF0ZShjaHVuaywgQ29udGV4dC53cmFwKGNvbnRleHQsIHRlbXBsYXRlLnRlbXBsYXRlTmFtZSkpLmVuZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKGR1c3Qub25Mb2FkLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgZHVzdC5vbkxvYWQobmFtZSwgY29udGV4dC5vcHRpb25zLCBkb25lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHVzdC5vbkxvYWQobmFtZSwgZG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaHVuay5zZXRFcnJvcihuZXcgRXJyb3IoJ1RlbXBsYXRlIE5vdCBGb3VuZDogJyArIG5hbWVPclRlbXBsYXRlKSk7XG4gICAgfVxuICB9XG5cbiAgZHVzdC5sb2FkU291cmNlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgLypqc2hpbnQgZXZpbDp0cnVlKi9cbiAgICByZXR1cm4gZXZhbChzb3VyY2UpO1xuICB9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgZHVzdC5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgfSBlbHNlIHtcbiAgICBkdXN0LmlzQXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuICB9XG5cbiAgZHVzdC5uZXh0VGljayA9IChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIER1c3QgaGFzIGl0cyBvd24gcnVsZXMgZm9yIHdoYXQgaXMgXCJlbXB0eVwiLS0gd2hpY2ggaXMgbm90IHRoZSBzYW1lIGFzIGZhbHN5LlxuICAgKiBFbXB0eSBhcnJheXMsIG51bGwsIGFuZCB1bmRlZmluZWQgYXJlIGVtcHR5XG4gICAqL1xuICBkdXN0LmlzRW1wdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZHVzdC5pc0FycmF5KHZhbHVlKSAmJiAhdmFsdWUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICF2YWx1ZTtcbiAgfTtcblxuICBkdXN0LmlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvYmoubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgZHVzdC5pc1RlbXBsYXRlRm4gPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbGVtID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgIGVsZW0uX19kdXN0Qm9keTtcbiAgfTtcblxuICAvKipcbiAgICogRGVjaWRlIHNvbWV3aGF0LW5haXZlbHkgaWYgc29tZXRoaW5nIGlzIGEgVGhlbmFibGUuXG4gICAqIEBwYXJhbSBlbGVtIHsqfSBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBpcyBgZWxlbWAgYSBUaGVuYWJsZT9cbiAgICovXG4gIGR1c3QuaXNUaGVuYWJsZSA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbSAmJlxuICAgICAgICAgICB0eXBlb2YgZWxlbSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgdHlwZW9mIGVsZW0udGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgfTtcblxuICAvKipcbiAgICogRGVjaWRlIHZlcnkgbmFpdmVseSBpZiBzb21ldGhpbmcgaXMgYSBTdHJlYW0uXG4gICAqIEBwYXJhbSBlbGVtIHsqfSBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBpcyBgZWxlbWAgYSBTdHJlYW0/XG4gICAqL1xuICBkdXN0LmlzU3RyZWFtYWJsZSA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbSAmJlxuICAgICAgICAgICB0eXBlb2YgZWxlbS5vbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICB0eXBlb2YgZWxlbS5waXBlID09PSAnZnVuY3Rpb24nO1xuICB9O1xuXG4gIC8vIGFwcGx5IHRoZSBmaWx0ZXIgY2hhaW4gYW5kIHJldHVybiB0aGUgb3V0cHV0IHN0cmluZ1xuICBkdXN0LmZpbHRlciA9IGZ1bmN0aW9uKHN0cmluZywgYXV0bywgZmlsdGVycywgY29udGV4dCkge1xuICAgIHZhciBpLCBsZW4sIG5hbWUsIGZpbHRlcjtcbiAgICBpZiAoZmlsdGVycykge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gZmlsdGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBuYW1lID0gZmlsdGVyc1tpXTtcbiAgICAgICAgaWYgKCFuYW1lLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlciA9IGR1c3QuZmlsdGVyc1tuYW1lXTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzJykge1xuICAgICAgICAgIGF1dG8gPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzdHJpbmcgPSBmaWx0ZXIoc3RyaW5nLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkdXN0LmxvZygnSW52YWxpZCBmaWx0ZXIgYCcgKyBuYW1lICsgJ2AnLCBXQVJOKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBieSBkZWZhdWx0IGFsd2F5cyBhcHBseSB0aGUgaCBmaWx0ZXIsIHVubGVzcyBhc2tlZCB0byB1bmVzY2FwZSB3aXRoIHxzXG4gICAgaWYgKGF1dG8pIHtcbiAgICAgIHN0cmluZyA9IGR1c3QuZmlsdGVyc1thdXRvXShzdHJpbmcsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xuXG4gIGR1c3QuZmlsdGVycyA9IHtcbiAgICBoOiBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gZHVzdC5lc2NhcGVIdG1sKHZhbHVlKTsgfSxcbiAgICBqOiBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gZHVzdC5lc2NhcGVKcyh2YWx1ZSk7IH0sXG4gICAgdTogZW5jb2RlVVJJLFxuICAgIHVjOiBlbmNvZGVVUklDb21wb25lbnQsXG4gICAganM6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBkdXN0LmVzY2FwZUpTT04odmFsdWUpOyB9LFxuICAgIGpwOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFKU09OKSB7ZHVzdC5sb2coJ0pTT04gaXMgdW5kZWZpbmVkOyBjb3VsZCBub3QgcGFyc2UgYCcgKyB2YWx1ZSArICdgJywgV0FSTik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gQ29udGV4dChzdGFjaywgZ2xvYmFsLCBvcHRpb25zLCBibG9ja3MsIHRlbXBsYXRlTmFtZSkge1xuICAgIGlmKHN0YWNrICE9PSB1bmRlZmluZWQgJiYgIShzdGFjayBpbnN0YW5jZW9mIFN0YWNrKSkge1xuICAgICAgc3RhY2sgPSBuZXcgU3RhY2soc3RhY2spO1xuICAgIH1cbiAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgdGhpcy5nbG9iYWwgPSBnbG9iYWw7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICB0aGlzLl9pc0NvbnRleHQgPSB0cnVlO1xuICB9XG5cbiAgZHVzdC5tYWtlQmFzZSA9IGR1c3QuY29udGV4dCA9IGZ1bmN0aW9uKGdsb2JhbCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29udGV4dCh1bmRlZmluZWQsIGdsb2JhbCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgZHVzdC5pc0NvbnRleHQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmouX2lzQ29udGV4dCA9PT0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBjbG9zdXJlIHNjb3BlIGFyb3VuZCBhIFRoZW5hYmxlLWNhbGxiYWNrLlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGEgVGhlbmFibGUgdGhhdCB3aWxsIHJlc3VtZSBhXG4gICAqIENvbnRleHQgbG9va3VwIG9uY2UgdGhlIFRoZW5hYmxlIHJlc29sdmVzIHdpdGggbmV3IGRhdGEsIGFkZGluZyB0aGF0IG5ld1xuICAgKiBkYXRhIHRvIHRoZSBsb29rdXAgc3RhY2suXG4gICAqL1xuICBmdW5jdGlvbiBnZXRXaXRoUmVzb2x2ZWREYXRhKGN0eCwgY3VyLCBkb3duKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBjdHgucHVzaChkYXRhKS5fZ2V0KGN1ciwgZG93bik7XG4gICAgfTtcbiAgfVxuXG4gIENvbnRleHQud3JhcCA9IGZ1bmN0aW9uKGNvbnRleHQsIG5hbWUpIHtcbiAgICBpZiAoZHVzdC5pc0NvbnRleHQoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbnRleHQoY29udGV4dCwge30sIHt9LCBudWxsLCBuYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIEFQSSBmb3IgZ2V0dGluZyBhIHZhbHVlIGZyb20gdGhlIGNvbnRleHQuXG4gICAqIEBtZXRob2QgZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHRoZSB2YWx1ZS4gU3VwcG9ydGVkIGZvcm1hdHMgYXJlOlxuICAgKiAna2V5J1xuICAgKiAncGF0aC50by5rZXknXG4gICAqICcucGF0aC50by5rZXknXG4gICAqIFsncGF0aCcsICd0bycsICdrZXknXVxuICAgKiBbJ2tleSddXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2N1cj1mYWxzZV0gQm9vbGVhbiB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSBzZWFyY2ggc2hvdWxkIGJlIGxpbWl0ZWQgdG8gdGhlXG4gICAqIGN1cnJlbnQgY29udGV4dCAodHJ1ZSksIG9yIGlmIGdldCBzaG91bGQgc2VhcmNoIGluIHBhcmVudCBjb250ZXh0cyBhcyB3ZWxsIChmYWxzZSkuXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge3N0cmluZ3xvYmplY3R9XG4gICAqL1xuICBDb250ZXh0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXRoLCBjdXIpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAocGF0aFswXSA9PT0gJy4nKSB7XG4gICAgICAgIGN1ciA9IHRydWU7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigxKTtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXQoY3VyLCBwYXRoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgdmFsdWUgZnJvbSB0aGUgY29udGV4dFxuICAgKiBAbWV0aG9kIF9nZXRcbiAgICogQHBhcmFtIHtib29sZWFufSBjdXIgR2V0IG9ubHkgZnJvbSB0aGUgY3VycmVudCBjb250ZXh0XG4gICAqIEBwYXJhbSB7YXJyYXl9IGRvd24gQW4gYXJyYXkgb2YgZWFjaCBzdGVwIGluIHRoZSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge3N0cmluZyB8IG9iamVjdH1cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbihjdXIsIGRvd24pIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5zdGFjayB8fCB7fSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIHZhbHVlLCBmaXJzdCwgbGVuLCBjdHhUaGlzLCBmbjtcblxuICAgIGZpcnN0ID0gZG93blswXTtcbiAgICBsZW4gPSBkb3duLmxlbmd0aDtcblxuICAgIGlmIChjdXIgJiYgbGVuID09PSAwKSB7XG4gICAgICBjdHhUaGlzID0gY3R4O1xuICAgICAgY3R4ID0gY3R4LmhlYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY3VyKSB7XG4gICAgICAgIC8vIFNlYXJjaCB1cCB0aGUgc3RhY2sgZm9yIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgICB3aGlsZSAoY3R4KSB7XG4gICAgICAgICAgaWYgKGN0eC5pc09iamVjdCkge1xuICAgICAgICAgICAgY3R4VGhpcyA9IGN0eC5oZWFkO1xuICAgICAgICAgICAgdmFsdWUgPSBjdHguaGVhZFtmaXJzdF07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4ID0gY3R4LnRhaWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgbG9va2luZyBpbiB0aGUgZ2xvYmFsIGNvbnRleHQgaWYgd2UgaGF2ZW4ndCBmb3VuZCBhbnl0aGluZyB5ZXRcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHggPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHggPSB0aGlzLmdsb2JhbCAmJiB0aGlzLmdsb2JhbFtmaXJzdF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3R4KSB7XG4gICAgICAgIC8vIGlmIHNjb3BlIGlzIGxpbWl0ZWQgYnkgYSBsZWFkaW5nIGRvdCwgZG9uJ3Qgc2VhcmNoIHVwIHRoZSB0cmVlXG4gICAgICAgIGlmKGN0eC5oZWFkKSB7XG4gICAgICAgICAgY3R4ID0gY3R4LmhlYWRbZmlyc3RdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnRleHQncyBoZWFkIGlzIGVtcHR5LCB2YWx1ZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpcyBub3QgZGVmaW5lZFxuICAgICAgICAgIGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoY3R4ICYmIGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKGR1c3QuaXNUaGVuYWJsZShjdHgpKSB7XG4gICAgICAgICAgLy8gQmFpbCBlYXJseSBieSByZXR1cm5pbmcgYSBUaGVuYWJsZSBmb3IgdGhlIHJlbWFpbmRlciBvZiB0aGUgc2VhcmNoIHRyZWVcbiAgICAgICAgICByZXR1cm4gY3R4LnRoZW4oZ2V0V2l0aFJlc29sdmVkRGF0YSh0aGlzLCBjdXIsIGRvd24uc2xpY2UoaSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjdHhUaGlzID0gY3R4O1xuICAgICAgICBjdHggPSBjdHhbZG93bltpXV07XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN0eCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gY3R4LmFwcGx5KGN0eFRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGR1c3QubG9nKGVyciwgRVJST1IpO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZuLl9fZHVzdEJvZHkgPSAhIWN0eC5fX2R1c3RCb2R5O1xuICAgICAgcmV0dXJuIGZuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3R4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZHVzdC5sb2coJ0Nhbm5vdCBmaW5kIHJlZmVyZW5jZSBgeycgKyBkb3duLmpvaW4oJy4nKSArICd9YCBpbiB0ZW1wbGF0ZSBgJyArIHRoaXMuZ2V0VGVtcGxhdGVOYW1lKCkgKyAnYCcsIElORk8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uKGN1ciwgZG93bikge1xuICAgIHJldHVybiB0aGlzLl9nZXQoY3VyLCBkb3duKTtcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oaGVhZCwgaWR4LCBsZW4pIHtcbiAgICBpZihoZWFkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGR1c3QubG9nKFwiTm90IHB1c2hpbmcgYW4gdW5kZWZpbmVkIHZhcmlhYmxlIG9udG8gdGhlIGNvbnRleHRcIiwgSU5GTyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmViYXNlKG5ldyBTdGFjayhoZWFkLCB0aGlzLnN0YWNrLCBpZHgsIGxlbikpO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5jdXJyZW50KCk7XG4gICAgdGhpcy5zdGFjayA9IHRoaXMuc3RhY2sgJiYgdGhpcy5zdGFjay50YWlsO1xuICAgIHJldHVybiBoZWFkO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLnJlYmFzZSA9IGZ1bmN0aW9uKGhlYWQpIHtcbiAgICByZXR1cm4gbmV3IENvbnRleHQoaGVhZCwgdGhpcy5nbG9iYWwsIHRoaXMub3B0aW9ucywgdGhpcy5ibG9ja3MsIHRoaXMuZ2V0VGVtcGxhdGVOYW1lKCkpO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlYmFzZSgpO1xuICAgIGNvbnRleHQuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjayAmJiB0aGlzLnN0YWNrLmhlYWQ7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuZ2V0QmxvY2sgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgYmxvY2tzLCBsZW4sIGZuO1xuXG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGtleSA9IGtleShuZXcgQ2h1bmsoKSwgdGhpcykuZGF0YS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICBibG9ja3MgPSB0aGlzLmJsb2NrcztcblxuICAgIGlmICghYmxvY2tzKSB7XG4gICAgICBkdXN0LmxvZygnTm8gYmxvY2tzIGZvciBjb250ZXh0IGAnICsga2V5ICsgJ2AgaW4gdGVtcGxhdGUgYCcgKyB0aGlzLmdldFRlbXBsYXRlTmFtZSgpICsgJ2AnLCBERUJVRyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGVuID0gYmxvY2tzLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGZuID0gYmxvY2tzW2xlbl1ba2V5XTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZHVzdC5sb2coJ01hbGZvcm1lZCB0ZW1wbGF0ZSBgJyArIHRoaXMuZ2V0VGVtcGxhdGVOYW1lKCkgKyAnYCB3YXMgbWlzc2luZyBvbmUgb3IgbW9yZSBibG9ja3MuJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLnNoaWZ0QmxvY2tzID0gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLFxuICAgICAgICBuZXdCbG9ja3M7XG5cbiAgICBpZiAobG9jYWxzKSB7XG4gICAgICBpZiAoIWJsb2Nrcykge1xuICAgICAgICBuZXdCbG9ja3MgPSBbbG9jYWxzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0Jsb2NrcyA9IGJsb2Nrcy5jb25jYXQoW2xvY2Fsc10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDb250ZXh0KHRoaXMuc3RhY2ssIHRoaXMuZ2xvYmFsLCB0aGlzLm9wdGlvbnMsIG5ld0Jsb2NrcywgdGhpcy5nZXRUZW1wbGF0ZU5hbWUoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgdmFyIGNodW5rO1xuXG4gICAgaWYodHlwZW9mIGJvZHkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbiAgICBjaHVuayA9IG5ldyBDaHVuaygpLnJlbmRlcihib2R5LCB0aGlzKTtcbiAgICBpZihjaHVuayBpbnN0YW5jZW9mIENodW5rKSB7XG4gICAgICByZXR1cm4gY2h1bmsuZGF0YS5qb2luKCcnKTsgLy8gaWU3IHBlcmZcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmdldFRlbXBsYXRlTmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlTmFtZTtcbiAgfTtcblxuICBmdW5jdGlvbiBTdGFjayhoZWFkLCB0YWlsLCBpZHgsIGxlbikge1xuICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgdGhpcy5pc09iamVjdCA9IGhlYWQgJiYgdHlwZW9mIGhlYWQgPT09ICdvYmplY3QnO1xuICAgIHRoaXMuaGVhZCA9IGhlYWQ7XG4gICAgdGhpcy5pbmRleCA9IGlkeDtcbiAgICB0aGlzLm9mID0gbGVuO1xuICB9XG5cbiAgZnVuY3Rpb24gU3R1YihjYWxsYmFjaykge1xuICAgIHRoaXMuaGVhZCA9IG5ldyBDaHVuayh0aGlzKTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5vdXQgPSAnJztcbiAgfVxuXG4gIFN0dWIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNodW5rID0gdGhpcy5oZWFkO1xuXG4gICAgd2hpbGUgKGNodW5rKSB7XG4gICAgICBpZiAoY2h1bmsuZmx1c2hhYmxlKSB7XG4gICAgICAgIHRoaXMub3V0ICs9IGNodW5rLmRhdGEuam9pbignJyk7IC8vaWU3IHBlcmZcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsuZXJyb3IpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhjaHVuay5lcnJvcik7XG4gICAgICAgIGR1c3QubG9nKCdSZW5kZXJpbmcgZmFpbGVkIHdpdGggZXJyb3IgYCcgKyBjaHVuay5lcnJvciArICdgJywgRVJST1IpO1xuICAgICAgICB0aGlzLmZsdXNoID0gRU1QVFlfRlVOQztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2h1bmsgPSBjaHVuay5uZXh0O1xuICAgICAgdGhpcy5oZWFkID0gY2h1bms7XG4gICAgfVxuICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgdGhpcy5vdXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGludGVyZmFjZSBzb3J0IG9mIGxpa2UgYSBTdHJlYW1zMiBSZWFkYWJsZVN0cmVhbS5cbiAgICovXG4gIGZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXcgQ2h1bmsodGhpcyk7XG4gIH1cblxuICBTdHJlYW0ucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNodW5rID0gdGhpcy5oZWFkO1xuXG4gICAgd2hpbGUoY2h1bmspIHtcbiAgICAgIGlmIChjaHVuay5mbHVzaGFibGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmsuZGF0YS5qb2luKCcnKSk7IC8vaWU3IHBlcmZcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsuZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGNodW5rLmVycm9yKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgZHVzdC5sb2coJ1N0cmVhbWluZyBmYWlsZWQgd2l0aCBlcnJvciBgJyArIGNodW5rLmVycm9yICsgJ2AnLCBFUlJPUik7XG4gICAgICAgIHRoaXMuZmx1c2ggPSBFTVBUWV9GVU5DO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjaHVuayA9IGNodW5rLm5leHQ7XG4gICAgICB0aGlzLmhlYWQgPSBjaHVuaztcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZXMgbGlzdGVuZXJzIGZvciBgdHlwZWAgYnkgcGFzc2luZyBkYXRhLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAqIE5vZGUgc3RyZWFtLCB3aGljaCBjYW4gcGFzcyBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgKiBAcmV0dXJuIGB0cnVlYCBpZiBldmVudCBoYWQgbGlzdGVuZXJzLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgU3RyZWFtLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cyB8fCB7fSxcbiAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV0gfHwgW10sXG4gICAgICAgIGksIGw7XG5cbiAgICBpZiAoIWhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgZHVzdC5sb2coJ1N0cmVhbSBicm9hZGNhc3RpbmcsIGJ1dCBubyBsaXN0ZW5lcnMgZm9yIGAnICsgdHlwZSArICdgJywgREVCVUcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGhhbmRsZXJzID0gaGFuZGxlcnMuc2xpY2UoMCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIFN0cmVhbS5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IHt9LFxuICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IGV2ZW50c1t0eXBlXSB8fCBbXTtcblxuICAgIGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZHVzdC5sb2coJ05vIGNhbGxiYWNrIGZ1bmN0aW9uIHByb3ZpZGVkIGZvciBgJyArIHR5cGUgKyAnYCBldmVudCBsaXN0ZW5lcicsIFdBUk4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBpcGVzIHRvIGEgV3JpdGFibGVTdHJlYW0uIE5vdGUgdGhhdCBiYWNrcHJlc3N1cmUgaXNuJ3QgaW1wbGVtZW50ZWQsXG4gICAqIHNvIHdlIGp1c3Qgd3JpdGUgYXMgZmFzdCBhcyB3ZSBjYW4uXG4gICAqIEBwYXJhbSBzdHJlYW0ge1dyaXRhYmxlU3RyZWFtfVxuICAgKiBAcmV0dXJuIHNlbGZcbiAgICovXG4gIFN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIGlmKHR5cGVvZiBzdHJlYW0ud3JpdGUgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICB0eXBlb2Ygc3RyZWFtLmVuZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZHVzdC5sb2coJ0luY29tcGF0aWJsZSBzdHJlYW0gcGFzc2VkIHRvIGBwaXBlYCcsIFdBUk4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGRlc3RFbmRlZCA9IGZhbHNlO1xuXG4gICAgaWYodHlwZW9mIHN0cmVhbS5lbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdHJlYW0uZW1pdCgncGlwZScsIHRoaXMpO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZiBzdHJlYW0ub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVzdEVuZGVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gICAgLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYoZGVzdEVuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmVhbS53cml0ZShkYXRhLCAndXRmOCcpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGR1c3QubG9nKGVyciwgRVJST1IpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmKGRlc3RFbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICAgIGRlc3RFbmRlZCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZHVzdC5sb2coZXJyLCBFUlJPUik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQ2h1bmsocm9vdCwgbmV4dCwgdGFwcykge1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB0aGlzLmRhdGEgPSBbXTsgLy9pZTcgcGVyZlxuICAgIHRoaXMuZmx1c2hhYmxlID0gZmFsc2U7XG4gICAgdGhpcy50YXBzID0gdGFwcztcbiAgfVxuXG4gIENodW5rLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgdGFwcyA9IHRoaXMudGFwcztcblxuICAgIGlmICh0YXBzKSB7XG4gICAgICBkYXRhID0gdGFwcy5nbyhkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy53cml0ZShkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5mbHVzaGFibGUgPSB0cnVlO1xuICAgIHRoaXMucm9vdC5mbHVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBjdXJzb3IgPSBuZXcgQ2h1bmsodGhpcy5yb290LCB0aGlzLm5leHQsIHRoaXMudGFwcyksXG4gICAgICAgIGJyYW5jaCA9IG5ldyBDaHVuayh0aGlzLnJvb3QsIGN1cnNvciwgdGhpcy50YXBzKTtcblxuICAgIHRoaXMubmV4dCA9IGJyYW5jaDtcbiAgICB0aGlzLmZsdXNoYWJsZSA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrKGJyYW5jaCk7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGR1c3QubG9nKGVyciwgRVJST1IpO1xuICAgICAgYnJhbmNoLnNldEVycm9yKGVycik7XG4gICAgfVxuICAgIHJldHVybiBjdXJzb3I7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uKHRhcCkge1xuICAgIHZhciB0YXBzID0gdGhpcy50YXBzO1xuXG4gICAgaWYgKHRhcHMpIHtcbiAgICAgIHRoaXMudGFwcyA9IHRhcHMucHVzaCh0YXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhcHMgPSBuZXcgVGFwKHRhcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS51bnRhcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGFwcyA9IHRoaXMudGFwcy50YWlsO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihib2R5LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGJvZHkodGhpcywgY29udGV4dCk7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLnJlZmVyZW5jZSA9IGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIGF1dG8sIGZpbHRlcnMpIHtcbiAgICBpZiAodHlwZW9mIGVsZW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVsZW0gPSBlbGVtLmFwcGx5KGNvbnRleHQuY3VycmVudCgpLCBbdGhpcywgY29udGV4dCwgbnVsbCwge2F1dG86IGF1dG8sIGZpbHRlcnM6IGZpbHRlcnN9XSk7XG4gICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIENodW5rKSB7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlKGVsZW0sIGNvbnRleHQsIGF1dG8sIGZpbHRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZHVzdC5pc1RoZW5hYmxlKGVsZW0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5hd2FpdChlbGVtLCBjb250ZXh0LCBudWxsLCBhdXRvLCBmaWx0ZXJzKTtcbiAgICB9IGVsc2UgaWYgKGR1c3QuaXNTdHJlYW1hYmxlKGVsZW0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0oZWxlbSwgY29udGV4dCwgbnVsbCwgYXV0bywgZmlsdGVycyk7XG4gICAgfSBlbHNlIGlmICghZHVzdC5pc0VtcHR5KGVsZW0pKSB7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZShkdXN0LmZpbHRlcihlbGVtLCBhdXRvLCBmaWx0ZXJzLCBjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUuc2VjdGlvbiA9IGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIGJvZGllcywgcGFyYW1zKSB7XG4gICAgdmFyIGJvZHkgPSBib2RpZXMuYmxvY2ssXG4gICAgICAgIHNraXAgPSBib2RpZXNbJ2Vsc2UnXSxcbiAgICAgICAgY2h1bmsgPSB0aGlzLFxuICAgICAgICBpLCBsZW4sIGhlYWQ7XG5cbiAgICBpZiAodHlwZW9mIGVsZW0gPT09ICdmdW5jdGlvbicgJiYgIWR1c3QuaXNUZW1wbGF0ZUZuKGVsZW0pKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbGVtID0gZWxlbS5hcHBseShjb250ZXh0LmN1cnJlbnQoKSwgW3RoaXMsIGNvbnRleHQsIGJvZGllcywgcGFyYW1zXSk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBkdXN0LmxvZyhlcnIsIEVSUk9SKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIC8vIEZ1bmN0aW9ucyB0aGF0IHJldHVybiBjaHVua3MgYXJlIGFzc3VtZWQgdG8gaGF2ZSBoYW5kbGVkIHRoZSBjaHVuayBtYW51YWxseS5cbiAgICAgIC8vIE1ha2UgdGhhdCBjaHVuayB0aGUgY3VycmVudCBvbmUgYW5kIGdvIHRvIHRoZSBuZXh0IG1ldGhvZCBpbiB0aGUgY2hhaW4uXG4gICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIENodW5rKSB7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkdXN0LmlzRW1wdHlPYmplY3QoYm9kaWVzKSkge1xuICAgICAgLy8gTm8gYm9kaWVzIHRvIHJlbmRlciwgYW5kIHdlJ3ZlIGFscmVhZHkgaW52b2tlZCBhbnkgZnVuY3Rpb24gdGhhdCB3YXMgYXZhaWxhYmxlIGluXG4gICAgICAvLyBob3BlcyBvZiByZXR1cm5pbmcgYSBDaHVuay5cbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG5cbiAgICBpZiAoIWR1c3QuaXNFbXB0eU9iamVjdChwYXJhbXMpKSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5wdXNoKHBhcmFtcyk7XG4gICAgfVxuXG4gICAgLypcbiAgICBEdXN0J3MgZGVmYXVsdCBiZWhhdmlvciBpcyB0byBlbnVtZXJhdGUgb3ZlciB0aGUgYXJyYXkgZWxlbSwgcGFzc2luZyBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkgdG8gdGhlIGJsb2NrLlxuICAgIFdoZW4gZWxlbSByZXNvbHZlcyB0byBhIHZhbHVlIG9yIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LCBEdXN0IHNldHMgdGhlIGN1cnJlbnQgY29udGV4dCB0byB0aGUgdmFsdWVcbiAgICBhbmQgcmVuZGVycyB0aGUgYmxvY2sgb25lIHRpbWUuXG4gICAgKi9cbiAgICBpZiAoZHVzdC5pc0FycmF5KGVsZW0pKSB7XG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICBsZW4gPSBlbGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICBoZWFkID0gY29udGV4dC5zdGFjayAmJiBjb250ZXh0LnN0YWNrLmhlYWQgfHwge307XG4gICAgICAgICAgaGVhZC4kbGVuID0gbGVuO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaGVhZC4kaWR4ID0gaTtcbiAgICAgICAgICAgIGNodW5rID0gYm9keShjaHVuaywgY29udGV4dC5wdXNoKGVsZW1baV0sIGksIGxlbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoZWFkLiRpZHggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaGVhZC4kbGVuID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiBjaHVuaztcbiAgICAgICAgfSBlbHNlIGlmIChza2lwKSB7XG4gICAgICAgICAgcmV0dXJuIHNraXAodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGR1c3QuaXNUaGVuYWJsZShlbGVtKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXdhaXQoZWxlbSwgY29udGV4dCwgYm9kaWVzKTtcbiAgICB9IGVsc2UgaWYgKGR1c3QuaXNTdHJlYW1hYmxlKGVsZW0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0oZWxlbSwgY29udGV4dCwgYm9kaWVzKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0gPT09IHRydWUpIHtcbiAgICAgLy8gdHJ1ZSBpcyB0cnV0aHkgYnV0IGRvZXMgbm90IGNoYW5nZSBjb250ZXh0XG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICByZXR1cm4gYm9keSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsZW0gfHwgZWxlbSA9PT0gMCkge1xuICAgICAgIC8vIGV2ZXJ5dGhpbmcgdGhhdCBldmFsdWF0ZXMgdG8gdHJ1ZSBhcmUgdHJ1dGh5ICggZS5nLiBOb24tZW1wdHkgc3RyaW5ncyBhbmQgRW1wdHkgb2JqZWN0cyBhcmUgdHJ1dGh5LiApXG4gICAgICAgLy8gemVybyBpcyB0cnV0aHlcbiAgICAgICAvLyBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB0aGF0IGRpZCBub3QgcmV0dXJucyBhIGNodW5rLCB0cnV0aGluZXNzIGlzIGV2YWx1YXRlZCBiYXNlZCBvbiB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICByZXR1cm4gYm9keSh0aGlzLCBjb250ZXh0LnB1c2goZWxlbSkpO1xuICAgICAgfVxuICAgICAvLyBub25leGlzdGVudCwgc2NhbGFyIGZhbHNlIHZhbHVlLCBzY2FsYXIgZW1wdHkgc3RyaW5nLCBudWxsLFxuICAgICAvLyB1bmRlZmluZWQgYXJlIGFsbCBmYWxzeVxuICAgIH0gZWxzZSBpZiAoc2tpcCkge1xuICAgICAgcmV0dXJuIHNraXAodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIGR1c3QubG9nKCdTZWN0aW9uIHdpdGhvdXQgY29ycmVzcG9uZGluZyBrZXkgaW4gdGVtcGxhdGUgYCcgKyBjb250ZXh0LmdldFRlbXBsYXRlTmFtZSgpICsgJ2AnLCBERUJVRyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIGJvZGllcykge1xuICAgIHZhciBib2R5ID0gYm9kaWVzLmJsb2NrLFxuICAgICAgICBza2lwID0gYm9kaWVzWydlbHNlJ107XG5cbiAgICBpZiAoIWR1c3QuaXNFbXB0eShlbGVtKSkge1xuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkodGhpcywgY29udGV4dCk7XG4gICAgICB9XG4gICAgICBkdXN0LmxvZygnTm8gYmxvY2sgZm9yIGV4aXN0cyBjaGVjayBpbiB0ZW1wbGF0ZSBgJyArIGNvbnRleHQuZ2V0VGVtcGxhdGVOYW1lKCkgKyAnYCcsIERFQlVHKTtcbiAgICB9IGVsc2UgaWYgKHNraXApIHtcbiAgICAgIHJldHVybiBza2lwKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUubm90ZXhpc3RzID0gZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgYm9kaWVzKSB7XG4gICAgdmFyIGJvZHkgPSBib2RpZXMuYmxvY2ssXG4gICAgICAgIHNraXAgPSBib2RpZXNbJ2Vsc2UnXTtcblxuICAgIGlmIChkdXN0LmlzRW1wdHkoZWxlbSkpIHtcbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIHJldHVybiBib2R5KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZHVzdC5sb2coJ05vIGJsb2NrIGZvciBub3QtZXhpc3RzIGNoZWNrIGluIHRlbXBsYXRlIGAnICsgY29udGV4dC5nZXRUZW1wbGF0ZU5hbWUoKSArICdgJywgREVCVUcpO1xuICAgIH0gZWxzZSBpZiAoc2tpcCkge1xuICAgICAgcmV0dXJuIHNraXAodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5ibG9jayA9IGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIGJvZGllcykge1xuICAgIHZhciBib2R5ID0gZWxlbSB8fCBib2RpZXMuYmxvY2s7XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgcmV0dXJuIGJvZHkodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5wYXJ0aWFsID0gZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgcGFydGlhbENvbnRleHQsIHBhcmFtcykge1xuICAgIHZhciBoZWFkO1xuXG4gICAgaWYocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIENvbXBhdGliaWxpdHkgZm9yIDwgMi43LjAgd2hlcmUgYHBhcnRpYWxDb250ZXh0YCBkaWQgbm90IGV4aXN0XG4gICAgICBwYXJhbXMgPSBwYXJ0aWFsQ29udGV4dDtcbiAgICAgIHBhcnRpYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoIWR1c3QuaXNFbXB0eU9iamVjdChwYXJhbXMpKSB7XG4gICAgICBwYXJ0aWFsQ29udGV4dCA9IHBhcnRpYWxDb250ZXh0LmNsb25lKCk7XG4gICAgICBoZWFkID0gcGFydGlhbENvbnRleHQucG9wKCk7XG4gICAgICBwYXJ0aWFsQ29udGV4dCA9IHBhcnRpYWxDb250ZXh0LnB1c2gocGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wdXNoKGhlYWQpO1xuICAgIH1cblxuICAgIGlmIChkdXN0LmlzVGVtcGxhdGVGbihlbGVtKSkge1xuICAgICAgLy8gVGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBldmFsdWF0aW5nIGBlbGVtYCBpcyBhIHBhcnRpYWwgbmFtZVxuICAgICAgLy8gTG9hZCB0aGUgcGFydGlhbCBhZnRlciBnZXR0aW5nIGl0cyBuYW1lIGFuZCBlbmQgdGhlIGFzeW5jIGNodW5rXG4gICAgICByZXR1cm4gdGhpcy5jYXB0dXJlKGVsZW0sIGNvbnRleHQsIGZ1bmN0aW9uKG5hbWUsIGNodW5rKSB7XG4gICAgICAgIHBhcnRpYWxDb250ZXh0LnRlbXBsYXRlTmFtZSA9IG5hbWU7XG4gICAgICAgIGxvYWQobmFtZSwgY2h1bmssIHBhcnRpYWxDb250ZXh0KS5lbmQoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0aWFsQ29udGV4dC50ZW1wbGF0ZU5hbWUgPSBlbGVtO1xuICAgICAgcmV0dXJuIGxvYWQoZWxlbSwgdGhpcywgcGFydGlhbENvbnRleHQpO1xuICAgIH1cbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUuaGVscGVyID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMsIGF1dG8pIHtcbiAgICB2YXIgY2h1bmsgPSB0aGlzLFxuICAgICAgICBmaWx0ZXJzID0gcGFyYW1zLmZpbHRlcnMsXG4gICAgICAgIHJldDtcblxuICAgIC8vIFByZS0yLjcuMSBjb21wYXQ6IGlmIGF1dG8gaXMgdW5kZWZpbmVkLCBpdCdzIGFuIG9sZCB0ZW1wbGF0ZS4gQXV0b21hdGljYWxseSBlc2NhcGVcbiAgICBpZiAoYXV0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdXRvID0gJ2gnO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBpbnZhbGlkIGhlbHBlcnMsIHNpbWlsYXIgdG8gaW52YWxpZCBmaWx0ZXJzXG4gICAgaWYoZHVzdC5oZWxwZXJzW25hbWVdKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBkdXN0LmhlbHBlcnNbbmFtZV0oY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIENodW5rKSB7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBpZih0eXBlb2YgZmlsdGVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBmaWx0ZXJzID0gZmlsdGVycy5zcGxpdCgnfCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZHVzdC5pc0VtcHR5T2JqZWN0KGJvZGllcykpIHtcbiAgICAgICAgICByZXR1cm4gY2h1bmsuc2VjdGlvbihyZXQsIGNvbnRleHQsIGJvZGllcywgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIZWxwZXJzIGFjdCBzbGlnaHRseSBkaWZmZXJlbnRseSBmcm9tIGZ1bmN0aW9ucyBpbiBjb250ZXh0IGluIHRoYXQgdGhleSB3aWxsIGFjdCBhc1xuICAgICAgICAvLyBhIHJlZmVyZW5jZSBpZiB0aGV5IGFyZSBzZWxmLWNsb3NpbmcgKGR1ZSB0byBncmFtbWFyIGxpbWl0YXRpb25zKVxuICAgICAgICAvLyBJbiB0aGUgQ2h1bmsuYXdhaXQgZnVuY3Rpb24gd2UgY2hlY2sgdG8gbWFrZSBzdXJlIGJvZGllcyBpcyBudWxsIGJlZm9yZSBhY3RpbmcgYXMgYSByZWZlcmVuY2VcbiAgICAgICAgcmV0dXJuIGNodW5rLnJlZmVyZW5jZShyZXQsIGNvbnRleHQsIGF1dG8sIGZpbHRlcnMpO1xuICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgZHVzdC5sb2coJ0Vycm9yIGluIGhlbHBlciBgJyArIG5hbWUgKyAnYDogJyArIGVyci5tZXNzYWdlLCBFUlJPUik7XG4gICAgICAgIHJldHVybiBjaHVuay5zZXRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkdXN0LmxvZygnSGVscGVyIGAnICsgbmFtZSArICdgIGRvZXMgbm90IGV4aXN0JywgV0FSTik7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNlcnZlIGEgY2h1bmsgdG8gYmUgZXZhbHVhdGVkIG9uY2UgYSB0aGVuYWJsZSBpcyByZXNvbHZlZCBvciByZWplY3RlZFxuICAgKiBAcGFyYW0gdGhlbmFibGUge1RoZW5hYmxlfSB0aGUgdGFyZ2V0IHRoZW5hYmxlIHRvIGF3YWl0XG4gICAqIEBwYXJhbSBjb250ZXh0IHtDb250ZXh0fSBjb250ZXh0IHRvIHVzZSB0byByZW5kZXIgdGhlIGRlZmVycmVkIGNodW5rXG4gICAqIEBwYXJhbSBib2RpZXMge09iamVjdH0gbXVzdCBjb250YWluIGEgXCJib2R5XCIsIG1heSBjb250YWluIGFuIFwiZXJyb3JcIlxuICAgKiBAcGFyYW0gYXV0byB7U3RyaW5nfSBhdXRvbWF0aWNhbGx5IGFwcGx5IHRoaXMgZmlsdGVyIGlmIHRoZSBUaGVuYWJsZSBpcyBhIHJlZmVyZW5jZVxuICAgKiBAcGFyYW0gZmlsdGVycyB7QXJyYXl9IGFwcGx5IHRoZXNlIGZpbHRlcnMgaWYgdGhlIFRoZW5hYmxlIGlzIGEgcmVmZXJlbmNlXG4gICAqIEByZXR1cm4ge0NodW5rfVxuICAgKi9cbiAgQ2h1bmsucHJvdG90eXBlLmF3YWl0ID0gZnVuY3Rpb24odGhlbmFibGUsIGNvbnRleHQsIGJvZGllcywgYXV0bywgZmlsdGVycykge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihjaHVuaykge1xuICAgICAgdGhlbmFibGUudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChib2RpZXMpIHtcbiAgICAgICAgICBjaHVuayA9IGNodW5rLnNlY3Rpb24oZGF0YSwgY29udGV4dCwgYm9kaWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBY3R1YWxseSBhIHJlZmVyZW5jZS4gU2VsZi1jbG9zaW5nIHNlY3Rpb25zIGRvbid0IHJlbmRlclxuICAgICAgICAgIGNodW5rID0gY2h1bmsucmVmZXJlbmNlKGRhdGEsIGNvbnRleHQsIGF1dG8sIGZpbHRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rLmVuZCgpO1xuICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIHZhciBlcnJvckJvZHkgPSBib2RpZXMgJiYgYm9kaWVzLmVycm9yO1xuICAgICAgICBpZihlcnJvckJvZHkpIHtcbiAgICAgICAgICBjaHVuay5yZW5kZXIoZXJyb3JCb2R5LCBjb250ZXh0LnB1c2goZXJyKSkuZW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHVzdC5sb2coJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbiBpbiBgJyArIGNvbnRleHQuZ2V0VGVtcGxhdGVOYW1lKCkgKyAnYCcsIElORk8pO1xuICAgICAgICAgIGNodW5rLmVuZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzZXJ2ZSBhIGNodW5rIHRvIGJlIGV2YWx1YXRlZCB3aXRoIHRoZSBjb250ZW50cyBvZiBhIHN0cmVhbWFibGUuXG4gICAqIEN1cnJlbnRseSBhbiBlcnJvciBldmVudCB3aWxsIGJvbWIgb3V0IHRoZSBzdHJlYW0uIE9uY2UgYW4gZXJyb3JcbiAgICogaXMgcmVjZWl2ZWQsIHdlIHB1c2ggaXQgdG8gYW4gezplcnJvcn0gYmxvY2sgaWYgb25lIGV4aXN0cywgYW5kIGxvZyBvdGhlcndpc2UsXG4gICAqIHRoZW4gc3RvcCBsaXN0ZW5pbmcgdG8gdGhlIHN0cmVhbS5cbiAgICogQHBhcmFtIHN0cmVhbWFibGUge1N0cmVhbWFibGV9IHRoZSB0YXJnZXQgc3RyZWFtYWJsZSB0aGF0IHdpbGwgZW1pdCBldmVudHNcbiAgICogQHBhcmFtIGNvbnRleHQge0NvbnRleHR9IGNvbnRleHQgdG8gdXNlIHRvIHJlbmRlciBlYWNoIHRodW5rXG4gICAqIEBwYXJhbSBib2RpZXMge09iamVjdH0gbXVzdCBjb250YWluIGEgXCJib2R5XCIsIG1heSBjb250YWluIGFuIFwiZXJyb3JcIlxuICAgKiBAcmV0dXJuIHtDaHVua31cbiAgICovXG4gIENodW5rLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0sIGNvbnRleHQsIGJvZGllcywgYXV0bywgZmlsdGVycykge1xuICAgIHZhciBib2R5ID0gYm9kaWVzICYmIGJvZGllcy5ibG9jayxcbiAgICAgICAgZXJyb3JCb2R5ID0gYm9kaWVzICYmIGJvZGllcy5lcnJvcjtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIHZhciBlbmRlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtXG4gICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIGRhdGEodGh1bmspIHtcbiAgICAgICAgICBpZihlbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihib2R5KSB7XG4gICAgICAgICAgICAvLyBGb3JrIGEgbmV3IGNodW5rIG91dCBvZiB0aGUgYmxvY2tzdHJlYW0gc28gdGhhdCB3ZSBjYW4gZmx1c2ggaXQgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgY2h1bmsucmVuZGVyKGJvZHksIGNvbnRleHQucHVzaCh0aHVuaykpLmVuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmKCFib2RpZXMpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYWN0dWFsbHkgYSByZWZlcmVuY2UsIGRvbid0IGZvcmssIGp1c3Qgd3JpdGUgaW50byB0aGUgbWFzdGVyIGFzeW5jIGNodW5rXG4gICAgICAgICAgICBjaHVuayA9IGNodW5rLnJlZmVyZW5jZSh0aHVuaywgY29udGV4dCwgYXV0bywgZmlsdGVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICAgICAgaWYoZW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZXJyb3JCb2R5KSB7XG4gICAgICAgICAgICBjaHVuay5yZW5kZXIoZXJyb3JCb2R5LCBjb250ZXh0LnB1c2goZXJyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR1c3QubG9nKCdVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIGAnICsgY29udGV4dC5nZXRUZW1wbGF0ZU5hbWUoKSArICdgJywgSU5GTyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCFlbmRlZCkge1xuICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2h1bmsuZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2VuZCcsIGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgICAgICBpZighZW5kZWQpIHtcbiAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNodW5rLmVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLmNhcHR1cmUgPSBmdW5jdGlvbihib2R5LCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihjaHVuaykge1xuICAgICAgdmFyIHN0dWIgPSBuZXcgU3R1YihmdW5jdGlvbihlcnIsIG91dCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2h1bmsuc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhvdXQsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBib2R5KHN0dWIuaGVhZCwgY29udGV4dCkuZW5kKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLnNldEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgdGhpcy5lcnJvciA9IGVycjtcbiAgICB0aGlzLnJvb3QuZmx1c2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBDaHVuayBhbGlhc2VzXG4gIGZvcih2YXIgZiBpbiBDaHVuay5wcm90b3R5cGUpIHtcbiAgICBpZihkdXN0Ll9hbGlhc2VzW2ZdKSB7XG4gICAgICBDaHVuay5wcm90b3R5cGVbZHVzdC5fYWxpYXNlc1tmXV0gPSBDaHVuay5wcm90b3R5cGVbZl07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gVGFwKGhlYWQsIHRhaWwpIHtcbiAgICB0aGlzLmhlYWQgPSBoZWFkO1xuICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gIH1cblxuICBUYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih0YXApIHtcbiAgICByZXR1cm4gbmV3IFRhcCh0YXAsIHRoaXMpO1xuICB9O1xuXG4gIFRhcC5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciB0YXAgPSB0aGlzO1xuXG4gICAgd2hpbGUodGFwKSB7XG4gICAgICB2YWx1ZSA9IHRhcC5oZWFkKHZhbHVlKTtcbiAgICAgIHRhcCA9IHRhcC50YWlsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdmFyIEhDSEFSUyA9IC9bJjw+XCInXS8sXG4gICAgICBBTVAgICAgPSAvJi9nLFxuICAgICAgTFQgICAgID0gLzwvZyxcbiAgICAgIEdUICAgICA9IC8+L2csXG4gICAgICBRVU9UICAgPSAvXFxcIi9nLFxuICAgICAgU1FVT1QgID0gL1xcJy9nO1xuXG4gIGR1c3QuZXNjYXBlSHRtbCA9IGZ1bmN0aW9uKHMpIHtcbiAgICBpZiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgfHwgKHMgJiYgdHlwZW9mIHMudG9TdHJpbmcgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgIGlmICh0eXBlb2YgcyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzID0gcy50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKCFIQ0hBUlMudGVzdChzKSkge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzLnJlcGxhY2UoQU1QLCcmYW1wOycpLnJlcGxhY2UoTFQsJyZsdDsnKS5yZXBsYWNlKEdULCcmZ3Q7JykucmVwbGFjZShRVU9ULCcmcXVvdDsnKS5yZXBsYWNlKFNRVU9ULCAnJiMzOTsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH07XG5cbiAgdmFyIEJTID0gL1xcXFwvZyxcbiAgICAgIEZTID0gL1xcLy9nLFxuICAgICAgQ1IgPSAvXFxyL2csXG4gICAgICBMUyA9IC9cXHUyMDI4L2csXG4gICAgICBQUyA9IC9cXHUyMDI5L2csXG4gICAgICBOTCA9IC9cXG4vZyxcbiAgICAgIExGID0gL1xcZi9nLFxuICAgICAgU1EgPSAvJy9nLFxuICAgICAgRFEgPSAvXCIvZyxcbiAgICAgIFRCID0gL1xcdC9nO1xuXG4gIGR1c3QuZXNjYXBlSnMgPSBmdW5jdGlvbihzKSB7XG4gICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHNcbiAgICAgICAgLnJlcGxhY2UoQlMsICdcXFxcXFxcXCcpXG4gICAgICAgIC5yZXBsYWNlKEZTLCAnXFxcXC8nKVxuICAgICAgICAucmVwbGFjZShEUSwgJ1xcXFxcIicpXG4gICAgICAgIC5yZXBsYWNlKFNRLCAnXFxcXFxcJycpXG4gICAgICAgIC5yZXBsYWNlKENSLCAnXFxcXHInKVxuICAgICAgICAucmVwbGFjZShMUywgJ1xcXFx1MjAyOCcpXG4gICAgICAgIC5yZXBsYWNlKFBTLCAnXFxcXHUyMDI5JylcbiAgICAgICAgLnJlcGxhY2UoTkwsICdcXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKExGLCAnXFxcXGYnKVxuICAgICAgICAucmVwbGFjZShUQiwgJ1xcXFx0Jyk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9O1xuXG4gIGR1c3QuZXNjYXBlSlNPTiA9IGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoIUpTT04pIHtcbiAgICAgIGR1c3QubG9nKCdKU09OIGlzIHVuZGVmaW5lZDsgY291bGQgbm90IGVzY2FwZSBgJyArIG8gKyAnYCcsIFdBUk4pO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvKVxuICAgICAgICAucmVwbGFjZShMUywgJ1xcXFx1MjAyOCcpXG4gICAgICAgIC5yZXBsYWNlKFBTLCAnXFxcXHUyMDI5JylcbiAgICAgICAgLnJlcGxhY2UoTFQsICdcXFxcdTAwM2MnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGR1c3Q7XG5cbn0pKTtcbiIsIi8qKlxuKiBAcHJlc2VydmUgSFRNTDUgU2hpdiAzLjcuMyB8IEBhZmFya2FzIEBqZGFsdG9uIEBqb25fbmVhbCBAcmVtIHwgTUlUL0dQTDIgTGljZW5zZWRcbiovXG47KGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQpIHtcbi8qanNoaW50IGV2aWw6dHJ1ZSAqL1xuICAvKiogdmVyc2lvbiAqL1xuICB2YXIgdmVyc2lvbiA9ICczLjcuMy1wcmUnO1xuXG4gIC8qKiBQcmVzZXQgb3B0aW9ucyAqL1xuICB2YXIgb3B0aW9ucyA9IHdpbmRvdy5odG1sNSB8fCB7fTtcblxuICAvKiogVXNlZCB0byBza2lwIHByb2JsZW0gZWxlbWVudHMgKi9cbiAgdmFyIHJlU2tpcCA9IC9ePHxeKD86YnV0dG9ufG1hcHxzZWxlY3R8dGV4dGFyZWF8b2JqZWN0fGlmcmFtZXxvcHRpb258b3B0Z3JvdXApJC9pO1xuXG4gIC8qKiBOb3QgYWxsIGVsZW1lbnRzIGNhbiBiZSBjbG9uZWQgaW4gSUUgKiovXG4gIHZhciBzYXZlQ2xvbmVzID0gL14oPzphfGJ8Y29kZXxkaXZ8ZmllbGRzZXR8aDF8aDJ8aDN8aDR8aDV8aDZ8aXxsYWJlbHxsaXxvbHxwfHF8c3BhbnxzdHJvbmd8c3R5bGV8dGFibGV8dGJvZHl8dGR8dGh8dHJ8dWwpJC9pO1xuXG4gIC8qKiBEZXRlY3Qgd2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyBkZWZhdWx0IGh0bWw1IHN0eWxlcyAqL1xuICB2YXIgc3VwcG9ydHNIdG1sNVN0eWxlcztcblxuICAvKiogTmFtZSBvZiB0aGUgZXhwYW5kbywgdG8gd29yayB3aXRoIG11bHRpcGxlIGRvY3VtZW50cyBvciB0byByZS1zaGl2IG9uZSBkb2N1bWVudCAqL1xuICB2YXIgZXhwYW5kbyA9ICdfaHRtbDVzaGl2JztcblxuICAvKiogVGhlIGlkIGZvciB0aGUgdGhlIGRvY3VtZW50cyBleHBhbmRvICovXG4gIHZhciBleHBhbklEID0gMDtcblxuICAvKiogQ2FjaGVkIGRhdGEgZm9yIGVhY2ggZG9jdW1lbnQgKi9cbiAgdmFyIGV4cGFuZG9EYXRhID0ge307XG5cbiAgLyoqIERldGVjdCB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHVua25vd24gZWxlbWVudHMgKi9cbiAgdmFyIHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzO1xuXG4gIChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgYS5pbm5lckhUTUwgPSAnPHh5ej48L3h5ej4nO1xuICAgICAgICAvL2lmIHRoZSBoaWRkZW4gcHJvcGVydHkgaXMgaW1wbGVtZW50ZWQgd2UgY2FuIGFzc3VtZSwgdGhhdCB0aGUgYnJvd3NlciBzdXBwb3J0cyBiYXNpYyBIVE1MNSBTdHlsZXNcbiAgICAgICAgc3VwcG9ydHNIdG1sNVN0eWxlcyA9ICgnaGlkZGVuJyBpbiBhKTtcblxuICAgICAgICBzdXBwb3J0c1Vua25vd25FbGVtZW50cyA9IGEuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSB8fCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gYXNzaWduIGEgZmFsc2UgcG9zaXRpdmUgaWYgdW5hYmxlIHRvIHNoaXZcbiAgICAgICAgICAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCkoJ2EnKTtcbiAgICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIGZyYWcuY2xvbmVOb2RlID09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZnJhZy5jcmVhdGVEb2N1bWVudEZyYWdtZW50ID09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZnJhZy5jcmVhdGVFbGVtZW50ID09ICd1bmRlZmluZWQnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSgpKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIC8vIGFzc2lnbiBhIGZhbHNlIHBvc2l0aXZlIGlmIGRldGVjdGlvbiBmYWlscyA9PiB1bmFibGUgdG8gc2hpdlxuICAgICAgc3VwcG9ydHNIdG1sNVN0eWxlcyA9IHRydWU7XG4gICAgICBzdXBwb3J0c1Vua25vd25FbGVtZW50cyA9IHRydWU7XG4gICAgfVxuXG4gIH0oKSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdHlsZSBzaGVldCB3aXRoIHRoZSBnaXZlbiBDU1MgdGV4dCBhbmQgYWRkcyBpdCB0byB0aGUgZG9jdW1lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3NzVGV4dCBUaGUgQ1NTIHRleHQuXG4gICAqIEByZXR1cm5zIHtTdHlsZVNoZWV0fSBUaGUgc3R5bGUgZWxlbWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZFN0eWxlU2hlZXQob3duZXJEb2N1bWVudCwgY3NzVGV4dCkge1xuICAgIHZhciBwID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyksXG4gICAgICAgIHBhcmVudCA9IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSB8fCBvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgIHAuaW5uZXJIVE1MID0gJ3g8c3R5bGU+JyArIGNzc1RleHQgKyAnPC9zdHlsZT4nO1xuICAgIHJldHVybiBwYXJlbnQuaW5zZXJ0QmVmb3JlKHAubGFzdENoaWxkLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYGh0bWw1LmVsZW1lbnRzYCBhcyBhbiBhcnJheS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBzaGl2ZWQgZWxlbWVudCBub2RlIG5hbWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudHMoKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gaHRtbDUuZWxlbWVudHM7XG4gICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50cyA9PSAnc3RyaW5nJyA/IGVsZW1lbnRzLnNwbGl0KCcgJykgOiBlbGVtZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmRzIHRoZSBidWlsdC1pbiBsaXN0IG9mIGh0bWw1IGVsZW1lbnRzXG4gICAqIEBtZW1iZXJPZiBodG1sNVxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gbmV3RWxlbWVudHMgd2hpdGVzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvciBhcnJheSBvZiBuZXcgZWxlbWVudCBuYW1lcyB0byBzaGl2XG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGNvbnRleHQgZG9jdW1lbnQuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRFbGVtZW50cyhuZXdFbGVtZW50cywgb3duZXJEb2N1bWVudCkge1xuICAgIHZhciBlbGVtZW50cyA9IGh0bWw1LmVsZW1lbnRzO1xuICAgIGlmKHR5cGVvZiBlbGVtZW50cyAhPSAnc3RyaW5nJyl7XG4gICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgaWYodHlwZW9mIG5ld0VsZW1lbnRzICE9ICdzdHJpbmcnKXtcbiAgICAgIG5ld0VsZW1lbnRzID0gbmV3RWxlbWVudHMuam9pbignICcpO1xuICAgIH1cbiAgICBodG1sNS5lbGVtZW50cyA9IGVsZW1lbnRzICsnICcrIG5ld0VsZW1lbnRzO1xuICAgIHNoaXZEb2N1bWVudChvd25lckRvY3VtZW50KTtcbiAgfVxuXG4gICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhc3NvY2lhdGVkIHRvIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBkb2N1bWVudC5cbiAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IG9mIGRhdGEuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFeHBhbmRvRGF0YShvd25lckRvY3VtZW50KSB7XG4gICAgdmFyIGRhdGEgPSBleHBhbmRvRGF0YVtvd25lckRvY3VtZW50W2V4cGFuZG9dXTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICBleHBhbklEKys7XG4gICAgICAgIG93bmVyRG9jdW1lbnRbZXhwYW5kb10gPSBleHBhbklEO1xuICAgICAgICBleHBhbmRvRGF0YVtleHBhbklEXSA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgYSBzaGl2ZWQgZWxlbWVudCBmb3IgdGhlIGdpdmVuIG5vZGVOYW1lIGFuZCBkb2N1bWVudFxuICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lIG5hbWUgb2YgdGhlIGVsZW1lbnRcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgY29udGV4dCBkb2N1bWVudC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHNoaXZlZCBlbGVtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudChub2RlTmFtZSwgb3duZXJEb2N1bWVudCwgZGF0YSl7XG4gICAgaWYgKCFvd25lckRvY3VtZW50KSB7XG4gICAgICAgIG93bmVyRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9XG4gICAgaWYoc3VwcG9ydHNVbmtub3duRWxlbWVudHMpe1xuICAgICAgICByZXR1cm4gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBnZXRFeHBhbmRvRGF0YShvd25lckRvY3VtZW50KTtcbiAgICB9XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoZGF0YS5jYWNoZVtub2RlTmFtZV0pIHtcbiAgICAgICAgbm9kZSA9IGRhdGEuY2FjaGVbbm9kZU5hbWVdLmNsb25lTm9kZSgpO1xuICAgIH0gZWxzZSBpZiAoc2F2ZUNsb25lcy50ZXN0KG5vZGVOYW1lKSkge1xuICAgICAgICBub2RlID0gKGRhdGEuY2FjaGVbbm9kZU5hbWVdID0gZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKSkuY2xvbmVOb2RlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IGRhdGEuY3JlYXRlRWxlbShub2RlTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgYWRkaW5nIHNvbWUgZWxlbWVudHMgdG8gZnJhZ21lbnRzIGluIElFIDwgOSBiZWNhdXNlXG4gICAgLy8gKiBBdHRyaWJ1dGVzIGxpa2UgYG5hbWVgIG9yIGB0eXBlYCBjYW5ub3QgYmUgc2V0L2NoYW5nZWQgb25jZSBhbiBlbGVtZW50XG4gICAgLy8gICBpcyBpbnNlcnRlZCBpbnRvIGEgZG9jdW1lbnQvZnJhZ21lbnRcbiAgICAvLyAqIExpbmsgZWxlbWVudHMgd2l0aCBgc3JjYCBhdHRyaWJ1dGVzIHRoYXQgYXJlIGluYWNjZXNzaWJsZSwgYXMgd2l0aFxuICAgIC8vICAgYSA0MDMgcmVzcG9uc2UsIHdpbGwgY2F1c2UgdGhlIHRhYi93aW5kb3cgdG8gY3Jhc2hcbiAgICAvLyAqIFNjcmlwdCBlbGVtZW50cyBhcHBlbmRlZCB0byBmcmFnbWVudHMgd2lsbCBleGVjdXRlIHdoZW4gdGhlaXIgYHNyY2BcbiAgICAvLyAgIG9yIGB0ZXh0YCBwcm9wZXJ0eSBpcyBzZXRcbiAgICByZXR1cm4gbm9kZS5jYW5IYXZlQ2hpbGRyZW4gJiYgIXJlU2tpcC50ZXN0KG5vZGVOYW1lKSAmJiAhbm9kZS50YWdVcm4gPyBkYXRhLmZyYWcuYXBwZW5kQ2hpbGQobm9kZSkgOiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgYSBzaGl2ZWQgRG9jdW1lbnRGcmFnbWVudCBmb3IgdGhlIGdpdmVuIGRvY3VtZW50XG4gICAqIEBtZW1iZXJPZiBodG1sNVxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBjb250ZXh0IGRvY3VtZW50LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2hpdmVkIERvY3VtZW50RnJhZ21lbnQuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVEb2N1bWVudEZyYWdtZW50KG93bmVyRG9jdW1lbnQsIGRhdGEpe1xuICAgIGlmICghb3duZXJEb2N1bWVudCkge1xuICAgICAgICBvd25lckRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIGlmKHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzKXtcbiAgICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBkYXRhID0gZGF0YSB8fCBnZXRFeHBhbmRvRGF0YShvd25lckRvY3VtZW50KTtcbiAgICB2YXIgY2xvbmUgPSBkYXRhLmZyYWcuY2xvbmVOb2RlKCksXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBlbGVtcyA9IGdldEVsZW1lbnRzKCksXG4gICAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XG4gICAgZm9yKDtpPGw7aSsrKXtcbiAgICAgICAgY2xvbmUuY3JlYXRlRWxlbWVudChlbGVtc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGl2cyB0aGUgYGNyZWF0ZUVsZW1lbnRgIGFuZCBgY3JlYXRlRG9jdW1lbnRGcmFnbWVudGAgbWV0aG9kcyBvZiB0aGUgZG9jdW1lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gb3duZXJEb2N1bWVudCBUaGUgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIG9mIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIHNoaXZNZXRob2RzKG93bmVyRG9jdW1lbnQsIGRhdGEpIHtcbiAgICBpZiAoIWRhdGEuY2FjaGUpIHtcbiAgICAgICAgZGF0YS5jYWNoZSA9IHt9O1xuICAgICAgICBkYXRhLmNyZWF0ZUVsZW0gPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQ7XG4gICAgICAgIGRhdGEuY3JlYXRlRnJhZyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudDtcbiAgICAgICAgZGF0YS5mcmFnID0gZGF0YS5jcmVhdGVGcmFnKCk7XG4gICAgfVxuXG5cbiAgICBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlTmFtZSkge1xuICAgICAgLy9hYm9ydCBzaGl2XG4gICAgICBpZiAoIWh0bWw1LnNoaXZNZXRob2RzKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEuY3JlYXRlRWxlbShub2RlTmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChub2RlTmFtZSwgb3duZXJEb2N1bWVudCwgZGF0YSk7XG4gICAgfTtcblxuICAgIG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCA9IEZ1bmN0aW9uKCdoLGYnLCAncmV0dXJuIGZ1bmN0aW9uKCl7JyArXG4gICAgICAndmFyIG49Zi5jbG9uZU5vZGUoKSxjPW4uY3JlYXRlRWxlbWVudDsnICtcbiAgICAgICdoLnNoaXZNZXRob2RzJiYoJyArXG4gICAgICAgIC8vIHVucm9sbCB0aGUgYGNyZWF0ZUVsZW1lbnRgIGNhbGxzXG4gICAgICAgIGdldEVsZW1lbnRzKCkuam9pbigpLnJlcGxhY2UoL1tcXHdcXC06XSsvZywgZnVuY3Rpb24obm9kZU5hbWUpIHtcbiAgICAgICAgICBkYXRhLmNyZWF0ZUVsZW0obm9kZU5hbWUpO1xuICAgICAgICAgIGRhdGEuZnJhZy5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgICByZXR1cm4gJ2MoXCInICsgbm9kZU5hbWUgKyAnXCIpJztcbiAgICAgICAgfSkgK1xuICAgICAgJyk7cmV0dXJuIG59J1xuICAgICkoaHRtbDUsIGRhdGEuZnJhZyk7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogU2hpdnMgdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gc2hpdi5cbiAgICogQHJldHVybnMge0RvY3VtZW50fSBUaGUgc2hpdmVkIGRvY3VtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gc2hpdkRvY3VtZW50KG93bmVyRG9jdW1lbnQpIHtcbiAgICBpZiAoIW93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgb3duZXJEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpO1xuXG4gICAgaWYgKGh0bWw1LnNoaXZDU1MgJiYgIXN1cHBvcnRzSHRtbDVTdHlsZXMgJiYgIWRhdGEuaGFzQ1NTKSB7XG4gICAgICBkYXRhLmhhc0NTUyA9ICEhYWRkU3R5bGVTaGVldChvd25lckRvY3VtZW50LFxuICAgICAgICAvLyBjb3JyZWN0cyBibG9jayBkaXNwbGF5IG5vdCBkZWZpbmVkIGluIElFNi83LzgvOVxuICAgICAgICAnYXJ0aWNsZSxhc2lkZSxkaWFsb2csZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsbWFpbixuYXYsc2VjdGlvbntkaXNwbGF5OmJsb2NrfScgK1xuICAgICAgICAvLyBhZGRzIHN0eWxpbmcgbm90IHByZXNlbnQgaW4gSUU2LzcvOC85XG4gICAgICAgICdtYXJre2JhY2tncm91bmQ6I0ZGMDtjb2xvcjojMDAwfScgK1xuICAgICAgICAvLyBoaWRlcyBub24tcmVuZGVyZWQgZWxlbWVudHNcbiAgICAgICAgJ3RlbXBsYXRle2Rpc3BsYXk6bm9uZX0nXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXN1cHBvcnRzVW5rbm93bkVsZW1lbnRzKSB7XG4gICAgICBzaGl2TWV0aG9kcyhvd25lckRvY3VtZW50LCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGBodG1sNWAgb2JqZWN0IGlzIGV4cG9zZWQgc28gdGhhdCBtb3JlIGVsZW1lbnRzIGNhbiBiZSBzaGl2ZWQgYW5kXG4gICAqIGV4aXN0aW5nIHNoaXZpbmcgY2FuIGJlIGRldGVjdGVkIG9uIGlmcmFtZXMuXG4gICAqIEB0eXBlIE9iamVjdFxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAvLyBvcHRpb25zIGNhbiBiZSBjaGFuZ2VkIGJlZm9yZSB0aGUgc2NyaXB0IGlzIGluY2x1ZGVkXG4gICAqIGh0bWw1ID0geyAnZWxlbWVudHMnOiAnbWFyayBzZWN0aW9uJywgJ3NoaXZDU1MnOiBmYWxzZSwgJ3NoaXZNZXRob2RzJzogZmFsc2UgfTtcbiAgICovXG4gIHZhciBodG1sNSA9IHtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Ygbm9kZSBuYW1lcyBvZiB0aGUgZWxlbWVudHMgdG8gc2hpdi5cbiAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgKiBAdHlwZSBBcnJheXxTdHJpbmdcbiAgICAgKi9cbiAgICAnZWxlbWVudHMnOiBvcHRpb25zLmVsZW1lbnRzIHx8ICdhYmJyIGFydGljbGUgYXNpZGUgYXVkaW8gYmRpIGNhbnZhcyBkYXRhIGRhdGFsaXN0IGRldGFpbHMgZGlhbG9nIGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBoZWFkZXIgaGdyb3VwIG1haW4gbWFyayBtZXRlciBuYXYgb3V0cHV0IHBpY3R1cmUgcHJvZ3Jlc3Mgc2VjdGlvbiBzdW1tYXJ5IHRlbXBsYXRlIHRpbWUgdmlkZW8nLFxuXG4gICAgLyoqXG4gICAgICogY3VycmVudCB2ZXJzaW9uIG9mIGh0bWw1c2hpdlxuICAgICAqL1xuICAgICd2ZXJzaW9uJzogdmVyc2lvbixcblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSBIVE1MNSBzdHlsZSBzaGVldCBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgICdzaGl2Q1NTJzogKG9wdGlvbnMuc2hpdkNTUyAhPT0gZmFsc2UpLFxuXG4gICAgLyoqXG4gICAgICogSXMgZXF1YWwgdG8gdHJ1ZSBpZiBhIGJyb3dzZXIgc3VwcG9ydHMgY3JlYXRpbmcgdW5rbm93bi9IVE1MNSBlbGVtZW50c1xuICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICAnc3VwcG9ydHNVbmtub3duRWxlbWVudHMnOiBzdXBwb3J0c1Vua25vd25FbGVtZW50cyxcblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSBkb2N1bWVudCdzIGBjcmVhdGVFbGVtZW50YCBhbmQgYGNyZWF0ZURvY3VtZW50RnJhZ21lbnRgXG4gICAgICogbWV0aG9kcyBzaG91bGQgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgICdzaGl2TWV0aG9kcyc6IChvcHRpb25zLnNoaXZNZXRob2RzICE9PSBmYWxzZSksXG5cbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyB0byBkZXNjcmliZSB0aGUgdHlwZSBvZiBgaHRtbDVgIG9iamVjdCAoXCJkZWZhdWx0XCIgb3IgXCJkZWZhdWx0IHByaW50XCIpLlxuICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgICd0eXBlJzogJ2RlZmF1bHQnLFxuXG4gICAgLy8gc2hpdnMgdGhlIGRvY3VtZW50IGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGBodG1sNWAgb2JqZWN0IG9wdGlvbnNcbiAgICAnc2hpdkRvY3VtZW50Jzogc2hpdkRvY3VtZW50LFxuXG4gICAgLy9jcmVhdGVzIGEgc2hpdmVkIGVsZW1lbnRcbiAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuXG4gICAgLy9jcmVhdGVzIGEgc2hpdmVkIGRvY3VtZW50RnJhZ21lbnRcbiAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50OiBjcmVhdGVEb2N1bWVudEZyYWdtZW50LFxuXG4gICAgLy9leHRlbmRzIGxpc3Qgb2YgZWxlbWVudHNcbiAgICBhZGRFbGVtZW50czogYWRkRWxlbWVudHNcbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBleHBvc2UgaHRtbDVcbiAgd2luZG93Lmh0bWw1ID0gaHRtbDU7XG5cbiAgLy8gc2hpdiB0aGUgZG9jdW1lbnRcbiAgc2hpdkRvY3VtZW50KGRvY3VtZW50KTtcblxuICBpZih0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGh0bWw1O1xuICB9XG5cbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGRvY3VtZW50KSk7XG4iLCJcclxudmFyIEwgPSB7XHJcblx0dmVyc2lvbjogJzEuMC4xJ1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZXhwb3NlKCkge1xyXG5cdHZhciBvbGRMID0gd2luZG93Lkw7XHJcblxyXG5cdEwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHdpbmRvdy5MID0gb2xkTDtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdHdpbmRvdy5MID0gTDtcclxufVxyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgZm9yIE5vZGUgbW9kdWxlIHBhdHRlcm4gbG9hZGVycywgaW5jbHVkaW5nIEJyb3dzZXJpZnlcclxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEw7XHJcblxyXG4vLyBkZWZpbmUgTGVhZmxldCBhcyBhbiBBTUQgbW9kdWxlXHJcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0ZGVmaW5lKEwpO1xyXG59XHJcblxyXG4vLyBkZWZpbmUgTGVhZmxldCBhcyBhIGdsb2JhbCBMIHZhcmlhYmxlLCBzYXZpbmcgdGhlIG9yaWdpbmFsIEwgdG8gcmVzdG9yZSBsYXRlciBpZiBuZWVkZWRcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ZXhwb3NlKCk7XHJcbn1cclxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuTC5VdGlsID0ge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcblx0Ly8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChkZXN0KSB7XHJcblx0XHR2YXIgaSwgaiwgbGVuLCBzcmM7XHJcblxyXG5cdFx0Zm9yIChqID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcblx0XHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuXHRcdFx0Zm9yIChpIGluIHNyYykge1xyXG5cdFx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBkZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG5cdC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtPYmplY3QuY3JlYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlKVxyXG5cdGNyZWF0ZTogT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdFx0ZnVuY3Rpb24gRigpIHt9XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvKSB7XHJcblx0XHRcdEYucHJvdG90eXBlID0gcHJvdG87XHJcblx0XHRcdHJldHVybiBuZXcgRigpO1xyXG5cdFx0fTtcclxuXHR9KSgpLFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBib3VuZCB0byB0aGUgYXJndW1lbnRzIHBhc3NlZCwgbGlrZSBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxyXG5cdC8vIEhhcyBhIGBMLmJpbmQoKWAgc2hvcnRjdXQuXHJcblx0YmluZDogZnVuY3Rpb24gKGZuLCBvYmopIHtcclxuXHRcdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0XHRpZiAoZm4uYmluZCkge1xyXG5cdFx0XHRyZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgYW4gb2JqZWN0LCBhc3NpZ2luZyBpdCBvbmUgaWYgaXQgZG9lc24ndCBoYXZlIGl0LlxyXG5cdHN0YW1wOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0XHRvYmouX2xlYWZsZXRfaWQgPSBvYmouX2xlYWZsZXRfaWQgfHwgKytMLlV0aWwubGFzdElkO1xyXG5cdFx0cmV0dXJuIG9iai5fbGVhZmxldF9pZDtcclxuXHRcdC8qZXNsaW50LWVuYWJsZSAqL1xyXG5cdH0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG5cdC8vIExhc3QgdW5pcXVlIElEIHVzZWQgYnkgW2BzdGFtcCgpYF0oI3V0aWwtc3RhbXApXHJcblx0bGFzdElkOiAwLFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcblx0Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGZ1bmN0aW9uIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gc2NvcGUgYGNvbnRleHRgXHJcblx0Ly8gKHNvIHRoYXQgdGhlIGB0aGlzYCBrZXl3b3JkIHJlZmVycyB0byBgY29udGV4dGAgaW5zaWRlIGBmbmAncyBjb2RlKS4gVGhlIGZ1bmN0aW9uXHJcblx0Ly8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuXHQvLyByZWNlaXZlZCBieSB0aGUgYm91bmQgZnVuY3Rpb24gd2lsbCBiZSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGJpbmRpbmcgdGhlXHJcblx0Ly8gZnVuY3Rpb24sIGZvbGxvd2VkIGJ5IGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gaW52b2tpbmcgdGhlIGJvdW5kIGZ1bmN0aW9uLlxyXG5cdC8vIEhhcyBhbiBgTC5iaW5kYCBzaG9ydGN1dC5cclxuXHR0aHJvdHRsZTogZnVuY3Rpb24gKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcblx0XHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcclxuXHRcdFx0bG9jayA9IGZhbHNlO1xyXG5cdFx0XHRpZiAoYXJncykge1xyXG5cdFx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdFx0XHRhcmdzID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0d3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAobG9jaykge1xyXG5cdFx0XHRcdC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxyXG5cdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcclxuXHRcdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRcdGxvY2sgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiB3cmFwcGVyRm47XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHdyYXBOdW0obnVtOiBOdW1iZXIsIHJhbmdlOiBOdW1iZXJbXSwgaW5jbHVkZU1heD86IEJvb2xlYW4pOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG5cdC8vIGByYW5nZVswXWAgYW5kIGByYW5nZVsxXWAuIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGFsd2F5cyBzbWFsbGVyIHRoYW5cclxuXHQvLyBgcmFuZ2VbMV1gIHVubGVzcyBgaW5jbHVkZU1heGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuXHR3cmFwTnVtOiBmdW5jdGlvbiAoeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcclxuXHRcdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHRcdCAgICBtaW4gPSByYW5nZVswXSxcclxuXHRcdCAgICBkID0gbWF4IC0gbWluO1xyXG5cdFx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBmYWxzZUZuKCk6IEZ1bmN0aW9uXHJcblx0Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXHJcblx0ZmFsc2VGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBmb3JtYXROdW0obnVtOiBOdW1iZXIsIGRpZ2l0cz86IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHRvIGBkaWdpdHNgIGRlY2ltYWxzLCBvciB0byA1IGRlY2ltYWxzIGJ5IGRlZmF1bHQuXHJcblx0Zm9ybWF0TnVtOiBmdW5jdGlvbiAobnVtLCBkaWdpdHMpIHtcclxuXHRcdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgZGlnaXRzIHx8IDUpO1xyXG5cdFx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG5cdC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtTdHJpbmcucHJvdG90eXBlLnRyaW1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltKVxyXG5cdHRyaW06IGZ1bmN0aW9uIChzdHIpIHtcclxuXHRcdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuXHQvLyBUcmltcyBhbmQgc3BsaXRzIHRoZSBzdHJpbmcgb24gd2hpdGVzcGFjZSBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgcGFydHMuXHJcblx0c3BsaXRXb3JkczogZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0cmV0dXJuIEwuVXRpbC50cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcblx0Ly8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG5cdHNldE9wdGlvbnM6IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpIHtcclxuXHRcdGlmICghb2JqLmhhc093blByb3BlcnR5KCdvcHRpb25zJykpIHtcclxuXHRcdFx0b2JqLm9wdGlvbnMgPSBvYmoub3B0aW9ucyA/IEwuVXRpbC5jcmVhdGUob2JqLm9wdGlvbnMpIDoge307XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdFx0b2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmo6IE9iamVjdCwgZXhpc3RpbmdVcmw/OiBTdHJpbmcsIHVwcGVyY2FzZT86IEJvb2xlYW4pOiBTdHJpbmdcclxuXHQvLyBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHBhcmFtZXRlciBVUkwgc3RyaW5nLCBlLmcuIGB7YTogXCJmb29cIiwgYjogXCJiYXJcIn1gXHJcblx0Ly8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG5cdC8vIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQuIElmIGB1cHBlcmNhc2VgIGlzIGB0cnVlYCwgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsXHJcblx0Ly8gYmUgdXBwZXJjYXNlZCAoZS5nLiBgJz9BPWZvbyZCPWJhcidgKVxyXG5cdGdldFBhcmFtU3RyaW5nOiBmdW5jdGlvbiAob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcblx0XHR2YXIgcGFyYW1zID0gW107XHJcblx0XHRmb3IgKHZhciBpIGluIG9iaikge1xyXG5cdFx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG5cdC8vIFNpbXBsZSB0ZW1wbGF0aW5nIGZhY2lsaXR5LCBhY2NlcHRzIGEgdGVtcGxhdGUgc3RyaW5nIG9mIHRoZSBmb3JtIGAnSGVsbG8ge2F9LCB7Yn0nYFxyXG5cdC8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcblx0Ly8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcblx0Ly8gZGF0YSB2YWx1ZXMg4oCUIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcGFzc2luZyBgZGF0YWAgYXMgYW4gYXJndW1lbnQuXHJcblx0dGVtcGxhdGU6IGZ1bmN0aW9uIChzdHIsIGRhdGEpIHtcclxuXHRcdHJldHVybiBzdHIucmVwbGFjZShMLlV0aWwudGVtcGxhdGVSZSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcblx0XHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dGVtcGxhdGVSZTogL1xceyAqKFtcXHdfXFwtXSspICpcXH0vZyxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGlzQXJyYXkob2JqKTogQm9vbGVhblxyXG5cdC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGluZGV4T2YoYXJyYXk6IEFycmF5LCBlbDogT2JqZWN0KTogTnVtYmVyXHJcblx0Ly8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LnByb3RvdHlwZS5pbmRleE9mXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mKVxyXG5cdGluZGV4T2Y6IGZ1bmN0aW9uIChhcnJheSwgZWwpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBlbXB0eUltYWdlVXJsOiBTdHJpbmdcclxuXHQvLyBEYXRhIFVSSSBzdHJpbmcgY29udGFpbmluZyBhIGJhc2U2NC1lbmNvZGVkIGVtcHR5IEdJRiBpbWFnZS5cclxuXHQvLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuXHQvLyBtb2JpbGUgZGV2aWNlcyAoYnkgc2V0dGluZyBpbWFnZSBgc3JjYCB0byB0aGlzIHN0cmluZykuXHJcblx0ZW1wdHlJbWFnZVVybDogJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nXHJcbn07XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cdC8vIGluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG5cdGZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuXHRcdHJldHVybiB3aW5kb3dbJ3dlYmtpdCcgKyBuYW1lXSB8fCB3aW5kb3dbJ21veicgKyBuYW1lXSB8fCB3aW5kb3dbJ21zJyArIG5hbWVdO1xyXG5cdH1cclxuXHJcblx0dmFyIGxhc3RUaW1lID0gMDtcclxuXHJcblx0Ly8gZmFsbGJhY2sgZm9yIElFIDctOFxyXG5cdGZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG5cdFx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuXHRcdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG5cdFx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuXHRcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcblx0fVxyXG5cclxuXHR2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyLFxyXG5cdCAgICBjYW5jZWxGbiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG5cdCAgICAgICAgICAgICAgIGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuXHQvLyBTY2hlZHVsZXMgYGZuYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBicm93c2VyIHJlcGFpbnRzLiBgZm5gIGlzIGJvdW5kIHRvXHJcblx0Ly8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcclxuXHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXHJcblx0Ly8gW2B3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLFxyXG5cdC8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxyXG5cdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lID0gZnVuY3Rpb24gKGZuLCBjb250ZXh0LCBpbW1lZGlhdGUpIHtcclxuXHRcdGlmIChpbW1lZGlhdGUgJiYgcmVxdWVzdEZuID09PSB0aW1lb3V0RGVmZXIpIHtcclxuXHRcdFx0Zm4uY2FsbChjb250ZXh0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiByZXF1ZXN0Rm4uY2FsbCh3aW5kb3csIEwuYmluZChmbiwgY29udGV4dCkpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQ6IE51bWJlcik6IHVuZGVmaW5lZFxyXG5cdC8vIENhbmNlbHMgYSBwcmV2aW91cyBgcmVxdWVzdEFuaW1GcmFtZWAuIFNlZSBhbHNvIFt3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWUpLlxyXG5cdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGlmIChpZCkge1xyXG5cdFx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG4vLyBzaG9ydGN1dHMgZm9yIG1vc3QgdXNlZCB1dGlsaXR5IGZ1bmN0aW9uc1xyXG5MLmV4dGVuZCA9IEwuVXRpbC5leHRlbmQ7XHJcbkwuYmluZCA9IEwuVXRpbC5iaW5kO1xyXG5MLnN0YW1wID0gTC5VdGlsLnN0YW1wO1xyXG5MLnNldE9wdGlvbnMgPSBMLlV0aWwuc2V0T3B0aW9ucztcclxuXG5cclxuLy8gQGNsYXNzIENsYXNzXHJcbi8vIEBha2EgTC5DbGFzc1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gQHVuaW5oZXJpdGFibGVcclxuXHJcbi8vIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG5cclxuTC5DbGFzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuTC5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChwcm9wczogT2JqZWN0KTogRnVuY3Rpb25cclxuXHQvLyBbRXh0ZW5kcyB0aGUgY3VycmVudCBjbGFzc10oI2NsYXNzLWluaGVyaXRhbmNlKSBnaXZlbiB0aGUgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZC5cclxuXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJlbnRQcm90byA9IE5ld0NsYXNzLl9fc3VwZXJfXyA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBMLlV0aWwuY3JlYXRlKHBhcmVudFByb3RvKTtcclxuXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcblx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAncHJvdG90eXBlJykge1xyXG5cdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG5cdFx0TC5leHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLnN0YXRpY3M7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRMLlV0aWwuZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcblx0XHRkZWxldGUgcHJvcHMuaW5jbHVkZXM7XHJcblx0fVxyXG5cclxuXHQvLyBtZXJnZSBvcHRpb25zXHJcblx0aWYgKHByb3RvLm9wdGlvbnMpIHtcclxuXHRcdHByb3BzLm9wdGlvbnMgPSBMLlV0aWwuZXh0ZW5kKEwuVXRpbC5jcmVhdGUocHJvdG8ub3B0aW9ucyksIHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0TC5leHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHJcblx0cHJvdG8uX2luaXRIb29rcyA9IFtdO1xyXG5cclxuXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG5cdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIE5ld0NsYXNzO1xyXG59O1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuLy8gW0luY2x1ZGVzIGEgbWl4aW5dKCNjbGFzcy1pbmNsdWRlcykgaW50byB0aGUgY3VycmVudCBjbGFzcy5cclxuTC5DbGFzcy5pbmNsdWRlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0TC5leHRlbmQodGhpcy5wcm90b3R5cGUsIHByb3BzKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uczogT2JqZWN0KTogdGhpc1xyXG4vLyBbTWVyZ2VzIGBvcHRpb25zYF0oI2NsYXNzLW9wdGlvbnMpIGludG8gdGhlIGRlZmF1bHRzIG9mIHRoZSBjbGFzcy5cclxuTC5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdEwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuTC5DbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBFdmVudGVkXHJcbiAqIEBha2EgTC5FdmVudGVkXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gKiB9ICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAqXHJcbiAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbkwuRXZlbnRlZCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdCAqL1xyXG5cdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBtZXRob2Qgb2ZmKHR5cGU6IFN0cmluZywgZm4/OiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGF0IHBhcnRpY3VsYXIgZXZlbnQgZnJvbSB0aGUgb2JqZWN0LiBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIGBvbmAsIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWUgY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmYoZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZjogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIG9uIHRoZSBvYmplY3QuXHJcblx0ICovXHJcblx0b2ZmOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKCF0eXBlcykge1xyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0eXBlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcblx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHJcblx0XHQvKiBnZXQvaW5pdCBsaXN0ZW5lcnMgZm9yIHR5cGUgKi9cclxuXHRcdHZhciB0eXBlTGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKCF0eXBlTGlzdGVuZXJzKSB7XHJcblx0XHRcdHR5cGVMaXN0ZW5lcnMgPSBbXTtcclxuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gdHlwZUxpc3RlbmVycztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHR2YXIgbmV3TGlzdGVuZXIgPSB7Zm46IGZuLCBjdHg6IGNvbnRleHR9LFxyXG5cdFx0ICAgIGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnM7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGlzdGVuZXJzLnB1c2gobmV3TGlzdGVuZXIpO1xyXG5cdFx0dHlwZUxpc3RlbmVycy5jb3VudCsrO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyxcclxuXHRcdCAgICBpLFxyXG5cdFx0ICAgIGxlbjtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykgeyByZXR1cm47IH1cclxuXHJcblx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghZm4pIHtcclxuXHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHJcblx0XHRcdC8vIGZpbmQgZm4gYW5kIHJlbW92ZSBpdFxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRpZiAobC5jdHggIT09IGNvbnRleHQpIHsgY29udGludWU7IH1cclxuXHRcdFx0XHRpZiAobC5mbiA9PT0gZm4pIHtcclxuXHJcblx0XHRcdFx0XHQvLyBzZXQgdGhlIHJlbW92ZWQgbGlzdGVuZXIgdG8gbm9vcCBzbyB0aGF0J3Mgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdFx0XHRsLmZuID0gTC5VdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcblx0XHRcdFx0XHRcdC8qIGNvcHkgYXJyYXkgaW4gY2FzZSBldmVudHMgYXJlIGJlaW5nIGZpcmVkICovXHJcblx0XHRcdFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXJlKHR5cGU6IFN0cmluZywgZGF0YT86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBGaXJlcyBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGFuIGRhdGFcclxuXHQvLyBvYmplY3Qg4oCUIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBjb250YWluIGl0c1xyXG5cdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBtaWdodCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXHJcblx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xyXG5cdFx0aWYgKCF0aGlzLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudCA9IEwuVXRpbC5leHRlbmQoe30sIGRhdGEsIHt0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQgPSAodGhpcy5fZmlyaW5nQ291bnQgKyAxKSB8fCAxO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdFx0bC5mbi5jYWxsKGwuY3R4IHx8IHRoaXMsIGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50LS07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gcGFyZW50cyAoc2V0IHdpdGggYWRkRXZlbnRQYXJlbnQpXHJcblx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxyXG5cdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBwcm9wYWdhdGUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuXHQvLyBCZWhhdmVzIGFzIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKSwgZXhjZXB0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgZ2V0IGZpcmVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cclxuXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMub25jZSh0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gTC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHRcdCAgICAub2ZmKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdC8vIGFkZCBhIGxpc3RlbmVyIHRoYXQncyBleGVjdXRlZCBvbmNlIGFuZCByZW1vdmVkIGFmdGVyIHRoYXRcclxuXHRcdHJldHVybiB0aGlzXHJcblx0XHQgICAgLm9uKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdCAgICAub24odHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gZXZlbnQgcGFyZW50IC0gYW4gYEV2ZW50ZWRgIHRoYXQgd2lsbCByZWNlaXZlIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50cyA9IHRoaXMuX2V2ZW50UGFyZW50cyB8fCB7fTtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50c1tMLnN0YW1wKG9iaildID0gb2JqO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBldmVudCBwYXJlbnQsIHNvIGl0IHdpbGwgc3RvcCByZWNlaXZpbmcgcHJvcGFnYXRlZCBldmVudHNcclxuXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRQYXJlbnRzW0wuc3RhbXAob2JqKV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgTC5leHRlbmQoe2xheWVyOiBlLnRhcmdldH0sIGUpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIHByb3RvID0gTC5FdmVudGVkLnByb3RvdHlwZTtcclxuXHJcbi8vIGFsaWFzZXM7IHdlIHNob3VsZCBkaXRjaCB0aG9zZSBldmVudHVhbGx5XHJcblxyXG4vLyBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxucHJvdG8uYWRkRXZlbnRMaXN0ZW5lciA9IHByb3RvLm9uO1xyXG5cclxuLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbi8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbnByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90by5jbGVhckFsbEV2ZW50TGlzdGVuZXJzID0gcHJvdG8ub2ZmO1xyXG5cclxuLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxucHJvdG8uYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBwcm90by5vbmNlO1xyXG5cclxuLy8gQG1ldGhvZCBmaXJlRXZlbnQo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYGZpcmUo4oCmKWBdKCNldmVudGVkLWZpcmUpXHJcbnByb3RvLmZpcmVFdmVudCA9IHByb3RvLmZpcmU7XHJcblxyXG4vLyBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJzKOKApik6IEJvb2xlYW5cclxuLy8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxyXG5wcm90by5oYXNFdmVudExpc3RlbmVycyA9IHByb3RvLmxpc3RlbnM7XHJcblxyXG5MLk1peGluID0ge0V2ZW50czogcHJvdG99O1xyXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgQnJvd3NlclxyXG4gKiBAYWthIEwuQnJvd3NlclxyXG4gKlxyXG4gKiBBIG5hbWVzcGFjZSB3aXRoIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBicm93c2VyL2ZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAqICAgYWxlcnQoJ1VwZ3JhZGUgeW91ciBicm93c2VyLCBkdWRlIScpO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcclxuXHQgICAgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxyXG5cclxuXHQgICAgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93LFxyXG5cclxuXHQgICAgd2Via2l0ICAgID0gdWEuaW5kZXhPZignd2Via2l0JykgIT09IC0xLFxyXG5cdCAgICBwaGFudG9tanMgPSB1YS5pbmRleE9mKCdwaGFudG9tJykgIT09IC0xLFxyXG5cdCAgICBhbmRyb2lkMjMgPSB1YS5zZWFyY2goJ2FuZHJvaWQgWzIzXScpICE9PSAtMSxcclxuXHQgICAgY2hyb21lICAgID0gdWEuaW5kZXhPZignY2hyb21lJykgIT09IC0xLFxyXG5cdCAgICBnZWNrbyAgICAgPSB1YS5pbmRleE9mKCdnZWNrbycpICE9PSAtMSAgJiYgIXdlYmtpdCAmJiAhd2luZG93Lm9wZXJhICYmICFpZSxcclxuXHJcblx0ICAgIHdpbiA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdXaW4nKSA9PT0gMCxcclxuXHJcblx0ICAgIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdWEuaW5kZXhPZignbW9iaWxlJykgIT09IC0xLFxyXG5cdCAgICBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQsXHJcblx0ICAgIHBvaW50ZXIgPSB3aW5kb3cuUG9pbnRlckV2ZW50IHx8IG1zUG9pbnRlcixcclxuXHJcblx0ICAgIGllM2QgPSBpZSAmJiAoJ3RyYW5zaXRpb24nIGluIGRvYy5zdHlsZSksXHJcblx0ICAgIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjMsXHJcblx0ICAgIGdlY2tvM2QgPSAnTW96UGVyc3BlY3RpdmUnIGluIGRvYy5zdHlsZSxcclxuXHQgICAgb3BlcmExMiA9ICdPVHJhbnNpdGlvbicgaW4gZG9jLnN0eWxlO1xyXG5cclxuXHJcblx0dmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmIChwb2ludGVyIHx8ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fFxyXG5cdFx0XHQod2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCkpO1xyXG5cclxuXHRMLkJyb3dzZXIgPSB7XHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGllOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyAobm90IEVkZ2UpLlxyXG5cdFx0aWU6IGllLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBpZWx0OTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBsZXNzIHRoYW4gOS5cclxuXHRcdGllbHQ5OiBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcixcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgZWRnZTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciB0aGUgRWRnZSB3ZWIgYnJvd3Nlci5cclxuXHRcdGVkZ2U6ICdtc0xhdW5jaFVyaScgaW4gbmF2aWdhdG9yICYmICEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIGxpa2UgQ2hyb21lIGFuZCBTYWZhcmkgKGluY2x1ZGluZyBtb2JpbGUgdmVyc2lvbnMpLlxyXG5cdFx0d2Via2l0OiB3ZWJraXQsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGdlY2tvOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cclxuXHRcdGdlY2tvOiBnZWNrbyxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgYW5kcm9pZDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcblx0XHRhbmRyb2lkOiB1YS5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBhbmRyb2lkMjM6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgcnVubmluZyBvbiBBbmRyb2lkIDIgb3IgQW5kcm9pZCAzLlxyXG5cdFx0YW5kcm9pZDIzOiBhbmRyb2lkMjMsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGNocm9tZTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciB0aGUgQ2hyb21lIGJyb3dzZXIuXHJcblx0XHRjaHJvbWU6IGNocm9tZSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgc2FmYXJpOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHRoZSBTYWZhcmkgYnJvd3Nlci5cclxuXHRcdHNhZmFyaTogIWNocm9tZSAmJiB1YS5pbmRleE9mKCdzYWZhcmknKSAhPT0gLTEsXHJcblxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcblx0XHR3aW46IHdpbixcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGllM2Q6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcblx0XHRpZTNkOiBpZTNkLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuXHRcdHdlYmtpdDNkOiB3ZWJraXQzZCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5cdFx0Z2Vja28zZDogZ2Vja28zZCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zICh2ZXJzaW9uIDEyIG9yIGxhdGVyKS5cclxuXHRcdG9wZXJhMTI6IG9wZXJhMTIsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5cdFx0YW55M2Q6ICF3aW5kb3cuTF9ESVNBQkxFXzNEICYmIChpZTNkIHx8IHdlYmtpdDNkIHx8IGdlY2tvM2QpICYmICFvcGVyYTEyICYmICFwaGFudG9tanMsXHJcblxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5cdFx0bW9iaWxlOiBtb2JpbGUsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxuXHRcdG1vYmlsZVdlYmtpdDogbW9iaWxlICYmIHdlYmtpdCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2Ugc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuXHRcdG1vYmlsZVdlYmtpdDNkOiBtb2JpbGUgJiYgd2Via2l0M2QsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxuXHRcdG1vYmlsZU9wZXJhOiBtb2JpbGUgJiYgd2luZG93Lm9wZXJhLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxuXHRcdG1vYmlsZUdlY2tvOiBtb2JpbGUgJiYgZ2Vja28sXHJcblxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbdG91Y2ggZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvVG91Y2hfZXZlbnRzKS5cclxuXHRcdHRvdWNoOiAhIXRvdWNoLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtc1BvaW50ZXI6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgaW1wbGVtZW50aW5nIHRoZSBNaWNyb3NvZnQgdG91Y2ggZXZlbnRzIG1vZGVsIChub3RhYmx5IElFMTApLlxyXG5cdFx0bXNQb2ludGVyOiAhIW1zUG9pbnRlcixcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgcG9pbnRlcjogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG5cdFx0cG9pbnRlcjogISFwb2ludGVyLFxyXG5cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIG9uIGEgaGlnaC1yZXNvbHV0aW9uIFwicmV0aW5hXCIgc2NyZWVuLlxyXG5cdFx0cmV0aW5hOiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAvIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpKSA+IDFcclxuXHR9O1xyXG5cclxufSgpKTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgUG9pbnRcclxuICogQGFrYSBMLlBvaW50XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBganNcclxuICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLlBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHJvdW5kKSB7XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdHRoaXMueSA9IChyb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5KTtcclxufTtcclxuXHJcbkwuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLngsIHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQoTC5wb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG5cdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGUgY3VycmVudC5cclxuXHRzdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdChMLnBvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X3N1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG5cdFx0dGhpcy55IC09IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpdmlkZUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAvPSBudW07XHJcblx0XHR0aGlzLnkgLz0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtdWx0aXBseUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAqPSBudW07XHJcblx0XHR0aGlzLnkgKj0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gTXVsdGlwbHkgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IGVhY2ggY29vcmRpbmF0ZSBvZlxyXG5cdC8vIGBzY2FsZWAuIEluIGxpbmVhciBhbGdlYnJhIHRlcm1zLCBtdWx0aXBseSB0aGUgcG9pbnQgYnkgdGhlXHJcblx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuXHQvLyBkZWZpbmVkIGJ5IGBzY2FsZWAuXHJcblx0c2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG5cdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG5cdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyUG9pbnQ6IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMueCxcclxuXHRcdCAgICB5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG5cdFx0ICAgICAgIHBvaW50LnkgPT09IHRoaXMueTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGJvdGggY29vcmRpbmF0ZXMgb2YgdGhlIGdpdmVuIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgY3VycmVudCBwb2ludCBjb29yZGluYXRlcyAoaW4gYWJzb2x1dGUgdmFsdWVzKS5cclxuXHRjb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyhwb2ludC54KSA8PSBNYXRoLmFicyh0aGlzLngpICYmXHJcblx0XHQgICAgICAgTWF0aC5hYnMocG9pbnQueSkgPD0gTWF0aC5hYnModGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAnUG9pbnQoJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4vLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4vLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5MLnBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBMLlBvaW50KSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKEwuVXRpbC5pc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoeFswXSwgeFsxXSk7XHJcblx0fVxyXG5cdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIHggJiYgJ3knIGluIHgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4LngsIHgueSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5Qb2ludCh4LCB5LCByb3VuZCk7XHJcbn07XHJcblxuLypcclxuICogQGNsYXNzIEJvdW5kc1xyXG4gKiBAYWthIEwuQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIGluIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcDEgPSBMLnBvaW50KDEwLCAxMCksXHJcbiAqIHAyID0gTC5wb2ludCg0MCwgNjApLFxyXG4gKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuQm91bmRzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG5MLkJvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBleHRlbmQocG9pbnQ6IFBvaW50KTogdGhpc1xyXG5cdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcblx0XHQvLyBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHQvLyBAcHJvcGVydHkgbWF4OiBQb2ludFxyXG5cdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcblx0XHRcdHRoaXMubWluID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKHBvaW50LngsIHRoaXMubWluLngpO1xyXG5cdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihwb2ludC55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KHBvaW50LnksIHRoaXMubWF4LnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBib3VuZHNcclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhwb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTC5Qb2ludCkge1xyXG5cdFx0XHRvYmogPSBMLnBvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSBMLmJvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMLkJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSBMLmJvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IEwuYm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMubWluICYmIHRoaXMubWF4KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5ib3VuZHModG9wTGVmdDogUG9pbnQsIGJvdHRvbVJpZ2h0OiBQb2ludClcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0d28gY29vcmRpbmF0ZXMgKHVzdWFsbHkgdG9wLWxlZnQgYW5kIGJvdHRvbS1yaWdodCBjb3JuZXJzKS5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgcG9pbnRzIGl0IGNvbnRhaW5zXHJcbkwuYm91bmRzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEwuQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLkJvdW5kcyhhLCBiKTtcclxufTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRyYW5zZm9ybWF0aW9uID0gbmV3IEwuVHJhbnNmb3JtYXRpb24oMiwgNSwgLTEsIDEwKSxcclxuICogXHRwID0gTC5wb2ludCgxLCAyKSxcclxuICogXHRwMiA9IHRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShwKSwgLy8gIEwucG9pbnQoNywgOClcclxuICogXHRwMyA9IHRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHAyKTsgLy8gIEwucG9pbnQoMSwgMilcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgbmV3IEwuVHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBDcmVhdGVzIGEgYFRyYW5zZm9ybWF0aW9uYCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5MLlRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufTtcclxuXHJcbkwuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuXHQvLyBPbmx5IGFjY2VwdHMgcmVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkgeyAvLyAoUG9pbnQsIE51bWJlcikgLT4gUG9pbnRcclxuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm0ocG9pbnQuY2xvbmUoKSwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGRlc3RydWN0aXZlIHRyYW5zZm9ybSAoZmFzdGVyKVxyXG5cdF90cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHBvaW50LnggPSBzY2FsZSAqICh0aGlzLl9hICogcG9pbnQueCArIHRoaXMuX2IpO1xyXG5cdFx0cG9pbnQueSA9IHNjYWxlICogKHRoaXMuX2MgKiBwb2ludC55ICsgdGhpcy5fZCk7XHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXZlcnNlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCwgb3B0aW9uYWxseSBkaXZpZGVkXHJcblx0Ly8gYnkgdGhlIGdpdmVuIHNjYWxlLiBPbmx5IGFjY2VwdHMgcmVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHQgICAgICAgIChwb2ludC54IC8gc2NhbGUgLSB0aGlzLl9iKSAvIHRoaXMuX2EsXHJcblx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG5cdH1cclxufTtcclxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICpcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICovXHJcblxyXG5MLkRvbVV0aWwgPSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcblx0Ly8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuXHRnZXQ6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBzdHlsZUF0dHJpYjogU3RyaW5nKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgY2VydGFpbiBzdHlsZSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcclxuXHQvLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcblx0Z2V0U3R5bGU6IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcclxuXHJcblx0XHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcblx0XHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcblx0XHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lOiBTdHJpbmcsIGNsYXNzTmFtZT86IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG5cdGNyZWF0ZTogZnVuY3Rpb24gKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblxyXG5cdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcclxuXHJcblx0XHRpZiAoY29udGFpbmVyKSB7XHJcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG5cdC8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdGlmIChwYXJlbnQpIHtcclxuXHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxyXG5cdC8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuXHRlbXB0eTogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZHJlbiBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuXHR0b0Zyb250OiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdGVsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG5cdC8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkcmVuIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmFjayBmcm9tIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuXHR0b0JhY2s6IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnQuZmlyc3RDaGlsZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIGBuYW1lYC5cclxuXHRoYXNDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHRcdH1cclxuXHRcdHZhciBjbGFzc05hbWUgPSBMLkRvbVV0aWwuZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcblx0Ly8gQWRkcyBgbmFtZWAgdG8gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHZhciBjbGFzc2VzID0gTC5VdGlsLnNwbGl0V29yZHMobmFtZSk7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICghTC5Eb21VdGlsLmhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gTC5Eb21VdGlsLmdldENsYXNzKGVsKTtcclxuXHRcdFx0TC5Eb21VdGlsLnNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG5cdC8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0Q2xhc3MoZWwsIEwuVXRpbC50cmltKCgnICcgKyBMLkRvbVV0aWwuZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcblx0Ly8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5cdHNldENsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5cdGdldENsYXNzOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcblx0Ly8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcblx0Ly8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHtcclxuXHJcblx0XHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5fc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3NldE9wYWNpdHlJRTogZnVuY3Rpb24gKGVsLCB2YWx1ZSkge1xyXG5cdFx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG5cdFx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHRcdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuXHRcdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdFx0aWYgKGZpbHRlcikge1xyXG5cdFx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuXHRcdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG5cdC8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuXHQvLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG5cdC8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG5cdHRlc3RQcm9wOiBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcblx0Ly8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcblx0Ly8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcblx0c2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuXHRcdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IEwuUG9pbnQoMCwgMCk7XHJcblxyXG5cdFx0ZWwuc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPVxyXG5cdFx0XHQoTC5Ccm93c2VyLmllM2QgP1xyXG5cdFx0XHRcdCd0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknIDpcclxuXHRcdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuXHRcdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IFBvaW50KVxyXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcblx0Ly8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuXHQvLyAodXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gcG9zaXRpb24gaXRzIGxheWVycykuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCwgcG9pbnQpIHsgLy8gKEhUTUxFbGVtZW50LCBQb2ludFssIEJvb2xlYW5dKVxyXG5cclxuXHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG5cdFx0Lyplc2xpbnQtZW5hYmxlICovXHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcblx0XHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0XHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRcdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IEwuUG9pbnQoMCwgMCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0Ly8gcHJlZml4IHN0eWxlIHByb3BlcnR5IG5hbWVzXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG5cdC8vIFZlbmRvci1wcmVmaXhlZCBmcmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG5cdEwuRG9tVXRpbC5UUkFOU0ZPUk0gPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcblx0XHRcdFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcblxyXG5cdC8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuXHQvLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcblx0Ly8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG5cdC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZS5cclxuXHR2YXIgdHJhbnNpdGlvbiA9IEwuRG9tVXRpbC5UUkFOU0lUSU9OID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG5cdFx0XHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcblx0TC5Eb21VdGlsLlRSQU5TSVRJT05fRU5EID1cclxuXHRcdFx0dHJhbnNpdGlvbiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IHRyYW5zaXRpb24gPT09ICdPVHJhbnNpdGlvbicgPyB0cmFuc2l0aW9uICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcblx0Ly8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuXHQvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG5cdC8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuXHQvLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG5cdC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuXHRpZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdH07XHJcblx0XHRMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdH07XHJcblxyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG5cdFx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblx0XHRcdFx0dGhpcy5fdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcblx0XHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSB0aGlzLl91c2VyU2VsZWN0O1xyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl91c2VyU2VsZWN0O1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG5cdC8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuXHQvLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuXHRMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub24od2luZG93LCAnZHJhZ3N0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcblx0Ly8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcblx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcclxuXHQvLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG5cdC8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcclxuXHQvLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXHJcblx0TC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuXHRcdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG5cdFx0TC5Eb21VdGlsLnJlc3RvcmVPdXRsaW5lKCk7XHJcblx0XHR0aGlzLl9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9vdXRsaW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLm91dGxpbmU7XHJcblx0XHRlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKHdpbmRvdywgJ2tleWRvd24nLCBMLkRvbVV0aWwucmVzdG9yZU91dGxpbmUsIHRoaXMpO1xyXG5cdH07XHJcblxyXG5cdC8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcblx0Ly8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuXHRMLkRvbVV0aWwucmVzdG9yZU91dGxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5fb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZSA9IHRoaXMuX291dGxpbmVTdHlsZTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9vdXRsaW5lRWxlbWVudDtcclxuXHRcdGRlbGV0ZSB0aGlzLl9vdXRsaW5lU3R5bGU7XHJcblx0XHRMLkRvbUV2ZW50Lm9mZih3aW5kb3csICdrZXlkb3duJywgTC5Eb21VdGlsLnJlc3RvcmVPdXRsaW5lLCB0aGlzKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cbi8qIEBjbGFzcyBMYXRMbmdcclxuICogQGFrYSBMLkxhdExuZ1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5MYXRMbmcgPSBmdW5jdGlvbiAobGF0LCBsbmcsIGFsdCkge1xyXG5cdGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xyXG5cdH1cclxuXHJcblx0Ly8gQHByb3BlcnR5IGxhdDogTnVtYmVyXHJcblx0Ly8gTGF0aXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubGF0ID0gK2xhdDtcclxuXHJcblx0Ly8gQHByb3BlcnR5IGxuZzogTnVtYmVyXHJcblx0Ly8gTG9uZ2l0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxuZyA9ICtsbmc7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBhbHQ6IE51bWJlclxyXG5cdC8vIEFsdGl0dWRlIGluIG1ldGVycyAob3B0aW9uYWwpXHJcblx0aWYgKGFsdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR0aGlzLmFsdCA9ICthbHQ7XHJcblx0fVxyXG59O1xyXG5cclxuTC5MYXRMbmcucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyTGF0TG5nOiBMYXRMbmcsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYExhdExuZ2AgcG9pbnQgaXMgYXQgdGhlIHNhbWUgcG9zaXRpb24gKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSBMLmxhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLmxhdCwgcHJlY2lzaW9uKSArICcsICcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMubG5nLCBwcmVjaXNpb24pICsgJyknO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlckxhdExuZzogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgKGluIG1ldGVycykgdG8gdGhlIGdpdmVuIGBMYXRMbmdgIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIFtIYXZlcnNpbmUgZm9ybXVsYV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYSkuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKG90aGVyKSB7XHJcblx0XHRyZXR1cm4gTC5DUlMuRWFydGguZGlzdGFuY2UodGhpcywgTC5sYXRMbmcob3RoZXIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXAoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nYCBvYmplY3Qgd2l0aCB0aGUgbG9uZ2l0dWRlIHdyYXBwZWQgc28gaXQncyBhbHdheXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEwuQ1JTLkVhcnRoLndyYXBMYXRMbmcodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JvdW5kcyhzaXplSW5NZXRlcnM6IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGluIHdoaWNoIGVhY2ggYm91bmRhcnkgaXMgYHNpemVJbk1ldGVyc2AgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG5cdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcblx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuXHRcdHJldHVybiBMLmxhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMubGF0LCB0aGlzLmxuZywgdGhpcy5hbHQpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcobGF0aXR1ZGU6IE51bWJlciwgbG9uZ2l0dWRlOiBOdW1iZXIsIGFsdGl0dWRlPzogTnVtYmVyKTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIHRoZSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChhbmQgb3B0aW9uYWxseSBhbHRpdHVkZSkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbTnVtYmVyLCBOdW1iZXJdYCBvciBgW051bWJlciwgTnVtYmVyLCBOdW1iZXJdYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogT2JqZWN0KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyfWAgb3IgYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXIsIGFsdDogTnVtYmVyfWAgaW5zdGVhZC5cclxuXHJcbkwubGF0TG5nID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIEwuTGF0TG5nKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKEwuVXRpbC5pc0FycmF5KGEpICYmIHR5cGVvZiBhWzBdICE9PSAnb2JqZWN0Jykge1xyXG5cdFx0aWYgKGEubGVuZ3RoID09PSAzKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uLCBhLmFsdCk7XHJcblx0fVxyXG5cdGlmIChiID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEwuTGF0TG5nKGEsIGIsIGMpO1xyXG59O1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBMYXRMbmdCb3VuZHNcclxuICogQGFrYSBMLkxhdExuZ0JvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgZ2VvZ3JhcGhpY2FsIGFyZWEgb24gYSBtYXAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBzb3V0aFdlc3QgPSBMLmxhdExuZyg0MC43MTIsIC03NC4yMjcpLFxyXG4gKiBub3J0aEVhc3QgPSBMLmxhdExuZyg0MC43NzQsIC03NC4xMjUpLFxyXG4gKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhzb3V0aFdlc3QsIG5vcnRoRWFzdCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogbWFwLmZpdEJvdW5kcyhbXHJcbiAqIFx0WzQwLjcxMiwgLTc0LjIyN10sXHJcbiAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICogXSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuTGF0TG5nQm91bmRzID0gZnVuY3Rpb24gKHNvdXRoV2VzdCwgbm9ydGhFYXN0KSB7IC8vIChMYXRMbmcsIExhdExuZykgb3IgKExhdExuZ1tdKVxyXG5cdGlmICghc291dGhXZXN0KSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IG5vcnRoRWFzdCA/IFtzb3V0aFdlc3QsIG5vcnRoRWFzdF0gOiBzb3V0aFdlc3Q7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG5MLkxhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50XHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nKSB7XHJcblx0XHRcdHN3MiA9IG9iajtcclxuXHRcdFx0bmUyID0gb2JqO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTC5MYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcblx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZChMLmxhdExuZyhvYmopIHx8IEwubGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG5cdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTC5MYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XHJcblx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMLkxhdExuZyhuZTIubGF0LCBuZTIubG5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XHJcblx0XHRcdHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XHJcblx0XHRcdG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XHJcblx0XHRcdG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYmlnZ2VyIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiBwZXJjZW50YWdlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxyXG5cdFx0ICAgIHdpZHRoQnVmZmVyID0gTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMLkxhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdCAgICAgICAgbmV3IEwuTGF0TG5nKG5lLmxhdCArIGhlaWdodEJ1ZmZlciwgbmUubG5nICsgd2lkdGhCdWZmZXIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFdlc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgd2VzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFNvdXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVhc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZWFzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldE5vcnRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zIChsYXRsbmc6IExhdExuZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikgeyAvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nKSAtPiBCb29sZWFuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTC5MYXRMbmcpIHtcclxuXHRcdFx0b2JqID0gTC5sYXRMbmcob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IEwubGF0TG5nQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMLkxhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouZ2V0U291dGhXZXN0KCk7XHJcblx0XHRcdG5lMiA9IG9iai5nZXROb3J0aEVhc3QoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3MiA9IG5lMiA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKHN3Mi5sYXQgPj0gc3cubGF0KSAmJiAobmUyLmxhdCA8PSBuZS5sYXQpICYmXHJcblx0XHQgICAgICAgKHN3Mi5sbmcgPj0gc3cubG5nKSAmJiAobmUyLmxuZyA8PSBuZS5sbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRJbnRlcnNlY3RzID0gKG5lMi5sYXQgPj0gc3cubGF0KSAmJiAoc3cyLmxhdCA8PSBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ0ludGVyc2VjdHMgPSAobmUyLmxuZyA+PSBzdy5sbmcpICYmIChzdzIubG5nIDw9IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdE92ZXJsYXBzID0gKG5lMi5sYXQgPiBzdy5sYXQpICYmIChzdzIubGF0IDwgbmUubGF0KSxcclxuXHRcdCAgICBsbmdPdmVybGFwcyA9IChuZTIubG5nID4gc3cubG5nKSAmJiAoc3cyLmxuZyA8IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdE92ZXJsYXBzICYmIGxuZ092ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9CQm94U3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgd2l0aCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgaW4gYSAnc291dGh3ZXN0X2xuZyxzb3V0aHdlc3RfbGF0LG5vcnRoZWFzdF9sbmcsbm9ydGhlYXN0X2xhdCcgZm9ybWF0LiBVc2VmdWwgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gd2ViIHNlcnZpY2VzIHRoYXQgcmV0dXJuIGdlbyBkYXRhLlxyXG5cdHRvQkJveFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIFt0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSwgdGhpcy5nZXROb3J0aCgpXS5qb2luKCcsJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikgdG8gdGhlIGdpdmVuIGJvdW5kcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpKSAmJlxyXG5cdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoc291dGhXZXN0OiBMYXRMbmcsIG5vcnRoRWFzdDogTGF0TG5nKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGJ5IGRlZmluaW5nIHNvdXRoLXdlc3QgYW5kIG5vcnRoLWVhc3QgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbkwubGF0TG5nQm91bmRzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhhLCBiKTtcclxufTtcclxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHNlY3Rpb25cclxuICogTGVhZmxldCBjb21lcyB3aXRoIGEgc2V0IG9mIGFscmVhZHkgZGVmaW5lZCBQcm9qZWN0aW9ucyBvdXQgb2YgdGhlIGJveDpcclxuICpcclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLkxvbkxhdFxyXG4gKlxyXG4gKiBFcXVpcmVjdGFuZ3VsYXIsIG9yIFBsYXRlIENhcnJlZSBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBzaW1wbGUgcHJvamVjdGlvbixcclxuICogbW9zdGx5IHVzZWQgYnkgR0lTIGVudGh1c2lhc3RzLiBEaXJlY3RseSBtYXBzIGB4YCBhcyBsb25naXR1ZGUsIGFuZCBgeWAgYXNcclxuICogbGF0aXR1ZGUuIEFsc28gc3VpdGFibGUgZm9yIGZsYXQgd29ybGRzLCBlLmcuIGdhbWUgbWFwcy4gVXNlZCBieSB0aGVcclxuICogYEVQU0c6MzM5NWAgYW5kIGBTaW1wbGVgIENSUy5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24gPSB7fTtcclxuXHJcbkwuUHJvamVjdGlvbi5Mb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGxhdGxuZy5sbmcsIGxhdGxuZy5sYXQpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogTC5ib3VuZHMoWy0xODAsIC05MF0sIFsxODAsIDkwXSlcclxufTtcclxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAqXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBmb3Igb25saW5lIG1hcHMsXHJcbiAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IDYzNzgxMzcsXHJcblx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcblx0XHQgICAgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4obWF4LCBsYXRsbmcubGF0KSwgLW1heCksXHJcblx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KFxyXG5cdFx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoXHJcblx0XHRcdCgyICogTWF0aC5hdGFuKE1hdGguZXhwKHBvaW50LnkgLyB0aGlzLlIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcclxuXHRcdFx0cG9pbnQueCAqIGQgLyB0aGlzLlIpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBkID0gNjM3ODEzNyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gTC5ib3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcblx0fSkoKVxyXG59O1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBDUlNcclxuICogQGFrYSBMLkNSU1xyXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IGRlZmluZXMgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtcyBmb3IgcHJvamVjdGluZ1xyXG4gKiBnZW9ncmFwaGljYWwgcG9pbnRzIGludG8gcGl4ZWwgKHNjcmVlbikgY29vcmRpbmF0ZXMgYW5kIGJhY2sgKGFuZCB0b1xyXG4gKiBjb29yZGluYXRlcyBpbiBvdGhlciB1bml0cyBmb3IgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuIFNlZVxyXG4gKiBbc3BhdGlhbCByZWZlcmVuY2Ugc3lzdGVtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nvb3JkaW5hdGVfcmVmZXJlbmNlX3N5c3RlbSkuXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAqIENSUyBub3QgZGVmaW5lZCBieSBkZWZhdWx0LCB0YWtlIGEgbG9vayBhdCB0aGVcclxuICogW1Byb2o0TGVhZmxldF0oaHR0cHM6Ly9naXRodWIuY29tL2thcnRlbmEvUHJvajRMZWFmbGV0KSBwbHVnaW4uXHJcbiAqL1xyXG5cclxuTC5DUlMgPSB7XHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb1BvaW50KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIGdpdmVuIHpvb20uXHJcblx0bGF0TG5nVG9Qb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb24uX3RyYW5zZm9ybShwcm9qZWN0ZWRQb2ludCwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBsYXRMbmdUb1BvaW50YC4gUHJvamVjdHMgcGl4ZWwgY29vcmRpbmF0ZXMgb24gYSBnaXZlblxyXG5cdC8vIHpvb20gaW50byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblx0cG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHVudHJhbnNmb3JtZWRQb2ludCA9IHRoaXMudHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocG9pbnQsIHNjYWxlKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdCh1bnRyYW5zZm9ybWVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gY29vcmRpbmF0ZXMgaW4gdW5pdHMgYWNjZXB0ZWQgZm9yXHJcblx0Ly8gdGhpcyBDUlMgKGUuZy4gbWV0ZXJzIGZvciBFUFNHOjM4NTcsIGZvciBwYXNzaW5nIGl0IHRvIFdNUyBzZXJ2aWNlcykuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwcm9qZWN0ZWQgY29vcmRpbmF0ZSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIExhdExuZy5cclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlKHpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIHVzZWQgd2hlbiB0cmFuc2Zvcm1pbmcgcHJvamVjdGVkIGNvb3JkaW5hdGVzIGludG9cclxuXHQvLyBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBwYXJ0aWN1bGFyIHpvb20uIEZvciBleGFtcGxlLCBpdCByZXR1cm5zXHJcblx0Ly8gYDI1NiAqIDJeem9vbWAgZm9yIE1lcmNhdG9yLWJhc2VkIENSUy5cclxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiAyNTYgKiBNYXRoLnBvdygyLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb20oc2NhbGU6IE51bWJlcik6IE51bWJlclxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlKClgLCByZXR1cm5zIHRoZSB6b29tIGxldmVsIGNvcnJlc3BvbmRpbmcgdG8gYSBzY2FsZVxyXG5cdC8vIGZhY3RvciBvZiBgc2NhbGVgLlxyXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xyXG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlIC8gMjU2KSAvIE1hdGguTE4yO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UHJvamVjdGVkQm91bmRzKHpvb206IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3Rpb24ncyBib3VuZHMgc2NhbGVkIGFuZCB0cmFuc2Zvcm1lZCBmb3IgdGhlIHByb3ZpZGVkIGB6b29tYC5cclxuXHRnZXRQcm9qZWN0ZWRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRpZiAodGhpcy5pbmZpbml0ZSkgeyByZXR1cm4gbnVsbDsgfVxyXG5cclxuXHRcdHZhciBiID0gdGhpcy5wcm9qZWN0aW9uLmJvdW5kcyxcclxuXHRcdCAgICBzID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICBtaW4gPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1pbiwgcyksXHJcblx0XHQgICAgbWF4ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5tYXgsIHMpO1xyXG5cclxuXHRcdHJldHVybiBMLmJvdW5kcyhtaW4sIG1heCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHJcblx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG5cdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcblx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcblx0Ly8gYXhpcyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG5cdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG5cdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcblx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcblx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IEwuVXRpbC53cmFwTnVtKGxhdGxuZy5sbmcsIHRoaXMud3JhcExuZywgdHJ1ZSkgOiBsYXRsbmcubG5nLFxyXG5cdFx0ICAgIGxhdCA9IHRoaXMud3JhcExhdCA/IEwuVXRpbC53cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG5cdFx0ICAgIGFsdCA9IGxhdGxuZy5hbHQ7XHJcblxyXG5cdFx0cmV0dXJuIEwubGF0TG5nKGxhdCwgbG5nLCBhbHQpO1xyXG5cdH1cclxufTtcclxuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuU2ltcGxlXG4gKlxuICogQSBzaW1wbGUgQ1JTIHRoYXQgbWFwcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGludG8gYHhgIGFuZCBgeWAgZGlyZWN0bHkuXG4gKiBNYXkgYmUgdXNlZCBmb3IgbWFwcyBvZiBmbGF0IHN1cmZhY2VzIChlLmcuIGdhbWUgbWFwcykuIE5vdGUgdGhhdCB0aGUgYHlgXG4gKiBheGlzIHNob3VsZCBzdGlsbCBiZSBpbnZlcnRlZCAoZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wKS4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIHNpbXBsZSBldWNsaWRlYW4gZGlzdGFuY2UuXG4gKi9cblxuTC5DUlMuU2ltcGxlID0gTC5leHRlbmQoe30sIEwuQ1JTLCB7XG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5Mb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiBuZXcgTC5UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMCksXG5cblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuXHR9LFxuXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0fSxcblxuXHRpbmZpbml0ZTogdHJ1ZVxufSk7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5FYXJ0aFxuICpcbiAqIFNlcnZlcyBhcyB0aGUgYmFzZSBmb3IgQ1JTIHRoYXQgYXJlIGdsb2JhbCBzdWNoIHRoYXQgdGhleSBjb3ZlciB0aGUgZWFydGguXG4gKiBDYW4gb25seSBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciBvdGhlciBDUlMgYW5kIGNhbm5vdCBiZSB1c2VkIGRpcmVjdGx5LFxuICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBtZXRlcnMuXG4gKi9cblxuTC5DUlMuRWFydGggPSBMLmV4dGVuZCh7fSwgTC5DUlMsIHtcblx0d3JhcExuZzogWy0xODAsIDE4MF0sXG5cblx0Ly8gTWVhbiBFYXJ0aCBSYWRpdXMsIGFzIHJlY29tbWVuZGVkIGZvciB1c2UgYnlcblx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcblx0Ly8gc2VlIGh0dHA6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuXHRSOiA2MzcxMDAwLFxuXG5cdC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBwb2ludHMgdXNpbmcgc3BoZXJpY2FsIGxhdyBvZiBjb3NpbmVzIGFwcHJveGltYXRpb25cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIHJhZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0ICAgIGxhdDEgPSBsYXRsbmcxLmxhdCAqIHJhZCxcblx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkLFxuXHRcdCAgICBhID0gTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQyKSArXG5cdFx0ICAgICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MoKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkKTtcblxuXHRcdHJldHVybiB0aGlzLlIgKiBNYXRoLmFjb3MoTWF0aC5taW4oYSwgMSkpO1xuXHR9XG59KTtcblxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzg1N1xyXG4gKlxyXG4gKiBUaGUgbW9zdCBjb21tb24gQ1JTIGZvciBvbmxpbmUgbWFwcywgdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWxcclxuICogdGlsZSBwcm92aWRlcnMuIFVzZXMgU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uIFNldCBpbiBieSBkZWZhdWx0IGluXHJcbiAqIE1hcCdzIGBjcnNgIG9wdGlvbi5cclxuICovXHJcblxyXG5MLkNSUy5FUFNHMzg1NyA9IEwuZXh0ZW5kKHt9LCBMLkNSUy5FYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiBuZXcgTC5UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXHJcbkwuQ1JTLkVQU0c5MDA5MTMgPSBMLmV4dGVuZCh7fSwgTC5DUlMuRVBTRzM4NTcsIHtcclxuXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbn0pO1xyXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICpcclxuICogQSBjb21tb24gQ1JTIGFtb25nIEdJUyBlbnRodXNpYXN0cy4gVXNlcyBzaW1wbGUgRXF1aXJlY3Rhbmd1bGFyIHByb2plY3Rpb24uXHJcbiAqL1xyXG5cclxuTC5DUlMuRVBTRzQzMjYgPSBMLmV4dGVuZCh7fSwgTC5DUlMuRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uTG9uTGF0LFxyXG5cdHRyYW5zZm9ybWF0aW9uOiBuZXcgTC5UcmFuc2Zvcm1hdGlvbigxIC8gMTgwLCAxLCAtMSAvIDE4MCwgMC41KVxyXG59KTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgTWFwXHJcbiAqIEBha2EgTC5NYXBcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogVGhlIGNlbnRyYWwgY2xhc3Mgb2YgdGhlIEFQSSDigJQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAgb24gYSBwYWdlIGFuZCBtYW5pcHVsYXRlIGl0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBpbml0aWFsaXplIHRoZSBtYXAgb24gdGhlIFwibWFwXCIgZGl2IHdpdGggYSBnaXZlbiBjZW50ZXIgYW5kIHpvb21cclxuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XHJcbiAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAqIFx0em9vbTogMTNcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuXHJcbkwuTWFwID0gTC5FdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuXHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogTC5DUlMuRVBTRzM4NTcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBnZW9ncmFwaGljIGNlbnRlciBvZiB0aGUgbWFwXHJcblx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBtYXAgem9vbSBsZXZlbFxyXG5cdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcblx0XHQvLyBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC4gT3ZlcnJpZGVzIGFueSBgbWluWm9vbWAgb3B0aW9uIHNldCBvbiBtYXAgbGF5ZXJzLlxyXG5cdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC4gT3ZlcnJpZGVzIGFueSBgbWF4Wm9vbWAgb3B0aW9uIHNldCBvbiBtYXAgbGF5ZXJzLlxyXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuXHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcclxuXHRcdGxheWVyczogW10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuXHRcdC8vIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgbWFwIHJlc3RyaWN0cyB0aGUgdmlldyB0byB0aGUgZ2l2ZW5cclxuXHRcdC8vIGdlb2dyYXBoaWNhbCBib3VuZHMsIGJvdW5jaW5nIHRoZSB1c2VyIGJhY2sgd2hlbiBoZSB0cmllcyB0byBwYW5cclxuXHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxyXG5cdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG5cdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXIgPSAqXHJcblx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcblx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuXHRcdHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcblxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB0aWxlIGZhZGUgYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWFya2VyWm9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgbWFya2VycyBhbmltYXRlIHRoZWlyIHpvb20gd2l0aCB0aGUgem9vbSBhbmltYXRpb24sIGlmIGRpc2FibGVkXHJcblx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG5cdFx0Ly8gZW5hYmxlZCBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG5cdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcclxuXHRcdC8vIHZhbHVlIHNob3VsZCBub3QgYmUgY2hhbmdlZCB1bmxlc3MgYSB3ZWIgYnJvd3NlciBwb3NpdGlvbnMgbGF5ZXJzIGluXHJcblx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG5cdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gRm9yY2VzIHRoZSBtYXAncyB6b29tIGxldmVsIHRvIGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIHRoaXMsIHBhcnRpY3VsYXJseVxyXG5cdFx0Ly8gcmlnaHQgYWZ0ZXIgYSBbYGZpdEJvdW5kcygpYF0oI21hcC1maXRib3VuZHMpIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG5cdFx0Ly8gKGUuZy4gYDAuNWAgb3IgYDAuMWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LiBBIHZhbHVlIG9mIGAwYFxyXG5cdFx0Ly8gbWVhbnMgdGhlIHpvb20gbGV2ZWwgd2lsbCBub3QgYmUgc25hcHBlZCBhZnRlciBgZml0Qm91bmRzYCBvciBhIHBpbmNoLXpvb20uXHJcblx0XHR6b29tU25hcDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21EZWx0YTogTnVtYmVyID0gMVxyXG5cdFx0Ly8gQ29udHJvbHMgaG93IG11Y2ggdGhlIG1hcCdzIHpvb20gbGV2ZWwgd2lsbCBjaGFuZ2UgYWZ0ZXIgYVxyXG5cdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuXHRcdC8vIG9yIGAtYCBvbiB0aGUga2V5Ym9hcmQsIG9yIHVzaW5nIHRoZSBbem9vbSBjb250cm9sc10oI2NvbnRyb2wtem9vbSkuXHJcblx0XHQvLyBWYWx1ZXMgc21hbGxlciB0aGFuIGAxYCAoZS5nLiBgMC41YCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuXHJcblx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgYnJvd3NlciB3aW5kb3cgcmVzaXplIHRvIHVwZGF0ZSBpdHNlbGYuXHJcblx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykgeyAvLyAoSFRNTEVsZW1lbnQgb3IgU3RyaW5nLCBPYmplY3QpXHJcblx0XHRvcHRpb25zID0gTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuXHRcdHRoaXMuX29uUmVzaXplID0gTC5iaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbShvcHRpb25zLnpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnNldFZpZXcoTC5sYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFZpZXcoY2VudGVyOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSB3aXRoIHRoZSBnaXZlblxyXG5cdC8vIGFuaW1hdGlvbiBvcHRpb25zLlxyXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdC8vIHJlcGxhY2VkIGJ5IGFuaW1hdGlvbi1wb3dlcmVkIGltcGxlbWVudGF0aW9uIGluIE1hcC5QYW5BbmltYXRpb24uanNcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb207XHJcblx0XHR0aGlzLl9yZXNldFZpZXcoTC5sYXRMbmcoY2VudGVyKSwgem9vbSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHpvb20gb2YgdGhlIG1hcC5cclxuXHRzZXRab29tOiBmdW5jdGlvbiAoem9vbSwgb3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbUluKGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIEluY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21JbjogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChMLkJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoTC5Ccm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcblx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBMLlBvaW50ID8gbGF0bG5nIDogdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZyksXHJcblxyXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGNvbnRhaW5lclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKS5tdWx0aXBseUJ5KDEgLSAxIC8gc2NhbGUpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyh2aWV3SGFsZi5hZGQoY2VudGVyT2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhuZXdDZW50ZXIsIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0X2dldEJvdW5kc0NlbnRlclpvb206IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGJvdW5kcyA9IGJvdW5kcy5nZXRCb3VuZHMgPyBib3VuZHMuZ2V0Qm91bmRzKCkgOiBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSBMLnBvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gTC5wb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHJcblx0XHQgICAgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMsIGZhbHNlLCBwYWRkaW5nVEwuYWRkKHBhZGRpbmdCUikpO1xyXG5cclxuXHRcdHpvb20gPSAodHlwZW9mIG9wdGlvbnMubWF4Wm9vbSA9PT0gJ251bWJlcicpID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcblx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zOiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7IC8vIChQb2ludClcclxuXHRcdC8vIHJlcGxhY2VkIHdpdGggYW5pbWF0ZWQgcGFuQnkgaW4gTWFwLlBhbkFuaW1hdGlvbi5qc1xyXG5cdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHJcblx0XHR0aGlzLl9yYXdQYW5CeShMLnBvaW50KG9mZnNldCkpO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogQm91bmRzKTogdGhpc1xyXG5cdC8vIFJlc3RyaWN0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIGdpdmVuIGJvdW5kcyAoc2VlIHRoZSBbbWF4Qm91bmRzXSgjbWFwLW1heGJvdW5kcykgb3B0aW9uKS5cclxuXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm1pblpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm1heFpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIEwubGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcblx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9QYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG5cdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LlxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gTC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChMLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBUT0RPIGhhbmRsZXIuYWRkVG9cclxuXHQvLyBUT0RPIEFwcHJvcGlhdGUgZG9jcyBzZWN0aW9uP1xyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGFkZEhhbmRsZXIobmFtZTogU3RyaW5nLCBIYW5kbGVyQ2xhc3M6IEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBuZXcgYEhhbmRsZXJgIHRvIHRoZSBtYXAsIGdpdmVuIGl0cyBuYW1lIGFuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcblx0XHRpZiAoIUhhbmRsZXJDbGFzcykgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcblx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmUoKTogdGhpc1xyXG5cdC8vIERlc3Ryb3lzIHRoZSBtYXAgYW5kIGNsZWFycyBhbGwgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY29udGFpbmVySWQgIT09IHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYmVpbmcgcmV1c2VkIGJ5IGFub3RoZXIgaW5zdGFuY2UnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyB0aHJvd3MgZXJyb3IgaW4gSUU2LThcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZDtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcklkO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0Lyplc2xpbnQtZW5hYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgZGVzdHJveWVkIHdpdGggW3JlbW92ZV0oI21hcC1yZW1vdmUpIG1ldGhvZC5cclxuXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgY3JlYXRlUGFuZShuYW1lOiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDcmVhdGVzIGEgbmV3IFttYXAgcGFuZV0oI21hcC1wYW5lKSB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeSxcclxuXHQvLyB0aGVuIHJldHVybnMgaXQuIFRoZSBwYW5lIGlzIGNyZWF0ZWQgYXMgYSBjaGlsZHJlbiBvZiBgY29udGFpbmVyYCwgb3JcclxuXHQvLyBhcyBhIGNoaWxkcmVuIG9mIHRoZSBtYWluIG1hcCBwYW5lIGlmIG5vdCBzZXQuXHJcblx0Y3JlYXRlUGFuZTogZnVuY3Rpb24gKG5hbWUsIGNvbnRhaW5lcikge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXBhbmUnICsgKG5hbWUgPyAnIGxlYWZsZXQtJyArIG5hbWUucmVwbGFjZSgnUGFuZScsICcnKSArICctcGFuZScgOiAnJyksXHJcblx0XHQgICAgcGFuZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyIHx8IHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmIChuYW1lKSB7XHJcblx0XHRcdHRoaXMuX3BhbmVzW25hbWVdID0gcGFuZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBjZW50ZXIgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RDZW50ZXIgJiYgIXRoaXMuX21vdmVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2xhc3RDZW50ZXI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBtYXAgdmlld1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG5cdFx0ICAgIG5lID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldFRvcFJpZ2h0KCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1pblpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLCBvciBgMGAgYnkgZGVmYXVsdC5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcblx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcblx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG5cdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cclxuXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cdFx0cGFkZGluZyA9IEwucG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuXHRcdCAgICBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcblx0XHQgICAgYm91bmRzU2l6ZSA9IHRoaXMucHJvamVjdChzZSwgem9vbSkuc3VidHJhY3QodGhpcy5wcm9qZWN0KG53LCB6b29tKSksXHJcblx0XHQgICAgc25hcCA9IEwuQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcblxyXG5cdFx0dmFyIHNjYWxlID0gTWF0aC5taW4oc2l6ZS54IC8gYm91bmRzU2l6ZS54LCBzaXplLnkgLyBib3VuZHNTaXplLnkpO1xyXG5cdFx0em9vbSA9IHRoaXMuZ2V0U2NhbGVab29tKHNjYWxlLCB6b29tKTtcclxuXHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcblx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgTC5Qb2ludChcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGgsXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCk7XHJcblxyXG5cdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsQm91bmRzKCk6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuXHQvLyBjb29yZGluYXRlcyAoc29tZXRpbWVzIHVzZWZ1bCBpbiBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gbmV3IEwuQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE86IENoZWNrIHNlbWFudGljcyAtIGlzbid0IHRoZSBwaXhlbCBvcmlnaW4gdGhlIDAsMCBjb29yZCByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuXHQvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbmVnYXRpdmUgb2Zmc2V0cy5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsT3JpZ2luKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG5cdC8vIHRoZSBtYXAgbGF5ZXIgKHVzZWZ1bCBpbiBjdXN0b20gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsT3JpZ2luO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgd29ybGQncyBib3VuZHMgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIHpvb20gbGV2ZWwgYHpvb21gLlxyXG5cdC8vIElmIGB6b29tYCBpcyBvbWl0dGVkLCB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIHVzZWQuXHJcblx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lKHBhbmU6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhIFttYXAgcGFuZV0oI21hcC1wYW5lKSwgZ2l2ZW4gaXRzIG5hbWUgb3IgaXRzIEhUTUwgZWxlbWVudCAoaXRzIGlkZW50aXR5KS5cclxuXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIFtwYW5lc10oI21hcC1wYW5lKSBhcyBrZXlzIGFuZFxyXG5cdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXHJcblx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYW5lcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgbWFwLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgZmFjdG9yIHRvIGJlIGFwcGxpZWQgdG8gYSBtYXAgdHJhbnNpdGlvbiBmcm9tIHpvb20gbGV2ZWxcclxuXHQvLyBgZnJvbVpvb21gIHRvIGB0b1pvb21gLiBVc2VkIGludGVybmFsbHkgdG8gaGVscCB3aXRoIHpvb20gYW5pbWF0aW9ucy5cclxuXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcblx0XHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0cmV0dXJuIGNycy5zY2FsZSh0b1pvb20pIC8gY3JzLnNjYWxlKGZyb21ab29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXHJcblx0Ly8gbGV2ZWwgYW5kIGV2ZXJ5dGhpbmcgaXMgc2NhbGVkIGJ5IGEgZmFjdG9yIG9mIGBzY2FsZWAuIEludmVyc2Ugb2ZcclxuXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSwgZnJvbVpvb20pIHtcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0dmFyIHpvb20gPSBjcnMuem9vbShzY2FsZSAqIGNycy5zY2FsZShmcm9tWm9vbSkpO1xyXG5cdFx0cmV0dXJuIGlzTmFOKHpvb20pID8gSW5maW5pdHkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGBMYXRMbmdgIGFjY29yZGluZyB0byB0aGUgcHJvamVjdGlvblxyXG5cdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG5cdC8vIGBUcmFuc2Zvcm1hdGlvbmAuIFRoZSByZXN1bHQgaXMgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBDUlMgb3JpZ2luLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQoTC5sYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBJbnZlcnNlIG9mIFtgcHJvamVjdGBdKCNtYXAtcHJvamVjdCkuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcoTC5wb2ludChwb2ludCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGxheWVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSBMLnBvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRsYXRMbmdUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdChMLmxhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuXHRcdHJldHVybiBwcm9qZWN0ZWRQb2ludC5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgYGxhdGAgYW5kIGBsbmdgIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIG1hcCdzIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlXHJcblx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcoTC5sYXRMbmcobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG9cclxuXHQvLyB0aGUgbWFwJ3MgQ1JTLiBCeSBkZWZhdWx0IHRoaXMgbWVhc3VyZXMgZGlzdGFuY2UgaW4gbWV0ZXJzLlxyXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UoTC5sYXRMbmcobGF0bG5nMSksIEwubGF0TG5nKGxhdGxuZzIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gTC5wb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gTC5wb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zXHJcblx0Ly8gdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChMLnBvaW50KHBvaW50KSk7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXRMbmdUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9Db250YWluZXJQb2ludCh0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChMLmxhdExuZyhsYXRsbmcpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGVcclxuXHQvLyBtYXAgY29udGFpbmVyIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIEwuRG9tRXZlbnQuZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF5ZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXRMbmcoZXY6IE1vdXNlRXZlbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG5cdC8vIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF0TG5nOiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBtYXAgaW5pdGlhbGl6YXRpb24gbWV0aG9kc1xyXG5cclxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmdldChpZCk7XHJcblxyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIG5vdCBmb3VuZC4nKTtcclxuXHRcdH0gZWxzZSBpZiAoY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xyXG5cdFx0dGhpcy5fY29udGFpbmVySWQgPSBMLlV0aWwuc3RhbXAoY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHR0aGlzLl9mYWRlQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiAmJiBMLkJyb3dzZXIuYW55M2Q7XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udGFpbmVyJyArXHJcblx0XHRcdChMLkJyb3dzZXIudG91Y2ggPyAnIGxlYWZsZXQtdG91Y2gnIDogJycpICtcclxuXHRcdFx0KEwuQnJvd3Nlci5yZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArXHJcblx0XHRcdChMLkJyb3dzZXIuaWVsdDkgPyAnIGxlYWZsZXQtb2xkaWUnIDogJycpICtcclxuXHRcdFx0KEwuQnJvd3Nlci5zYWZhcmkgPyAnIGxlYWZsZXQtc2FmYXJpJyA6ICcnKSArXHJcblx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gTC5Eb21VdGlsLmdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdFBhbmVzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2luaXRDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBhbmVzID0gdGhpcy5fcGFuZXMgPSB7fTtcclxuXHRcdHRoaXMuX3BhbmVSZW5kZXJlcnMgPSB7fTtcclxuXHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly9cclxuXHRcdC8vIFBhbmVzIGFyZSBET00gZWxlbWVudHMgdXNlZCB0byBjb250cm9sIHRoZSBvcmRlcmluZyBvZiBsYXllcnMgb24gdGhlIG1hcC4gWW91XHJcblx0XHQvLyBjYW4gYWNjZXNzIHBhbmVzIHdpdGggW2BtYXAuZ2V0UGFuZWBdKCNtYXAtZ2V0cGFuZSkgb3JcclxuXHRcdC8vIFtgbWFwLmdldFBhbmVzYF0oI21hcC1nZXRwYW5lcykgbWV0aG9kcy4gTmV3IHBhbmVzIGNhbiBiZSBjcmVhdGVkIHdpdGggdGhlXHJcblx0XHQvLyBbYG1hcC5jcmVhdGVQYW5lYF0oI21hcC1jcmVhdGVwYW5lKSBtZXRob2QuXHJcblx0XHQvL1xyXG5cdFx0Ly8gRXZlcnkgbWFwIGhhcyB0aGUgZm9sbG93aW5nIGRlZmF1bHQgcGFuZXMgdGhhdCBkaWZmZXIgb25seSBpbiB6SW5kZXguXHJcblx0XHQvL1xyXG5cdFx0Ly8gQHBhbmUgbWFwUGFuZTogSFRNTEVsZW1lbnQgPSAnYXV0bydcclxuXHRcdC8vIFBhbmUgdGhhdCBjb250YWlucyBhbGwgb3RoZXIgbWFwIHBhbmVzXHJcblxyXG5cdFx0dGhpcy5fbWFwUGFuZSA9IHRoaXMuY3JlYXRlUGFuZSgnbWFwUGFuZScsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IEwuUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgdmVjdG9yIG92ZXJsYXlzIChgUGF0aGBzKSwgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG5cdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEljb25gcyBvZiBgTWFya2VyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcblx0XHQvLyBQYW5lIGZvciB0b29sdGlwLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYFBvcHVwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MocGFuZXMuc2hhZG93UGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyB0aGF0IG1vZGlmeSBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IEwuUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XHJcblx0XHR6b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XHJcblxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHRcdHRoaXNcclxuXHRcdFx0Ll9tb3ZlU3RhcnQoem9vbUNoYW5nZWQpXHJcblx0XHRcdC5fbW92ZShjZW50ZXIsIHpvb20pXHJcblx0XHRcdC5fbW92ZUVuZCh6b29tQ2hhbmdlZCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHZpZXdyZXNldDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBuZWVkcyB0byByZWRyYXcgaXRzIGNvbnRlbnQgKHRoaXMgdXN1YWxseSBoYXBwZW5zXHJcblx0XHQvLyBvbiBtYXAgem9vbSBvciBsb2FkKS4gVmVyeSB1c2VmdWwgZm9yIGNyZWF0aW5nIGN1c3RvbSBvdmVybGF5cy5cclxuXHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgaW5pdGlhbGl6ZWQgKHdoZW4gaXRzIGNlbnRlciBhbmQgem9vbSBhcmUgc2V0XHJcblx0XHQvLyBmb3IgdGhlIGZpcnN0IHRpbWUpLlxyXG5cdFx0aWYgKGxvYWRpbmcpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVTdGFydDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkKSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0fSxcclxuXHJcblx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEpIHtcclxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0em9vbSA9IHRoaXMuX3pvb207XHJcblx0XHR9XHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IGNlbnRlcjtcclxuXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgem9vbTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBjaGFuZ2UgaW4gem9vbSBsZXZlbCwgaW5jbHVkaW5nIHpvb21cclxuXHRcdC8vIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCB8fCAoZGF0YSAmJiBkYXRhLnBpbmNoKSkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgbW92ZW1lbnQgb2YgdGhlIG1hcCwgaW5jbHVkaW5nIHBhbiBhbmRcclxuXHRcdC8vIGZseSBhbmltYXRpb25zLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGhhcyBjaGFuZ2VkLCBhZnRlciBhbnkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21lbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGNlbnRlciBvZiB0aGUgbWFwIHN0b3BzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RvcHBlZFxyXG5cdFx0Ly8gZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3N0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmx5VG9GcmFtZSk7XHJcblx0XHRpZiAodGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yYXdQYW5CeTogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG5cdH0sXHJcblxyXG5cdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmTG9hZGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuXHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBldmVudHNcclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xyXG5cdFx0aWYgKCFMLkRvbUV2ZW50KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX3RhcmdldHMgPSB7fTtcclxuXHRcdHRoaXMuX3RhcmdldHNbTC5zdGFtcCh0aGlzLl9jb250YWluZXIpXSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nO1xyXG5cclxuXHRcdC8vIEBldmVudCBjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKG9yIHRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgZGJsY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyAob3IgZG91YmxlLXRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vkb3duOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2V1cDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdmVyOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBlbnRlcnMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW91dDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vtb3ZlOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGlsZSB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGNvbnRleHRtZW51OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAsIHByZXZlbnRzXHJcblx0XHQvLyBkZWZhdWx0IGJyb3dzZXIgY29udGV4dCBtZW51IGZyb20gc2hvd2luZyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzIG9uXHJcblx0XHQvLyB0aGlzIGV2ZW50LiBBbHNvIGZpcmVkIG9uIG1vYmlsZSB3aGVuIHRoZSB1c2VyIGhvbGRzIGEgc2luZ2xlIHRvdWNoXHJcblx0XHQvLyBmb3IgYSBzZWNvbmQgKGFsc28gY2FsbGVkIGxvbmcgcHJlc3MpLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXByZXNzOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0TC5Eb21FdmVudFtvbk9mZl0odGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcblx0XHRcdCdtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuXHRcdFx0TC5Eb21FdmVudFtvbk9mZl0od2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0dGhpc1tvbk9mZl0oJ21vdmVlbmQnLCB0aGlzLl9vbk1vdmVFbmQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDA7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdGlmIChNYXRoLm1heChNYXRoLmFicyhwb3MueCksIE1hdGguYWJzKHBvcy55KSkgPj0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG5cdFx0XHQvLyBhIHBpeGVsIG9mZnNldCBvbiB2ZXJ5IGhpZ2ggdmFsdWVzLCBzZWU6IGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZGc2cjVoaGIvXHJcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB0aGlzLmdldFpvb20oKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2ZpbmRFdmVudFRhcmdldHM6IGZ1bmN0aW9uIChlLCB0eXBlKSB7XHJcblx0XHR2YXIgdGFyZ2V0cyA9IFtdLFxyXG5cdFx0ICAgIHRhcmdldCxcclxuXHRcdCAgICBpc0hvdmVyID0gdHlwZSA9PT0gJ21vdXNlb3V0JyB8fCB0eXBlID09PSAnbW91c2VvdmVyJyxcclxuXHRcdCAgICBzcmMgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXHJcblx0XHQgICAgZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcblx0XHR3aGlsZSAoc3JjKSB7XHJcblx0XHRcdHRhcmdldCA9IHRoaXMuX3RhcmdldHNbTC5zdGFtcChzcmMpXTtcclxuXHRcdFx0aWYgKHRhcmdldCAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAncHJlY2xpY2snKSAmJiAhZS5fc2ltdWxhdGVkICYmIHRoaXMuX2RyYWdnYWJsZU1vdmVkKHRhcmdldCkpIHtcclxuXHRcdFx0XHQvLyBQcmV2ZW50IGZpcmluZyBjbGljayBhZnRlciB5b3UganVzdCBkcmFnZ2VkIGFuIG9iamVjdC5cclxuXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRhcmdldCAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyICYmICFMLkRvbUV2ZW50Ll9pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHsgYnJlYWs7IH1cclxuXHRcdFx0XHR0YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlcikgeyBicmVhazsgfVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzcmMgPT09IHRoaXMuX2NvbnRhaW5lcikgeyBicmVhazsgfVxyXG5cdFx0XHRzcmMgPSBzcmMucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGggJiYgIWRyYWdnaW5nICYmICFpc0hvdmVyICYmIEwuRG9tRXZlbnQuX2lzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkge1xyXG5cdFx0XHR0YXJnZXRzID0gW3RoaXNdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZURPTUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQgfHwgTC5Eb21FdmVudC5fc2tpcHBlZChlKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdHlwZSA9IGUudHlwZSA9PT0gJ2tleXByZXNzJyAmJiBlLmtleUNvZGUgPT09IDEzID8gJ2NsaWNrJyA6IGUudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuXHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XHJcblx0XHRcdEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZShlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuXHR9LFxyXG5cclxuXHRfZmlyZURPTUV2ZW50OiBmdW5jdGlvbiAoZSwgdHlwZSwgdGFyZ2V0cykge1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG5cdFx0XHQvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcclxuXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuXHRcdFx0Ly8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXHJcblx0XHRcdHZhciBzeW50aCA9IEwuVXRpbC5leHRlbmQoe30sIGUpO1xyXG5cdFx0XHRzeW50aC50eXBlID0gJ3ByZWNsaWNrJztcclxuXHRcdFx0dGhpcy5fZmlyZURPTUV2ZW50KHN5bnRoLCBzeW50aC50eXBlLCB0YXJnZXRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZS5fc3RvcHBlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBGaW5kIHRoZSBsYXllciB0aGUgZXZlbnQgaXMgcHJvcGFnYXRpbmcgZnJvbSBhbmQgaXRzIHBhcmVudHMuXHJcblx0XHR0YXJnZXRzID0gKHRhcmdldHMgfHwgW10pLmNvbmNhdCh0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpKTtcclxuXHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdO1xyXG5cdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnKSB7XHJcblx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldCBpbnN0YW5jZW9mIEwuTWFya2VyO1xyXG5cdFx0XHRkYXRhLmNvbnRhaW5lclBvaW50ID0gaXNNYXJrZXIgP1xyXG5cdFx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG5cdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG5cdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG5cdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcblx0XHRcdFx0KHRhcmdldHNbaV0ub3B0aW9ucy5ub25CdWJibGluZ0V2ZW50cyAmJiBMLlV0aWwuaW5kZXhPZih0YXJnZXRzW2ldLm9wdGlvbnMubm9uQnViYmxpbmdFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRvYmogPSBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLmVuYWJsZWQoKSA/IG9iaiA6IHRoaXM7XHJcblx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIHdoZW5SZWFkeShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcblx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcblx0Ly8gaWYgaXQncyBhbHJlYWR5IGluaXRpYWxpemVkLCBvcHRpb25hbGx5IHBhc3NpbmcgYSBmdW5jdGlvbiBjb250ZXh0LlxyXG5cdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCB8fCB0aGlzLCB7dGFyZ2V0OiB0aGlzfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSkgfHwgbmV3IEwuUG9pbnQoMCwgMCk7XHJcblx0fSxcclxuXHJcblx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0cmV0dXJuIHBvcyAmJiAhcG9zLmVxdWFscyhbMCwgMF0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciBwaXhlbE9yaWdpbiA9IGNlbnRlciAmJiB6b29tICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHR0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDpcclxuXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG5cdFx0cmV0dXJuIHBpeGVsT3JpZ2luLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ1RvTmV3TGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcblx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgTC5Cb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRCb3VuZHNPZmZzZXQodmlld0JvdW5kcywgYm91bmRzLCB6b29tKTtcclxuXHJcblx0XHQvLyBJZiBvZmZzZXQgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIGlnbm9yZS5cclxuXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuXHRcdC8vIGFuIGluZmluaXRlIGxvb3Agb2YgdGlueSBvZmZzZXRzLlxyXG5cdFx0aWYgKG9mZnNldC5yb3VuZCgpLmVxdWFscyhbMCwgMF0pKSB7XHJcblx0XHRcdHJldHVybiBjZW50ZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3Qgb2Zmc2V0IGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcblx0XHR2YXIgdmlld0JvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgTC5Cb3VuZHModmlld0JvdW5kcy5taW4uYWRkKG9mZnNldCksIHZpZXdCb3VuZHMubWF4LmFkZChvZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIG9mZnNldCBuZWVkZWQgZm9yIHB4Qm91bmRzIHRvIGdldCBpbnNpZGUgbWF4Qm91bmRzIGF0IGEgc3BlY2lmaWVkIHpvb21cclxuXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IEwuYm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuXHRcdCAgICApLFxyXG5cdFx0ICAgIG1pbk9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5taW4uc3VidHJhY3QocHhCb3VuZHMubWluKSxcclxuXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG5cdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LnksIC1tYXhPZmZzZXQueSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGR4LCBkeSk7XHJcblx0fSxcclxuXHJcblx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG5cdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG5cdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuXHR9LFxyXG5cclxuXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBMLkJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbkwubWFwID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLk1hcChpZCwgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxuICogQGNsYXNzIExheWVyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogQGFrYSBMLkxheWVyXG4gKiBAYWthIElMYXllclxuICpcbiAqIEEgc2V0IG9mIG1ldGhvZHMgZnJvbSB0aGUgTGF5ZXIgYmFzZSBjbGFzcyB0aGF0IGFsbCBMZWFmbGV0IGxheWVycyB1c2UuXG4gKiBJbmhlcml0cyBhbGwgbWV0aG9kcywgb3B0aW9ucyBhbmQgZXZlbnRzIGZyb20gYEwuRXZlbnRlZGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5NYXJrZXIobGF0bG5nKS5hZGRUbyhtYXApO1xuICogbGF5ZXIuYWRkVG8obWFwKTtcbiAqIGxheWVyLnJlbW92ZSgpO1xuICogYGBgXG4gKlxuICogQGV2ZW50IGFkZDogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyBhZGRlZCB0byBhIG1hcFxuICpcbiAqIEBldmVudCByZW1vdmU6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgbWFwXG4gKi9cblxuXG5MLkxheWVyID0gTC5FdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcblx0XHQvLyBCeSBkZWZhdWx0IHRoZSBsYXllciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAncyBbb3ZlcmxheSBwYW5lXSgjbWFwLW92ZXJsYXlwYW5lKS4gT3ZlcnJpZGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBsYXllciB0byBiZSBwbGFjZWQgb24gYW5vdGhlciBwYW5lIGJ5IGRlZmF1bHQuXG5cdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblx0XHRub25CdWJibGluZ0V2ZW50czogW10gIC8vIEFycmF5IG9mIGV2ZW50cyB0aGF0IHNob3VsZCBub3QgYmUgYnViYmxlZCB0byBET00gcGFyZW50cyAobGlrZSB0aGUgbWFwKVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xuXHQgKiBBZGRzIHRoZSBsYXllciB0byB0aGUgZ2l2ZW4gbWFwXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcblx0XHRpZiAob2JqKSB7XG5cdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcblx0fSxcblxuXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0dGhpcy5fbWFwLl90YXJnZXRzW0wuc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbTC5zdGFtcCh0YXJnZXRFbCldO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cblx0XHQvLyBjaGVjayBpbiBjYXNlIGxheWVyIGdldHMgYWRkZWQgYW5kIHRoZW4gcmVtb3ZlZCBiZWZvcmUgdGhlIG1hcCBpcyByZWFkeVxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xuXG5cdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcblx0XHRcdG1hcC5vbihldmVudHMsIHRoaXMpO1xuXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMub25BZGQobWFwKTtcblxuXHRcdGlmICh0aGlzLmdldEF0dHJpYnV0aW9uICYmIHRoaXMuX21hcC5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdHRoaXMuX21hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuYWRkQXR0cmlidXRpb24odGhpcy5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuXHRcdG1hcC5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogdGhpc30pO1xuXHR9XG59KTtcblxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAqIEB1bmluaGVyaXRhYmxlXG4gKlxuICogRXZlcnkgbGF5ZXIgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkxheWVyYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxuICpcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBjb2RlIHRoYXQgY3JlYXRlcyBET00gZWxlbWVudHMgZm9yIHRoZSBsYXllciwgYWRkcyB0aGVtIHRvIGBtYXAgcGFuZXNgIHdoZXJlIHRoZXkgc2hvdWxkIGJlbG9uZyBhbmQgcHV0cyBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLlxuICpcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxheWVyJ3MgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmVzIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjbGF5ZXItb25hZGQpLiBDYWxsZWQgb24gW2BtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpYF0oI21hcC1yZW1vdmVsYXllcikuXG4gKlxuICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIGB7IHZpZXdyZXNldDogdGhpcy5fcmVzZXQgfWAgZm9yIFtgYWRkRXZlbnRMaXN0ZW5lcmBdKCNldmVudGVkLWFkZGV2ZW50bGlzdGVuZXIpLiBUaGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIG1hcCB3aXRoIHlvdXIgbGF5ZXIuXG4gKlxuICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGAgd2hlbmV2ZXIgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gKlxuICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gKiBPcHRpb25hbCBtZXRob2QuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKSwgYmVmb3JlIHRoZSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLCBiZWZvcmUgZXZlbnRzIGFyZSBpbml0aWFsaXplZCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZSBtYXAgaXMgaW4gYSB1c2FibGUgc3RhdGUuIFVzZSBmb3IgZWFybHkgaW5pdGlhbGl6YXRpb24gb25seS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFwXG4gKiBAc2VjdGlvbiBMYXllciBldmVudHNcbiAqXG4gKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAqXG4gKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gc29tZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICpcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAqL1xuTC5NYXAuaW5jbHVkZSh7XG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcblx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcblxuXHRcdGxheWVyLl9tYXBUb0FkZCA9IHRoaXM7XG5cblx0XHRpZiAobGF5ZXIuYmVmb3JlQWRkKSB7XG5cdFx0XHRsYXllci5iZWZvcmVBZGQodGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy53aGVuUmVhZHkobGF5ZXIuX2xheWVyQWRkLCBsYXllcik7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gTC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5nZXRBdHRyaWJ1dGlvbiAmJiB0aGlzLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wucmVtb3ZlQXR0cmlidXRpb24obGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRyZXR1cm4gISFsYXllciAmJiAoTC5zdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcblx0fSxcblxuXHQvKiBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG5cdCAqIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgbWFwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXG5cdCAqIGBgYFxuXHQgKiBtYXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKXtcblx0ICogICAgIGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcblx0ICogfSk7XG5cdCAqIGBgYFxuXHQgKi9cblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRsYXllcnMgPSBsYXllcnMgPyAoTC5VdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW0wuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuXHRcdCAgICBvbGRab29tU3BhbiA9IHRoaXMuX2dldFpvb21TcGFuKCk7XG5cblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuXHRcdFx0bWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gbWluWm9vbSA6IE1hdGgubWluKG1pblpvb20sIG9wdGlvbnMubWluWm9vbSk7XG5cdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gbWF4Wm9vbSA9PT0gLUluZmluaXR5ID8gdW5kZWZpbmVkIDogbWF4Wm9vbTtcblx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcblx0XHQvLyBAZXZlbnQgem9vbWxldmVsc2NoYW5nZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG5cdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG5cdFx0aWYgKG9sZFpvb21TcGFuICE9PSB0aGlzLl9nZXRab29tU3BhbigpKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yXHJcbiAqXHJcbiAqIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgbW9yZSBjb21wbGV4IHRoYW4gU3BoZXJpY2FsIE1lcmNhdG9yLiBUYWtlcyBpbnRvIGFjY291bnQgdGhhdCBFYXJ0aCBpcyBhIGdlb2lkLCBub3QgYSBwZXJmZWN0IHNwaGVyZS4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24uTWVyY2F0b3IgPSB7XHJcblx0UjogNjM3ODEzNyxcclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcblx0Ym91bmRzOiBMLmJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHkgPSBsYXRsbmcubGF0ICogZCxcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgY29uID0gZSAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG5cdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcblx0fVxyXG59O1xyXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICpcclxuICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICovXHJcblxyXG5MLkNSUy5FUFNHMzM5NSA9IEwuZXh0ZW5kKHt9LCBMLkNSUy5FYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjMzOTUnLFxyXG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5NZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIEwuUHJvamVjdGlvbi5NZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiBuZXcgTC5UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXG4vKlxuICogQGNsYXNzIEdyaWRMYXllclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuR3JpZExheWVyXG4gKlxuICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICpcbiAqXG4gKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMpe1xuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBnZXQgYSBjYW52YXMgY29udGV4dCBhbmQgZHJhdyBzb21ldGhpbmcgb24gaXQgdXNpbmcgY29vcmRzLngsIGNvb3Jkcy55IGFuZCBjb29yZHMuelxuICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICpcbiAqICAgICAgICAgLy8gcmV0dXJuIHRoZSB0aWxlIHNvIGl0IGNhbiBiZSByZW5kZXJlZCBvbiBzY3JlZW5cbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvbiBBc3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVGlsZSBjcmVhdGlvbiBjYW4gYWxzbyBiZSBhc3luY2hyb25vdXMsIHRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYSB0aGlyZC1wYXJ0eSBkcmF3aW5nIGxpYnJhcnkuIE9uY2UgdGhlIHRpbGUgaXMgZmluaXNoZWQgZHJhd2luZyBpdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgZG9uZSgpYCBjYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICogICAgICAgICB2YXIgZXJyb3I7XG4gKlxuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBkcmF3IHNvbWV0aGluZyBhc3luY2hyb25vdXNseSBhbmQgcGFzcyB0aGUgdGlsZSB0byB0aGUgZG9uZSgpIGNhbGxiYWNrXG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAqICAgICAgICAgfSwgMTAwMCk7XG4gKlxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uXG4gKi9cblxuXG5MLkdyaWRMYXllciA9IEwuTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcblx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG5cdFx0dGlsZVNpemU6IDI1NixcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBJZiBgZmFsc2VgLCBuZXcgdGlsZXMgYXJlIGxvYWRlZCBkdXJpbmcgcGFubmluZywgb3RoZXJ3aXNlIG9ubHkgYWZ0ZXIgaXQgKGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UpLiBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIG90aGVyd2lzZSBgZmFsc2VgLlxuXHRcdHVwZGF0ZVdoZW5JZGxlOiBMLkJyb3dzZXIubW9iaWxlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuWm9vbWluZzogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cblx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlSW50ZXJ2YWw6IE51bWJlciA9IDIwMFxuXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG5cdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcblx0XHQvLyBTdHJpbmcgdG8gYmUgc2hvd24gaW4gdGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wsIGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSwgZS5nLiBcIsKpIE1hcGJveFwiLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcblx0XHQvLyBUaGUgZXhwbGljaXQgekluZGV4IG9mIHRoZSB0aWxlIGxheWVyLlxuXHRcdHpJbmRleDogMSxcblxuXHRcdC8vIEBvcHRpb24gYm91bmRzOiBMYXRMbmdCb3VuZHMgPSB1bmRlZmluZWRcblx0XHQvLyBJZiBzZXQsIHRpbGVzIHdpbGwgb25seSBiZSBsb2FkZWQgaW5zaWRlIHRoZSBzZXQgYExhdExuZ0JvdW5kc2AuXG5cdFx0Ym91bmRzOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCB0aGF0IHRpbGVzIHdpbGwgYmUgbG9hZGVkIGF0LiBCeSBkZWZhdWx0IHRoZSBlbnRpcmUgbWFwLlxuXHRcdG1pblpvb206IDAsXG5cblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdGhhdCB0aWxlcyB3aWxsIGJlIGxvYWRlZCBhdC5cblx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG5vV3JhcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0aGUgbGF5ZXIgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGFudGltZXJpZGlhbi4gSWYgYHRydWVgLCB0aGVcblx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG5cdFx0Ly8gZWZmZWN0IHdoZW4gdGhlIFttYXAgQ1JTXSgjbWFwLWNycykgZG9lc24ndCB3cmFwIGFyb3VuZC5cblx0XHRub1dyYXA6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgZ3JpZCBsYXllciB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgdGlsZSBsYXllci4gRW1wdHkgYnkgZGVmYXVsdC5cblx0XHRjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG5cdFx0Ly8gV2hlbiBwYW5uaW5nIHRoZSBtYXAsIGtlZXAgdGhpcyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgdGlsZXMgYmVmb3JlIHVubG9hZGluZyB0aGVtLlxuXHRcdGtlZXBCdWZmZXI6IDJcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcblxuXHRcdHRoaXMuX2xldmVscyA9IHt9O1xuXHRcdHRoaXMuX3RpbGVzID0ge307XG5cblx0XHR0aGlzLl9yZXNldFZpZXcoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuX2FkZFpvb21MaW1pdCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdFx0dGhpcy5fdGlsZVpvb20gPSBudWxsO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0TC5Eb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRMLkRvbVV0aWwudG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbjogU3RyaW5nXG5cdC8vIFVzZWQgYnkgdGhlIGBhdHRyaWJ1dGlvbiBjb250cm9sYCwgcmV0dXJucyB0aGUgW2F0dHJpYnV0aW9uIG9wdGlvbl0oI2dyaWRsYXllci1hdHRyaWJ1dGlvbikuXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHRpbGVzIGZvciB0aGlzIGxheWVyLlxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFtvcGFjaXR5XSgjZ3JpZGxheWVyLW9wYWNpdHkpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNncmlkbGF5ZXItemluZGV4KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNMb2FkaW5nOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGFueSB0aWxlIGluIHRoZSBncmlkIGxheWVyIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy5cblx0aXNMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRpbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXc6IHRoaXNcblx0Ly8gQ2F1c2VzIHRoZSBsYXllciB0byBjbGVhciBhbGwgdGhlIHRpbGVzIGFuZCByZXF1ZXN0IHRoZW0gYWdhaW4uXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdwcmVyZXNldDogdGhpcy5faW52YWxpZGF0ZUFsbCxcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fb25Nb3ZlRW5kXG5cdFx0fTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XG5cdFx0XHQvLyB1cGRhdGUgdGlsZXMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcblx0XHRcdGlmICghdGhpcy5fb25Nb3ZlKSB7XG5cdFx0XHRcdHRoaXMuX29uTW92ZSA9IEwuVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBgR3JpZExheWVyYC5cblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBgY29vcmRzYC4gSWYgdGhlIGBkb25lYCBjYWxsYmFja1xuXHQvLyBpcyBzcGVjaWZpZWQsIGl0IG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGZpbmlzaGVkIGxvYWRpbmcgYW5kIGRyYXdpbmcuXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQG1ldGhvZCBnZXRUaWxlU2l6ZTogUG9pbnRcblx0Ly8gTm9ybWFsaXplcyB0aGUgW3RpbGVTaXplIG9wdGlvbl0oI2dyaWRsYXllci10aWxlc2l6ZSkgaW50byBhIHBvaW50LiBVc2VkIGJ5IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QuXG5cdGdldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHMgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG5cdFx0cmV0dXJuIHMgaW5zdGFuY2VvZiBMLlBvaW50ID8gcyA6IG5ldyBMLlBvaW50KHMsIHMpO1xuXHR9LFxuXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdH0sXG5cblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG5cdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG5cdFx0aWYgKEwuQnJvd3Nlci5pZWx0OSkgeyByZXR1cm47IH1cblxuXHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuXHRcdCAgICBuZXh0RnJhbWUgPSBmYWxzZSxcblx0XHQgICAgd2lsbFBydW5lID0gZmFsc2U7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICghdGlsZS5jdXJyZW50IHx8ICF0aWxlLmxvYWRlZCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIgZmFkZSA9IE1hdGgubWluKDEsIChub3cgLSB0aWxlLmxvYWRlZCkgLyAyMDApO1xuXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcblx0XHRcdGlmIChmYWRlIDwgMSkge1xuXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7IHdpbGxQcnVuZSA9IHRydWU7IH1cblx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cblx0XHRpZiAobmV4dEZyYW1lKSB7XG5cdFx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtbGF5ZXIgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfdXBkYXRlTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxuXHRcdCAgICBtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XG5cblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHRpZiAodGhpcy5fbGV2ZWxzW3pdLmVsLmNoaWxkcmVuLmxlbmd0aCB8fCB6ID09PSB6b29tKSB7XG5cdFx0XHRcdHRoaXMuX2xldmVsc1t6XS5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tIC0gTWF0aC5hYnMoem9vbSAtIHopO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cblx0XHRcdGxldmVsLmVsID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdGxldmVsLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb207XG5cblx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuXHRcdFx0bGV2ZWwuem9vbSA9IHpvb207XG5cblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSk7XG5cblx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG5cdFx0XHRMLlV0aWwuZmFsc2VGbihsZXZlbC5lbC5vZmZzZXRXaWR0aCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuXHRcdHJldHVybiBsZXZlbDtcblx0fSxcblxuXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGtleSwgdGlsZTtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG5cdFx0XHR6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ucmV0YWluKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdH1cblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXG5cdFx0dGhpcy5fdGlsZVpvb20gPSBudWxsO1xuXHR9LFxuXG5cdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG5cdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG5cdFx0ICAgIHoyID0geiAtIDEsXG5cdFx0ICAgIGNvb3JkczIgPSBuZXcgTC5Qb2ludCgreDIsICt5Mik7XG5cdFx0Y29vcmRzMi56ID0gK3oyO1xuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMyKSxcblx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoejIgPiBtaW5ab29tKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmV0YWluUGFyZW50KHgyLCB5MiwgejIsIG1pblpvb20pO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfcmV0YWluQ2hpbGRyZW46IGZ1bmN0aW9uICh4LCB5LCB6LCBtYXhab29tKSB7XG5cblx0XHRmb3IgKHZhciBpID0gMiAqIHg7IGkgPCAyICogeCArIDI7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDIgKiB5OyBqIDwgMiAqIHkgKyAyOyBqKyspIHtcblxuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IEwuUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cblx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpLFxuXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xuXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG5cdH0sXG5cblx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0dmFyIHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKTtcblx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcblx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG5cblx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG5cdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG5cdFx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG5cdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFub1BydW5lKSB7XG5cdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcblx0XHRcdC8vIGEgem9vbSBhbmltIG9yIGEgcGluY2ggZ2VzdHVyZVxuXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcblx0XHR9XG5cblx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtcyhjZW50ZXIsIHpvb20pO1xuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcblx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpXG5cdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG5cdFx0aWYgKEwuQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybShsZXZlbC5lbCwgdHJhbnNsYXRlLCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycyxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcyh0aGlzLl90aWxlWm9vbSk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHR9LFxuXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSBtYXAucHJvamVjdChjZW50ZXIsIHRoaXMuX3RpbGVab29tKS5mbG9vcigpLFxuXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuXHRcdHJldHVybiBuZXcgTC5Cb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcblx0fSxcblxuXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG5cdFx0aWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTsgfVxuXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG5cdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuXHRcdCAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcblx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcblx0XHQgICAgcXVldWUgPSBbXSxcblx0XHQgICAgbWFyZ2luID0gdGhpcy5vcHRpb25zLmtlZXBCdWZmZXIsXG5cdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBMLkJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3Jkcztcblx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMoTC5wb2ludChjLngsIGMueSkpKSB7XG5cdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcblx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG5cdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG5cdFx0Zm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IEwuUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG5cdFx0XHRcdGlmICh0aWxlKSB7XG5cdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cblx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG5cdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcblx0XHRyZXR1cm4gTC5sYXRMbmdCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcykub3ZlcmxhcHModGlsZUJvdW5kcyk7XG5cdH0sXG5cblx0X2tleVRvQm91bmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KSk7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBpdHMgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuXHRfdGlsZUNvb3Jkc1RvQm91bmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblxuXHRcdCAgICBud1BvaW50ID0gY29vcmRzLnNjYWxlQnkodGlsZVNpemUpLFxuXHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQodGlsZVNpemUpLFxuXG5cdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcblx0XHRcdG53ID0gbWFwLndyYXBMYXRMbmcobncpO1xuXHRcdFx0c2UgPSBtYXAud3JhcExhdExuZyhzZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhudywgc2UpO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8ga2V5IGZvciB0aGUgdGlsZSBjYWNoZVxuXHRfdGlsZUNvb3Jkc1RvS2V5OiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnkgKyAnOicgKyBjb29yZHMuejtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNhY2hlIGtleSB0byBjb29yZGluYXRlc1xuXHRfa2V5VG9UaWxlQ29vcmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGsgPSBrZXkuc3BsaXQoJzonKSxcblx0XHQgICAgY29vcmRzID0gbmV3IEwuUG9pbnQoK2tbMF0sICtrWzFdKTtcblx0XHRjb29yZHMueiA9ICtrWzJdO1xuXHRcdHJldHVybiBjb29yZHM7XG5cdH0sXG5cblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aWxlLmVsKTtcblxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuXHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUnKTtcblxuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHR0aWxlLnN0eWxlLndpZHRoID0gdGlsZVNpemUueCArICdweCc7XG5cdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSB0aWxlU2l6ZS55ICsgJ3B4JztcblxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IEwuVXRpbC5mYWxzZUZuO1xuXHRcdHRpbGUub25tb3VzZW1vdmUgPSBMLlV0aWwuZmFsc2VGbjtcblxuXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0aWYgKEwuQnJvd3Nlci5pZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblx0XHR9XG5cblx0XHQvLyB3aXRob3V0IHRoaXMgaGFjaywgdGlsZXMgZGlzYXBwZWFyIGFmdGVyIHpvb20gb24gQ2hyb21lIGZvciBBbmRyb2lkXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjA3OFxuXHRcdGlmIChMLkJyb3dzZXIuYW5kcm9pZCAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMykge1xuXHRcdFx0dGlsZS5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHR9XG5cdH0sXG5cblx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpLFxuXHRcdCAgICBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgTC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG5cblx0XHR0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuXHRcdC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG5cdFx0Ly8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuXHRcdGlmICh0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoIDwgMikge1xuXHRcdFx0Ly8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cblx0XHRcdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKEwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuXHRcdH1cblxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG5cdFx0XHRlbDogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzLFxuXHRcdFx0Y3VycmVudDogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG5cdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuXHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAoZXJyKSB7XG5cdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBsb2FkaW5nIGEgdGlsZS5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuXHRcdFx0XHRlcnJvcjogZXJyLFxuXHRcdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0dGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcblx0XHRpZiAodGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuXHRcdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHR9XG5cblx0XHRpZiAoIWVycikge1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRpbGUuZWwsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cblx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG5cdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG5cdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG5cdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cblx0XHRcdGlmIChMLkJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHRcdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBtb3JlIHRoYW4gMC4yIHNlY3MgKHRoZSBkdXJhdGlvbiBvZiB0aGUgdGlsZSBmYWRlLWluKVxuXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cblx0XHRcdFx0c2V0VGltZW91dChMLmJpbmQodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyksIDI1MCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRUaWxlUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy5zY2FsZUJ5KHRoaXMuZ2V0VGlsZVNpemUoKSkuc3VidHJhY3QodGhpcy5fbGV2ZWwub3JpZ2luKTtcblx0fSxcblxuXHRfd3JhcENvb3JkczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBuZXdDb29yZHMgPSBuZXcgTC5Qb2ludChcblx0XHRcdHRoaXMuX3dyYXBYID8gTC5VdGlsLndyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuXHRcdFx0dGhpcy5fd3JhcFkgPyBMLlV0aWwud3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcFkpIDogY29vcmRzLnkpO1xuXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG5cdFx0cmV0dXJuIG5ld0Nvb3Jkcztcblx0fSxcblxuXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHRyZXR1cm4gbmV3IEwuQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG5cdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuXHR9LFxuXG5cdF9ub1RpbGVzVG9Mb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG5MLmdyaWRMYXllciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5HcmlkTGF5ZXIob3B0aW9ucyk7XG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyXHJcbiAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllclxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgR3JpZExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30udGlsZS5vc20ub3JnL3t6fS97eH0ve3l9LnBuZz97Zm9vfScsIHtmb286ICdiYXInfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAnaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS9ibGFibGEve3p9L3t4fS97eX17cn0ucG5nJ1xyXG4gKiBgYGBcclxuICpcclxuICogYHtzfWAgbWVhbnMgb25lIG9mIHRoZSBhdmFpbGFibGUgc3ViZG9tYWlucyAodXNlZCBzZXF1ZW50aWFsbHkgdG8gaGVscCB3aXRoIGJyb3dzZXIgcGFyYWxsZWwgcmVxdWVzdHMgcGVyIGRvbWFpbiBsaW1pdGF0aW9uOyBzdWJkb21haW4gdmFsdWVzIGFyZSBzcGVjaWZpZWQgaW4gb3B0aW9uczsgYGFgLCBgYmAgb3IgYGNgIGJ5IGRlZmF1bHQsIGNhbiBiZSBvbWl0dGVkKSwgYHt6fWAg4oCUIHpvb20gbGV2ZWwsIGB7eH1gIGFuZCBge3l9YCDigJQgdGlsZSBjb29yZGluYXRlcy4gYHtyfWAgY2FuIGJlIHVzZWQgdG8gYWRkIEAyeCB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgXHJcbiAqIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL3tmb299L3t6fS97eH0ve3l9LnBuZycsIHtmb286ICdiYXInfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5MLlRpbGVMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxyXG5cdFx0Ly8gTWluaW11bSB6b29tIG51bWJlci5cclxuXHRcdG1pblpvb206IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlci5cclxuXHRcdG1heFpvb206IDE4LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4TmF0aXZlWm9vbTogTnVtYmVyID0gbnVsbFxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxyXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBoaWdoZXIgdGhhbiBgbWF4TmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcclxuXHRcdC8vIGZyb20gYG1heE5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cclxuXHRcdG1heE5hdGl2ZVpvb206IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG5cdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcblx0XHR0bXM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHRydWUsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byAnJy4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgTC5Ccm93c2VyLnJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG5cdFx0XHRvcHRpb25zLnRpbGVTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnRpbGVTaXplIC8gMik7XHJcblxyXG5cdFx0XHRpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuXHRcdFx0XHRvcHRpb25zLm1heFpvb20tLTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuXHRcdFx0XHRvcHRpb25zLm1pblpvb20rKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5taW5ab29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0b3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTM3XHJcblx0XHRpZiAoIUwuQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdHRoaXMub24oJ3RpbGV1bmxvYWQnLCB0aGlzLl9vblRpbGVSZW1vdmUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nLCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gVXBkYXRlcyB0aGUgbGF5ZXIncyBVUkwgdGVtcGxhdGUgYW5kIHJlZHJhd3MgaXQgKHVubGVzcyBgbm9SZWRyYXdgIGlzIHNldCB0byBgdHJ1ZWApLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgb3ZlcnJpZGVzIEdyaWRMYXllcidzIFtgY3JlYXRlVGlsZSgpYF0oI2dyaWRsYXllci1jcmVhdGV0aWxlKVxyXG5cdC8vIHRvIHJldHVybiBhbiBgPGltZz5gIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBhcHByb3BpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG5cdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XHJcblx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQub24odGlsZSwgJ2xvYWQnLCBMLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cdFx0TC5Eb21FdmVudC5vbih0aWxlLCAnZXJyb3InLCBMLmJpbmQodGhpcy5fdGlsZU9uRXJyb3IsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luKSB7XHJcblx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSAnJztcclxuXHRcdH1cclxuXHJcblx0XHQvKlxyXG5cdFx0IEFsdCB0YWcgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBrZWVwIHNjcmVlbiByZWFkZXJzIGZyb20gcmVhZGluZyBVUkwgYW5kIGZvciBjb21wbGlhbmNlIHJlYXNvbnNcclxuXHRcdCBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvSDY3XHJcblx0XHQqL1xyXG5cdFx0dGlsZS5hbHQgPSAnJztcclxuXHJcblx0XHR0aWxlLnNyYyA9IHRoaXMuZ2V0VGlsZVVybChjb29yZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcblx0Ly8gQHVuaW5oZXJpdGFibGVcclxuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIG1pZ2h0IHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxyXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVVybChjb29yZHM6IE9iamVjdCk6IFN0cmluZ1xyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGN1c3RvbSB0aWxlIFVSTCBuYW1pbmcgc2NoZW1lcy5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0cjogTC5Ccm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpLFxyXG5cdFx0XHR4OiBjb29yZHMueCxcclxuXHRcdFx0eTogY29vcmRzLnksXHJcblx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG5cdFx0fTtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG5cdFx0XHR2YXIgaW52ZXJ0ZWRZID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55IC0gY29vcmRzLnk7XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEwuVXRpbC50ZW1wbGF0ZSh0aGlzLl91cmwsIEwuZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG5cdFx0Ly8gRm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzMzMzJcclxuXHRcdGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuXHRcdFx0c2V0VGltZW91dChMLmJpbmQoZG9uZSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsKSB7XHJcblx0XHRcdHRpbGUuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0XHRkb25lKGUsIHRpbGUpO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIHRpbGVTaXplID0gTC5HcmlkTGF5ZXIucHJvdG90eXBlLmdldFRpbGVTaXplLmNhbGwodGhpcyksXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX3RpbGVab29tICsgdGhpcy5vcHRpb25zLnpvb21PZmZzZXQsXHJcblx0XHQgICAgem9vbU4gPSB0aGlzLm9wdGlvbnMubWF4TmF0aXZlWm9vbTtcclxuXHJcblx0XHQvLyBpbmNyZWFzZSB0aWxlIHNpemUgd2hlbiBvdmVyc2NhbGluZ1xyXG5cdFx0cmV0dXJuIHpvb21OICE9PSBudWxsICYmIHpvb20gPiB6b29tTiA/XHJcblx0XHRcdFx0dGlsZVNpemUuZGl2aWRlQnkobWFwLmdldFpvb21TY2FsZSh6b29tTiwgem9vbSkpLnJvdW5kKCkgOlxyXG5cdFx0XHRcdHRpbGVTaXplO1xyXG5cdH0sXHJcblxyXG5cdF9vblRpbGVSZW1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl90aWxlWm9vbTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHR6b29tID0gb3B0aW9ucy5tYXhab29tIC0gem9vbTtcclxuXHRcdH1cclxuXHJcblx0XHR6b29tICs9IG9wdGlvbnMuem9vbU9mZnNldDtcclxuXHJcblx0XHRyZXR1cm4gb3B0aW9ucy5tYXhOYXRpdmVab29tICE9PSBudWxsID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhOYXRpdmVab29tKSA6IHpvb207XHJcblx0fSxcclxuXHJcblx0X2dldFN1YmRvbWFpbjogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnNbaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcblx0X2Fib3J0TG9hZGluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksIHRpbGU7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2ldLmNvb3Jkcy56ICE9PSB0aGlzLl90aWxlWm9vbSkge1xyXG5cdFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXS5lbDtcclxuXHJcblx0XHRcdFx0dGlsZS5vbmxvYWQgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0aWYgKCF0aWxlLmNvbXBsZXRlKSB7XHJcblx0XHRcdFx0XHR0aWxlLnNyYyA9IEwuVXRpbC5lbXB0eUltYWdlVXJsO1xyXG5cdFx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aWxlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbkwudGlsZUxheWVyID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5UaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gKiBAaW5oZXJpdHMgVGlsZUxheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gKiBcdGZvcm1hdDogJ2ltYWdlL3BuZycsXHJcbiAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLlRpbGVMYXllci5XTVMgPSBMLlRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyLldNUyBvcHRpb25zXHJcblx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG5cdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcblx0Ly8gW25vbi1zdGFuZGFyZCB2ZW5kb3IgV01TIHBhcmFtZXRlcnNdKGh0dHA6Ly9kb2NzLmdlb3NlcnZlci5vcmcvc3RhYmxlL2VuL3VzZXIvc2VydmljZXMvd21zL3ZlbmRvci5odG1sKS5cclxuXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcblx0XHRzZXJ2aWNlOiAnV01TJyxcclxuXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gKioocmVxdWlyZWQpKiogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIGxheWVycyB0byBzaG93LlxyXG5cdFx0bGF5ZXJzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN0eWxlczogU3RyaW5nID0gJydcclxuXHRcdC8vIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBzdHlsZXMuXHJcblx0XHRzdHlsZXM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZm9ybWF0OiBTdHJpbmcgPSAnaW1hZ2UvanBlZydcclxuXHRcdC8vIFdNUyBpbWFnZSBmb3JtYXQgKHVzZSBgJ2ltYWdlL3BuZydgIGZvciBsYXllcnMgd2l0aCB0cmFuc3BhcmVuY3kpLlxyXG5cdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc3BhcmVudDogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBXTVMgc2VydmljZSB3aWxsIHJldHVybiBpbWFnZXMgd2l0aCB0cmFuc3BhcmVuY3kuXHJcblx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB2ZXJzaW9uOiBTdHJpbmcgPSAnMS4xLjEnXHJcblx0XHQvLyBWZXJzaW9uIG9mIHRoZSBXTVMgc2VydmljZSB0byB1c2VcclxuXHRcdHZlcnNpb246ICcxLjEuMSdcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gbnVsbFxyXG5cdFx0Ly8gQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIHRvIHVzZSBmb3IgdGhlIFdNUyByZXF1ZXN0cywgZGVmYXVsdHMgdG9cclxuXHRcdC8vIG1hcCBDUlMuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3Qgc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdXBwZXJjYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgV01TIHJlcXVlc3QgcGFyYW1ldGVyIGtleXMgd2lsbCBiZSB1cHBlcmNhc2UuXHJcblx0XHR1cHBlcmNhc2U6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHR2YXIgd21zUGFyYW1zID0gTC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XHJcblxyXG5cdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcclxuXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0XHRpZiAoIShpIGluIHRoaXMub3B0aW9ucykpIHtcclxuXHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0b3B0aW9ucyA9IEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR3bXNQYXJhbXMud2lkdGggPSB3bXNQYXJhbXMuaGVpZ2h0ID0gb3B0aW9ucy50aWxlU2l6ZSAqIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBMLkJyb3dzZXIucmV0aW5hID8gMiA6IDEpO1xyXG5cclxuXHRcdHRoaXMud21zUGFyYW1zID0gd21zUGFyYW1zO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG5cdFx0dGhpcy5fY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XHJcblx0XHR0aGlzLl93bXNWZXJzaW9uID0gcGFyc2VGbG9hdCh0aGlzLndtc1BhcmFtcy52ZXJzaW9uKTtcclxuXHJcblx0XHR2YXIgcHJvamVjdGlvbktleSA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zID8gJ2NycycgOiAnc3JzJztcclxuXHRcdHRoaXMud21zUGFyYW1zW3Byb2plY3Rpb25LZXldID0gdGhpcy5fY3JzLmNvZGU7XHJcblxyXG5cdFx0TC5UaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKSxcclxuXHRcdCAgICBudyA9IHRoaXMuX2Nycy5wcm9qZWN0KHRpbGVCb3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgIHNlID0gdGhpcy5fY3JzLnByb2plY3QodGlsZUJvdW5kcy5nZXRTb3V0aEVhc3QoKSksXHJcblxyXG5cdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBMLkNSUy5FUFNHNDMyNiA/XHJcblx0XHRcdCAgICBbc2UueSwgbncueCwgbncueSwgc2UueF0gOlxyXG5cdFx0XHQgICAgW253LngsIHNlLnksIHNlLngsIG53LnldKS5qb2luKCcsJyksXHJcblxyXG5cdFx0ICAgIHVybCA9IEwuVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdXJsICtcclxuXHRcdFx0TC5VdGlsLmdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRoaXMub3B0aW9ucy51cHBlcmNhc2UpICtcclxuXHRcdFx0KHRoaXMub3B0aW9ucy51cHBlcmNhc2UgPyAnJkJCT1g9JyA6ICcmYmJveD0nKSArIGJib3g7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBNZXJnZXMgYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBwYXJhbWV0ZXJzIGFuZCByZS1yZXF1ZXN0cyB0aWxlcyBvbiB0aGUgY3VycmVudCBzY3JlZW4gKHVubGVzcyBgbm9SZWRyYXdgIHdhcyBzZXQgdG8gdHJ1ZSkuXHJcblx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zLCBub1JlZHJhdykge1xyXG5cclxuXHRcdEwuZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgV01TIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYmFzZSBVUkwgb2YgdGhlIFdNUyBzZXJ2aWNlIGFuZCBhIFdNUyBwYXJhbWV0ZXJzL29wdGlvbnMgb2JqZWN0LlxyXG5MLnRpbGVMYXllci53bXMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLlRpbGVMYXllci5XTVModXJsLCBvcHRpb25zKTtcclxufTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgSW1hZ2VPdmVybGF5XHJcbiAqIEBha2EgTC5JbWFnZU92ZXJsYXlcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHNpbmdsZSBpbWFnZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBpbWFnZVVybCA9ICdodHRwOi8vd3d3LmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGcnLFxyXG4gKiBcdGltYWdlQm91bmRzID0gW1s0MC43MTIyMTYsIC03NC4yMjY1NV0sIFs0MC43NzM5NDEsIC03NC4xMjU0NF1dO1xyXG4gKiBMLmltYWdlT3ZlcmxheShpbWFnZVVybCwgaW1hZ2VCb3VuZHMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuSW1hZ2VPdmVybGF5ID0gTC5MYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgSW1hZ2VPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgaW1hZ2Ugb3ZlcmxheSB3aWxsIGVtaXQgW21vdXNlIGV2ZW50c10oI2ludGVyYWN0aXZlLWxheWVyKSB3aGVuIGNsaWNrZWQgb3IgaG92ZXJlZC5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF0dHJpYnV0aW9uOiBTdHJpbmcgPSBudWxsXHJcblx0XHQvLyBBbiBvcHRpb25hbCBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGBcclxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIGltYWdlIHdpbGwgaGF2ZSBpdHMgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byAnJy4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlT3B0cykge1xyXG5cdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcblx0XHRcdHRoaXMuc2V0T3BhY2l0eShzdHlsZU9wdHMub3BhY2l0eSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0TC5Eb21VdGlsLnRvRnJvbnQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRMLkRvbVV0aWwudG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dGhpcy5fYm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gTC5Eb21VdGlsLmNyZWF0ZSgnaW1nJyxcclxuXHRcdFx0XHQnbGVhZmxldC1pbWFnZS1sYXllciAnICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnIDogJycpKTtcclxuXHJcblx0XHRpbWcub25zZWxlY3RzdGFydCA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cdFx0aW1nLm9ubW91c2Vtb3ZlID0gTC5VdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0aW1nLm9ubG9hZCA9IEwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbikge1xyXG5cdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSAnJztcclxuXHRcdH1cclxuXHJcblx0XHRpbWcuc3JjID0gdGhpcy5fdXJsO1xyXG5cdFx0aW1nLmFsdCA9IHRoaXMub3B0aW9ucy5hbHQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZShlLnpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSwgZS56b29tLCBlLmNlbnRlcik7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuXHRcdCAgICBib3VuZHMgPSBuZXcgTC5Cb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oaW1hZ2UsIGJvdW5kcy5taW4pO1xyXG5cclxuXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRpbWFnZS5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbkwuaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcbn07XHJcblxuLypcclxuICogQGNsYXNzIEljb25cclxuICogQGFrYSBMLkljb25cclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBteUljb24gPSBMLmljb24oe1xyXG4gKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAqICAgICBpY29uU2l6ZTogWzM4LCA5NV0sXHJcbiAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAqICAgICBzaGFkb3dVcmw6ICdteS1pY29uLXNoYWRvdy5wbmcnLFxyXG4gKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gKiAgICAgc2hhZG93QW5jaG9yOiBbMjIsIDk0XVxyXG4gKiB9KTtcclxuICpcclxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIGBMLkljb24uRGVmYXVsdGAgZXh0ZW5kcyBgTC5JY29uYCBhbmQgaXMgdGhlIGJsdWUgaWNvbiBMZWFmbGV0IHVzZXMgZm9yIG1hcmtlcnMgYnkgZGVmYXVsdC5cclxuICpcclxuICovXHJcblxyXG5MLkljb24gPSBMLkNsYXNzLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcblx0ICogc2NyaXB0IHBhdGgpLiBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBpY29uIGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBpY29uIChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKS4gVGhlIGljb25cclxuXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcblx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93VXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1JldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBzaGFkb3cgaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgc2hhZG93IChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKSAodGhlIHNhbWVcclxuXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlSWNvbihvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gdGhlIGljb24gaGFzIHRvIGJlIHNob3duLCByZXR1cm5zIGEgYDxpbWc+YCBIVE1MIGVsZW1lbnRcclxuXHQvLyBzdHlsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zLlxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignaWNvbicsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlU2hhZG93KG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQXMgYGNyZWF0ZUljb25gLCBidXQgZm9yIHRoZSBzaGFkb3cgYmVuZWF0aCBpdC5cclxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcblx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcblx0XHRpZiAoIXNyYykge1xyXG5cdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbWcgPSB0aGlzLl9jcmVhdGVJbWcoc3JjLCBvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0lNRycgPyBvbGRJY29uIDogbnVsbCk7XHJcblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG5cdFx0cmV0dXJuIGltZztcclxuXHR9LFxyXG5cclxuXHRfc2V0SWNvblN0eWxlczogZnVuY3Rpb24gKGltZywgbmFtZSkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0XHR2YXIgc2l6ZU9wdGlvbiA9IG9wdGlvbnNbbmFtZSArICdTaXplJ107XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBzaXplT3B0aW9uID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaXplID0gTC5wb2ludChzaXplT3B0aW9uKSxcclxuXHRcdCAgICBhbmNob3IgPSBMLnBvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG5cdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gTC5Ccm93c2VyLnJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuaWNvbihvcHRpb25zOiBJY29uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG5MLmljb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5JY29uKG9wdGlvbnMpO1xyXG59O1xyXG5cbi8qXG4gKiBAbWluaWNsYXNzIEljb24uRGVmYXVsdCAoSWNvbilcbiAqIEBha2EgTC5JY29uLkRlZmF1bHRcbiAqIEBzZWN0aW9uXG4gKlxuICogQSB0cml2aWFsIHN1YmNsYXNzIG9mIGBJY29uYCwgcmVwcmVzZW50cyB0aGUgaWNvbiB0byB1c2UgaW4gYE1hcmtlcmBzIHdoZW5cbiAqIG5vIGljb24gaXMgc3BlY2lmaWVkLiBQb2ludHMgdG8gdGhlIGJsdWUgbWFya2VyIGltYWdlIGRpc3RyaWJ1dGVkIHdpdGggTGVhZmxldFxuICogcmVsZWFzZXMuXG4gKlxuICogSW4gb3JkZXIgdG8gY2hhbmdlIHRoZSBkZWZhdWx0IGljb24sIGp1c3QgY2hhbmdlIHRoZSBwcm9wZXJ0aWVzIG9mIGBMLkljb24uRGVmYXVsdC5wcm90b3R5cGUub3B0aW9uc2BcbiAqICh3aGljaCBpcyBhIHNldCBvZiBgSWNvbiBvcHRpb25zYCkuXG4gKi9cblxuTC5JY29uLkRlZmF1bHQgPSBMLkljb24uZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0aWNvblVybDogICAgICAgJ21hcmtlci1pY29uLnBuZycsXG5cdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG5cdFx0c2hhZG93VXJsOiAgICAgJ21hcmtlci1zaGFkb3cucG5nJyxcblx0XHRpY29uU2l6ZTogICAgWzI1LCA0MV0sXG5cdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuXHRcdHBvcHVwQW5jaG9yOiBbMSwgLTM0XSxcblx0XHR0b29sdGlwQW5jaG9yOiBbMTYsIC0yOF0sXG5cdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG5cdH0sXG5cblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKCFMLkljb24uRGVmYXVsdC5pbWFnZVBhdGgpIHtcdC8vIERlcHJlY2F0ZWQsIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IG9ubHlcblx0XHRcdEwuSWNvbi5EZWZhdWx0LmltYWdlUGF0aCA9IHRoaXMuX2RldGVjdEljb25QYXRoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQG9wdGlvbiBpbWFnZVBhdGg6IFN0cmluZ1xuXHRcdC8vIGBMLkljb24uRGVmYXVsdGAgd2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGFic29sdXRlIGxvY2F0aW9uIG9mIHRoZVxuXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcblx0XHQvLyB3YXksIHNldCB0aGlzIG9wdGlvbiB0byBwb2ludCB0byB0aGUgcmlnaHQgYWJzb2x1dGUgcGF0aC5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoKSArIEwuSWNvbi5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLCBuYW1lKTtcblx0fSxcblxuXHRfZGV0ZWN0SWNvblBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAgJ2xlYWZsZXQtZGVmYXVsdC1pY29uLXBhdGgnLCBkb2N1bWVudC5ib2R5KTtcblx0XHR2YXIgcGF0aCA9IEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fFxuXHRcdCAgICAgICAgICAgTC5Eb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXG5cdFx0cmV0dXJuIHBhdGguaW5kZXhPZigndXJsJykgPT09IDAgP1xuXHRcdFx0cGF0aC5yZXBsYWNlKC9edXJsXFwoW1xcXCJcXCddPy8sICcnKS5yZXBsYWNlKC9tYXJrZXItaWNvblxcLnBuZ1tcXFwiXFwnXT9cXCkkLywgJycpIDogJyc7XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBAY2xhc3MgTWFya2VyXHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKiBAYWthIEwuTWFya2VyXHJcbiAqIEwuTWFya2VyIGlzIHVzZWQgdG8gZGlzcGxheSBjbGlja2FibGUvZHJhZ2dhYmxlIGljb25zIG9uIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5tYXJrZXIoWzUwLjUsIDMwLjVdKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLk1hcmtlciA9IEwuTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBpY29uOiBJY29uID0gKlxyXG5cdFx0Ly8gSWNvbiBjbGFzcyB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLiBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uIElmIG5vdCBzcGVjaWZpZWQsIGEgbmV3IGBMLkljb24uRGVmYXVsdGAgaXMgdXNlZC5cclxuXHRcdGljb246IG5ldyBMLkljb24uRGVmYXVsdCgpLFxyXG5cclxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcclxuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgY2FuIGJlIHRhYmJlZCB0byB3aXRoIGEga2V5Ym9hcmQgYW5kIGNsaWNrZWQgYnkgcHJlc3NpbmcgZW50ZXIuXHJcblx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRpdGxlOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGJyb3dzZXIgdG9vbHRpcCB0aGF0IGFwcGVhciBvbiBtYXJrZXIgaG92ZXIgKG5vIHRvb2x0aXAgYnkgZGVmYXVsdCkuXHJcblx0XHR0aXRsZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpY29uIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG5cdFx0YWx0OiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleE9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcblx0XHR6SW5kZXhPZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9uSG92ZXI6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcblx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT2Zmc2V0OiBOdW1iZXIgPSAyNTBcclxuXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG5cdFx0cmlzZU9mZnNldDogMjUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ21hcmtlclBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdtYXJrZXJQYW5lJyxcclxuXHJcblx0XHQvLyBGSVhNRTogc2hhZG93UGFuZSBpcyBubyBsb25nZXIgYSB2YWxpZCBvcHRpb25cclxuXHRcdG5vbkJ1YmJsaW5nRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddXHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKlxyXG5cdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5fem9vbUFuaW1hdGVkICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5kcmFnZ2luZy5yZW1vdmVIb29rcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR6b29tOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXggb2Zmc2V0XSgjbWFya2VyLXppbmRleG9mZnNldCkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRzZXRJY29uOiBmdW5jdGlvbiAoaWNvbikge1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcclxuXHJcblx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG5cdFx0ICAgIGFkZEljb24gPSBmYWxzZTtcclxuXHJcblx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcblx0XHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFkZEljb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAob3B0aW9ucy5hbHQpIHtcclxuXHRcdFx0XHRpY29uLmFsdCA9IG9wdGlvbnMuYWx0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcblx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKG5ld1NoYWRvdywgY2xhc3NUb0FkZCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZSgnc2hhZG93UGFuZScpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2ljb24pO1xyXG5cdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3pJbmRleCA9IHBvcy55ICsgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldDtcclxuXHJcblx0XHR0aGlzLl9yZXNldFpJbmRleCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHRoaXMuX2ljb24uc3R5bGUuekluZGV4ID0gdGhpcy5fekluZGV4ICsgb2Zmc2V0O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKG9wdCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpLnJvdW5kKCk7XHJcblxyXG5cdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbnRlcmFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0aWYgKEwuSGFuZGxlci5NYXJrZXJEcmFnKSB7XHJcblx0XHRcdHZhciBkcmFnZ2FibGUgPSB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlO1xyXG5cdFx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xyXG5cdFx0XHRcdGRyYWdnYWJsZSA9IHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpO1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IEwuSGFuZGxlci5NYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5faWNvbiwgb3BhY2l0eSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0WkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIE1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcbkwubWFya2VyID0gZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5NYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxufTtcclxuXG4vKlxuICogQGNsYXNzIERpdkljb25cbiAqIEBha2EgTC5EaXZJY29uXG4gKiBAaW5oZXJpdHMgSWNvblxuICpcbiAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICpcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gKi9cblxuTC5EaXZJY29uID0gTC5JY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG5cdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG5cdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cblx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC5cblx0XHRodG1sOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuXHRcdGJnUG9zOiBudWxsLFxuXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG5cblx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuXHRcdFx0dmFyIGJnUG9zID0gTC5wb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbkwuZGl2SWNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5EaXZJY29uKG9wdGlvbnMpO1xufTtcblxuLypcclxuICogQGNsYXNzIERpdk92ZXJsYXlcclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqIEBha2EgTC5EaXZPdmVybGF5XHJcbiAqIEJhc2UgbW9kZWwgZm9yIEwuUG9wdXAgYW5kIEwuVG9vbHRpcC4gSW5oZXJpdCBmcm9tIGl0IGZvciBjdXN0b20gcG9wdXAgbGlrZSBwbHVnaW5zLlxyXG4gKi9cclxuXHJcbi8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG5MLkRpdk92ZXJsYXkgPSBMLkxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBEaXZPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uIFVzZWZ1bCB0byBjb250cm9sIHRoZSBhbmNob3JcclxuXHRcdC8vIG9mIHRoZSBwb3B1cCB3aGVuIG9wZW5pbmcgaXQgb24gc29tZSBvdmVybGF5cy5cclxuXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAncG9wdXBQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdwb3B1cFBhbmUnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZW1vdmVUaW1lb3V0KTtcclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChMLmJpbmQoTC5Eb21VdGlsLnJlbW92ZSwgTC5Eb21VdGlsLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IG9mIHBvcHVwLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgd2hlcmUgdGhlIHBvcHVwIHdpbGwgb3Blbi5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cC5cclxuXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldENvbnRlbnQoaHRtbENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIHBvcHVwLiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc291cmNlIGxheWVyIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIHBvcHVwLlxyXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHR0aGlzLl9jb250ZW50ID0gY29udGVudDtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIEFsaWFzIGZvciBbZ2V0Q29udGVudCgpXSgjcG9wdXAtZ2V0Y29udGVudClcclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdXBkYXRlOiBudWxsXHJcblx0Ly8gVXBkYXRlcyB0aGUgcG9wdXAgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgcG9wdXAgYWZ0ZXIgc29tZXRoaW5nIGluc2lkZSBjaGFuZ2VkLCBlLmcuIGltYWdlIGxvYWRlZC5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlQ29udGVudCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlTGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XHJcblxyXG5cdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl91cGRhdGVQb3NpdGlvbixcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl91cGRhdGVQb3NpdGlvblxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzT3BlbjogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIHdoZW4gdGhlIHBvcHVwIGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuXHRpc09wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhIXRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCBpbiBmcm9udCBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0TC5Eb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCB0byB0aGUgYmFjayBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRMLkRvbVV0aWwudG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlQ29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XHJcblx0XHR2YXIgY29udGVudCA9ICh0eXBlb2YgdGhpcy5fY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLl9jb250ZW50KHRoaXMuX3NvdXJjZSB8fCB0aGlzKSA6IHRoaXMuX2NvbnRlbnQ7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuXHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdCAgICBvZmZzZXQgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9mZnNldCA9IG9mZnNldC5hZGQocG9zKS5hZGQoYW5jaG9yKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYm90dG9tID0gdGhpcy5fY29udGFpbmVyQm90dG9tID0gLW9mZnNldC55LFxyXG5cdFx0ICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54O1xyXG5cclxuXHRcdC8vIGJvdHRvbSBwb3NpdGlvbiB0aGUgcG9wdXAgaW4gY2FzZSB0aGUgaGVpZ2h0IG9mIHRoZSBwb3B1cCBjaGFuZ2VzIChpbWFnZXMgbG9hZGluZyBldGMpXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuYm90dG9tID0gYm90dG9tICsgJ3B4JztcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XHJcblx0fSxcclxuXHJcblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIFswLCAwXTtcclxuXHR9XHJcblxyXG59KTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgUG9wdXBcclxuICogQGluaGVyaXRzIERpdk92ZXJsYXlcclxuICogQGFrYSBMLlBvcHVwXHJcbiAqIFVzZWQgdG8gb3BlbiBwb3B1cHMgaW4gY2VydGFpbiBwbGFjZXMgb2YgdGhlIG1hcC4gVXNlIFtNYXAub3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgdG9cclxuICogb3BlbiBwb3B1cHMgd2hpbGUgbWFraW5nIHN1cmUgdGhhdCBvbmx5IG9uZSBwb3B1cCBpcyBvcGVuIGF0IG9uZSB0aW1lXHJcbiAqIChyZWNvbW1lbmRlZCBmb3IgdXNhYmlsaXR5KSwgb3IgdXNlIFtNYXAuYWRkTGF5ZXJdKCNtYXAtYWRkbGF5ZXIpIHRvIG9wZW4gYXMgbWFueSBhcyB5b3Ugd2FudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogSWYgeW91IHdhbnQgdG8ganVzdCBiaW5kIGEgcG9wdXAgdG8gbWFya2VyIGNsaWNrIGFuZCB0aGVuIG9wZW4gaXQsIGl0J3MgcmVhbGx5IGVhc3k6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcmtlci5iaW5kUG9wdXAocG9wdXBDb250ZW50KS5vcGVuUG9wdXAoKTtcclxuICogYGBgXHJcbiAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRQb3B1cGAgbWV0aG9kLlxyXG4gKiBIZXJlJ3MgYSBtb3JlIGNvbXBsaWNhdGVkIHdheSB0byBvcGVuIGEgcG9wdXAgb24gYSBtYXA6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb3B1cCA9IEwucG9wdXAoKVxyXG4gKiBcdC5zZXRMYXRMbmcobGF0bG5nKVxyXG4gKiBcdC5zZXRDb250ZW50KCc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICogXHQub3Blbk9uKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbkwuUG9wdXAgPSBMLkRpdk92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFBvcHVwIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAzMDBcclxuXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1heFdpZHRoOiAzMDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5XaWR0aDogTnVtYmVyID0gNTBcclxuXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1pbldpZHRoOiA1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEhlaWdodDogTnVtYmVyID0gbnVsbFxyXG5cdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG5cdFx0Ly8gaW5zaWRlIGEgcG9wdXAgaWYgaXRzIGNvbnRlbnQgZXhjZWVkcyBpdC5cclxuXHRcdG1heEhlaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uXHJcblx0XHQvLyB0byBmaXQgdGhlIG9wZW5lZCBwb3B1cC5cclxuXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG5cdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxyXG5cdFx0Ly8gb2ZmIG9mIHRoZSBzY3JlZW4gd2hpbGUgaXQgaXMgb3Blbi5cclxuXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VCdXR0b246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvQ2xvc2U6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwIChzZXQgZ2xvYmFsbHkgYnlcclxuXHRcdC8vIHRoZSBNYXAncyBbY2xvc2VQb3B1cE9uQ2xpY2tdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbikuXHJcblx0XHRhdXRvQ2xvc2U6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBwb3B1cCB0byB0aGUgbWFwIGFuZCBjbG9zZXMgdGhlIHByZXZpb3VzIG9uZS4gVGhlIHNhbWUgYXMgYG1hcC5vcGVuUG9wdXAocG9wdXApYC5cclxuXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vcGVuUG9wdXAodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0TC5EaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGlzIG9wZW5lZCBpbiB0aGUgbWFwXHJcblx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdC8vIEZvciBub24tcGF0aCBsYXllcnMsIHdlIHRvZ2dsZSB0aGUgcG9wdXAgd2hlbiBjbGlja2luZ1xyXG5cdFx0XHQvLyBhZ2FpbiB0aGUgbGF5ZXIsIHNvIHByZXZlbnQgdGhlIG1hcCB0byByZW9wZW4gaXQuXHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIEwuUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdEwuRGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgTC5QYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0gTC5EaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHJcblx0XHRpZiAoJ2Nsb3NlT25DbGljaycgaW4gdGhpcy5vcHRpb25zID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG5cdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLFxyXG5cdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG5cdFx0XHQnIGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgcHJlZml4ICsgJy1jbG9zZS1idXR0b24nLCBjb250YWluZXIpO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICcmIzIxNTsnO1xyXG5cclxuXHRcdFx0TC5Eb21FdmVudC5vbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQtd3JhcHBlcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHdyYXBwZXIpXHJcblx0XHRcdC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGVudE5vZGUpXHJcblx0XHRcdC5vbih3cmFwcGVyLCAnY29udGV4dG1lbnUnLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG5cdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAtY29udGFpbmVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX3RpcCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcblx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAnJztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcblx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcblx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcblx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG5cdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG5cdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbiB8fCAodGhpcy5fbWFwLl9wYW5BbmltICYmIHRoaXMuX21hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChMLkRvbVV0aWwuZ2V0U3R5bGUodGhpcy5fY29udGFpbmVyLCAnbWFyZ2luQm90dG9tJyksIDEwKSB8fCAwLFxyXG5cdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcblx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuXHRcdCAgICBsYXllclBvcyA9IG5ldyBMLlBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGxheWVyUG9zLl9hZGQoTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG5cdFx0ICAgIHBhZGRpbmcgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ1RMID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IEwucG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXHJcblx0XHQgICAgZHggPSAwLFxyXG5cdFx0ICAgIGR5ID0gMDtcclxuXHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHsgLy8gbGVmdFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgKyBwYWRkaW5nQlIueSA+IHNpemUueSkgeyAvLyBib3R0b21cclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYXV0b3BhbnN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBhdXRvcGFubmluZyB3aGVuIG9wZW5pbmcgYSBwb3B1cC5cclxuXHRcdGlmIChkeCB8fCBkeSkge1xyXG5cdFx0XHRtYXBcclxuXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG5cdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25DbG9zZUJ1dHRvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fY2xvc2UoKTtcclxuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIEwucG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbkwucG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBMLlBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbn07XHJcblxyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gKiBAb3B0aW9uIGNsb3NlUG9wdXBPbkNsaWNrOiBCb29sZWFuID0gdHJ1ZVxyXG4gKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gKi9cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRjbG9zZVBvcHVwT25DbGljazogdHJ1ZVxyXG59KTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbkwuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdGlmICghKHBvcHVwIGluc3RhbmNlb2YgTC5Qb3B1cCkpIHtcclxuXHRcdFx0cG9wdXAgPSBuZXcgTC5Qb3B1cChvcHRpb25zKS5zZXRDb250ZW50KHBvcHVwKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGF0bG5nKSB7XHJcblx0XHRcdHBvcHVwLnNldExhdExuZyhsYXRsbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKHBvcHVwKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fcG9wdXAub3B0aW9ucy5hdXRvQ2xvc2UpIHtcclxuXHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcG9wdXAgPSBwb3B1cDtcclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKHBvcHVwKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAocG9wdXA/OiBQb3B1cCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgb3BlbmVkIHdpdGggW29wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIChvciB0aGUgZ2l2ZW4gb25lKS5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAocG9wdXApIHtcclxuXHRcdGlmICghcG9wdXAgfHwgcG9wdXAgPT09IHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHBvcHVwID0gdGhpcy5fcG9wdXA7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdGlmIChwb3B1cCkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHBvcHVwKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHMgZXhhbXBsZVxuICpcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Qb3B1cCgpO1xuICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xuICogYGBgXG4gKlxuICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXG4gKi9cblxuLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xuTC5MYXllci5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGJpbmRQb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258UG9wdXAsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xuXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgTC5Qb3B1cCkge1xuXHRcdFx0TC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xuXHRcdFx0Y29udGVudC5fc291cmNlID0gdGhpcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3BvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XG5cdFx0XHR0aGlzLm9uKHtcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXG5cdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XG5cdFx0XHR0aGlzLm9mZih7XG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpY2VkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHBvcHVwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxheWVyLCBsYXRsbmcpIHtcblx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXIpKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcblx0XHRcdGxheWVyID0gdGhpcztcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkZlYXR1cmVHcm91cCkge1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFsYXRsbmcpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlciA/IGxheWVyLmdldENlbnRlcigpIDogbGF5ZXIuZ2V0TGF0TG5nKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX21hcCkge1xuXHRcdFx0Ly8gc2V0IHBvcHVwIHNvdXJjZSB0byB0aGlzIGxheWVyXG5cdFx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gbGF5ZXI7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgcG9wdXAgKGNvbnRlbnQsIGxheW91dCwgZWN0Li4uKVxuXHRcdFx0dGhpcy5fcG9wdXAudXBkYXRlKCk7XG5cblx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX21hcC5vcGVuUG9wdXAodGhpcy5fcG9wdXAsIGxhdGxuZyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdHRoaXMuX3BvcHVwLl9jbG9zZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdGlmICh0aGlzLl9wb3B1cC5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vcGVuUG9wdXAodGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1BvcHVwT3BlbigpOiBib29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb3B1cC5pc09wZW4oKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFBvcHVwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8UG9wdXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcblx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XG5cdH0sXG5cblx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0aWYgKCF0aGlzLl9wb3B1cCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gcHJldmVudCBtYXAgY2xpY2tcblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XG5cblx0XHQvLyBpZiB0aGlzIGluaGVyaXRzIGZyb20gUGF0aCBpdHMgYSB2ZWN0b3IgYW5kIHdlIGNhbiBqdXN0XG5cdFx0Ly8gb3BlbiB0aGUgcG9wdXAgYXQgdGhlIG5ldyBsb2NhdGlvblxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuUGF0aCkge1xuXHRcdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXllciB8fCBlLnRhcmdldCwgZS5sYXRsbmcpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIG90aGVyd2lzZSB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XG5cdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxuXHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApICYmIHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IGxheWVyKSB7XG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vcGVuUG9wdXAobGF5ZXIsIGUubGF0bG5nKTtcblx0XHR9XG5cdH0sXG5cblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xuXHR9XG59KTtcblxuLypcclxuICogUG9wdXAgZXh0ZW5zaW9uIHRvIEwuTWFya2VyLCBhZGRpbmcgcG9wdXAtcmVsYXRlZCBtZXRob2RzLlxyXG4gKi9cclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoe1xyXG5cdF9nZXRQb3B1cEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMucG9wdXBBbmNob3IgfHwgWzAsIDBdO1xyXG5cdH1cclxufSk7XHJcblxuLypcbiAqIEBjbGFzcyBUb29sdGlwXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxuICogQGFrYSBMLlRvb2x0aXBcbiAqIFVzZWQgdG8gZGlzcGxheSBzbWFsbCB0ZXh0cyBvbiB0b3Agb2YgbWFwIGxheWVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAqIGBgYFxuICogTm90ZSBhYm91dCB0b29sdGlwIG9mZnNldC4gTGVhZmxldCB0YWtlcyB0d28gb3B0aW9ucyBpbiBjb25zaWRlcmF0aW9uXG4gKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0aW5nOlxuICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICovXG5cblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG5MLlRvb2x0aXAgPSBMLkRpdk92ZXJsYXkuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndG9vbHRpcFBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0b29sdGlwUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxuXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cblx0XHRvZmZzZXQ6IFswLCAwXSxcblxuXHRcdC8vIEBvcHRpb24gZGlyZWN0aW9uOiBTdHJpbmcgPSAnYXV0bydcblx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuXHRcdC8vIGB0b3BgLCBgYm90dG9tYCwgYGNlbnRlcmAsIGBhdXRvYC5cblx0XHQvLyBgYXV0b2Agd2lsbCBkeW5hbWljYWx5IHN3aXRjaCBiZXR3ZWVuIGByaWdodGAgYW5kIGBsZWZ0YCBhY2NvcmRpbmcgdG8gdGhlIHRvb2x0aXBcblx0XHQvLyBwb3NpdGlvbiBvbiB0aGUgbWFwLlxuXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxuXG5cdFx0Ly8gQG9wdGlvbiBwZXJtYW5lbnQ6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdG8gb3BlbiB0aGUgdG9vbHRpcCBwZXJtYW5lbnRseSBvciBvbmx5IG9uIG1vdXNlb3Zlci5cblx0XHRwZXJtYW5lbnQ6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBzdGlja3k6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgZm9sbG93IHRoZSBtb3VzZSBpbnN0ZWFkIG9mIGJlaW5nIGZpeGVkIGF0IHRoZSBmZWF0dXJlIGNlbnRlci5cblx0XHRzdGlja3k6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIGZlYXR1cmUgZXZlbnRzLlxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG5cdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cblx0XHRvcGFjaXR5OiAwLjlcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdEwuRGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXHRcdHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpcyBvcGVuZWQgaW4gdGhlIG1hcC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0TC5EaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaW4gdGhlIG1hcCBpcyBjbG9zZWQuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gTC5EaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuXHRcdGlmIChMLkJyb3dzZXIudG91Y2ggJiYgIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fbWFwLmNsb3NlVG9vbHRpcCh0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG5cdFx0ICAgIGNsYXNzTmFtZSA9IHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XG5cblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XG5cdH0sXG5cblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge30sXG5cblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge30sXG5cblx0X3NldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBjZW50ZXJQb2ludCA9IG1hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KG1hcC5nZXRDZW50ZXIoKSksXG5cdFx0ICAgIHRvb2x0aXBQb2ludCA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChwb3MpLFxuXHRcdCAgICBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLFxuXHRcdCAgICB0b29sdGlwV2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGgsXG5cdFx0ICAgIHRvb2x0aXBIZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuXHRcdCAgICBvZmZzZXQgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcblxuXHRcdGlmIChkaXJlY3Rpb24gPT09ICd0b3AnKSB7XG5cdFx0XHRwb3MgPSBwb3MuYWRkKEwucG9pbnQoLXRvb2x0aXBXaWR0aCAvIDIgKyBvZmZzZXQueCwgLXRvb2x0aXBIZWlnaHQgKyBvZmZzZXQueSArIGFuY2hvci55KSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QoTC5wb2ludCh0b29sdGlwV2lkdGggLyAyIC0gb2Zmc2V0LngsIC1vZmZzZXQueSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2VudGVyJykge1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KEwucG9pbnQodG9vbHRpcFdpZHRoIC8gMiArIG9mZnNldC54LCB0b29sdGlwSGVpZ2h0IC8gMiAtIGFuY2hvci55ICsgb2Zmc2V0LnkpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyB8fCBkaXJlY3Rpb24gPT09ICdhdXRvJyAmJiB0b29sdGlwUG9pbnQueCA8IGNlbnRlclBvaW50LngpIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdyaWdodCc7XG5cdFx0XHRwb3MgPSBwb3MuYWRkKFtvZmZzZXQueCArIGFuY2hvci54LCBhbmNob3IueSAtIHRvb2x0aXBIZWlnaHQgLyAyICsgb2Zmc2V0LnldKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KEwucG9pbnQodG9vbHRpcFdpZHRoICsgYW5jaG9yLnggLSBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSAtIG9mZnNldC55KSk7XG5cdFx0fVxuXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtbGVmdCcpO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLScgKyBkaXJlY3Rpb24pO1xuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCBvcGFjaXR5KTtcblx0XHR9XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cblx0XHRyZXR1cm4gTC5wb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yICYmICF0aGlzLm9wdGlvbnMuc3RpY2t5ID8gdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yKCkgOiBbMCwgMF0pO1xuXHR9XG5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbi8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbi8vIEluc3RhbnRpYXRlcyBhIFRvb2x0aXAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgdG9vbHRpcCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG5MLnRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdHJldHVybiBuZXcgTC5Ub29sdGlwKG9wdGlvbnMsIHNvdXJjZSk7XG59O1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuTC5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuXHRcdGlmICghKHRvb2x0aXAgaW5zdGFuY2VvZiBMLlRvb2x0aXApKSB7XG5cdFx0XHR0b29sdGlwID0gbmV3IEwuVG9vbHRpcChvcHRpb25zKS5zZXRDb250ZW50KHRvb2x0aXApO1xuXHRcdH1cblxuXHRcdGlmIChsYXRsbmcpIHtcblx0XHRcdHRvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIodG9vbHRpcCkpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKHRvb2x0aXApO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKHRvb2x0aXA/OiBUb29sdGlwKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgZ2l2ZW4gYXMgcGFyYW1ldGVyLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG5cdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIodG9vbHRpcCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn0pO1xuXG4vKlxuICogQG5hbWVzcGFjZSBMYXllclxuICogQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzIGV4YW1wbGVcbiAqXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICogbGF5ZXIub3BlblRvb2x0aXAoKTtcbiAqIGxheWVyLmNsb3NlVG9vbHRpcCgpO1xuICogYGBgXG4gKi9cblxuLy8gQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzXG5MLkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcblx0Ly8gbmVjY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuXHRiaW5kVG9vbHRpcDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgTC5Ub29sdGlwKSB7XG5cdFx0XHRMLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gY29udGVudDtcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBMLnRvb2x0aXAob3B0aW9ucywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQgJiYgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKSkge1xuXHRcdFx0dGhpcy5vcGVuVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIHRvb2x0aXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kVG9vbHRpcGAuXG5cdHVuYmluZFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnModHJ1ZSk7XG5cdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9pbml0VG9vbHRpcEludGVyYWN0aW9uczogZnVuY3Rpb24gKHJlbW92ZSkge1xuXHRcdGlmICghcmVtb3ZlICYmIHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkKSB7IHJldHVybjsgfVxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJyxcblx0XHQgICAgZXZlbnRzID0ge1xuXHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlVG9vbHRpcCxcblx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG5cdFx0ICAgIH07XG5cdFx0aWYgKCF0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMubW91c2VvdmVyID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHRldmVudHMubW91c2VvdXQgPSB0aGlzLmNsb3NlVG9vbHRpcDtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5KSB7XG5cdFx0XHRcdGV2ZW50cy5tb3VzZW1vdmUgPSB0aGlzLl9tb3ZlVG9vbHRpcDtcblx0XHRcdH1cblx0XHRcdGlmIChMLkJyb3dzZXIudG91Y2gpIHtcblx0XHRcdFx0ZXZlbnRzLmNsaWNrID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHR9XG5cdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcblx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpY2VkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XG5cdFx0aWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyKSkge1xuXHRcdFx0bGF0bG5nID0gbGF5ZXI7XG5cdFx0XHRsYXllciA9IHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5GZWF0dXJlR3JvdXApIHtcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghbGF0bG5nKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllci5nZXRDZW50ZXIgPyBsYXllci5nZXRDZW50ZXIoKSA6IGxheWVyLmdldExhdExuZygpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuX21hcCkge1xuXG5cdFx0XHQvLyBzZXQgdG9vbHRpcCBzb3VyY2UgdG8gdGhpcyBsYXllclxuXHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gbGF5ZXI7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgdG9vbHRpcCAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZSgpO1xuXG5cdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX21hcC5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLCBsYXRsbmcpO1xuXG5cdFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBtYXkgbm90IGJlIGRlZmluZWQgaWYgbm90IHBlcm1hbmVudCBhbmQgbmV2ZXJcblx0XHRcdC8vIG9wZW5lZC5cblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5fY2xvc2UoKTtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdG9nZ2xlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cblx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNUb29sdGlwT3BlbigpOiBib29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG5cdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5pc09wZW4oKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFRvb2x0aXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxUb29sdGlwKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdHNldFRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0VG9vbHRpcCgpOiBUb29sdGlwXG5cdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0Z2V0VG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuXHR9LFxuXG5cdF9vcGVuVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8ICF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5vcGVuVG9vbHRpcChsYXllciwgdGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSA/IGUubGF0bG5nIDogdW5kZWZpbmVkKTtcblx0fSxcblxuXHRfbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nLCBjb250YWluZXJQb2ludCwgbGF5ZXJQb2ludDtcblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSAmJiBlLm9yaWdpbmFsRXZlbnQpIHtcblx0XHRcdGNvbnRhaW5lclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG5cdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KTtcblx0XHRcdGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XG5cdFx0fVxuXHRcdHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBUb29sdGlwIGV4dGVuc2lvbiB0byBMLk1hcmtlciwgYWRkaW5nIHRvb2x0aXAtcmVsYXRlZCBtZXRob2RzLlxyXG4gKi9cclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoe1xyXG5cdF9nZXRUb29sdGlwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yIHx8IFswLCAwXTtcclxuXHR9XHJcbn0pO1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBMYXllckdyb3VwXHJcbiAqIEBha2EgTC5MYXllckdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGdyb3VwIHNldmVyYWwgbGF5ZXJzIGFuZCBoYW5kbGUgdGhlbSBhcyBvbmUuIElmIHlvdSBhZGQgaXQgdG8gdGhlIG1hcCxcclxuICogYW55IGxheWVycyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGdyb3VwIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBvbiB0aGUgbWFwIGFzXHJcbiAqIHdlbGwuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5sYXllckdyb3VwKFttYXJrZXIxLCBtYXJrZXIyXSlcclxuICogXHQuYWRkTGF5ZXIocG9seWxpbmUpXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuTGF5ZXJHcm91cCA9IEwuTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxheWVycykge1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiAhIWxheWVyICYmIChsYXllciBpbiB0aGlzLl9sYXllcnMgfHwgdGhpcy5nZXRMYXllcklkKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYWxsIHRoZSBsYXllcnMgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG5cdC8vIENhbGxzIGBtZXRob2ROYW1lYCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyBhbnlcclxuXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcblx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuXHRpbnZva2U6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcblx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcblx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG5cdFx0XHRcdGxheWVyW21ldGhvZE5hbWVdLmFwcGx5KGxheWVyLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgZ3JvdXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuXHQvLyBgYGBqc1xyXG5cdC8vIGdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHQvLyBcdGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcclxuXHQvLyB9KTtcclxuXHQvLyBgYGBcclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxyXG5cdC8vIFJldHVybnMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElELlxyXG5cdGdldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJzKCk6IExheWVyW11cclxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllcnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllcnMucHVzaCh0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGxheWVycztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDYWxscyBgc2V0WkluZGV4YCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyB0aGUgei1pbmRleC5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVySWQobGF5ZXI6IExheWVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgaW50ZXJuYWwgSUQgZm9yIGEgbGF5ZXJcclxuXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiBMLnN0YW1wKGxheWVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM6IExheWVyW10pXHJcbi8vIENyZWF0ZSBhIGxheWVyIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycy5cclxuTC5sYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycykge1xyXG5cdHJldHVybiBuZXcgTC5MYXllckdyb3VwKGxheWVycyk7XHJcbn07XHJcblxuLypcclxuICogQGNsYXNzIEZlYXR1cmVHcm91cFxyXG4gKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllckdyb3VwXHJcbiAqXHJcbiAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAqICAqIFtgYmluZFBvcHVwYF0oI2xheWVyLWJpbmRwb3B1cCkgYmluZHMgYSBwb3B1cCB0byBhbGwgb2YgdGhlIGxheWVycyBhdCBvbmNlIChsaWtld2lzZSB3aXRoIFtgYmluZFRvb2x0aXBgXSgjbGF5ZXItYmluZHRvb2x0aXApKVxyXG4gKiAgKiBFdmVudHMgYXJlIHByb3BhZ2F0ZWQgdG8gdGhlIGBGZWF0dXJlR3JvdXBgLCBzbyBpZiB0aGUgZ3JvdXAgaGFzIGFuIGV2ZW50XHJcbiAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gKiBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICogICogSGFzIGBsYXllcmFkZGAgYW5kIGBsYXllcnJlbW92ZWAgZXZlbnRzXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAqIFx0LmJpbmRQb3B1cCgnSGVsbG8gd29ybGQhJylcclxuICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5GZWF0dXJlR3JvdXAgPSBMLkxheWVyR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdEwuTGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgYWRkZWQgdG8gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdEwuTGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgTGF0TG5nQm91bmRzIG9mIHRoZSBGZWF0dXJlIEdyb3VwIChjcmVhdGVkIGZyb20gYm91bmRzIGFuZCBjb29yZGluYXRlcyBvZiBpdHMgY2hpbGRyZW4pLlxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5mZWF0dXJlR3JvdXAobGF5ZXJzOiBMYXllcltdKVxyXG4vLyBDcmVhdGUgYSBmZWF0dXJlIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycy5cclxuTC5mZWF0dXJlR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG59O1xyXG5cbi8qXG4gKiBAY2xhc3MgUmVuZGVyZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLlJlbmRlcmVyXG4gKlxuICogQmFzZSBjbGFzcyBmb3IgdmVjdG9yIHJlbmRlcmVyIGltcGxlbWVudGF0aW9ucyAoYFNWR2AsIGBDYW52YXNgKS4gSGFuZGxlcyB0aGVcbiAqIERPTSBjb250YWluZXIgb2YgdGhlIHJlbmRlcmVyLCBpdHMgYm91bmRzLCBhbmQgaXRzIHpvb20gYW5pbWF0aW9uLlxuICpcbiAqIEEgYFJlbmRlcmVyYCB3b3JrcyBhcyBhbiBpbXBsaWNpdCBsYXllciBncm91cCBmb3IgYWxsIGBQYXRoYHMgLSB0aGUgcmVuZGVyZXJcbiAqIGl0c2VsZiBjYW4gYmUgYWRkZWQgb3IgcmVtb3ZlZCB0byB0aGUgbWFwLiBBbGwgcGF0aHMgdXNlIGEgcmVuZGVyZXIsIHdoaWNoIGNhblxuICogYmUgaW1wbGljaXQgKHRoZSBtYXAgd2lsbCBkZWNpZGUgdGhlIHR5cGUgb2YgcmVuZGVyZXIgYW5kIHVzZSBpdCBhdXRvbWF0aWNhbGx5KVxuICogb3IgZXhwbGljaXQgKHVzaW5nIHRoZSBbYHJlbmRlcmVyYF0oI3BhdGgtcmVuZGVyZXIpIG9wdGlvbiBvZiB0aGUgcGF0aCkuXG4gKlxuICogRG8gbm90IHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCB1c2UgYFNWR2AgYW5kIGBDYW52YXNgIGluc3RlYWQuXG4gKlxuICogQGV2ZW50IHVwZGF0ZTogRXZlbnRcbiAqIEZpcmVkIHdoZW4gdGhlIHJlbmRlcmVyIHVwZGF0ZXMgaXRzIGJvdW5kcywgY2VudGVyIGFuZCB6b29tLCBmb3IgZXhhbXBsZSB3aGVuXG4gKiBpdHMgbWFwIGhhcyBtb3ZlZFxuICovXG5cbkwuUmVuZGVyZXIgPSBMLkxheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhZGRpbmc6IE51bWJlciA9IDAuMVxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuXHRcdHBhZGRpbmc6IDAuMVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdEwuc3RhbXAodGhpcyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpOyAvLyBkZWZpbmVkIGJ5IHJlbmRlcmVyIGltcGxlbWVudGF0aW9uc1xuXG5cdFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuXHRcdH1cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcblx0fSxcblxuXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdH0sXG5cblx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG5cdFx0ICAgIHBvc2l0aW9uID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciksXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KDAuNSArIHRoaXMub3B0aW9ucy5wYWRkaW5nKSxcblx0XHQgICAgY3VycmVudENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fY2VudGVyLCB6b29tKSxcblx0XHQgICAgZGVzdENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QoY2VudGVyLCB6b29tKSxcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gZGVzdENlbnRlclBvaW50LnN1YnRyYWN0KGN1cnJlbnRDZW50ZXJQb2ludCksXG5cblx0XHQgICAgdG9wTGVmdE9mZnNldCA9IHZpZXdIYWxmLm11bHRpcGx5QnkoLXNjYWxlKS5hZGQocG9zaXRpb24pLmFkZCh2aWV3SGFsZikuc3VidHJhY3QoY2VudGVyT2Zmc2V0KTtcblxuXHRcdGlmIChMLkJyb3dzZXIuYW55M2QpIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fY2VudGVyLCB0aGlzLl96b29tKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVXBkYXRlIHBpeGVsIGJvdW5kcyBvZiByZW5kZXJlciBjb250YWluZXIgKGZvciBwb3NpdGlvbmluZy9zaXppbmcvY2xpcHBpbmcgbGF0ZXIpXG5cdFx0Ly8gU3ViY2xhc3NlcyBhcmUgcmVzcG9uc2libGUgb2YgZmlyaW5nIHRoZSAndXBkYXRlJyBldmVudC5cblx0XHR2YXIgcCA9IHRoaXMub3B0aW9ucy5wYWRkaW5nLFxuXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcblx0XHQgICAgbWluID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHNpemUubXVsdGlwbHlCeSgtcCkpLnJvdW5kKCk7XG5cblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTC5Cb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG5cblxuTC5NYXAuaW5jbHVkZSh7XG5cdC8vIEBuYW1lc3BhY2UgTWFwOyBAbWV0aG9kIGdldFJlbmRlcmVyKGxheWVyOiBQYXRoKTogUmVuZGVyZXJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW5cblx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcblx0Ly8gYXJlIHJlc3BlY3RlZCwgYW5kIHRoYXQgdGhlIHJlbmRlcmVycyBkbyBleGlzdCBvbiB0aGUgbWFwLlxuXHRnZXRSZW5kZXJlcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuXHRcdC8vIFVzZSB0aGlzIHNwZWNpZmljIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgZm9yIHRoaXMgcGF0aC4gVGFrZXNcblx0XHQvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hcCdzIFtkZWZhdWx0IHJlbmRlcmVyXSgjbWFwLXJlbmRlcmVyKS5cblx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdGlmICghcmVuZGVyZXIpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAb3B0aW9uIHByZWZlckNhbnZhczogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHQvLyBXaGV0aGVyIGBQYXRoYHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIGEgYENhbnZhc2AgcmVuZGVyZXIuXG5cdFx0XHQvLyBCeSBkZWZhdWx0LCBhbGwgYFBhdGhgcyBhcmUgcmVuZGVyZWQgaW4gYSBgU1ZHYCByZW5kZXJlci5cblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgPSAodGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyAmJiBMLmNhbnZhcygpKSB8fCBMLnN2ZygpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlciA9IChMLlNWRyAmJiBMLnN2Zyh7cGFuZTogbmFtZX0pKSB8fCAoTC5DYW52YXMgJiYgTC5jYW52YXMoe3BhbmU6IG5hbWV9KSk7XG5cdFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdID0gcmVuZGVyZXI7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fVxufSk7XG5cbi8qXG4gKiBAY2xhc3MgUGF0aFxuICogQGFrYSBMLlBhdGhcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxuICpcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgY29udGFpbnMgb3B0aW9ucyBhbmQgY29uc3RhbnRzIHNoYXJlZCBiZXR3ZWVuIHZlY3RvclxuICogb3ZlcmxheXMgKFBvbHlnb24sIFBvbHlsaW5lLCBDaXJjbGUpLiBEbyBub3QgdXNlIGl0IGRpcmVjdGx5LiBFeHRlbmRzIGBMYXllcmAuXG4gKi9cblxuTC5QYXRoID0gTC5MYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUGF0aCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHN0cm9rZTogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRzdHJva2U6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGNvbG9yOiBTdHJpbmcgPSAnIzMzODhmZidcblx0XHQvLyBTdHJva2UgY29sb3Jcblx0XHRjb2xvcjogJyMzMzg4ZmYnLFxuXG5cdFx0Ly8gQG9wdGlvbiB3ZWlnaHQ6IE51bWJlciA9IDNcblx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG5cdFx0d2VpZ2h0OiAzLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVDYXA6IFN0cmluZz0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVDYXA6ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVKb2luOiBTdHJpbmcgPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gZGFzaEFycmF5OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hBcnJheTogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZGFzaE9mZnNldDogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoT2Zmc2V0OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsOiBCb29sZWFuID0gZGVwZW5kc1xuXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRmaWxsOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gZmlsbENvbG9yOiBTdHJpbmcgPSAqXG5cdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuXHRcdGZpbGxDb2xvcjogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbE9wYWNpdHk6IE51bWJlciA9IDAuMlxuXHRcdC8vIEZpbGwgb3BhY2l0eS5cblx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsUnVsZTogU3RyaW5nID0gJ2V2ZW5vZGQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cblx0XHRmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuXG5cdFx0Ly8gY2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3Ncblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZVxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cblx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdFx0dGhpcy5fcmVuZGVyZXIub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR6b29tZW5kOiB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIHN0eWxlKTtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9CYWNrKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gZGVmaW5lZCBpbiBjaGlsZHJlbiBjbGFzc2VzXG5cdFx0dGhpcy5fcHJvamVjdCgpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9jbGlja1RvbGVyYW5jZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuc3Ryb2tlID8gdGhpcy5vcHRpb25zLndlaWdodCAvIDIgOiAwKSArIChMLkJyb3dzZXIudG91Y2ggPyAxMCA6IDApO1xuXHR9XG59KTtcblxuLypcclxuICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5aW5lIHBvaW50cyBwcm9jZXNzaW5nLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBtYWtlIHBvbHlsaW5lcyBsaWdodG5pbmctZmFzdC5cclxuICovXHJcblxyXG5MLkxpbmVVdGlsID0ge1xyXG5cclxuXHQvLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuXHQvLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuXHQvLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG5cdC8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcblx0Ly8gW0RvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcblx0Ly8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG5cdC8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuXHQvLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG5cdC8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHA6Ly9tb3VybmVyLmdpdGh1Yi5jb20vc2ltcGxpZnktanMvKS5cclxuXHRzaW1wbGlmeTogZnVuY3Rpb24gKHBvaW50cywgdG9sZXJhbmNlKSB7XHJcblx0XHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHRcdC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0XHQvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcblx0cG9pbnRUb1NlZ21lbnREaXN0YW5jZTogIGZ1bmN0aW9uIChwLCBwMSwgcDIpIHtcclxuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuXHRjbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGZ1bmN0aW9uIChwLCBwMSwgcDIpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG5cdF9zaW1wbGlmeURQOiBmdW5jdGlvbiAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHRcdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG5cdFx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0XHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdFx0bWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuXHRcdHZhciBpLFxyXG5cdFx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3UG9pbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcDogZnVuY3Rpb24gKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdFx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0XHQgICAgaW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0XHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG5cdFx0XHRzcURpc3QgPSB0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcblx0XHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG5cdFx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG5cdF9yZWR1Y2VQb2ludHM6IGZ1bmN0aW9uIChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0XHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0XHRwcmV2ID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG5cdC8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcblx0Ly8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG5cdC8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcblx0Y2xpcFNlZ21lbnQ6IGZ1bmN0aW9uIChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdFx0dmFyIGNvZGVBID0gdXNlTGFzdENvZGUgPyB0aGlzLl9sYXN0Q29kZSA6IHRoaXMuX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHRcdCAgICBjb2RlQiA9IHRoaXMuX2dldEJpdENvZGUoYiwgYm91bmRzKSxcclxuXHJcblx0XHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0XHQvLyBzYXZlIDJuZCBjb2RlIHRvIGF2b2lkIGNhbGN1bGF0aW5nIGl0IG9uIHRoZSBuZXh0IHNlZ21lbnRcclxuXHRcdHRoaXMuX2xhc3RDb2RlID0gY29kZUI7XHJcblxyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0Ly8gaWYgYSxiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgYWNjZXB0KVxyXG5cdFx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xyXG5cdFx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGlmIGEsYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCByZWplY3QpXHJcblx0XHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0XHRjb2RlT3V0ID0gY29kZUEgfHwgY29kZUI7XHJcblx0XHRcdHAgPSB0aGlzLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRuZXdDb2RlID0gdGhpcy5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuXHRcdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdFx0YSA9IHA7XHJcblx0XHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGIgPSBwO1xyXG5cdFx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9nZXRFZGdlSW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG5cdFx0dmFyIGR4ID0gYi54IC0gYS54LFxyXG5cdFx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4LCB5O1xyXG5cclxuXHRcdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuXHRcdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xyXG5cdFx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuXHRcdFx0eCA9IGEueCArIGR4ICogKG1pbi55IC0gYS55KSAvIGR5O1xyXG5cdFx0XHR5ID0gbWluLnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG5cdFx0XHR4ID0gbWF4Lng7XHJcblx0XHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuXHRcdFx0eCA9IG1pbi54O1xyXG5cdFx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHgsIHksIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qml0Q29kZTogZnVuY3Rpb24gKHAsIGJvdW5kcykge1xyXG5cdFx0dmFyIGNvZGUgPSAwO1xyXG5cclxuXHRcdGlmIChwLnggPCBib3VuZHMubWluLngpIHsgLy8gbGVmdFxyXG5cdFx0XHRjb2RlIHw9IDE7XHJcblx0XHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG5cdFx0XHRjb2RlIHw9IDI7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdFx0Y29kZSB8PSA0O1xyXG5cdFx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRcdGNvZGUgfD0gODtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29kZTtcclxuXHR9LFxyXG5cclxuXHQvLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuXHRfc3FEaXN0OiBmdW5jdGlvbiAocDEsIHAyKSB7XHJcblx0XHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5cdF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudDogZnVuY3Rpb24gKHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcblx0XHR2YXIgeCA9IHAxLngsXHJcblx0XHQgICAgeSA9IHAxLnksXHJcblx0XHQgICAgZHggPSBwMi54IC0geCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSB5LFxyXG5cdFx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdFx0ICAgIHQ7XHJcblxyXG5cdFx0aWYgKGRvdCA+IDApIHtcclxuXHRcdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRcdGlmICh0ID4gMSkge1xyXG5cdFx0XHRcdHggPSBwMi54O1xyXG5cdFx0XHRcdHkgPSBwMi55O1xyXG5cdFx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcblx0XHRcdFx0eCArPSBkeCAqIHQ7XHJcblx0XHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRkeCA9IHAueCAtIHg7XHJcblx0XHRkeSA9IHAueSAtIHk7XHJcblxyXG5cdFx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IEwuUG9pbnQoeCwgeSk7XHJcblx0fVxyXG59O1xyXG5cbi8qXG4gKiBAY2xhc3MgUG9seWxpbmVcbiAqIEBha2EgTC5Qb2x5bGluZVxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlsaW5lIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQYXRoYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0Wy0xMjIuNjgsIDQ1LjUxXSxcbiAqIFx0Wy0xMjIuNDMsIDM3Ljc3XSxcbiAqIFx0Wy0xMTguMiwgMzQuMDRdXG4gKiBdO1xuICpcbiAqIHZhciBwb2x5bGluZSA9IEwucG9seWxpbmUobGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5bGluZVxuICogbWFwLmZpdEJvdW5kcyhwb2x5bGluZS5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIGBNdWx0aVBvbHlsaW5lYCBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbWy0xMjIuNjgsIDQ1LjUxXSxcbiAqIFx0IFstMTIyLjQzLCAzNy43N10sXG4gKiBcdCBbLTExOC4yLCAzNC4wNF1dLFxuICogXHRbWy03My45MSwgNDAuNzhdLFxuICogXHQgWy04Ny42MiwgNDEuODNdLFxuICogXHQgWy05Ni43MiwgMzIuNzZdXVxuICogXTtcbiAqIGBgYFxuICovXG5cbkwuUG9seWxpbmUgPSBMLlBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBvbHlsaW5lIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcblx0XHQvLyBIb3cgbXVjaCB0byBzaW1wbGlmeSB0aGUgcG9seWxpbmUgb24gZWFjaCB6b29tIGxldmVsLiBNb3JlIG1lYW5zXG5cdFx0Ly8gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBhbmQgbGVzcyBtZWFucyBtb3JlIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uLlxuXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG5cdFx0Ly8gQG9wdGlvbiBub0NsaXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIERpc2FibGUgcG9seWxpbmUgY2xpcHBpbmcuXG5cdFx0bm9DbGlwOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmdzKCk6IExhdExuZ1tdXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cblx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5ncyhsYXRsbmdzOiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gUmVwbGFjZXMgYWxsIHRoZSBwb2ludHMgaW4gdGhlIHBvbHlsaW5lIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMuXG5cdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzRW1wdHkoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgUG9seWxpbmUgaGFzIG5vIExhdExuZ3MuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoO1xuXHR9LFxuXG5cdGNsb3Nlc3RMYXllclBvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LFxuXHRcdCAgICBtaW5Qb2ludCA9IG51bGwsXG5cdFx0ICAgIGNsb3Nlc3QgPSBMLkxpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHQgICAgcDEsIHAyO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG5cdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG5cdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Qb2ludDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcG9seWxpbmUuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxuXHRcdGlmIChoYWxmRGlzdCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tpICsgMV07XG5cdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XG5cblx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtcblx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz8gTGF0TG5nW10pOiB0aGlzXG5cdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2Zcblx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3Npbmdcblx0Ly8gYSBzcGVjaWZpYyByaW5nIGFzIGEgTGF0TG5nIGFycmF5ICh0aGF0IHlvdSBjYW4gZWFybGllciBhY2Nlc3Mgd2l0aCBbYGdldExhdExuZ3NgXSgjcG9seWxpbmUtZ2V0bGF0bG5ncykpLlxuXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcblx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcblx0XHRsYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcblx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgY29udmVydCBsYXRsbmdzIGlucHV0IGludG8gYWN0dWFsIExhdExuZyBpbnN0YW5jZXM7IGNhbGN1bGF0ZSBib3VuZHMgYWxvbmcgdGhlIHdheVxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdCAgICBmbGF0ID0gTC5Qb2x5bGluZS5fZmxhdChsYXRsbmdzKTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoZmxhdCkge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSBMLmxhdExuZyhsYXRsbmdzW2ldKTtcblx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweEJvdW5kcyA9IG5ldyBMLkJvdW5kcygpO1xuXHRcdHRoaXMuX3JpbmdzID0gW107XG5cdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IG5ldyBMLlBvaW50KHcsIHcpO1xuXG5cdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG5cdFx0XHRweEJvdW5kcy5taW4uX3N1YnRyYWN0KHApO1xuXHRcdFx0cHhCb3VuZHMubWF4Ll9hZGQocCk7XG5cdFx0XHR0aGlzLl9weEJvdW5kcyA9IHB4Qm91bmRzO1xuXHRcdH1cblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSB0dXJucyBsYXRsbmdzIGludG8gYSBzZXQgb2YgcmluZ3Mgd2l0aCBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcblx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMLkxhdExuZyxcblx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG5cdFx0ICAgIGksIHJpbmc7XG5cblx0XHRpZiAoZmxhdCkge1xuXHRcdFx0cmluZyA9IFtdO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHRwcm9qZWN0ZWRCb3VuZHMuZXh0ZW5kKHJpbmdbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNsaXAgcG9seWxpbmUgYnkgcmVuZGVyZXIgYm91bmRzIHNvIHRoYXQgd2UgaGF2ZSBsZXNzIHRvIHJlbmRlciBmb3IgcGVyZm9ybWFuY2Vcblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIGksIGosIGssIGxlbiwgbGVuMiwgc2VnbWVudCwgcG9pbnRzO1xuXG5cdFx0Zm9yIChpID0gMCwgayA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBMLkxpbmVVdGlsLmNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIXNlZ21lbnQpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG5cdFx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyBvdXQgb2Ygc2NyZWVuLCBvciBpdCdzIHRoZSBsYXN0IG9uZSwgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lIHBhcnRcblx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG5cdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcblx0XHRcdFx0XHRrKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydHNbaV0gPSBMLkxpbmVVdGlsLnNpbXBsaWZ5KHBhcnRzW2ldLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG5cdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4vLyBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LiBZb3UgY2FuIGNyZWF0ZSBhIGBQb2x5bGluZWAgb2JqZWN0IHdpdGhcbi8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4vLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbkwucG9seWxpbmUgPSBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XG59O1xuXG5MLlBvbHlsaW5lLl9mbGF0ID0gZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0Ly8gdHJ1ZSBpZiBpdCdzIGEgZmxhdCBhcnJheSBvZiBsYXRsbmdzOyBmYWxzZSBpZiBuZXN0ZWRcblx0cmV0dXJuICFMLlV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XG59O1xuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFBvbHlVdGlsXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlnb24gZ2VvbWV0cmllcy5cclxuICovXHJcblxyXG5MLlBvbHlVdGlsID0ge307XHJcblxyXG4vKiBAZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzOiBQb2ludFtdLCBib3VuZHM6IEJvdW5kcywgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXVxyXG4gKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ2VtYW4gYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXRoZXJsYW5kJUUyJTgwJTkzSG9kZ21hbl9hbGdvcml0aG0pKS5cclxuICogVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5Z29uIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmdcclxuICogcGVyZm9ybWFuY2UuIE5vdGUgdGhhdCBwb2x5Z29uIHBvaW50cyBuZWVkcyBkaWZmZXJlbnQgYWxnb3JpdGhtIGZvciBjbGlwcGluZ1xyXG4gKiB0aGFuIHBvbHlsaW5lLCBzbyB0aGVyZSdzIGEgc2VwZXJhdGUgbWV0aG9kIGZvciBpdC5cclxuICovXHJcbkwuUG9seVV0aWwuY2xpcFBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHAsXHJcblx0ICAgIGx1ID0gTC5MaW5lVXRpbDtcclxuXHJcblx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRwb2ludHNbaV0uX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgZWFjaCBlZGdlIChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXHJcblx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG5cdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG5cdFx0Y2xpcHBlZFBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRcdGEgPSBwb2ludHNbaV07XHJcblx0XHRcdGIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0Ly8gaWYgYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBnb2VzIG91dCBvZiBzY3JlZW4pXHJcblx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcblx0XHRcdFx0XHRwID0gbHUuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0XHRwLl9jb2RlID0gbHUuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKGEpO1xyXG5cclxuXHRcdFx0Ly8gZWxzZSBpZiBiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZW50ZXJzIHRoZSBzY3JlZW4pXHJcblx0XHRcdH0gZWxzZSBpZiAoIShiLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHRwID0gbHUuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0cC5fY29kZSA9IGx1Ll9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRwb2ludHMgPSBjbGlwcGVkUG9pbnRzO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufTtcclxuXG4vKlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBha2EgTC5Qb2x5Z29uXG4gKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlnb24gb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlsaW5lYC5cbiAqXG4gKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1stMTExLjAzLCA0MV0sWy0xMTEuMDQsIDQ1XSxbLTEwNC4wNSwgNDVdLFstMTA0LjA1LCA0MV1dO1xuICpcbiAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbWy0xMTEuMDMsIDQxXSxbLTExMS4wNCwgNDVdLFstMTA0LjA1LCA0NV0sWy0xMDQuMDUsIDQxXV0sIC8vIG91dGVyIHJpbmdcbiAqICAgW1stMTA4LjU4LDM3LjI5XSxbLTEwOC41OCw0MC43MV0sWy0xMDIuNTAsNDAuNzFdLFstMTAyLjUwLDM3LjI5XV0gLy8gaG9sZVxuICogXTtcbiAqIGBgYFxuICpcbiAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gKiAgICAgW1stMTExLjAzLCA0MV0sWy0xMTEuMDQsIDQ1XSxbLTEwNC4wNSwgNDVdLFstMTA0LjA1LCA0MV1dLCAvLyBvdXRlciByaW5nXG4gKiAgICAgW1stMTA4LjU4LDM3LjI5XSxbLTEwOC41OCw0MC43MV0sWy0xMDIuNTAsNDAuNzFdLFstMTAyLjUwLDM3LjI5XV0gLy8gaG9sZVxuICogICBdLFxuICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gKiAgICAgW1stMTA5LjA1LCAzN10sWy0xMDkuMDMsIDQxXSxbLTEwMi4wNSwgNDFdLFstMTAyLjA0LCAzN10sWy0xMDkuMDUsIDM4XV1cbiAqICAgXVxuICogXTtcbiAqIGBgYFxuICovXG5cbkwuUG9seWdvbiA9IEwuUG9seWxpbmUuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGosIHAxLCBwMiwgZiwgYXJlYSwgeCwgeSwgY2VudGVyLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5Z29uIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0YXJlYSA9IHggPSB5ID0gMDtcblxuXHRcdGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG5cdFx0XHRwMSA9IHBvaW50c1tpXTtcblx0XHRcdHAyID0gcG9pbnRzW2pdO1xuXG5cdFx0XHRmID0gcDEueSAqIHAyLnggLSBwMi55ICogcDEueDtcblx0XHRcdHggKz0gKHAxLnggKyBwMi54KSAqIGY7XG5cdFx0XHR5ICs9IChwMS55ICsgcDIueSkgKiBmO1xuXHRcdFx0YXJlYSArPSBmICogMztcblx0XHR9XG5cblx0XHRpZiAoYXJlYSA9PT0gMCkge1xuXHRcdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXG5cdFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhjZW50ZXIpO1xuXHR9LFxuXG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gTC5Qb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG5cdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG5cdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIEwuTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdEwuUG9seWxpbmUucHJvdG90eXBlLl9zZXRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyk7XG5cdFx0aWYgKEwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzWzBdKSA/IHRoaXMuX2xhdGxuZ3NbMF0gOiB0aGlzLl9sYXRsbmdzWzBdWzBdO1xuXHR9LFxuXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHMsXG5cdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuXHRcdCAgICBwID0gbmV3IEwuUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEwuQm91bmRzKGJvdW5kcy5taW4uc3VidHJhY3QocCksIGJvdW5kcy5tYXguYWRkKHApKTtcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aCwgY2xpcHBlZDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjbGlwcGVkID0gTC5Qb2x5VXRpbC5jbGlwUG9seWdvbih0aGlzLl9yaW5nc1tpXSwgYm91bmRzLCB0cnVlKTtcblx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMsIHRydWUpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnBvbHlnb24obGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuTC5wb2x5Z29uID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLlBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XG59O1xuXG4vKlxuICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAqL1xuXG4vKlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICogQGFrYSBMLlJldGFuZ2xlXG4gKiBAaW5oZXJpdHMgUG9seWdvblxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gKiBgYGBcbiAqXG4gKi9cblxuXG5MLlJlY3RhbmdsZSA9IEwuUG9seWdvbi5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdFx0TC5Qb2x5Z29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcyksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSByZWN0YW5nbGUgd2l0aCB0aGUgcGFzc2VkIGJvdW5kcy5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0TGF0TG5ncyh0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSk7XG5cdH0sXG5cblx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdGxhdExuZ0JvdW5kcyA9IEwubGF0TG5nQm91bmRzKGxhdExuZ0JvdW5kcyk7XG5cdFx0cmV0dXJuIFtcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKVxuXHRcdF07XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucmVjdGFuZ2xlKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbkwucmVjdGFuZ2xlID0gZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG59O1xuXG4vKlxuICogQGNsYXNzIENpcmNsZU1hcmtlclxuICogQGFrYSBMLkNpcmNsZU1hcmtlclxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNpcmNsZSBvZiBhIGZpeGVkIHNpemUgd2l0aCByYWRpdXMgc3BlY2lmaWVkIGluIHBpeGVscy4gRXh0ZW5kcyBgUGF0aGAuXG4gKi9cblxuTC5DaXJjbGVNYXJrZXIgPSBMLlBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENpcmNsZU1hcmtlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlciA9IDEwXG5cdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcblx0XHRyYWRpdXM6IDEwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7bGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xuXHR9LFxuXG5cdHNldFN0eWxlIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG5cdFx0TC5QYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBMLkJvdW5kcyh0aGlzLl9wb2ludC5zdWJ0cmFjdChwKSwgdGhpcy5fcG9pbnQuYWRkKHApKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyk7XG5cdH0sXG5cblx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cyAmJiAhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jaXJjbGVNYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGVNYXJrZXIgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBtYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG5MLmNpcmNsZU1hcmtlciA9IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkNpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xufTtcblxuLypcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBha2EgTC5DaXJjbGVcbiAqIEBpbmhlcml0cyBDaXJjbGVNYXJrZXJcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAqXG4gKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY2lyY2xlKFs1MC41LCAzMC41XSwge3JhZGl1czogMjAwfSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbkwuQ2lyY2xlID0gTC5DaXJjbGVNYXJrZXIuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBmYWN0b3J5IChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucz8pXG5cdFx0XHRvcHRpb25zID0gTC5leHRlbmQoe30sIGxlZ2FjeU9wdGlvbnMsIHtyYWRpdXM6IG9wdGlvbnN9KTtcblx0XHR9XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XG5cblx0XHRpZiAoaXNOYU4odGhpcy5vcHRpb25zLnJhZGl1cykpIHsgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU4nKTsgfVxuXG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlcjsgUmFkaXVzIG9mIHRoZSBjaXJjbGUsIGluIG1ldGVycy5cblx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21SYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG5cdH0sXG5cblx0c2V0U3R5bGU6IEwuUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEwuQ1JTLkVhcnRoLmRpc3RhbmNlKSB7XG5cdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gTC5DUlMuRWFydGguUikgLyBkLFxuXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcblx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG5cdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cblx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcblx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IE1hdGgubWF4KE1hdGgucm91bmQocC54IC0gbWFwLnByb2plY3QoW2xhdDIsIGxuZyAtIGxuZ1JdKS54KSwgMSk7XG5cdFx0XHR0aGlzLl9yYWRpdXNZID0gTWF0aC5tYXgoTWF0aC5yb3VuZChwLnkgLSB0b3AueSksIDEpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsYXRsbmcyID0gY3JzLnVucHJvamVjdChjcnMucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLCAwXSkpO1xuXG5cdFx0XHR0aGlzLl9wb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4vLyB3aGljaCBjb250YWlucyB0aGUgY2lyY2xlIHJhZGl1cy5cbi8vIEBhbHRlcm5hdGl2ZVxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBPYnNvbGV0ZSB3YXkgb2YgaW5zdGFudGlhdGluZyBhIGNpcmNsZSwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBjb2RlLlxuLy8gRG8gbm90IHVzZSBpbiBuZXcgYXBwbGljYXRpb25zIG9yIHBsdWdpbnMuXG5MLmNpcmNsZSA9IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpO1xufTtcblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLlNWR1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zdmcpLCBTVkcgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICogdGhpcyBjYXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuTC5TVkcgPSBMLlJlbmRlcmVyLmV4dGVuZCh7XG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IEwuUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXHRcdGV2ZW50cy56b29tc3RhcnQgPSB0aGlzLl9vblpvb21TdGFydDtcblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5TVkcuY3JlYXRlKCdzdmcnKTtcblxuXHRcdC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNsaWNrIHRocm91Z2ggc3ZnIHJvb3Q7IHdlJ2xsIHJlc2V0IGl0IGJhY2sgaW4gaW5kaXZpZHVhbCBwYXRoc1xuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuXHRcdHRoaXMuX3Jvb3RHcm91cCA9IEwuU1ZHLmNyZWF0ZSgnZycpO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yb290R3JvdXApO1xuXHR9LFxuXG5cdF9vblpvb21TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIERyYWctdGhlbi1waW5jaCBpbnRlcmFjdGlvbnMgbWlnaHQgbWVzcyB1cCB0aGUgY2VudGVyIGFuZCB6b29tLlxuXHRcdC8vIEluIHRoaXMgY2FzZSwgdGhlIGVhc2llc3Qgd2F5IHRvIHByZXZlbnQgdGhpcyBpcyByZS1kbyB0aGUgcmVuZGVyZXJcblx0XHQvLyAgIGJvdW5kcyBhbmQgcGFkZGluZyB3aGVuIHRoZSB6b29taW5nIHN0YXJ0cy5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRMLlJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cblx0XHQvLyBzZXQgc2l6ZSBvZiBzdmctY29udGFpbmVyIGlmIGNoYW5nZWRcblx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR0aGlzLl9zdmdTaXplID0gc2l6ZTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZW1lbnQ6IHVwZGF0ZSBjb250YWluZXIgdmlld0JveCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGluZGl2aWR1YWwgbGF5ZXJzXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdC8vIG1ldGhvZHMgYmVsb3cgYXJlIGNhbGxlZCBieSB2ZWN0b3IgbGF5ZXJzIGltcGxlbWVudGF0aW9uc1xuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCA9IEwuU1ZHLmNyZWF0ZSgncGF0aCcpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcblx0XHQvLyBDdXN0b20gY2xhc3MgbmFtZSBzZXQgb24gYW4gZWxlbWVudC4gT25seSBmb3IgU1ZHIHJlbmRlcmVyLlxuXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhdGgsIGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhdGgsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl9yb290R3JvdXAuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZShsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKCFwYXRoKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBMLlNWRy5wb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgciA9IGxheWVyLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gbGF5ZXIuX3JhZGl1c1kgfHwgcixcblx0XHQgICAgYXJjID0gJ2EnICsgciArICcsJyArIHIyICsgJyAwIDEsMCAnO1xuXG5cdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3Ncblx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcblx0XHRcdFx0YXJjICsgKHIgKiAyKSArICcsMCAnICtcblx0XHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoKTtcblx0fSxcblxuXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0TC5Eb21VdGlsLnRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0TC5Eb21VdGlsLnRvQmFjayhsYXllci5fcGF0aCk7XG5cdH1cbn0pO1xuXG5cbi8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcbkwuZXh0ZW5kKEwuU1ZHLCB7XG5cdC8vIEBmdW5jdGlvbiBjcmVhdGUobmFtZTogU3RyaW5nKTogU1ZHRWxlbWVudFxuXHQvLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcblx0Ly8gY29ycmVzcG9uZGluZyB0byB0aGUgY2xhc3MgbmFtZSBwYXNzZWQuIEZvciBleGFtcGxlLCB1c2luZyAnbGluZScgd2lsbCByZXR1cm5cblx0Ly8gYW4gaW5zdGFuY2Ugb2YgW1NWR0xpbmVFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHTGluZUVsZW1lbnQpLlxuXHRjcmVhdGU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcblx0fSxcblxuXHQvLyBAZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzOiBQb2ludFtdLCBjbG9zZWQ6IEJvb2xlYW4pOiBTdHJpbmdcblx0Ly8gR2VuZXJhdGVzIGEgU1ZHIHBhdGggc3RyaW5nIGZvciBtdWx0aXBsZSByaW5ncywgd2l0aCBlYWNoIHJpbmcgdHVybmluZ1xuXHQvLyBpbnRvIFwiTS4uTC4uTC4uXCIgaW5zdHJ1Y3Rpb25zXG5cdHBvaW50c1RvUGF0aDogZnVuY3Rpb24gKHJpbmdzLCBjbG9zZWQpIHtcblx0XHR2YXIgc3RyID0gJycsXG5cdFx0ICAgIGksIGosIGxlbiwgbGVuMiwgcG9pbnRzLCBwO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBvaW50cyA9IHJpbmdzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRwID0gcG9pbnRzW2pdO1xuXHRcdFx0XHRzdHIgKz0gKGogPyAnTCcgOiAnTScpICsgcC54ICsgJyAnICsgcC55O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjbG9zZXMgdGhlIHJpbmcgZm9yIHBvbHlnb25zOyBcInhcIiBpcyBWTUwgc3ludGF4XG5cdFx0XHRzdHIgKz0gY2xvc2VkID8gKEwuQnJvd3Nlci5zdmcgPyAneicgOiAneCcpIDogJyc7XG5cdFx0fVxuXG5cdFx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3Ncblx0XHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcblx0fVxufSk7XG5cbi8vIEBuYW1lc3BhY2UgQnJvd3NlcjsgQHByb3BlcnR5IHN2ZzogQm9vbGVhblxuLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbkwuQnJvd3Nlci5zdmcgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgTC5TVkcuY3JlYXRlKCdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcblxuXG4vLyBAbmFtZXNwYWNlIFNWR1xuLy8gQGZhY3RvcnkgTC5zdmcob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgU1ZHIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5MLnN2ZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBMLkJyb3dzZXIuc3ZnIHx8IEwuQnJvd3Nlci52bWwgPyBuZXcgTC5TVkcob3B0aW9ucykgOiBudWxsO1xufTtcblxuLypcbiAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gKi9cblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqXG4gKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydCBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluIHRoaXMgY2FzZS5cbiAqXG4gKiBWTUwgd2FzIGRlcHJlY2F0ZWQgaW4gMjAxMiwgd2hpY2ggbWVhbnMgVk1MIGZ1bmN0aW9uYWxpdHkgZXhpc3RzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIEJyb3dzZXI7IEBwcm9wZXJ0eSB2bWw6IEJvb2xlYW5cbi8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cbkwuQnJvd3Nlci52bWwgPSAhTC5Ccm93c2VyLnN2ZyAmJiAoZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcblxuXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcblxuXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xuXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0oKSk7XG5cbi8vIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG5MLlNWRy5pbmNsdWRlKCFMLkJyb3dzZXIudm1sID8ge30gOiB7XG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciA9IEwuU1ZHLmNyZWF0ZSgnc2hhcGUnKTtcblxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcblxuXHRcdGxheWVyLl9wYXRoID0gTC5TVkcuY3JlYXRlKCdwYXRoJyk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmUoY29udGFpbmVyKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRpZiAoIXN0cm9rZSkge1xuXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gTC5TVkcuY3JlYXRlKCdzdHJva2UnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4Jztcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBMLlV0aWwuaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcblx0XHRcdH1cblx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XG5cdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuXHRcdH0gZWxzZSBpZiAoc3Ryb2tlKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGlmICghZmlsbCkge1xuXHRcdFx0XHRmaWxsID0gbGF5ZXIuX2ZpbGwgPSBMLlNWRy5jcmVhdGUoJ2ZpbGwnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcblx0XHRcdGZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblxuXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKGZpbGwpO1xuXHRcdFx0bGF5ZXIuX2ZpbGwgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuXHRcdCAgICByID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSxcblx0XHQgICAgcjIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZIHx8IHIpO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC50b0Zyb250KGxheWVyLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0TC5Eb21VdGlsLnRvQmFjayhsYXllci5fY29udGFpbmVyKTtcblx0fVxufSk7XG5cbmlmIChMLkJyb3dzZXIudm1sKSB7XG5cdEwuU1ZHLmNyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxsdm1sOicgKyBuYW1lICsgJyBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9KSgpO1xufVxuXG4vKlxuICogQGNsYXNzIENhbnZhc1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuQ2FudmFzXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWNhbnZhcyksIENhbnZhcyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbkwuQ2FudmFzID0gTC5SZW5kZXJlci5leHRlbmQoe1xuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcblxuXHRcdC8vIFJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbCxcblx0XHQvLyBpbiBjYXNlIG9mIHJlbW92aW5nIHRoZSByZW5kZXJlciBpdHNlbGYgZnJvbSB0aGUgbWFwLlxuXHRcdHRoaXMuX2RyYXcoKTtcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCBMLlV0aWwudGhyb3R0bGUodGhpcy5fb25Nb3VzZU1vdmUsIDMyLCB0aGlzKSwgdGhpcylcblx0XHRcdC5vbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpXG5cdFx0XHQub24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVNb3VzZU91dCwgdGhpcyk7XG5cblx0XHR0aGlzLl9jdHggPSBjb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9kcmF3bkxheWVycyA9IHt9O1xuXG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gTC5Ccm93c2VyLnJldGluYSA/IDIgOiAxO1xuXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG5cdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdGlmIChMLkJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG5cdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tMLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogTC5VdGlsLmZhbHNlRm4sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGxheWVyLl9yZW1vdmVkID0gdHJ1ZTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbGF5ZXIuX3B4Qm91bmRzO1xuXHRcdHRoaXMuX2RyYXcodHJ1ZSk7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fZHJhdygpO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVEYXNoQXJyYXk6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5vcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoJywnKSxcblx0XHRcdCAgICBkYXNoQXJyYXkgPSBbXSxcblx0XHRcdCAgICBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKE51bWJlcihwYXJ0c1tpXSkpO1xuXHRcdFx0fVxuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzIHx8IG5ldyBMLkJvdW5kcygpO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1pbi5zdWJ0cmFjdChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IHRoaXMuX3JlZHJhd1JlcXVlc3QgfHwgTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHR0aGlzLl9kcmF3KHRydWUpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uIChjbGVhcikge1xuXHRcdHRoaXMuX2NsZWFyID0gY2xlYXI7XG5cdFx0dmFyIGxheWVyLCBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG5cdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLl9jdHgucmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgYm91bmRzLm1heC54IC0gYm91bmRzLm1pbi54LCBib3VuZHMubWF4LnkgLSBib3VuZHMubWluLnkpO1xuXHRcdFx0dGhpcy5fY3R4LmNsaXAoKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHRcdGlmIChjbGVhciAmJiBsYXllci5fcmVtb3ZlZCkge1xuXHRcdFx0XHRkZWxldGUgbGF5ZXIuX3JlbW92ZWQ7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cblx0XHR2YXIgaSwgaiwgbGVuMiwgcCxcblx0XHQgICAgcGFydHMgPSBsYXllci5fcGFydHMsXG5cdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4O1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9kcmF3bkxheWVyc1tsYXllci5fbGVhZmxldF9pZF0gPSBsYXllcjtcblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcblx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG5cdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAobGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuXHRcdCAgICByID0gbGF5ZXIuX3JhZGl1cyxcblx0XHQgICAgcyA9IChsYXllci5fcmFkaXVzWSB8fCByKSAvIHI7XG5cblx0XHR0aGlzLl9kcmF3bkxheWVyc1tsYXllci5fbGVhZmxldF9pZF0gPSBsYXllcjtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cdH0sXG5cblx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG5cdFx0dmFyIGNsZWFyID0gdGhpcy5fY2xlYXIsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNsZWFyID8gJ2Rlc3RpbmF0aW9uLW91dCcgOiAnc291cmNlLW92ZXInO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gY2xlYXIgPyAxIDogb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gY2xlYXIgPyAxIDogb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHQvLyBpZiBjbGVhcmluZyBzaGFwZSwgZG8gaXQgd2l0aCB0aGUgcHJldmlvdXNseSBkcmF3biBsaW5lIHdpZHRoXG5cdFx0XHRsYXllci5fcHJldldlaWdodCA9IGN0eC5saW5lV2lkdGggPSBjbGVhciA/IGxheWVyLl9wcmV2V2VpZ2h0ICsgMSA6IG9wdGlvbnMud2VpZ2h0O1xuXG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG5cdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDYW52YXMgb2J2aW91c2x5IGRvZXNuJ3QgaGF2ZSBtb3VzZSBldmVudHMgZm9yIGluZGl2aWR1YWwgZHJhd24gb2JqZWN0cyxcblx0Ly8gc28gd2UgZW11bGF0ZSB0aGF0IGJ5IGNhbGN1bGF0aW5nIHdoYXQncyB1bmRlciB0aGUgbW91c2Ugb24gbW91c2Vtb3ZlL2NsaWNrIG1hbnVhbGx5XG5cblx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSksIGxheWVycyA9IFtdLCBsYXllcjtcblxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpICYmICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuXHRcdFx0XHRMLkRvbUV2ZW50Ll9mYWtlU3RvcChlKTtcblx0XHRcdFx0bGF5ZXJzLnB1c2gobGF5ZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobGF5ZXJzLmxlbmd0aCkgIHtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChsYXllcnMsIGUpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUsIHBvaW50KTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcblx0fSxcblxuXG5cdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuXHRcdGlmIChsYXllciAmJiAoZS50eXBlID09PSAnbW91c2VvdXQnIHx8ICFsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpKSB7XG5cdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcblx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVNb3VzZUhvdmVyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHtcblx0XHR2YXIgaWQsIGxheWVyO1xuXG5cdFx0Zm9yIChpZCBpbiB0aGlzLl9kcmF3bkxheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9kcmF3bkxheWVyc1tpZF07XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW3RoaXMuX2hvdmVyZWRMYXllcl0sIGUpO1xuXHRcdH1cblx0fSxcblxuXHRfZmlyZUV2ZW50OiBmdW5jdGlvbiAobGF5ZXJzLCBlLCB0eXBlKSB7XG5cdFx0dGhpcy5fbWFwLl9maXJlRE9NRXZlbnQoZSwgdHlwZSB8fCBlLnR5cGUsIGxheWVycyk7XG5cdH0sXG5cblx0Ly8gVE9ETyBfYnJpbmdUb0Zyb250ICYgX2JyaW5nVG9CYWNrLCBwcmV0dHkgdHJpY2t5XG5cblx0X2JyaW5nVG9Gcm9udDogTC5VdGlsLmZhbHNlRm4sXG5cdF9icmluZ1RvQmFjazogTC5VdGlsLmZhbHNlRm5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIEJyb3dzZXI7IEBwcm9wZXJ0eSBjYW52YXM6IEJvb2xlYW5cbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG5MLkJyb3dzZXIuY2FudmFzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dDtcbn0oKSk7XG5cbi8vIEBuYW1lc3BhY2UgQ2FudmFzXG4vLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbkwuY2FudmFzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIEwuQnJvd3Nlci5jYW52YXMgPyBuZXcgTC5DYW52YXMob3B0aW9ucykgOiBudWxsO1xufTtcblxuTC5Qb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG5cdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIHBhcnQsXG5cdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuXHRpZiAoIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuXHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdGlmIChMLkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuTC5Qb2x5Z29uLnByb3RvdHlwZS5fY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChwKSB7XG5cdHZhciBpbnNpZGUgPSBmYWxzZSxcblx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdGlmICghdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuXHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0cDEgPSBwYXJ0W2pdO1xuXHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuXHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRyZXR1cm4gaW5zaWRlIHx8IEwuUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG59O1xuXG5MLkNpcmNsZU1hcmtlci5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocCkge1xuXHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xufTtcblxuLypcclxuICogQGNsYXNzIEdlb0pTT05cclxuICogQGFrYSBMLkdlb0pTT05cclxuICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICogXHR9XHJcbiAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gKiB9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkdlb0pTT04gPSBMLkZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgR2VvSlNPTiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvaW50VG9MYXllcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIGhvdyBHZW9KU09OIHBvaW50cyBzcGF3biBMZWFmbGV0IGxheWVycy4gSXQgaXMgaW50ZXJuYWxseVxyXG5cdCAqIGNhbGxlZCB3aGVuIGRhdGEgaXMgYWRkZWQsIHBhc3NpbmcgdGhlIEdlb0pTT04gcG9pbnQgZmVhdHVyZSBhbmQgaXRzIGBMYXRMbmdgLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIHNwYXduIGEgZGVmYXVsdCBgTWFya2VyYDpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uKGdlb0pzb25Qb2ludCwgbGF0bG5nKSB7XHJcblx0ICogXHRyZXR1cm4gTC5tYXJrZXIobGF0bG5nKTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHN0eWxlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgdGhlIGBQYXRoIG9wdGlvbnNgIGZvciBzdHlsaW5nIEdlb0pTT04gbGluZXMgYW5kIHBvbHlnb25zLFxyXG5cdCAqIGNhbGxlZCBpbnRlcm5hbGx5IHdoZW4gZGF0YSBpcyBhZGRlZC5cclxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0byBub3Qgb3ZlcnJpZGUgYW55IGRlZmF1bHRzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4ge31cclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG9uRWFjaEZlYXR1cmU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggY3JlYXRlZCBgRmVhdHVyZWAsIGFmdGVyIGl0IGhhc1xyXG5cdCAqIGJlZW4gY3JlYXRlZCBhbmQgc3R5bGVkLiBVc2VmdWwgZm9yIGF0dGFjaGluZyBldmVudHMgYW5kIHBvcHVwcyB0byBmZWF0dXJlcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBkbyBub3RoaW5nIHdpdGggdGhlIG5ld2x5IGNyZWF0ZWQgbGF5ZXJzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7fVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBmaWx0ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZWNpZGUgd2hldGhlciB0byBpbmNsdWRlIGEgZmVhdHVyZSBvciBub3QuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gaW5jbHVkZSBhbGwgZmVhdHVyZXM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB0cnVlO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKiBOb3RlOiBkeW5hbWljYWxseSBjaGFuZ2luZyB0aGUgYGZpbHRlcmAgb3B0aW9uIHdpbGwgaGF2ZSBlZmZlY3Qgb25seSBvbiBuZXdseVxyXG5cdCAqIGFkZGVkIGRhdGEuIEl0IHdpbGwgX25vdF8gcmUtZXZhbHVhdGUgYWxyZWFkeSBpbmNsdWRlZCBmZWF0dXJlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY29vcmRzVG9MYXRMbmc6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyBHZW9KU09OIGNvb3JkaW5hdGVzIHRvIGBMYXRMbmdgcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0aGUgYGNvb3Jkc1RvTGF0TG5nYCBzdGF0aWMgbWV0aG9kLlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IExheWVyXHJcblx0Ly8gQWRkcyBhIEdlb0pTT04gb2JqZWN0IHRvIHRoZSBsYXllci5cclxuXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0dmFyIGZlYXR1cmVzID0gTC5VdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXllciA9IEwuR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucyk7XHJcblx0XHRpZiAoIWxheWVyKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0bGF5ZXIuZmVhdHVyZSA9IEwuR2VvSlNPTi5hc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG5cdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG5cdFx0dGhpcy5yZXNldFN0eWxlKGxheWVyKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcblx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVzZXRTdHlsZSggPFBhdGg+IGxheWVyICk6IExheWVyXHJcblx0Ly8gUmVzZXRzIHRoZSBnaXZlbiB2ZWN0b3IgbGF5ZXIncyBzdHlsZSB0byB0aGUgb3JpZ2luYWwgR2VvSlNPTiBzdHlsZSwgdXNlZnVsIGZvciByZXNldHRpbmcgc3R5bGUgYWZ0ZXIgaG92ZXIgZXZlbnRzLlxyXG5cdHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuXHRcdGxheWVyLm9wdGlvbnMgPSBMLlV0aWwuZXh0ZW5kKHt9LCBsYXllci5kZWZhdWx0T3B0aW9ucyk7XHJcblx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCB0aGlzLm9wdGlvbnMuc3R5bGUpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRTdHlsZSggPEZ1bmN0aW9uPiBzdHlsZSApOiBMYXllclxyXG5cdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuTC5leHRlbmQoTC5HZW9KU09OLCB7XHJcblx0Ly8gQGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihmZWF0dXJlRGF0YTogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKTogTGF5ZXJcclxuXHQvLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcblx0Ly8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcblx0Ly8gZnVuY3Rpb25zIGlmIHByb3ZpZGVkIGFzIG9wdGlvbnMuXHJcblx0Z2VvbWV0cnlUb0xheWVyOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0XHQgICAgY29vcmRzID0gZ2VvbWV0cnkgPyBnZW9tZXRyeS5jb29yZGluYXRlcyA6IG51bGwsXHJcblx0XHQgICAgbGF5ZXJzID0gW10sXHJcblx0XHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuXHRcdCAgICBjb29yZHNUb0xhdExuZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb29yZHNUb0xhdExuZyB8fCB0aGlzLmNvb3Jkc1RvTGF0TG5nLFxyXG5cdFx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuXHRcdGlmICghY29vcmRzICYmICFnZW9tZXRyeSkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcclxuXHRcdGNhc2UgJ1BvaW50JzpcclxuXHRcdFx0bGF0bG5nID0gY29vcmRzVG9MYXRMbmcoY29vcmRzKTtcclxuXHRcdFx0cmV0dXJuIHBvaW50VG9MYXllciA/IHBvaW50VG9MYXllcihnZW9qc29uLCBsYXRsbmcpIDogbmV3IEwuTWFya2VyKGxhdGxuZyk7XHJcblxyXG5cdFx0Y2FzZSAnTXVsdGlQb2ludCc6XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IGNvb3Jkc1RvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2gocG9pbnRUb0xheWVyID8gcG9pbnRUb0xheWVyKGdlb2pzb24sIGxhdGxuZykgOiBuZXcgTC5NYXJrZXIobGF0bG5nKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRcdGNhc2UgJ0xpbmVTdHJpbmcnOlxyXG5cdFx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuXHRcdFx0bGF0bG5ncyA9IHRoaXMuY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnID8gMCA6IDEsIGNvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ1BvbHlnb24nOlxyXG5cdFx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuXHRcdFx0bGF0bG5ncyA9IHRoaXMuY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIGNvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Y2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHZhciBsYXllciA9IHRoaXMuZ2VvbWV0cnlUb0xheWVyKHtcclxuXHRcdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldLFxyXG5cdFx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcblx0XHRcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0XHRcdGlmIChsYXllcikge1xyXG5cdFx0XHRcdFx0bGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdlb0pTT04gb2JqZWN0LicpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcblx0Ly8gQ3JlYXRlcyBhIGBMYXRMbmdgIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIDIgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSlcclxuXHQvLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cclxuXHRjb29yZHNUb0xhdExuZzogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhjb29yZHNbMV0sIGNvb3Jkc1swXSwgY29vcmRzWzJdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG5cdC8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuXHQvLyBgbGV2ZWxzRGVlcGAgc3BlY2lmaWVzIHRoZSBuZXN0aW5nIGxldmVsICgwIGlzIGZvciBhbiBhcnJheSBvZiBwb2ludHMsIDEgZm9yIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwb2ludHMsIGV0Yy4sIDAgYnkgZGVmYXVsdCkuXHJcblx0Ly8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG5cdGNvb3Jkc1RvTGF0TG5nczogZnVuY3Rpb24gKGNvb3JkcywgbGV2ZWxzRGVlcCwgY29vcmRzVG9MYXRMbmcpIHtcclxuXHRcdHZhciBsYXRsbmdzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGgsIGxhdGxuZzsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGxhdGxuZyA9IGxldmVsc0RlZXAgP1xyXG5cdFx0XHQgICAgICAgIHRoaXMuY29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNvb3Jkc1RvTGF0TG5nKSA6XHJcblx0XHRcdCAgICAgICAgKGNvb3Jkc1RvTGF0TG5nIHx8IHRoaXMuY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG5cdFx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGF0bG5ncztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nOiBMYXRMbmcpOiBBcnJheVxyXG5cdC8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG5cdGxhdExuZ1RvQ29vcmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0XHRbbGF0bG5nLmxuZywgbGF0bG5nLmxhdCwgbGF0bG5nLmFsdF0gOlxyXG5cdFx0XHRcdFtsYXRsbmcubG5nLCBsYXRsbmcubGF0XTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3M6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjbG9zZWQ/OiBCb29sZWFuKTogQXJyYXlcclxuXHQvLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdzYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmdzKVxyXG5cdC8vIGBjbG9zZWRgIGRldGVybWluZXMgd2hldGhlciB0aGUgZmlyc3QgcG9pbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIGNsb3NlIHRoZSBmZWF0dXJlLCBvbmx5IHVzZWQgd2hlbiBgbGV2ZWxzRGVlcGAgaXMgMC4gRmFsc2UgYnkgZGVmYXVsdC5cclxuXHRsYXRMbmdzVG9Db29yZHM6IGZ1bmN0aW9uIChsYXRsbmdzLCBsZXZlbHNEZWVwLCBjbG9zZWQpIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRjb29yZHMucHVzaChsZXZlbHNEZWVwID9cclxuXHRcdFx0XHRMLkdlb0pTT04ubGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3NbaV0sIGxldmVsc0RlZXAgLSAxLCBjbG9zZWQpIDpcclxuXHRcdFx0XHRMLkdlb0pTT04ubGF0TG5nVG9Db29yZHMobGF0bG5nc1tpXSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghbGV2ZWxzRGVlcCAmJiBjbG9zZWQpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2goY29vcmRzWzBdKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29vcmRzO1xyXG5cdH0sXHJcblxyXG5cdGdldEZlYXR1cmU6IGZ1bmN0aW9uIChsYXllciwgbmV3R2VvbWV0cnkpIHtcclxuXHRcdHJldHVybiBsYXllci5mZWF0dXJlID9cclxuXHRcdFx0XHRMLmV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDpcclxuXHRcdFx0XHRMLkdlb0pTT04uYXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb246IE9iamVjdCk6IE9iamVjdFxyXG5cdC8vIE5vcm1hbGl6ZSBHZW9KU09OIGdlb21ldHJpZXMvZmVhdHVyZXMgaW50byBHZW9KU09OIGZlYXR1cmVzLlxyXG5cdGFzRmVhdHVyZTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuXHRcdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJykge1xyXG5cdFx0XHRyZXR1cm4gZ2VvanNvbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdHByb3BlcnRpZXM6IHt9LFxyXG5cdFx0XHRnZW9tZXRyeTogZ2VvanNvblxyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ1BvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IEwuR2VvSlNPTi5sYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpKVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5NYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENpcmNsZU1hcmtlclxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5MLkNpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuTC5DaXJjbGVNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5bGluZVxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlsaW5lIChhcyBhIEdlb0pTT04gYExpbmVTdHJpbmdgIG9yIGBNdWx0aUxpbmVTdHJpbmdgIEZlYXR1cmUpLlxyXG5MLlBvbHlsaW5lLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIG11bHRpID0gIUwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5ncyk7XHJcblxyXG5cdHZhciBjb29yZHMgPSBMLkdlb0pTT04ubGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMSA6IDApO1xyXG5cclxuXHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdMaW5lU3RyaW5nJyxcclxuXHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHR9KTtcclxufTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWdvblxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcbkwuUG9seWdvbi5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cdHZhciBob2xlcyA9ICFMLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG5cdCAgICBtdWx0aSA9IGhvbGVzICYmICFMLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xyXG5cclxuXHR2YXIgY29vcmRzID0gTC5HZW9KU09OLmxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlKTtcclxuXHJcblx0aWYgKCFob2xlcykge1xyXG5cdFx0Y29vcmRzID0gW2Nvb3Jkc107XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcclxuXHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHR9KTtcclxufTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIExheWVyR3JvdXBcclxuTC5MYXllckdyb3VwLmluY2x1ZGUoe1xyXG5cdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04oKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnTXVsdGlQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBHZW9tZXRyeUNvbGxlY3Rpb25gKS5cclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdHlwZSA9IHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b011bHRpUG9pbnQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSB0eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcclxuXHRcdCAgICBqc29ucyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XHJcblx0XHRcdFx0dmFyIGpzb24gPSBsYXllci50b0dlb0pTT04oKTtcclxuXHRcdFx0XHRqc29ucy5wdXNoKGlzR2VvbWV0cnlDb2xsZWN0aW9uID8ganNvbi5nZW9tZXRyeSA6IEwuR2VvSlNPTi5hc0ZlYXR1cmUoanNvbikpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG5cdFx0XHRmZWF0dXJlczoganNvbnNcclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgR2VvSlNPTlxyXG4vLyBAZmFjdG9yeSBMLmdlb0pTT04oZ2VvanNvbj86IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIEdlb0pTT04gbGF5ZXIuIE9wdGlvbmFsbHkgYWNjZXB0cyBhbiBvYmplY3QgaW5cclxuLy8gW0dlb0pTT04gZm9ybWF0XShodHRwOi8vZ2VvanNvbi5vcmcvZ2VvanNvbi1zcGVjLmh0bWwpIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxyXG4vLyAoeW91IGNhbiBhbHRlcm5hdGl2ZWx5IGFkZCBpdCBsYXRlciB3aXRoIGBhZGREYXRhYCBtZXRob2QpIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5MLmdlb0pTT04gPSBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5HZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59O1xyXG4vLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG5MLmdlb0pzb24gPSBMLmdlb0pTT047XHJcblxuLypcclxuICogQG5hbWVzcGFjZSBEb21FdmVudFxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET00gZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnQpLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG4vLyBJbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMuXHJcblxyXG5cclxuXHJcbnZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbkwuRG9tRXZlbnQgPSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuXHQvLyBlbGVtZW50IGBlbGAuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lclxyXG5cdC8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcblx0Ly8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdG9uOiBmdW5jdGlvbiAob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb24ob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0eXBlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCxcclxuXHQvLyBpdCB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGF0IHBhcnRpY3VsYXIgRE9NIGV2ZW50IGZyb20gdGhlIGVsZW1lbnQuXHJcblx0Ly8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG5cdC8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdG9mZjogZnVuY3Rpb24gKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZihvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHZhciBpZCA9IHR5cGUgKyBMLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgTC5zdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcblx0XHRpZiAob2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRcdHRoaXMuYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoTC5Ccm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiB0aGlzLmFkZERvdWJsZVRhcExpc3RlbmVyKSB7XHJcblx0XHRcdHRoaXMuYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ29ud2hlZWwnIGluIG9iaiA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgfHwgKHR5cGUgPT09ICdtb3VzZWxlYXZlJykpIHtcclxuXHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdFx0XHRcdGlmIChMLkRvbUV2ZW50Ll9pc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyKGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOiAnbW91c2VvdXQnLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICh0eXBlID09PSAnY2xpY2snICYmIEwuQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIEwuRG9tRXZlbnQuX2ZpbHRlckNsaWNrKGUsIG9yaWdpbmFsSGFuZGxlcik7XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCdhdHRhY2hFdmVudCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0b2JqW2V2ZW50c0tleV0gPSBvYmpbZXZlbnRzS2V5XSB8fCB7fTtcclxuXHRcdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHR2YXIgaWQgPSB0eXBlICsgTC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIEwuc3RhbXAoY29udGV4dCkgOiAnJyksXHJcblx0XHQgICAgaGFuZGxlciA9IG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXTtcclxuXHJcblx0XHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaWQpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoTC5Ccm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiB0aGlzLnJlbW92ZURvdWJsZVRhcExpc3RlbmVyKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ud2hlZWwnIGluIG9iaiA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcblx0XHRcdFx0XHR0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6XHJcblx0XHRcdFx0XHR0eXBlID09PSAnbW91c2VsZWF2ZScgPyAnbW91c2VvdXQnIDogdHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldjogRE9NRXZlbnQpOiB0aGlzXHJcblx0Ly8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcblx0Ly8gYGBganNcclxuXHQvLyBMLkRvbUV2ZW50Lm9uKGRpdiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcblx0Ly8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZSkge1xyXG5cclxuXHRcdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0fSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQpIHsgIC8vIEluIGNhc2Ugb2YgTGVhZmxldCBldmVudC5cclxuXHRcdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdEwuRG9tRXZlbnQuX3NraXBwZWQoZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcblx0Ly8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnbW91c2V3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuXHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0cmV0dXJuIEwuRG9tRXZlbnQub24oZWwsICdtb3VzZXdoZWVsJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcblx0Ly8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkb3VibGVjbGljaydgLFxyXG5cdC8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuXHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbjogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR2YXIgc3RvcCA9IEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQub24oZWwsIEwuRHJhZ2dhYmxlLlNUQVJULmpvaW4oJyAnKSwgc3RvcCk7XHJcblxyXG5cdFx0cmV0dXJuIEwuRG9tRXZlbnQub24oZWwsIHtcclxuXHRcdFx0Y2xpY2s6IEwuRG9tRXZlbnQuX2Zha2VTdG9wLFxyXG5cdFx0XHRkYmxjbGljazogc3RvcFxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2OiBET01FdmVudCk6IHRoaXNcclxuXHQvLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXHJcblx0Ly8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG5cdC8vIHdpdGggcGFnZSByZWxvYWQgd2hlbiBhIGA8Zm9ybT5gIGlzIHN1Ym1pdHRlZCkuXHJcblx0Ly8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdFx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHN0b3AoZXYpOiB0aGlzXHJcblx0Ly8gRG9lcyBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBhdCB0aGUgc2FtZSB0aW1lLlxyXG5cdHN0b3A6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudFxyXG5cdFx0XHQucHJldmVudERlZmF1bHQoZSlcclxuXHRcdFx0LnN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuXHQvLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuXHQvLyBgY29udGFpbmVyYCBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG5cdGdldE1vdXNlUG9zaXRpb246IGZ1bmN0aW9uIChlLCBjb250YWluZXIpIHtcclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KFxyXG5cdFx0XHRlLmNsaWVudFggLSByZWN0LmxlZnQgLSBjb250YWluZXIuY2xpZW50TGVmdCxcclxuXHRcdFx0ZS5jbGllbnRZIC0gcmVjdC50b3AgLSBjb250YWluZXIuY2xpZW50VG9wKTtcclxuXHR9LFxyXG5cclxuXHQvLyBDaHJvbWUgb24gV2luIHNjcm9sbHMgZG91YmxlIHRoZSBwaXhlbHMgYXMgaW4gb3RoZXIgcGxhdGZvcm1zIChzZWUgIzQ1MzgpLFxyXG5cdC8vIGFuZCBGaXJlZm94IHNjcm9sbHMgZGV2aWNlIHBpeGVscywgbm90IENTUyBwaXhlbHNcclxuXHRfd2hlZWxQeEZhY3RvcjogKEwuQnJvd3Nlci53aW4gJiYgTC5Ccm93c2VyLmNocm9tZSkgPyAyIDpcclxuXHQgICAgICAgICAgICAgICAgTC5Ccm93c2VyLmdlY2tvID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG5cdCAgICAgICAgICAgICAgICAxLFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShldjogRE9NRXZlbnQpOiBOdW1iZXJcclxuXHQvLyBHZXRzIG5vcm1hbGl6ZWQgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNld2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG5cdC8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG5cdC8vIEV2ZW50cyBmcm9tIHBvaW50aW5nIGRldmljZXMgd2l0aG91dCBwcmVjaXNlIHNjcm9sbGluZyBhcmUgbWFwcGVkIHRvXHJcblx0Ly8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuXHRnZXRXaGVlbERlbHRhOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIChMLkJyb3dzZXIuZWRnZSkgPyBlLndoZWVsRGVsdGFZIC8gMiA6IC8vIERvbid0IHRydXN0IHdpbmRvdy1nZW9tZXRyeS1iYXNlZCBkZWx0YVxyXG5cdFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyBMLkRvbUV2ZW50Ll93aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcblx0XHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuXHRcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDIpID8gLWUuZGVsdGFZICogNjAgOiAvLyBQYWdlc1xyXG5cdFx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuXHRcdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuXHRcdCAgICAgICAoZS5kZXRhaWwgJiYgTWF0aC5hYnMoZS5kZXRhaWwpIDwgMzI3NjUpID8gLWUuZGV0YWlsICogMjAgOiAvLyBMZWdhY3kgTW96IGxpbmVzXHJcblx0XHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG5cdFx0ICAgICAgIDA7XHJcblx0fSxcclxuXHJcblx0X3NraXBFdmVudHM6IHt9LFxyXG5cclxuXHRfZmFrZVN0b3A6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBmYWtlcyBzdG9wUHJvcGFnYXRpb24gYnkgc2V0dGluZyBhIHNwZWNpYWwgZXZlbnQgZmxhZywgY2hlY2tlZC9yZXNldCB3aXRoIEwuRG9tRXZlbnQuX3NraXBwZWQoZSlcclxuXHRcdEwuRG9tRXZlbnQuX3NraXBFdmVudHNbZS50eXBlXSA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0X3NraXBwZWQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2tpcHBlZCA9IHRoaXMuX3NraXBFdmVudHNbZS50eXBlXTtcclxuXHRcdC8vIHJlc2V0IHdoZW4gY2hlY2tpbmcsIGFzIGl0J3Mgb25seSB1c2VkIGluIG1hcCBjb250YWluZXIgYW5kIHByb3BhZ2F0ZXMgb3V0c2lkZSBvZiB0aGUgbWFwXHJcblx0XHR0aGlzLl9za2lwRXZlbnRzW2UudHlwZV0gPSBmYWxzZTtcclxuXHRcdHJldHVybiBza2lwcGVkO1xyXG5cdH0sXHJcblxyXG5cdC8vIGNoZWNrIGlmIGVsZW1lbnQgcmVhbGx5IGxlZnQvZW50ZXJlZCB0aGUgZXZlbnQgdGFyZ2V0IChmb3IgbW91c2VlbnRlci9tb3VzZWxlYXZlKVxyXG5cdF9pc0V4dGVybmFsVGFyZ2V0OiBmdW5jdGlvbiAoZWwsIGUpIHtcclxuXHJcblx0XHR2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcclxuXHJcblx0XHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHR3aGlsZSAocmVsYXRlZCAmJiAocmVsYXRlZCAhPT0gZWwpKSB7XHJcblx0XHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHRoaXMgaXMgYSBob3JyaWJsZSB3b3JrYXJvdW5kIGZvciBhIGJ1ZyBpbiBBbmRyb2lkIHdoZXJlIGEgc2luZ2xlIHRvdWNoIHRyaWdnZXJzIHR3byBjbGljayBldmVudHNcclxuXHRfZmlsdGVyQ2xpY2s6IGZ1bmN0aW9uIChlLCBoYW5kbGVyKSB7XHJcblx0XHR2YXIgdGltZVN0YW1wID0gKGUudGltZVN0YW1wIHx8IChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LnRpbWVTdGFtcCkpLFxyXG5cdFx0ICAgIGVsYXBzZWQgPSBMLkRvbUV2ZW50Ll9sYXN0Q2xpY2sgJiYgKHRpbWVTdGFtcCAtIEwuRG9tRXZlbnQuX2xhc3RDbGljayk7XHJcblxyXG5cdFx0Ly8gYXJlIHRoZXkgY2xvc2VyIHRvZ2V0aGVyIHRoYW4gNTAwbXMgeWV0IG1vcmUgdGhhbiAxMDBtcz9cclxuXHRcdC8vIEFuZHJvaWQgdHlwaWNhbGx5IHRyaWdnZXJzIHRoZW0gfjMwMG1zIGFwYXJ0IHdoaWxlIG11bHRpcGxlIGxpc3RlbmVyc1xyXG5cdFx0Ly8gb24gdGhlIHNhbWUgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZCBmYXIgZmFzdGVyO1xyXG5cdFx0Ly8gb3IgY2hlY2sgaWYgY2xpY2sgaXMgc2ltdWxhdGVkIG9uIHRoZSBlbGVtZW50LCBhbmQgaWYgaXQgaXMsIHJlamVjdCBhbnkgbm9uLXNpbXVsYXRlZCBldmVudHNcclxuXHJcblx0XHRpZiAoKGVsYXBzZWQgJiYgZWxhcHNlZCA+IDEwMCAmJiBlbGFwc2VkIDwgNTAwKSB8fCAoZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrICYmICFlLl9zaW11bGF0ZWQpKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0TC5Eb21FdmVudC5fbGFzdENsaWNrID0gdGltZVN0YW1wO1xyXG5cclxuXHRcdGhhbmRsZXIoZSk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9uYF0oI2RvbWV2ZW50LW9uKVxyXG5MLkRvbUV2ZW50LmFkZExpc3RlbmVyID0gTC5Eb21FdmVudC5vbjtcclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vZmZgXSgjZG9tZXZlbnQtb2ZmKVxyXG5MLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyID0gTC5Eb21FdmVudC5vZmY7XHJcblxuLypcclxuICogQGNsYXNzIERyYWdnYWJsZVxyXG4gKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgbWFwIGFuZCBtYXJrZXIgZHJhZ2dpbmcuIE9ubHkgd29ya3MgZm9yIGVsZW1lbnRzXHJcbiAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAqIGRyYWdnYWJsZS5lbmFibGUoKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5EcmFnZ2FibGUgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG5cdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcblx0fSxcclxuXHJcblx0c3RhdGljczoge1xyXG5cdFx0U1RBUlQ6IEwuQnJvd3Nlci50b3VjaCA/IFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nXSA6IFsnbW91c2Vkb3duJ10sXHJcblx0XHRFTkQ6IHtcclxuXHRcdFx0bW91c2Vkb3duOiAnbW91c2V1cCcsXHJcblx0XHRcdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0XHRcdHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2hlbmQnXHJcblx0XHR9LFxyXG5cdFx0TU9WRToge1xyXG5cdFx0XHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdFx0XHR0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcclxuXHRcdFx0cG9pbnRlcmRvd246ICd0b3VjaG1vdmUnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBjb25zdHJ1Y3RvciBMLkRyYWdnYWJsZShlbDogSFRNTEVsZW1lbnQsIGRyYWdIYW5kbGU/OiBIVE1MRWxlbWVudCwgcHJldmVudE91dGxpbmU6IEJvb2xlYW4pXHJcblx0Ly8gQ3JlYXRlcyBhIGBEcmFnZ2FibGVgIG9iamVjdCBmb3IgbW92aW5nIGBlbGAgd2hlbiB5b3Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGBkcmFnSGFuZGxlYCBlbGVtZW50IChlcXVhbHMgYGVsYCBpdHNlbGYgYnkgZGVmYXVsdCkuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUpIHtcclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZW5hYmxlKClcclxuXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgTC5EcmFnZ2FibGUuU1RBUlQuam9pbignICcpLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcblx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBMLkRyYWdnYWJsZS5TVEFSVC5qb2luKCcgJyksIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChMLkRvbVV0aWwuaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKEwuRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHRcdEwuRHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRydWU7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcblx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcblx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xyXG5cclxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdC5vbihkb2N1bWVudCwgTC5EcmFnZ2FibGUuTU9WRVtlLnR5cGVdLCB0aGlzLl9vbk1vdmUsIHRoaXMpXHJcblx0XHRcdC5vbihkb2N1bWVudCwgTC5EcmFnZ2FibGUuRU5EW2UudHlwZV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgbmV3UG9pbnQgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXdQb2ludC5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XHJcblx0XHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xyXG5cclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9zdGFydFBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KS5zdWJ0cmFjdChvZmZzZXQpO1xyXG5cclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuXHRcdFx0Ly8gaWYgbmVjZXNzYXJ5XHJcblx0XHRcdGlmICgod2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSkgJiYgKHRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50SW5zdGFuY2UpKSB7XHJcblx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlUG9zaXRpb24sIHRoaXMsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcblx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcblx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nLlxyXG5cdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XHJcblx0fSxcclxuXHJcblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIEwuRHJhZ2dhYmxlLk1PVkUpIHtcclxuXHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHRcdC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLk1PVkVbaV0sIHRoaXMuX29uTW92ZSwgdGhpcylcclxuXHRcdFx0XHQub2ZmKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5FTkRbaV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmVkICYmIHRoaXMuX21vdmluZykge1xyXG5cdFx0XHQvLyBlbnN1cmUgZHJhZyBpcyBub3QgZmlyZWQgYWZ0ZXIgZHJhZ2VuZFxyXG5cdFx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHJcblx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZHJhZyBlbmRzLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcblx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdEwuRHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cdH1cclxufSk7XHJcblxuLypcblx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3Rcblx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4qL1xuXG4vLyBAY2xhc3MgSGFuZGxlclxuLy8gQGFrYSBMLkhhbmRsZXJcbi8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuTC5IYW5kbGVyID0gTC5DbGFzcy5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcblx0Ly8gRW5hYmxlcyB0aGUgaGFuZGxlclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5hZGRIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB0aGlzXG5cdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLnJlbW92ZUhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZFxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcblx0fVxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIENsYXNzZXMgaW5oZXJpdGluZyBmcm9tIGBIYW5kbGVyYCBtdXN0IGltcGxlbWVudCB0aGUgdHdvIGZvbGxvd2luZyBtZXRob2RzOlxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGRpc2FibGVkLCBzaG91bGQgcmVtb3ZlIHRoZSBldmVudCBob29rcyBhZGRlZCBwcmV2aW91c2x5LlxufSk7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgYmUgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQgdW5sZXNzIHJ1bm5pbmcgb24gb2xkIEFuZHJvaWQgZGV2aWNlcy5cblx0aW5lcnRpYTogIUwuQnJvd3Nlci5hbmRyb2lkMjMsXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG5cdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cblx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG5cdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG5cdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3NcblxuXHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cblx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcblx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2Vcblx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuXHQvLyBvZiB0aGUgd29ybGQgYW5kIHNlYW1sZXNzbHkganVtcHMgdG8gdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IGFsbCBvdmVybGF5c1xuXHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG5cdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG5cdC8vIEBvcHRpb24gbWF4Qm91bmRzVmlzY29zaXR5OiBOdW1iZXIgPSAwLjBcblx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcblx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcblx0Ly8gdXNlciB0byBkcmFnIG91dHNpZGUgdGhlIGJvdW5kcyBhdCBub3JtYWwgc3BlZWQsIGhpZ2hlciB2YWx1ZXMgd2lsbFxuXHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cblx0bWF4Qm91bmRzVmlzY29zaXR5OiAwLjBcbn0pO1xuXG5MLk1hcC5EcmFnID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShtYXAuX21hcFBhbmUsIG1hcC5fY29udGFpbmVyKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdFx0ZG93bjogdGhpcy5fb25Eb3duLFxuXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcblx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiJyk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAuX3N0b3AoKTtcblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpIHtcblx0XHRcdHZhciBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IEwuYm91bmRzKFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cblx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cblx0XHRcdGlmICh0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9tYXBcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG5cdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcblx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcblx0fSxcblxuXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG5cdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG5cdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cblx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG5cdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuXHR9LFxuXG5cdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG5cdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG5cdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcblx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG5cdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcblx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cblx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHRcdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG5cdFx0XHRcdFx0XHRlYXNlTGluZWFyaXR5OiBlYXNlLFxuXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG5cdFx0XHRcdFx0XHRhbmltYXRlOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbi8vIE1hcCBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIEwuTWFwLkRyYWcpO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkb3VibGVDbGlja1pvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBpbiBieSBkb3VibGUgY2xpY2tpbmcgb24gaXQgYW5kXG5cdC8vIHpvb21lZCBvdXQgYnkgZG91YmxlIGNsaWNraW5nIHdoaWxlIGhvbGRpbmcgc2hpZnQuIElmIHBhc3NlZFxuXHQvLyBgJ2NlbnRlcidgLCBkb3VibGUtY2xpY2sgem9vbSB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGVcblx0Ly8gIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRkb3VibGVDbGlja1pvb206IHRydWVcbn0pO1xuXG5MLk1hcC5Eb3VibGVDbGlja1pvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcblx0XHQgICAgem9vbSA9IGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IG9sZFpvb20gLSBkZWx0YSA6IG9sZFpvb20gKyBkZWx0YTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vXG4vLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbi8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbi8vIGFzIGRyYWdnaW5nIG9yIHRvdWNoIHpvb20gKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEZvciBleGFtcGxlOlxuLy9cbi8vIGBgYGpzXG4vLyBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbi8vIGBgYFxuLy9cbi8vIEBwcm9wZXJ0eSBkb3VibGVDbGlja1pvb206IEhhbmRsZXJcbi8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBMLk1hcC5Eb3VibGVDbGlja1pvb20pO1xuXG4vKlxuICogTC5IYW5kbGVyLlNjcm9sbFdoZWVsWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGVuYWJsZSBtb3VzZSBzY3JvbGwgd2hlZWwgem9vbSBvbiB0aGUgbWFwLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBNb3VzZXdoZWVsIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHBhc3NlZCBgJ2NlbnRlcidgLFxuXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHdoZWVsRGVib3VuY2VUaW1lOiBOdW1iZXIgPSA0MFxuXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cblx0d2hlZWxEZWJvdW5jZVRpbWU6IDQwLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcblx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuXHQvLyBtZWFuIGEgY2hhbmdlIG9mIG9uZSBmdWxsIHpvb20gbGV2ZWwuIFNtYWxsZXIgdmFsdWVzIHdpbGwgbWFrZSB3aGVlbC16b29taW5nXG5cdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxufSk7XG5cbkwuTWFwLlNjcm9sbFdoZWVsWm9vbSA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblx0fSxcblxuXHRfb25XaGVlbFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZGVsdGEgPSBMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGEoZSk7XG5cblx0XHR2YXIgZGVib3VuY2UgPSB0aGlzLl9tYXAub3B0aW9ucy53aGVlbERlYm91bmNlVGltZTtcblxuXHRcdHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuXHRcdHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblx0XHR9XG5cblx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KGRlYm91bmNlIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChMLmJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcblxuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cblx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcblx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIEwuTWFwLlNjcm9sbFdoZWVsWm9vbSk7XG5cbi8qXG4gKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gKiBAYWthIEwuUG9zQW5pbWF0aW9uXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gKiBmeC5ydW4oZWwsIFszMDAsIDUwMF0sIDAuNSk7XG4gKiBgYGBcbiAqXG4gKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAqXG4gKi9cblxuTC5Qb3NBbmltYXRpb24gPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cDovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbihlbCk7XG5cdFx0dGhpcy5fb2Zmc2V0ID0gbmV3UG9zLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKTtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuXHRcdC8vIEBldmVudCBzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzXG5cdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG5cdFx0dGhpcy5fYW5pbWF0ZSgpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc3RvcCgpXG5cdC8vIFN0b3BzIHRoZSBhbmltYXRpb24gKGlmIGN1cnJlbnRseSBydW5uaW5nKS5cblx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3N0ZXAodHJ1ZSk7XG5cdFx0dGhpcy5fY29tcGxldGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGFuaW1hdGlvbiBsb29wXG5cdFx0dGhpcy5fYW5pbUlkID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RlcCgpO1xuXHR9LFxuXG5cdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0cG9zLl9yb3VuZCgpO1xuXHRcdH1cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdC8vIEBldmVudCBlbmQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG5cdFx0dGhpcy5maXJlKCdlbmQnKTtcblx0fSxcblxuXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcblx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCB0aGlzLl9lYXNlT3V0UG93ZXIpO1xuXHR9XG59KTtcblxuLypcbiAqIEV4dGVuZHMgTC5NYXAgdG8gaGFuZGxlIHBhbm5pbmcgYW5pbWF0aW9ucy5cbiAqL1xuXG5MLk1hcC5pbmNsdWRlKHtcblxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XG5cblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcblx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihMLmxhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHRoaXMuX3N0b3AoKTtcblxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xuXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0b3B0aW9ucy56b29tID0gTC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XG5cdFx0XHRcdG9wdGlvbnMucGFuID0gTC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSwgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb259LCBvcHRpb25zLnBhbik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cblx0XHRcdHZhciBtb3ZlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XG5cblx0XHRcdGlmIChtb3ZlZCkge1xuXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xuXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20pO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcblx0XHRvZmZzZXQgPSBMLnBvaW50KG9mZnNldCkucm91bmQoKTtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG5cdFx0fVxuXHRcdC8vIElmIHdlIHBhbiB0b28gZmFyLCBDaHJvbWUgZ2V0cyBpc3N1ZXMgd2l0aCB0aWxlc1xuXHRcdC8vIGFuZCBtYWtlcyB0aGVtIGRpc2FwcGVhciBvciBhcHBlYXIgaW4gdGhlIHdyb25nIHBsYWNlIChzbGlnaHRseSBvZmZzZXQpICMyNjAyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSksIHRoaXMuZ2V0Wm9vbSgpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuXG5cdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcblx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxuXHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcblx0XHR9XG5cblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xuXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkucm91bmQoKTtcblx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9vblBhblRyYW5zaXRpb25TdGVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XG5cdH0sXG5cblx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xuXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuXHR9LFxuXG5cdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xuXHRcdC8vIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBjdXJyZW50IGNlbnRlcnMgaW4gcGl4ZWxzXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9mbG9vcigpO1xuXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSB0b28gZmFyIHVubGVzcyBhbmltYXRlOiB0cnVlIHNwZWNpZmllZCBpbiBvcHRpb25zXG5cdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbi8qXG4gKiBFeHRlbmRzIEwuTWFwIHRvIGhhbmRsZSB6b29tIGFuaW1hdGlvbnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCB6b29tIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxuXHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXG5cdHpvb21BbmltYXRpb246IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBOdW1iZXIgPSA0XG5cdC8vIFdvbid0IGFuaW1hdGUgem9vbSBpZiB0aGUgem9vbSBkaWZmZXJlbmNlIGV4Y2VlZHMgdGhpcyB2YWx1ZS5cblx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNFxufSk7XG5cbnZhciB6b29tQW5pbWF0ZWQgPSBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiBMLkJyb3dzZXIuYW55M2QgJiYgIUwuQnJvd3Nlci5tb2JpbGVPcGVyYTtcblxuaWYgKHpvb21BbmltYXRlZCkge1xuXG5cdEwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkb24ndCBhbmltYXRlIG9uIGJyb3dzZXJzIHdpdGhvdXQgaGFyZHdhcmUtYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnMgb3Igb2xkIEFuZHJvaWQvT3BlcmFcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbjtcblxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xuXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblxuXHRcdFx0dGhpcy5fY3JlYXRlQW5pbVByb3h5KCk7XG5cblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fcHJveHksIEwuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcblx0XHR9XG5cdH0pO1xufVxuXG5MLk1hcC5pbmNsdWRlKCF6b29tQW5pbWF0ZWQgPyB7fSA6IHtcblxuXHRfY3JlYXRlQW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcHJveHkgPSB0aGlzLl9wcm94eSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXByb3h5IGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xuXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xuXG5cdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIHByb3AgPSBMLkRvbVV0aWwuVFJBTlNGT1JNLFxuXHRcdFx0ICAgIHRyYW5zZm9ybSA9IHByb3h5LnN0eWxlW3Byb3BdO1xuXG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHByb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xuXG5cdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxuXHRcdFx0aWYgKHRyYW5zZm9ybSA9PT0gcHJveHkuc3R5bGVbcHJvcF0gJiYgdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xuXHRcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdsb2FkIG1vdmVlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXG5cdFx0XHQgICAgeiA9IHRoaXMuZ2V0Wm9vbSgpO1xuXHRcdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybShwcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSAmJiBlLnByb3BlcnR5TmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+PSAwKSB7XG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xuXHR9LFxuXG5cdF90cnlBbmltYXRlZFpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcblxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgZGlzYWJsZWQsIG5vdCBzdXBwb3J0ZWQgb3Igem9vbSBkaWZmZXJlbmNlIGlzIHRvbyBsYXJnZVxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XG5cdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpO1xuXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiB0aGUgem9vbSBvcmlnaW4gaXNuJ3Qgd2l0aGluIG9uZSBzY3JlZW4gZnJvbSB0aGUgY3VycmVudCBjZW50ZXIsIHVubGVzcyBmb3JjZWRcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpc1xuXHRcdFx0ICAgIC5fbW92ZVN0YXJ0KHRydWUpXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xuXHRcdH0sIHRoaXMpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xuXHRcdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IHRydWU7XG5cblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvQ2VudGVyID0gY2VudGVyO1xuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XG5cblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcblx0XHR9XG5cblx0XHQvLyBAZXZlbnQgem9vbWFuaW06IFpvb21BbmltRXZlbnRcblx0XHQvLyBGaXJlZCBvbiBldmVyeSBmcmFtZSBvZiBhIHpvb20gYW5pbWF0aW9uXG5cdFx0dGhpcy5maXJlKCd6b29tYW5pbScsIHtcblx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0em9vbTogem9vbSxcblx0XHRcdG5vVXBkYXRlOiBub1VwZGF0ZVxuXHRcdH0pO1xuXG5cdFx0Ly8gV29yayBhcm91bmQgd2Via2l0IG5vdCBmaXJpbmcgJ3RyYW5zaXRpb25lbmQnLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzY4OSwgMjY5M1xuXHRcdHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQsIHRoaXMpLCAyNTApO1xuXHR9LFxuXG5cdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xuXG5cdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20pO1xuXG5cdFx0Ly8gVGhpcyBhbmltIGZyYW1lIHNob3VsZCBwcmV2ZW50IGFuIG9ic2N1cmUgaU9TIHdlYmtpdCB0aWxlIGxvYWRpbmcgcmFjZSBjb25kaXRpb24uXG5cdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbW92ZUVuZCh0cnVlKTtcblx0XHR9LCB0aGlzKTtcblx0fVxufSk7XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXG5MLk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGZseVRvKGxhdGxuZzogTGF0TG5nLCB6b29tPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cblx0Zmx5VG86IGZ1bmN0aW9uICh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpIHtcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8ICFMLkJyb3dzZXIuYW55M2QpIHtcblx0XHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdG9wKCk7XG5cblx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcblx0XHQgICAgdG8gPSB0aGlzLnByb2plY3QodGFyZ2V0Q2VudGVyKSxcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxuXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xuXG5cdFx0dGFyZ2V0Q2VudGVyID0gTC5sYXRMbmcodGFyZ2V0Q2VudGVyKTtcblx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcblxuXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcblx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXG5cdFx0ICAgIHUxID0gKHRvLmRpc3RhbmNlVG8oZnJvbSkpIHx8IDEsXG5cdFx0ICAgIHJobyA9IDEuNDIsXG5cdFx0ICAgIHJobzIgPSByaG8gKiByaG87XG5cblx0XHRmdW5jdGlvbiByKGkpIHtcblx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXG5cdFx0XHQgICAgczIgPSBpID8gdzEgOiB3MCxcblx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXG5cdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXG5cdFx0XHQgICAgYiA9IHQxIC8gYjEsXG5cdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XG5cblx0XHRcdCAgICAvLyB3b3JrYXJvdW5kIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gYnVnIHdoZW4gc3EgPSAwLCBsb2cgPSAtSW5maW5pdGUsXG5cdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cblx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcblxuXHRcdFx0cmV0dXJuIGxvZztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XG5cdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxuXHRcdGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cblxuXHRcdHZhciByMCA9IHIoMCk7XG5cblx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxuXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XG5cblx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxuXG5cdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcblx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxuXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xuXG5cdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XG5cdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXG5cdFx0XHQgICAgcyA9IGVhc2VPdXQodCkgKiBTO1xuXG5cdFx0XHRpZiAodCA8PSAxKSB7XG5cdFx0XHRcdHRoaXMuX2ZseVRvRnJhbWUgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XG5cblx0XHRcdFx0dGhpcy5fbW92ZShcblx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxuXHRcdFx0XHRcdHRoaXMuZ2V0U2NhbGVab29tKHcwIC8gdyhzKSwgc3RhcnRab29tKSxcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXG5cdFx0XHRcdFx0Ll9tb3ZlRW5kKHRydWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlKTtcblxuXHRcdGZyYW1lLmNhbGwodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXG5cdC8vIGJ1dCB0YWtlcyBhIGJvdW5kcyBwYXJhbWV0ZXIgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xuXHRcdHJldHVybiB0aGlzLmZseVRvKHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcblx0fVxufSk7XG5cbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICovXHJcblxyXG5MLmV4dGVuZChMLkRvbUV2ZW50LCB7XHJcblxyXG5cdF90b3VjaHN0YXJ0OiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nIDogTC5Ccm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcmRvd24nIDogJ3RvdWNoc3RhcnQnLFxyXG5cdF90b3VjaGVuZDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiBMLkJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVydXAnIDogJ3RvdWNoZW5kJyxcclxuXHJcblx0Ly8gaW5zcGlyZWQgYnkgWmVwdG8gdG91Y2ggY29kZSBieSBUaG9tYXMgRnVjaHNcclxuXHRhZGREb3VibGVUYXBMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgaGFuZGxlciwgaWQpIHtcclxuXHRcdHZhciBsYXN0LCB0b3VjaCxcclxuXHRcdCAgICBkb3VibGVUYXAgPSBmYWxzZSxcclxuXHRcdCAgICBkZWxheSA9IDI1MDtcclxuXHJcblx0XHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xyXG5cdFx0XHR2YXIgY291bnQ7XHJcblxyXG5cdFx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0XHRjb3VudCA9IEwuRG9tRXZlbnQuX3BvaW50ZXJzQ291bnQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y291bnQgPSBlLnRvdWNoZXMubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoY291bnQgPiAxKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdFx0dmFyIG5vdyA9IERhdGUubm93KCksXHJcblx0XHRcdCAgICBkZWx0YSA9IG5vdyAtIChsYXN0IHx8IG5vdyk7XHJcblxyXG5cdFx0XHR0b3VjaCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblx0XHRcdGRvdWJsZVRhcCA9IChkZWx0YSA+IDAgJiYgZGVsdGEgPD0gZGVsYXkpO1xyXG5cdFx0XHRsYXN0ID0gbm93O1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG9uVG91Y2hFbmQoKSB7XHJcblx0XHRcdGlmIChkb3VibGVUYXAgJiYgIXRvdWNoLmNhbmNlbEJ1YmJsZSkge1xyXG5cdFx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdFx0Ly8gd29yayBhcm91bmQgLnR5cGUgYmVpbmcgcmVhZG9ubHkgd2l0aCBNU1BvaW50ZXIqIGV2ZW50c1xyXG5cdFx0XHRcdFx0dmFyIG5ld1RvdWNoID0ge30sXHJcblx0XHRcdFx0XHQgICAgcHJvcCwgaTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGkgaW4gdG91Y2gpIHtcclxuXHRcdFx0XHRcdFx0cHJvcCA9IHRvdWNoW2ldO1xyXG5cdFx0XHRcdFx0XHRuZXdUb3VjaFtpXSA9IHByb3AgJiYgcHJvcC5iaW5kID8gcHJvcC5iaW5kKHRvdWNoKSA6IHByb3A7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0b3VjaCA9IG5ld1RvdWNoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0b3VjaC50eXBlID0gJ2RibGNsaWNrJztcclxuXHRcdFx0XHRoYW5kbGVyKHRvdWNoKTtcclxuXHRcdFx0XHRsYXN0ID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJyxcclxuXHRcdCAgICB0b3VjaHN0YXJ0ID0gdGhpcy5fdG91Y2hzdGFydCxcclxuXHRcdCAgICB0b3VjaGVuZCA9IHRoaXMuX3RvdWNoZW5kO1xyXG5cclxuXHRcdG9ialtwcmUgKyB0b3VjaHN0YXJ0ICsgaWRdID0gb25Ub3VjaFN0YXJ0O1xyXG5cdFx0b2JqW3ByZSArIHRvdWNoZW5kICsgaWRdID0gb25Ub3VjaEVuZDtcclxuXHRcdG9ialtwcmUgKyAnZGJsY2xpY2snICsgaWRdID0gaGFuZGxlcjtcclxuXHJcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0b3VjaHN0YXJ0LCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcclxuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRvdWNoZW5kLCBvblRvdWNoRW5kLCBmYWxzZSk7XHJcblxyXG5cdFx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgKG5vdGFibHksIGNocm9tZSBvbiB3aW4xMCArIHRvdWNoc2NyZWVuICsgbW91c2UpLFxyXG5cdFx0Ly8gdGhlIGJyb3dzZXIgZG9lc24ndCBmaXJlIHRvdWNoZW5kL3BvaW50ZXJ1cCBldmVudHMgYnV0IGRvZXMgZmlyZVxyXG5cdFx0Ly8gbmF0aXZlIGRibGNsaWNrcy4gU2VlICM0MTI3LlxyXG5cdFx0aWYgKCFMLkJyb3dzZXIuZWRnZSkge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIGlkKSB7XHJcblx0XHR2YXIgcHJlID0gJ19sZWFmbGV0XycsXHJcblx0XHQgICAgdG91Y2hzdGFydCA9IG9ialtwcmUgKyB0aGlzLl90b3VjaHN0YXJ0ICsgaWRdLFxyXG5cdFx0ICAgIHRvdWNoZW5kID0gb2JqW3ByZSArIHRoaXMuX3RvdWNoZW5kICsgaWRdLFxyXG5cdFx0ICAgIGRibGNsaWNrID0gb2JqW3ByZSArICdkYmxjbGljaycgKyBpZF07XHJcblxyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fdG91Y2hzdGFydCwgdG91Y2hzdGFydCwgZmFsc2UpO1xyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fdG91Y2hlbmQsIHRvdWNoZW5kLCBmYWxzZSk7XHJcblx0XHRpZiAoIUwuQnJvd3Nlci5lZGdlKSB7XHJcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGRibGNsaWNrLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXG4vKlxuICogRXh0ZW5kcyBMLkRvbUV2ZW50IHRvIHByb3ZpZGUgdG91Y2ggc3VwcG9ydCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIFdpbmRvd3MtYmFzZWQgZGV2aWNlcy5cbiAqL1xuXG5MLmV4dGVuZChMLkRvbUV2ZW50LCB7XG5cblx0UE9JTlRFUl9ET1dOOiAgIEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bicsXG5cdFBPSU5URVJfTU9WRTogICBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnICAgOiAncG9pbnRlcm1vdmUnLFxuXHRQT0lOVEVSX1VQOiAgICAgTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgICAgIDogJ3BvaW50ZXJ1cCcsXG5cdFBPSU5URVJfQ0FOQ0VMOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCcsXG5cdFRBR19XSElURV9MSVNUOiBbJ0lOUFVUJywgJ1NFTEVDVCcsICdPUFRJT04nXSxcblxuXHRfcG9pbnRlcnM6IHt9LFxuXHRfcG9pbnRlcnNDb3VudDogMCxcblxuXHQvLyBQcm92aWRlcyBhIHRvdWNoIGV2ZW50cyB3cmFwcGVyIGZvciAobXMpcG9pbnRlciBldmVudHMuXG5cdC8vIHJlZiBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cblx0YWRkUG9pbnRlckxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXG5cdFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdFx0dGhpcy5fYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdFx0dGhpcy5fYWRkUG9pbnRlck1vdmUob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRcdHRoaXMuX2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBpZCkge1xuXHRcdHZhciBoYW5kbGVyID0gb2JqWydfbGVhZmxldF8nICsgdHlwZSArIGlkXTtcblxuXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9ET1dOLCBoYW5kbGVyLCBmYWxzZSk7XG5cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfTU9WRSwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9DQU5DRUwsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfYWRkUG9pbnRlclN0YXJ0OiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xuXHRcdHZhciBvbkRvd24gPSBMLmJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChlLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnICYmIGUucG9pbnRlclR5cGUgIT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UpIHtcblx0XHRcdFx0Ly8gSW4gSUUxMSwgc29tZSB0b3VjaCBldmVudHMgbmVlZHMgdG8gZmlyZSBmb3IgZm9ybSBjb250cm9scywgb3Jcblx0XHRcdFx0Ly8gdGhlIGNvbnRyb2xzIHdpbGwgc3RvcCB3b3JraW5nLiBXZSBrZWVwIGEgd2hpdGVsaXN0IG9mIHRhZyBuYW1lcyB0aGF0XG5cdFx0XHRcdC8vIG5lZWQgdGhlc2UgZXZlbnRzLiBGb3Igb3RoZXIgdGFyZ2V0IHRhZ3MsIHdlIHByZXZlbnQgZGVmYXVsdCBvbiB0aGUgZXZlbnQuXG5cdFx0XHRcdGlmICh0aGlzLlRBR19XSElURV9MSVNULmluZGV4T2YoZS50YXJnZXQudGFnTmFtZSkgPCAwKSB7XG5cdFx0XHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5faGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdG9ialsnX2xlYWZsZXRfdG91Y2hzdGFydCcgKyBpZF0gPSBvbkRvd247XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0RPV04sIG9uRG93biwgZmFsc2UpO1xuXG5cdFx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdFx0aWYgKCF0aGlzLl9wb2ludGVyRG9jTGlzdGVuZXIpIHtcblx0XHRcdHZhciBwb2ludGVyVXAgPSBMLmJpbmQodGhpcy5fZ2xvYmFsUG9pbnRlclVwLCB0aGlzKTtcblxuXHRcdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50RWxlbWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9ET1dOLCBMLmJpbmQodGhpcy5fZ2xvYmFsUG9pbnRlckRvd24sIHRoaXMpLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9NT1ZFLCBMLmJpbmQodGhpcy5fZ2xvYmFsUG9pbnRlck1vdmUsIHRoaXMpLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9VUCwgcG9pbnRlclVwLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9DQU5DRUwsIHBvaW50ZXJVcCwgdHJ1ZSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9nbG9iYWxQb2ludGVyRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHRcdHRoaXMuX3BvaW50ZXJzQ291bnQrKztcblx0fSxcblxuXHRfZ2xvYmFsUG9pbnRlck1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuXHRcdFx0dGhpcy5fcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0XHR9XG5cdH0sXG5cblx0X2dsb2JhbFBvaW50ZXJVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRkZWxldGUgdGhpcy5fcG9pbnRlcnNbZS5wb2ludGVySWRdO1xuXHRcdHRoaXMuX3BvaW50ZXJzQ291bnQtLTtcblx0fSxcblxuXHRfaGFuZGxlUG9pbnRlcjogZnVuY3Rpb24gKGUsIGhhbmRsZXIpIHtcblx0XHRlLnRvdWNoZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3BvaW50ZXJzKSB7XG5cdFx0XHRlLnRvdWNoZXMucHVzaCh0aGlzLl9wb2ludGVyc1tpXSk7XG5cdFx0fVxuXHRcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0XHRoYW5kbGVyKGUpO1xuXHR9LFxuXG5cdF9hZGRQb2ludGVyTW92ZTogZnVuY3Rpb24gKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0XHR2YXIgb25Nb3ZlID0gTC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHQvLyBkb24ndCBmaXJlIHRvdWNoIG1vdmVzIHdoZW4gbW91c2UgaXNuJ3QgZG93blxuXHRcdFx0aWYgKChlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmIGUuYnV0dG9ucyA9PT0gMCkgeyByZXR1cm47IH1cblxuXHRcdFx0dGhpcy5faGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdG9ialsnX2xlYWZsZXRfdG91Y2htb3ZlJyArIGlkXSA9IG9uTW92ZTtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfTU9WRSwgb25Nb3ZlLCBmYWxzZSk7XG5cdH0sXG5cblx0X2FkZFBvaW50ZXJFbmQ6IGZ1bmN0aW9uIChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdFx0dmFyIG9uVXAgPSBMLmJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRcdHRoaXMuX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHRvYmpbJ19sZWFmbGV0X3RvdWNoZW5kJyArIGlkXSA9IG9uVXA7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX1VQLCBvblVwLCBmYWxzZSk7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0NBTkNFTCwgb25VcCwgZmFsc2UpO1xuXHR9XG59KTtcblxuLypcbiAqIEwuSGFuZGxlci5Ub3VjaFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBhZGQgcGluY2ggem9vbSBvbiBzdXBwb3J0ZWQgbW9iaWxlIGJyb3dzZXJzLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdG91Y2gtZHJhZ2dpbmcgd2l0aCB0d28gZmluZ2Vycy4gSWZcblx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Zcblx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcblx0Ly8gYnJvd3NlcnMgZXhjZXB0IGZvciBvbGQgQW5kcm9pZHMuXG5cdHRvdWNoWm9vbTogTC5Ccm93c2VyLnRvdWNoICYmICFMLkJyb3dzZXIuYW5kcm9pZDIzLFxuXG5cdC8vIEBvcHRpb24gYm91bmNlQXRab29tTGltaXRzOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byB6b29tIGJleW9uZCBtaW4vbWF4IHpvb21cblx0Ly8gYW5kIHRoZW4gYm91bmNlIGJhY2sgd2hlbiBwaW5jaC16b29taW5nLlxuXHRib3VuY2VBdFpvb21MaW1pdHM6IHRydWVcbn0pO1xuXG5MLk1hcC5Ub3VjaFpvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0ICAgIC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKVxuXHRcdCAgICAub24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG5cdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cblxuXHRcdHRoaXMuX3pvb20gPSBtYXAuZ2V0U2NhbGVab29tKHNjYWxlLCB0aGlzLl9zdGFydFpvb20pO1xuXG5cdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuXHRcdFx0KHRoaXMuX3pvb20gPCBtYXAuZ2V0TWluWm9vbSgpICYmIHNjYWxlIDwgMSkgfHxcblx0XHRcdCh0aGlzLl96b29tID4gbWFwLmdldE1heFpvb20oKSAmJiBzY2FsZSA+IDEpKSkge1xuXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcblx0XHRcdGlmIChzY2FsZSA9PT0gMSkgeyByZXR1cm47IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG5cdFx0XHR2YXIgZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRcdGlmIChzY2FsZSA9PT0gMSAmJiBkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHsgcmV0dXJuOyB9XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSk7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHR2YXIgbW92ZUZuID0gTC5iaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSk7XG5cdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShtb3ZlRm4sIHRoaXMsIHRydWUpO1xuXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQgfHwgIXRoaXMuX3pvb21pbmcpIHtcblx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSlcblx0XHQgICAgLm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG5cblx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG5cdFx0XHR0aGlzLl9tYXAuX2FuaW1hdGVab29tKHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSksIHRydWUsIHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fbWFwLl9yZXNldFZpZXcodGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbi8vIFRvdWNoIHpvb20gaGFuZGxlci5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIEwuTWFwLlRvdWNoWm9vbSk7XG5cbi8qXG4gKiBMLk1hcC5UYXAgaXMgdXNlZCB0byBlbmFibGUgbW9iaWxlIGhhY2tzIGxpa2UgcXVpY2sgdGFwcyBhbmQgbG9uZyBob2xkLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdGFwOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBFbmFibGVzIG1vYmlsZSBoYWNrcyBmb3Igc3VwcG9ydGluZyBpbnN0YW50IHRhcHMgKGZpeGluZyAyMDBtcyBjbGlja1xuXHQvLyBkZWxheSBvbiBpT1MvQW5kcm9pZCkgYW5kIHRvdWNoIGhvbGRzIChmaXJlZCBhcyBgY29udGV4dG1lbnVgIGV2ZW50cykuXG5cdHRhcDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcblx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcblx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5MLk1hcC5UYXAgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMpIHsgcmV0dXJuOyB9XG5cblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXG5cdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcblxuXHRcdC8vIGRvbid0IHNpbXVsYXRlIGNsaWNrIG9yIHRyYWNrIGxvbmdwcmVzcyBpZiBtb3JlIHRoYW4gMSB0b3VjaFxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXSxcblx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXG5cdFx0Ly8gaWYgdG91Y2hpbmcgYSBsaW5rLCBoaWdobGlnaHQgaXRcblx0XHRpZiAoZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHR9XG5cblx0XHQvLyBzaW11bGF0ZSBsb25nIGhvbGQgYnV0IHNldHRpbmcgYSB0aW1lb3V0XG5cdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KEwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vblVwKCk7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpLCAxMDAwKTtcblxuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlZG93bicsIGZpcnN0KTtcblxuXHRcdEwuRG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9maXJlQ2xpY2sgJiYgZSAmJiBlLmNoYW5nZWRUb3VjaGVzKSB7XG5cblx0XHRcdHZhciBmaXJzdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0sXG5cdFx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHRcdGlmIChlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNldXAnLCBmaXJzdCk7XG5cblx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZW1vdmUnLCBmaXJzdCk7XG5cdH0sXG5cblx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG5cdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblx0XHRlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgPSB0cnVlO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoXG5cdFx0ICAgICAgICB0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsXG5cdFx0ICAgICAgICBlLnNjcmVlblgsIGUuc2NyZWVuWSxcblx0XHQgICAgICAgIGUuY2xpZW50WCwgZS5jbGllbnRZLFxuXHRcdCAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRhcDogSGFuZGxlclxuLy8gTW9iaWxlIHRvdWNoIGhhY2tzIChxdWljayB0YXAgYW5kIHRvdWNoIGhvbGQpIGhhbmRsZXIuXG5pZiAoTC5Ccm93c2VyLnRvdWNoICYmICFMLkJyb3dzZXIucG9pbnRlcikge1xuXHRMLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXAnLCBMLk1hcC5UYXApO1xufVxuXG4vKlxuICogTC5IYW5kbGVyLkJveFpvb20gaXMgdXNlZCB0byBhZGQgc2hpZnQtZHJhZyB6b29tIGludGVyYWN0aW9uIHRvIHRoZSBtYXBcbiAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGJveFpvb206IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcblx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG5cdGJveFpvb206IHRydWVcbn0pO1xuXG5MLk1hcC5Cb3hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG5cdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0TC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRMLkRvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogTC5Eb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEwuQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHR9LFxuXG5cdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fYm94KTtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXHRcdH1cblxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBMLkRvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9maW5pc2goKTtcblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gUG9zdHBvbmUgdG8gbmV4dCBKUyB0aWNrIHNvIGludGVybmFsIGNsaWNrIGV2ZW50IGhhbmRsaW5nXG5cdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cblx0XHRzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG5cdFx0dGhpcy5fbWFwXG5cdFx0XHQuZml0Qm91bmRzKGJvdW5kcylcblx0XHRcdC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuLy8gQm94IChzaGlmdC1kcmFnIHdpdGggbW91c2UpIHpvb20gaGFuZGxlci5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBMLk1hcC5Cb3hab29tKTtcblxuLypcbiAqIEwuTWFwLktleWJvYXJkIGlzIGhhbmRsaW5nIGtleWJvYXJkIGludGVyYWN0aW9uIHdpdGggdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBLZXlib2FyZCBOYXZpZ2F0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG5cdC8vIGFycm93cyBhbmQgYCtgL2AtYCBrZXlzLlxuXHRrZXlib2FyZDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG5cdC8vIEFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIHdoZW4gcHJlc3NpbmcgYW4gYXJyb3cga2V5LlxuXHRrZXlib2FyZFBhbkRlbHRhOiA4MFxufSk7XG5cbkwuTWFwLktleWJvYXJkID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cblx0a2V5Q29kZXM6IHtcblx0XHRsZWZ0OiAgICBbMzddLFxuXHRcdHJpZ2h0OiAgIFszOV0sXG5cdFx0ZG93bjogICAgWzQwXSxcblx0XHR1cDogICAgICBbMzhdLFxuXHRcdHpvb21JbjogIFsxODcsIDEwNywgNjEsIDE3MV0sXG5cdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR0aGlzLl9zZXRQYW5EZWx0YShtYXAub3B0aW9ucy5rZXlib2FyZFBhbkRlbHRhKTtcblx0XHR0aGlzLl9zZXRab29tRGVsdGEobWFwLm9wdGlvbnMuem9vbURlbHRhKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPD0gMCkge1xuXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xuXHRcdH1cblxuXHRcdEwuRG9tRXZlbnQub24oY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vbih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVtb3ZlSG9va3MoKTtcblxuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vZmYoe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZm9jdXNlZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0ICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8IGRvY0VsLnNjcm9sbFRvcCxcblx0XHQgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xuXG5cdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuXHRcdHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuXHR9LFxuXG5cdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IHRydWU7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2ZvY3VzJyk7XG5cdH0sXG5cblx0X29uQmx1cjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuXHR9LFxuXG5cdF9zZXRQYW5EZWx0YTogZnVuY3Rpb24gKHBhbkRlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMucmlnaHRbaV1dID0gW3BhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5EZWx0YV07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbkRlbHRhXTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21EZWx0YTogZnVuY3Rpb24gKHpvb21EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fem9vbUtleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb21EZWx0YTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbU91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tRGVsdGE7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9mZnNldDtcblxuXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuXG5cdFx0XHRpZiAobWFwLl9wYW5BbmltICYmIG1hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuXHRcdFx0aWYgKGUuc2hpZnRLZXkpIHtcblx0XHRcdFx0b2Zmc2V0ID0gTC5wb2ludChvZmZzZXQpLm11bHRpcGx5QnkoMyk7XG5cdFx0XHR9XG5cblx0XHRcdG1hcC5wYW5CeShvZmZzZXQpO1xuXG5cdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNykge1xuXHRcdFx0bWFwLmNsb3NlUG9wdXAoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbi8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2tleWJvYXJkJywgTC5NYXAuS2V5Ym9hcmQpO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLlxuICovXG5cbkwuSGFuZGxlci5NYXJrZXJEcmFnID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5lbmFibGUoKTtcblxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhpY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kcmFnZ2FibGUub2ZmKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5kaXNhYmxlKCk7XG5cblx0XHRpZiAodGhpcy5fbWFya2VyLl9pY29uKSB7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIEBzZWN0aW9uIERyYWdnaW5nIGV2ZW50c1xuXHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0YXJ0cyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXG5cdFx0dGhpcy5fb2xkTGF0TG5nID0gdGhpcy5fbWFya2VyLmdldExhdExuZygpO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuY2xvc2VQb3B1cCgpXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcblx0XHQgICAgaWNvblBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHNoYWRvdywgaWNvblBvcyk7XG5cdFx0fVxuXG5cdFx0bWFya2VyLl9sYXRsbmcgPSBsYXRsbmc7XG5cdFx0ZS5sYXRsbmcgPSBsYXRsbmc7XG5cdFx0ZS5vbGRMYXRMbmcgPSB0aGlzLl9vbGRMYXRMbmc7XG5cblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBtYXJrZXIuXG5cdFx0bWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblx0XHRkZWxldGUgdGhpcy5fb2xkTGF0TG5nO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbFxyXG4gKiBAYWthIEwuQ29udHJvbFxyXG4gKlxyXG4gKiBMLkNvbnRyb2wgaXMgYSBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgbWFwIGNvbnRyb2xzLiBIYW5kbGVzIHBvc2l0aW9uaW5nLlxyXG4gKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICovXHJcblxyXG5MLkNvbnRyb2wgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuXHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXHJcblx0XHQvLyBgJ3RvcHJpZ2h0J2AsIGAnYm90dG9tbGVmdCdgIG9yIGAnYm90dG9tcmlnaHQnYFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgTC5Db250cm9sIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHQgKi9cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBjb250cm9sIHRvIHRoZSBnaXZlbiBtYXAuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMucmVtb3ZlKCk7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuXHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcblx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcblx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG5cdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB7XHJcblx0XHRcdHRoaXMub25SZW1vdmUodGhpcy5fbWFwKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yZWZvY3VzT25NYXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBpZiBtYXAgZXhpc3RzIGFuZCBldmVudCBpcyBub3QgYSBrZXlib2FyZCBldmVudFxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiBlICYmIGUuc2NyZWVuWCA+IDAgJiYgZS5zY3JlZW5ZID4gMCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbChvcHRpb25zKTtcclxufTtcclxuXHJcbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAqIEB1bmluaGVyaXRhYmxlXHJcbiAqXHJcbiAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudFxyXG4gKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICpcclxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcClcclxuICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gKi9cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICovXHJcbkwuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG5cdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG5cdFx0ICAgICAgICAgICAgTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgbCArICdjb250cm9sLWNvbnRhaW5lcicsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQ29ybmVyKHZTaWRlLCBoU2lkZSkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gbCArIHZTaWRlICsgJyAnICsgbCArIGhTaWRlO1xyXG5cclxuXHRcdFx0Y29ybmVyc1t2U2lkZSArIGhTaWRlXSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAncmlnaHQnKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG5cdH1cclxufSk7XHJcblxuLypcclxuICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gKiBAYWthIEwuQ29udHJvbC5ab29tXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIEEgYmFzaWMgem9vbSBjb250cm9sIHdpdGggdHdvIGJ1dHRvbnMgKHpvb20gaW4gYW5kIHpvb20gb3V0KS4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB0byBgZmFsc2VgLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuWm9vbSA9IEwuQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLlpvb20gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnKydcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRleHQ6ICcrJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRpdGxlOiBTdHJpbmcgPSAnWm9vbSBpbidcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRleHQ6IFN0cmluZyA9ICctJ1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUZXh0OiAnLScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcblx0XHQgICAgY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2Jywgem9vbU5hbWUgKyAnIGxlYWZsZXQtYmFyJyksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbUluVGV4dCwgb3B0aW9ucy56b29tSW5UaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLWluJywgIGNvbnRhaW5lciwgdGhpcy5fem9vbUluKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tT3V0VGV4dCwgb3B0aW9ucy56b29tT3V0VGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1vdXQnLCBjb250YWluZXIsIHRoaXMuX3pvb21PdXQpO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRtYXAub24oJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub2ZmKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPCB0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdHRoaXMuX21hcC56b29tSW4odGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF96b29tT3V0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPiB0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdHRoaXMuX21hcC56b29tT3V0KHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbiAoaHRtbCwgdGl0bGUsIGNsYXNzTmFtZSwgY29udGFpbmVyLCBmbikge1xyXG5cdFx0dmFyIGxpbmsgPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuXHRcdEwuRG9tRXZlbnRcclxuXHRcdCAgICAub24obGluaywgJ21vdXNlZG93biBkYmxjbGljaycsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxyXG5cdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCBMLkRvbUV2ZW50LnN0b3ApXHJcblx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKVxyXG5cdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBsaW5rO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIHpvb21Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW3pvb20gY29udHJvbF0oI2NvbnRyb2wtem9vbSkgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdHpvb21Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTC5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgTC5Db250cm9sLlpvb20oKTtcclxuXHRcdHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLlpvb21cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnpvb20ob3B0aW9uczogQ29udHJvbC5ab29tIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSB6b29tIGNvbnRyb2xcclxuTC5jb250cm9sLnpvb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sLlpvb20ob3B0aW9ucyk7XHJcbn07XHJcblxuLypcclxuICogQGNsYXNzIENvbnRyb2wuQXR0cmlidXRpb25cclxuICogQGFrYSBMLkNvbnRyb2wuQXR0cmlidXRpb25cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogVGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wgYWxsb3dzIHlvdSB0byBkaXNwbGF5IGF0dHJpYnV0aW9uIGRhdGEgaW4gYSBzbWFsbCB0ZXh0IGJveCBvbiBhIG1hcC4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2BhdHRyaWJ1dGlvbkNvbnRyb2xgIG9wdGlvbl0oI21hcC1hdHRyaWJ1dGlvbmNvbnRyb2wpIHRvIGBmYWxzZWAsIGFuZCBpdCBmZXRjaGVzIGF0dHJpYnV0aW9uIHRleHRzIGZyb20gbGF5ZXJzIHdpdGggdGhlIFtgZ2V0QXR0cmlidXRpb25gIG1ldGhvZF0oI2xheWVyLWdldGF0dHJpYnV0aW9uKSBhdXRvbWF0aWNhbGx5LiBFeHRlbmRzIENvbnRyb2wuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sLkF0dHJpYnV0aW9uID0gTC5Db250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcHJlZml4OiBTdHJpbmcgPSAnTGVhZmxldCdcclxuXHRcdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHA6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj5MZWFmbGV0PC9hPidcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuXHRcdGlmIChMLkRvbUV2ZW50KSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHRleHQgYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuXHJcblx0c2V0UHJlZml4OiBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGF0dHJpYnV0aW9uIHRleHQgKGUuZy4gYCdWZWN0b3IgZGF0YSAmY29weTsgTWFwYm94J2ApLlxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBMLkNvbnRyb2wuQXR0cmlidXRpb24oKS5hZGRUbyh0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLkF0dHJpYnV0aW9uXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5hdHRyaWJ1dGlvbihvcHRpb25zOiBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbC5cclxuTC5jb250cm9sLmF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5BdHRyaWJ1dGlvbihvcHRpb25zKTtcclxufTtcclxuXG4vKlxuICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxuICpcbiAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5MLkNvbnRyb2wuU2NhbGUgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcblx0XHQvLyBNYXhpbXVtIHdpZHRoIG9mIHRoZSBjb250cm9sIGluIHBpeGVscy4gVGhlIHdpZHRoIGlzIHNldCBkeW5hbWljYWxseSB0byBzaG93IHJvdW5kIHZhbHVlcyAoZS5nLiAxMDAsIDIwMCwgNTAwKS5cblx0XHRtYXhXaWR0aDogMTAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBtZXRyaWMgc2NhbGUgbGluZSAobS9rbSkuXG5cdFx0bWV0cmljOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIGltcGVyaWFsIHNjYWxlIGxpbmUgKG1pL2Z0KS5cblx0XHRpbXBlcmlhbDogdHJ1ZVxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCBpcyB1cGRhdGVkIG9uIFtgbW92ZWVuZGBdKCNtYXAtbW92ZWVuZCksIG90aGVyd2lzZSBpdCdzIGFsd2F5cyB1cC10by1kYXRlICh1cGRhdGVkIG9uIFtgbW92ZWBdKCNtYXAtbW92ZSkpLlxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuXHRcdCAgICBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cblx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG5cdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG5cdFx0XHR0aGlzLl9tU2NhbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB5ID0gbWFwLmdldFNpemUoKS55IC8gMjtcblxuXHRcdHZhciBtYXhNZXRlcnMgPSBtYXAuZGlzdGFuY2UoXG5cdFx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLCB5XSksXG5cdFx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcblx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG5cdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG5cdH0sXG5cblx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG5cdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG5cdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuXHRcdGQgPSBkID49IDEwID8gMTAgOlxuXHRcdCAgICBkID49IDUgPyA1IDpcblx0XHQgICAgZCA+PSAzID8gMyA6XG5cdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG5cdFx0cmV0dXJuIHBvdzEwICogZDtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbkwuY29udHJvbC5zY2FsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5Db250cm9sLlNjYWxlKG9wdGlvbnMpO1xufTtcblxuLypcclxuICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC5odG1sKSkuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICogXHRcIk1hcGJveFwiOiBtYXBib3gsXHJcbiAqIFx0XCJPcGVuU3RyZWV0TWFwXCI6IG9zbVxyXG4gKiB9O1xyXG4gKlxyXG4gKiB2YXIgb3ZlcmxheXMgPSB7XHJcbiAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gKiBcdFwiUm9hZHNcIjogcm9hZHNMYXllclxyXG4gKiB9O1xyXG4gKlxyXG4gKiBMLmNvbnRyb2wubGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGBiYXNlTGF5ZXJzYCBhbmQgYG92ZXJsYXlzYCBwYXJhbWV0ZXJzIGFyZSBvYmplY3QgbGl0ZXJhbHMgd2l0aCBsYXllciBuYW1lcyBhcyBrZXlzIGFuZCBgTGF5ZXJgIG9iamVjdHMgYXMgdmFsdWVzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XHJcbiAqICAgICBcIjxzb21lTmFtZTE+XCI6IGxheWVyMSxcclxuICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBsYXllciBuYW1lcyBjYW4gY29udGFpbiBIVE1MLCB3aGljaCBhbGxvd3MgeW91IHRvIGFkZCBhZGRpdGlvbmFsIHN0eWxpbmcgdG8gdGhlIGl0ZW1zOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XCI8aW1nIHNyYz0nbXktbGF5ZXItaWNvbicgLz4gPHNwYW4gY2xhc3M9J215LWxheWVyLWl0ZW0nPk15IExheWVyPC9zcGFuPlwiOiBteUxheWVyfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuTC5Db250cm9sLkxheWVycyA9IEwuQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjb2xsYXBzZWQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIgb3IgdG91Y2guXHJcblx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9aSW5kZXg6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG5cdFx0YXV0b1pJbmRleDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGhpZGVTaW5nbGVCYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcblx0XHRoaWRlU2luZ2xlQmFzZTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBiYXNlIGxheWVyIChyYWRpbyBidXR0b24gZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBvdmVybGF5IChjaGVja2JveCBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRPdmVybGF5OiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmUgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGNvbnRyb2wuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKEwuc3RhbXAobGF5ZXIpKTtcclxuXHRcdGlmIChvYmopIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihvYmopLCAxKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcblx0Ly8gRXhwYW5kIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBjb2xsYXBzZWQuXHJcblx0ZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0dGhpcy5fZm9ybS5zdHlsZS5oZWlnaHQgPSBudWxsO1xyXG5cdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuXHRcdGlmIChhY2NlcHRhYmxlSGVpZ2h0IDwgdGhpcy5fZm9ybS5jbGllbnRIZWlnaHQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2Zvcm0sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0XHR0aGlzLl9mb3JtLnN0eWxlLmhlaWdodCA9IGFjY2VwdGFibGVIZWlnaHQgKyAncHgnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2Zvcm0sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcblx0Ly8gQ29sbGFwc2UgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGV4cGFuZGVkLlxyXG5cdGNvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycycsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKTtcclxuXHJcblx0XHQvLyBtYWtlcyB0aGlzIHdvcmsgb24gSUUgdG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXHJcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG5cdFx0TC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0aWYgKCFMLkJyb3dzZXIudG91Y2gpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZm9ybSA9IHRoaXMuX2Zvcm0gPSBMLkRvbVV0aWwuY3JlYXRlKCdmb3JtJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuXHRcdFx0aWYgKCFMLkJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHRcdEwuRG9tRXZlbnQub24oY29udGFpbmVyLCB7XHJcblx0XHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLmV4cGFuZCxcclxuXHRcdFx0XHRcdG1vdXNlbGVhdmU6IHRoaXMuY29sbGFwc2VcclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuXHRcdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcblxyXG5cdFx0XHRpZiAoTC5Ccm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHRcdCAgICAub24obGluaywgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wKVxyXG5cdFx0XHRcdCAgICAub24obGluaywgJ2NsaWNrJywgdGhpcy5leHBhbmQsIHRoaXMpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdEwuRG9tRXZlbnQub24obGluaywgJ2ZvY3VzJywgdGhpcy5leHBhbmQsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB3b3JrIGFyb3VuZCBmb3IgRmlyZWZveCBBbmRyb2lkIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzIwMzNcclxuXHRcdFx0TC5Eb21FdmVudC5vbihmb3JtLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0c2V0VGltZW91dChMLmJpbmQodGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKSwgMCk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cdFx0XHQvLyBUT0RPIGtleWJvYXJkIGFjY2Vzc2liaWxpdHlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYmFzZUxheWVyc0xpc3QgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBmb3JtKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgZm9ybSk7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLW92ZXJsYXlzJywgZm9ybSk7XHJcblxyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZvcm0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuX2xheWVyc1tpXSAmJiBMLnN0YW1wKHRoaXMuX2xheWVyc1tpXS5sYXllcikgPT09IGlkKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9hZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lLCBvdmVybGF5KSB7XHJcblx0XHRsYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG5cdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9aSW5kZXggJiYgbGF5ZXIuc2V0WkluZGV4KSB7XHJcblx0XHRcdHRoaXMuX2xhc3RaSW5kZXgrKztcclxuXHRcdFx0bGF5ZXIuc2V0WkluZGV4KHRoaXMuX2xhc3RaSW5kZXgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmVtcHR5KHRoaXMuX2Jhc2VMYXllcnNMaXN0KTtcclxuXHRcdEwuRG9tVXRpbC5lbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xyXG5cclxuXHRcdHZhciBiYXNlTGF5ZXJzUHJlc2VudCwgb3ZlcmxheXNQcmVzZW50LCBpLCBvYmosIGJhc2VMYXllcnNDb3VudCA9IDA7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRvYmogPSB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdHRoaXMuX2FkZEl0ZW0ob2JqKTtcclxuXHRcdFx0b3ZlcmxheXNQcmVzZW50ID0gb3ZlcmxheXNQcmVzZW50IHx8IG9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50IHx8ICFvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc0NvdW50ICs9ICFvYmoub3ZlcmxheSA/IDEgOiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEhpZGUgYmFzZSBsYXllcnMgc2VjdGlvbiBpZiB0aGVyZSdzIG9ubHkgb25lIGxheWVyLlxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5oaWRlU2luZ2xlQmFzZSkge1xyXG5cdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50ICYmIGJhc2VMYXllcnNDb3VudCA+IDE7XHJcblx0XHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0LnN0eWxlLmRpc3BsYXkgPSBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3NlcGFyYXRvci5zdHlsZS5kaXNwbGF5ID0gb3ZlcmxheXNQcmVzZW50ICYmIGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29uTGF5ZXJDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2hhbmRsaW5nQ2xpY2spIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKEwuc3RhbXAoZS50YXJnZXQpKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYmFzZWxheWVyY2hhbmdlOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGJhc2UgbGF5ZXIgaXMgY2hhbmdlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5YWRkOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5cmVtb3ZlOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBkZXNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBDb250cm9sLkxheWVyc1xyXG5cdFx0dmFyIHR5cGUgPSBvYmoub3ZlcmxheSA/XHJcblx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ292ZXJsYXlhZGQnIDogJ292ZXJsYXlyZW1vdmUnKSA6XHJcblx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ2Jhc2VsYXllcmNoYW5nZScgOiBudWxsKTtcclxuXHJcblx0XHRpZiAodHlwZSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSh0eXBlLCBvYmopO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIElFNyBidWdzIG91dCBpZiB5b3UgY3JlYXRlIGEgcmFkaW8gZHluYW1pY2FsbHksIHNvIHlvdSBoYXZlIHRvIGRvIGl0IHRoaXMgaGFja3kgd2F5IChzZWUgaHR0cDovL2JpdC5seS9QcVlMQmUpXHJcblx0X2NyZWF0ZVJhZGlvRWxlbWVudDogZnVuY3Rpb24gKG5hbWUsIGNoZWNrZWQpIHtcclxuXHJcblx0XHR2YXIgcmFkaW9IdG1sID0gJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3JcIiBuYW1lPVwiJyArXHJcblx0XHRcdFx0bmFtZSArICdcIicgKyAoY2hlY2tlZCA/ICcgY2hlY2tlZD1cImNoZWNrZWRcIicgOiAnJykgKyAnLz4nO1xyXG5cclxuXHRcdHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRyYWRpb0ZyYWdtZW50LmlubmVySFRNTCA9IHJhZGlvSHRtbDtcclxuXHJcblx0XHRyZXR1cm4gcmFkaW9GcmFnbWVudC5maXJzdENoaWxkO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRJdGVtOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxyXG5cdFx0ICAgIGNoZWNrZWQgPSB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSxcclxuXHRcdCAgICBpbnB1dDtcclxuXHJcblx0XHRpZiAob2JqLm92ZXJsYXkpIHtcclxuXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG5cdFx0XHRpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcclxuXHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xyXG5cdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVycycsIGNoZWNrZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlucHV0LmxheWVySWQgPSBMLnN0YW1wKG9iai5sYXllcik7XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vbihpbnB1dCwgJ2NsaWNrJywgdGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHRcdG5hbWUuaW5uZXJIVE1MID0gJyAnICsgb2JqLm5hbWU7XHJcblxyXG5cdFx0Ly8gSGVscHMgZnJvbSBwcmV2ZW50aW5nIGxheWVyIGNvbnRyb2wgZmxpY2tlciB3aGVuIGNoZWNrYm94ZXMgYXJlIGRpc2FibGVkXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yNzcxXHJcblx0XHR2YXIgaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG5cdFx0bGFiZWwuYXBwZW5kQ2hpbGQoaG9sZGVyKTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChpbnB1dCk7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IG9iai5vdmVybGF5ID8gdGhpcy5fb3ZlcmxheXNMaXN0IDogdGhpcy5fYmFzZUxheWVyc0xpc3Q7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG5cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiBsYWJlbDtcclxuXHR9LFxyXG5cclxuXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fZm9ybS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKSxcclxuXHRcdCAgICBpbnB1dCwgbGF5ZXIsIGhhc0xheWVyO1xyXG5cdFx0dmFyIGFkZGVkTGF5ZXJzID0gW10sXHJcblx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblx0XHRcdGhhc0xheWVyID0gdGhpcy5fbWFwLmhhc0xheWVyKGxheWVyKTtcclxuXHJcblx0XHRcdGlmIChpbnB1dC5jaGVja2VkICYmICFoYXNMYXllcikge1xyXG5cdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCAmJiBoYXNMYXllcikge1xyXG5cdFx0XHRcdHJlbW92ZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBCdWdmaXggaXNzdWUgMjMxODogU2hvdWxkIHJlbW92ZSBhbGwgb2xkIGxheWVycyBiZWZvcmUgcmVhZGRpbmcgbmV3IG9uZXNcclxuXHRcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihyZW1vdmVkTGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBhZGRlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIoYWRkZWRMYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2Zvcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JyksXHJcblx0XHQgICAgaW5wdXQsXHJcblx0XHQgICAgbGF5ZXIsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA+IGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9leHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHJlbW92ZSBtZSBpbiAxLjEuXHJcblx0XHRyZXR1cm4gdGhpcy5leHBhbmQoKTtcclxuXHR9LFxyXG5cclxuXHRfY29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHJlbW92ZSBtZSBpbiAxLjEuXHJcblx0XHRyZXR1cm4gdGhpcy5jb2xsYXBzZSgpO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5sYXllcnMoYmFzZWxheWVycz86IE9iamVjdCwgb3ZlcmxheXM/OiBPYmplY3QsIG9wdGlvbnM/OiBDb250cm9sLkxheWVycyBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxyXG5MLmNvbnRyb2wubGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxufTtcclxuXG4vKlxyXG4gKiBQcm92aWRlcyBMLk1hcCB3aXRoIGNvbnZlbmllbnQgc2hvcnRjdXRzIGZvciB1c2luZyBicm93c2VyIGdlb2xvY2F0aW9uIGZlYXR1cmVzLlxyXG4gKi9cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcblx0X2RlZmF1bHRMb2NhdGVPcHRpb25zOiB7XHJcblx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdHdhdGNoOiBmYWxzZVxyXG5cdFx0Ly8gc2V0VmlldzogZmFsc2VcclxuXHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHQvLyBtYXhpbXVtQWdlOiAwXHJcblx0XHQvLyBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcblx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcblx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cclxuXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcblx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG5cdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcclxuXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCB0aGlzLl9kZWZhdWx0TG9jYXRlT3B0aW9ucywgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBMLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IEwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMLkxhdExuZyhsYXQsIGxuZyksXHJcblx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnNldFZpZXcpIHtcclxuXHRcdFx0dmFyIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzKTtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhab29tKSA6IHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuXHRcdFx0Ym91bmRzOiBib3VuZHMsXHJcblx0XHRcdHRpbWVzdGFtcDogcG9zLnRpbWVzdGFtcFxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHBvcy5jb29yZHMpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBwb3MuY29vcmRzW2ldID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZm91bmQ6IExvY2F0aW9uRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpXHJcblx0XHQvLyB3ZW50IHN1Y2Nlc3NmdWxseS5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG5cdH1cclxufSk7XHJcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIoZnVuY3Rpb24od2luZG93LCB1bmRlZmluZWQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoIXdpbmRvdykgcmV0dXJuOyAvLyBTZXJ2ZXIgc2lkZVxuXG52YXJcbiAgICBfYmFyb24gPSB3aW5kb3cuYmFyb24sIC8vIFN0b3JlZCBiYXJvbiB2YWx1ZSBmb3Igbm9Db25mbGljdCB1c2FnZVxuICAgICQgPSB3aW5kb3cualF1ZXJ5LCAvLyBUcnlpbmcgdG8gdXNlIGpRdWVyeVxuICAgIG9yaWdpbiA9IHtcbiAgICAgICAgdjogeyAvLyBWZXJ0aWNhbFxuICAgICAgICAgICAgeDogJ1knLCBwb3M6ICd0b3AnLCBjcm9zc1BvczogJ2xlZnQnLCBzaXplOiAnaGVpZ2h0JywgY3Jvc3NTaXplOiAnd2lkdGgnLFxuICAgICAgICAgICAgY2xpZW50OiAnY2xpZW50SGVpZ2h0JywgY3Jvc3NDbGllbnQ6ICdjbGllbnRXaWR0aCcsIG9mZnNldDogJ29mZnNldEhlaWdodCcsIGNyb3NzT2Zmc2V0OiAnb2Zmc2V0V2lkdGgnLCBvZmZzZXRQb3M6ICdvZmZzZXRUb3AnLFxuICAgICAgICAgICAgc2Nyb2xsOiAnc2Nyb2xsVG9wJywgc2Nyb2xsU2l6ZTogJ3Njcm9sbEhlaWdodCdcbiAgICAgICAgfSxcbiAgICAgICAgaDogeyAvLyBIb3Jpem9udGFsXG4gICAgICAgICAgICB4OiAnWCcsIHBvczogJ2xlZnQnLCBjcm9zc1BvczogJ3RvcCcsIHNpemU6ICd3aWR0aCcsIGNyb3NzU2l6ZTogJ2hlaWdodCcsXG4gICAgICAgICAgICBjbGllbnQ6ICdjbGllbnRXaWR0aCcsIGNyb3NzQ2xpZW50OiAnY2xpZW50SGVpZ2h0Jywgb2Zmc2V0OiAnb2Zmc2V0V2lkdGgnLCBjcm9zc09mZnNldDogJ29mZnNldEhlaWdodCcsIG9mZnNldFBvczogJ29mZnNldExlZnQnLFxuICAgICAgICAgICAgc2Nyb2xsOiAnc2Nyb2xsTGVmdCcsIHNjcm9sbFNpemU6ICdzY3JvbGxXaWR0aCdcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvcikge1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IHdpbmRvdykgb2JqID0gW29ial07XG5cbiAgICAgICAgd2hpbGUgKG9ialtpXSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbCh0aGlzLCBvYmpbaV0sIGkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJhcm9uID0gZnVuY3Rpb24ocGFyYW1zKSB7IC8vIHRoaXMgLSB3aW5kb3cgb3IgalF1ZXJ5IGluc3RhbmNlXG4gICAgICAgIHZhciBqUXVlcnlNb2RlID0gZmFsc2UsLy8odGhpcyAmJiB0aGlzWzBdICYmIHRoaXNbMF0ubm9kZVR5cGUpLFxuICAgICAgICAgICAgcm9vdHMsXG4gICAgICAgICAgICAkO1xuXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgJCA9IHBhcmFtcy4kIHx8IHdpbmRvdy5qUXVlcnk7XG5cbiAgICAgICAgaWYgKGpRdWVyeU1vZGUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5yb290ID0gcm9vdHMgPSB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm9vdHMgPSAkKHBhcmFtcy5yb290IHx8IHBhcmFtcy5zY3JvbGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IGJhcm9uLmZuLmNvbnN0cnVjdG9yKHJvb3RzLCBwYXJhbXMsICQpO1xuICAgIH07XG5cbiAgICBiYXJvbi5mbiA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKHJvb3RzLCBpbnB1dCwgJCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHZhbGlkYXRlKGlucHV0KTtcblxuICAgICAgICAgICAgcGFyYW1zLiQgPSAkO1xuICAgICAgICAgICAgZWFjaC5jYWxsKHRoaXMsIHJvb3RzLCBmdW5jdGlvbihyb290LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUGFyYW1zID0gY2xvbmUocGFyYW1zKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMucm9vdCAmJiBwYXJhbXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJhbXMuc2Nyb2xsZXIgPSBwYXJhbXMuJChwYXJhbXMuc2Nyb2xsZXIsIHJvb3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsUGFyYW1zLnNjcm9sbGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJhbXMuc2Nyb2xsZXIgPSByb290O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJhbXMuc2Nyb2xsZXIgPSByb290O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxvY2FsUGFyYW1zLnJvb3QgPSByb290O1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBpbml0KGxvY2FsUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGkgKyAxO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuXG4gICAgICAgICAgICBlYWNoKHRoaXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmRpc3Bvc2UocGFyYW1zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlICh0aGlzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXS51cGRhdGUuYXBwbHkodGhpc1tpXSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmFyb246IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zLnJvb3QgPSBbXTtcbiAgICAgICAgICAgIHBhcmFtcy5zY3JvbGxlciA9IHRoaXMucGFyYW1zLnNjcm9sbGVyO1xuXG4gICAgICAgICAgICBlYWNoLmNhbGwodGhpcywgdGhpcywgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5yb290LnB1c2goZWxlbS5yb290KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zLmRpcmVjdGlvbiA9ICh0aGlzLnBhcmFtcy5kaXJlY3Rpb24gPT0gJ3YnKSA/ICdoJyA6ICd2JztcbiAgICAgICAgICAgIHBhcmFtcy5fY2hhaW4gPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gYmFyb24ocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYW5hZ2VFdmVudHMoaXRlbSwgZXZlbnRNYW5hZ2VyLCBtb2RlKSB7XG4gICAgICAgIGl0ZW0uX2V2ZW50SGFuZGxlcnMgPSBpdGVtLl9ldmVudEhhbmRsZXJzIHx8IFsgLy8gQ3JlYXRpbmcgbmV3IGZ1bmN0aW9ucyBmb3Igb25lIGJhcm9uIGl0ZW0gb25seSBvbmUgdGltZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIG9uU2Nyb2xsOlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW0uc2Nyb2xsZXIsXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2Nyb2xsKGUpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0eXBlOiAnc2Nyb2xsJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIC8vIG9uTW91c2VEb3duOlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW0uYmFyLFxuXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyAvLyBUZXh0IHNlbGVjdGlvbiBkaXNhYmxpbmcgaW4gT3BlcmEuLi4gYW5kIGFsbCBvdGhlciBicm93c2Vycz9cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZWxlY3Rpb24oKTsgLy8gRGlzYWJsZSB0ZXh0IHNlbGVjdGlvbiBpbiBpZThcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kcmFnLm5vdyA9IDE7IC8vIFNhdmUgcHJpdmF0ZSBieXRlXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaHN0YXJ0IG1vdXNlZG93bidcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvbk1vdXNlVXA6XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZG9jdW1lbnQsXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZWxlY3Rpb24oMSk7IC8vIEVuYWJsZSB0ZXh0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRyYWcubm93ID0gMDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgdHlwZTogJ21vdXNldXAgYmx1ciB0b3VjaGVuZCdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvbkNvb3JkaW5hdGVSZXNldDpcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBpdGVtLmJhcixcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9IDIpIHsgLy8gTm90IFJNXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl9wb3MwKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaHN0YXJ0IG1vdXNlZG93bidcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvbk1vdXNlTW92ZTpcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBkb2N1bWVudCxcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uZHJhZy5ub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZHJhZyhlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2Vtb3ZlIHRvdWNobW92ZSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvblJlc2l6ZTpcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB3aW5kb3csXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgdHlwZTogJ3Jlc2l6ZSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBzaXplQ2hhbmdlOlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW0ucm9vdCxcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0eXBlOiAnc2l6ZUNoYW5nZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcblxuICAgICAgICBlYWNoKGl0ZW0uX2V2ZW50SGFuZGxlcnMsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlcihldmVudC5lbGVtZW50LCBldmVudC50eXBlLCBldmVudC5oYW5kbGVyLCBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgKGl0ZW0uc2Nyb2xsZXIpIHtcbiAgICAgICAgLy8gICAgIGV2ZW50KGl0ZW0uc2Nyb2xsZXIsICdzY3JvbGwnLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uU2Nyb2xsLCBtb2RlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAoaXRlbS5iYXIpIHtcbiAgICAgICAgLy8gICAgIGV2ZW50KGl0ZW0uYmFyLCAndG91Y2hzdGFydCBtb3VzZWRvd24nLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uTW91c2VEb3duLCBtb2RlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBldmVudChkb2N1bWVudCwgJ21vdXNldXAgYmx1ciB0b3VjaGVuZCcsIGl0ZW0uX2V2ZW50SGFuZGxlcnMub25Nb3VzZVVwLCBtb2RlKTtcbiAgICAgICAgLy8gZXZlbnQoZG9jdW1lbnQsICd0b3VjaHN0YXJ0IG1vdXNlZG93bicsIGl0ZW0uX2V2ZW50SGFuZGxlcnMub25Db29yZGluYXRlUmVzZXQsIG1vZGUpO1xuICAgICAgICAvLyBldmVudChkb2N1bWVudCwgJ21vdXNlbW92ZSB0b3VjaG1vdmUnLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uTW91c2VNb3ZlLCBtb2RlKTtcbiAgICAgICAgLy8gZXZlbnQod2luZG93LCAncmVzaXplJywgaXRlbS5fZXZlbnRIYW5kbGVycy5vblJlc2l6ZSwgbW9kZSk7XG4gICAgICAgIC8vIGlmIChpdGVtLnJvb3QpIHtcbiAgICAgICAgLy8gICAgIGV2ZW50KGl0ZW0ucm9vdCwgJ3NpemVDaGFuZ2UnLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uUmVzaXplLCBtb2RlKTsgLy8gQ3VzdG9uIGV2ZW50IGZvciBhbHRlcm5hdGUgYmFyb24gdXBkYXRlIG1lY2hhbmlzbVxuICAgICAgICAvLyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFuYWdlQXR0cihub2RlLCBkaXJlY3Rpb24sIG1vZGUpIHtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gJ2RhdGEtYmFyb24tJyArIGRpcmVjdGlvbjtcblxuICAgICAgICBpZiAobW9kZSA9PSAnb24nKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgJ2luaXRlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ29mZicpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KHBhcmFtcykge1xuICAgICAgICBpZiAobWFuYWdlQXR0cihwYXJhbXMucm9vdCwgcGFyYW1zLmRpcmVjdGlvbikpIHJldHVybjtcblxuICAgICAgICB2YXIgb3V0ID0gbmV3IGl0ZW0ucHJvdG90eXBlLmNvbnN0cnVjdG9yKHBhcmFtcyk7IC8vIF9fcHJvdG9fXyBvZiByZXR1cm5pbmcgb2JqZWN0IGlzIGJhcm9uLnByb3RvdHlwZVxuXG4gICAgICAgIG1hbmFnZUV2ZW50cyhvdXQsIHBhcmFtcy5ldmVudCwgJ29uJyk7XG5cbiAgICAgICAgbWFuYWdlQXR0cihvdXQucm9vdCwgcGFyYW1zLmRpcmVjdGlvbiwgJ29uJyk7XG5cbiAgICAgICAgb3V0LnVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUoaW5wdXQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xuXG4gICAgICAgIGlucHV0ID0gaW5wdXQgfHwge307XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoaW5wdXQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IGNsb25lKGlucHV0KTtcblxuICAgICAgICBvdXRwdXQuZGlyZWN0aW9uID0gb3V0cHV0LmRpcmVjdGlvbiB8fCAndic7XG5cbiAgICAgICAgdmFyIGV2ZW50ID0gaW5wdXQuZXZlbnQgfHwgZnVuY3Rpb24oZWxlbSwgZXZlbnQsIGZ1bmMsIG1vZGUpIHtcbiAgICAgICAgICAgIG91dHB1dC4kKGVsZW0pW21vZGUgfHwgJ29uJ10oZXZlbnQsIGZ1bmMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG91dHB1dC5ldmVudCA9IGZ1bmN0aW9uKGVsZW1zLCBlLCBmdW5jLCBtb2RlKSB7XG4gICAgICAgICAgICBlYWNoKGVsZW1zLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQoZWxlbSwgZSwgZnVuYywgbW9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpcmUoZXZlbnROYW1lKSB7XG4gICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBpZiAodGhpcy5ldmVudHMgJiYgdGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV1baV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXRlbSA9IHt9O1xuXG4gICAgaXRlbS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciAkLFxuICAgICAgICAgICAgICAgIGJhclBvcyxcbiAgICAgICAgICAgICAgICBzY3JvbGxlclBvczAsXG4gICAgICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICAgICAgcmVzaXplUGF1c2VUaW1lcixcbiAgICAgICAgICAgICAgICBzY3JvbGxQYXVzZVRpbWVyLFxuICAgICAgICAgICAgICAgIHBhdXNlLFxuICAgICAgICAgICAgICAgIHNjcm9sbExhc3RGaXJlLFxuICAgICAgICAgICAgICAgIHJlc2l6ZUxhc3RGaXJlO1xuXG4gICAgICAgICAgICByZXNpemVMYXN0RmlyZSA9IHNjcm9sbExhc3RGaXJlID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgICQgPSB0aGlzLiQgPSBwYXJhbXMuJDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBwYXJhbXMuZXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXROb2RlKHNlbCwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkKHNlbCwgY29udGV4dClbMF07IC8vIENhbiBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRE9NIGVsZW1lbnRzXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBwYXJhbXMucm9vdDsgLy8gQWx3YXlzIGh0bWwgbm9kZSwgbm90IGp1c3Qgc2VsZWN0b3JcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIgPSBnZXROb2RlKHBhcmFtcy5zY3JvbGxlcik7IC8vIChwYXJhbXMuc2Nyb2xsZXIpID8gZ2V0Tm9kZShwYXJhbXMuc2Nyb2xsZXIsIHRoaXMucm9vdCkgOiB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB0aGlzLmJhciA9IGdldE5vZGUocGFyYW1zLmJhciwgdGhpcy5yb290KTtcbiAgICAgICAgICAgIHRyYWNrID0gdGhpcy50cmFjayA9IGdldE5vZGUocGFyYW1zLnRyYWNrLCB0aGlzLnJvb3QpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYWNrICYmIHRoaXMuYmFyKSB7XG4gICAgICAgICAgICAgICAgdHJhY2sgPSB0aGlzLmJhci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGlwcGVyID0gdGhpcy5zY3JvbGxlci5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHBhcmFtcy5kaXJlY3Rpb247XG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9IG9yaWdpblt0aGlzLmRpcmVjdGlvbl07XG4gICAgICAgICAgICB0aGlzLmJhck9uQ2xzID0gcGFyYW1zLmJhck9uQ2xzO1xuICAgICAgICAgICAgdGhpcy5iYXJUb3BMaW1pdCA9IDA7XG4gICAgICAgICAgICBwYXVzZSA9IHBhcmFtcy5wYXVzZSAqIDEwMDAgfHwgMDtcblxuICAgICAgICAgICAgLy8gVXBkYXRpbmcgaGVpZ2h0IG9yIHdpZHRoIG9mIGJhclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0QmFyU2l6ZShzaXplKSB7XG4gICAgICAgICAgICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgICAgICAgICAgdmFyIGJhck1pblNpemUgPSB0aGlzLmJhck1pblNpemUgfHwgMjA7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDAgJiYgc2l6ZSA8IGJhck1pblNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IGJhck1pblNpemU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5iYXIpLmNzcyh0aGlzLm9yaWdpbi5zaXplLCBwYXJzZUludChzaXplLCAxMCkgKyAncHgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIHRvcCBvciBsZWZ0IGJhciBwb3NpdGlvblxuICAgICAgICAgICAgZnVuY3Rpb24gcG9zQmFyKHBvcykge1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhcikge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuYmFyKS5jc3ModGhpcy5vcmlnaW4ucG9zLCArcG9zICsgJ3B4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGcmVlIHBhdGggZm9yIGJhclxuICAgICAgICAgICAgZnVuY3Rpb24gaygpIHtcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2tbdGhpcy5vcmlnaW4uY2xpZW50XSAtIHRoaXMuYmFyVG9wTGltaXQgLSB0aGlzLmJhclt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWxhdGl2ZSBjb250ZW50IHRvcCBwb3NpdGlvbiB0byBiYXIgdG9wIHBvc2l0aW9uXG4gICAgICAgICAgICBmdW5jdGlvbiByZWxUb1BvcyhyKSB7XG4gICAgICAgICAgICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgKiBrLmNhbGwodGhpcykgKyB0aGlzLmJhclRvcExpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCYXIgcG9zaXRpb24gdG8gcmVsYXRpdmUgY29udGVudCBwb3NpdGlvblxuICAgICAgICAgICAgZnVuY3Rpb24gcG9zVG9SZWwodCkge1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICAgICAgICAgIHJldHVybiAodCAtIHRoaXMuYmFyVG9wTGltaXQpIC8gay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDdXJzb3IgcG9zaXRpb24gaW4gbWFpbiBkaXJlY3Rpb24gaW4gcHggLy8gTm93IHdpdGggaU9zIHN1cHBvcnRcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlWydjbGllbnQnICsgdGhpcy5vcmlnaW4ueF0gfHwgKCgoZS5vcmlnaW5hbEV2ZW50IHx8IGUpLnRvdWNoZXMgfHwge30pWzBdIHx8IHt9KVsncGFnZScgKyB0aGlzLm9yaWdpbi54XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFRleHQgc2VsZWN0aW9uIHBvcyBwcmV2ZW50aW5nXG4gICAgICAgICAgICBmdW5jdGlvbiBkb250UG9zU2VsZWN0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wb3MgPSBmdW5jdGlvbih4KSB7IC8vIEFic29sdXRlIHNjcm9sbGVyIHBvc2l0aW9uIGluIHB4XG4gICAgICAgICAgICAgICAgdmFyIGllID0gJ3BhZ2UnICsgdGhpcy5vcmlnaW4ueCArICdPZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICBrZXkgPSAodGhpcy5zY3JvbGxlcltpZV0pID8gaWUgOiB0aGlzLm9yaWdpbi5zY3JvbGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkKSB0aGlzLnNjcm9sbGVyW2tleV0gPSB4O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsZXJba2V5XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucnBvcyA9IGZ1bmN0aW9uKHIpIHsgLy8gUmVsYXRpdmUgc2Nyb2xsZXIgcG9zaXRpb24gKDAuLjEpXG4gICAgICAgICAgICAgICAgdmFyIGZyZWUgPSB0aGlzLnNjcm9sbGVyW3RoaXMub3JpZ2luLnNjcm9sbFNpemVdIC0gdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5jbGllbnRdLFxuICAgICAgICAgICAgICAgICAgICB4O1xuXG4gICAgICAgICAgICAgICAgaWYgKHIpIHggPSB0aGlzLnBvcyhyICogZnJlZSk7XG4gICAgICAgICAgICAgICAgZWxzZSB4ID0gdGhpcy5wb3MoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB4IC8gKGZyZWUgfHwgMSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTd2l0Y2ggb24gdGhlIGJhciBieSBhZGRpbmcgdXNlci1kZWZpbmVkIENTUyBjbGFzc25hbWUgdG8gc2Nyb2xsZXJcbiAgICAgICAgICAgIHRoaXMuYmFyT24gPSBmdW5jdGlvbihkaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFyT25DbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2UgfHwgdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5jbGllbnRdID49IHRoaXMuc2Nyb2xsZXJbdGhpcy5vcmlnaW4uc2Nyb2xsU2l6ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5yb290KS5yZW1vdmVDbGFzcyh0aGlzLmJhck9uQ2xzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5yb290KS5hZGRDbGFzcyh0aGlzLmJhck9uQ2xzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX3BvczAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJQb3MwID0gdGhpcy5jdXJzb3IoZSkgLSBiYXJQb3M7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5zY3JvbGxdID0gcG9zVG9SZWwuY2FsbCh0aGlzLCB0aGlzLmN1cnNvcihlKSAtIHNjcm9sbGVyUG9zMCkgKiAodGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5zY3JvbGxTaXplXSAtIHRoaXMuc2Nyb2xsZXJbdGhpcy5vcmlnaW4uY2xpZW50XSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBUZXh0IHNlbGVjdGlvbiBwcmV2ZW50aW5nIG9uIGRyYWdcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudChkb2N1bWVudCwgJ3NlbGVjdHBvcyBzZWxlY3RzdGFydCcsIGRvbnRQb3NTZWxlY3QsIGVuYWJsZSA/ICdvZmYnIDogJ29uJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBvblJlc2l6ZSAmIERPTSBtb2RpZmllZCBoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gcmVzaXplTGFzdEZpcmUgPCBwYXVzZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplUGF1c2VUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gcGF1c2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLmNyb3NzT2Zmc2V0XSAtIHNlbGYuc2Nyb2xsZXJbc2VsZi5vcmlnaW4uY3Jvc3NDbGllbnRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZnJlZXplICYmICFzZWxmLmNsaXBwZXIuc3R5bGVbc2VsZi5vcmlnaW4uY3Jvc3NTaXplXSkgeyAvLyBTb3VsZCBmaXJlIG9ubHkgb25jZVxuICAgICAgICAgICAgICAgICAgICAgICAgJChzZWxmLmNsaXBwZXIpLmNzcyhzZWxmLm9yaWdpbi5jcm9zc1NpemUsIHNlbGYuY2xpcHBlcltzZWxmLm9yaWdpbi5jcm9zc0NsaWVudF0gLSBkZWx0YSArICdweCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICQoc2VsZi5zY3JvbGxlcikuY3NzKHNlbGYub3JpZ2luLmNyb3NzU2l6ZSwgc2VsZi5jbGlwcGVyW3NlbGYub3JpZ2luLmNyb3NzQ2xpZW50XSArIGRlbHRhICsgJ3B4Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuY2FsbChhcmd1bWVudHMsICdyZXNpemUnKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZUxhc3RGaXJlID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZVBhdXNlVGltZXIgPSBzZXRUaW1lb3V0KHVwZCwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG9uU2Nyb2xsIGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEJhclNpemUsIG5ld0JhclNpemUsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzY3JvbGxMYXN0RmlyZSA8IHBhdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzY3JvbGxQYXVzZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBwYXVzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QmFyU2l6ZSA9ICh0cmFja1tzZWxmLm9yaWdpbi5jbGllbnRdIC0gc2VsZi5iYXJUb3BMaW1pdCkgKiBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLmNsaWVudF0gLyBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLnNjcm9sbFNpemVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbmluZyBiYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRCYXJTaXplICE9IG5ld0JhclNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCYXJTaXplLmNhbGwoc2VsZiwgbmV3QmFyU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQmFyU2l6ZSA9IG5ld0JhclNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJhclBvcyA9IHJlbFRvUG9zLmNhbGwoc2VsZiwgc2VsZi5ycG9zKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NCYXIuY2FsbChzZWxmLCBiYXJQb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuY2FsbCggYXJndW1lbnRzLCAnc2Nyb2xsJyApO1xuICAgICAgICAgICAgICAgICAgICBmaXJlLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGFzdEZpcmUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsUGF1c2VUaW1lciA9IHNldFRpbWVvdXQodXBkLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgZmlyZS5jYWxsKHRoaXMsICd1cGQnLCBwYXJhbXMpOyAvLyDQntCx0L3QvtCy0LvRj9C10Lwg0L/QsNGA0LDQvNC10YLRgNGLINCy0YHQtdGFINC/0LvQsNCz0LjQvdC+0LJcblxuICAgICAgICAgICAgdGhpcy5yZXNpemUoMSk7XG4gICAgICAgICAgICB0aGlzLmJhck9uKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIG1hbmFnZUV2ZW50cyh0aGlzLCB0aGlzLmV2ZW50LCAnb2ZmJyk7XG4gICAgICAgICAgICBtYW5hZ2VBdHRyKHRoaXMucm9vdCwgcGFyYW1zLmRpcmVjdGlvbiwgJ29mZicpO1xuICAgICAgICAgICAgJCh0aGlzLnNjcm9sbGVyKS5jc3ModGhpcy5vcmlnaW4uY3Jvc3NTaXplLCAnJyk7XG4gICAgICAgICAgICB0aGlzLmJhck9uKHRydWUpO1xuICAgICAgICAgICAgZmlyZS5jYWxsKHRoaXMsICdkaXNwb3NlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZnVuYywgYXJnKSB7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBldmVudE5hbWUuc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgbmFtZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzW2ldID09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgICAgICBmdW5jLmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c1tuYW1lc1tpXV0gPSB0aGlzLmV2ZW50c1tuYW1lc1tpXV0gfHwgW107XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHNbbmFtZXNbaV1dLnB1c2goZnVuY3Rpb24odXNlckFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYy5jYWxsKHRoaXMsIHVzZXJBcmcgfHwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGJhcm9uLmZuLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGJhcm9uLmZuO1xuICAgIGl0ZW0ucHJvdG90eXBlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGl0ZW0ucHJvdG90eXBlO1xuXG4gICAgLy8gVXNlIHdoZW4geW91IG5lZWQgXCJiYXJvblwiIGdsb2JhbCB2YXIgZm9yIGFub3RoZXIgcHVycG9zZXNcbiAgICBiYXJvbi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5iYXJvbiA9IF9iYXJvbjsgLy8gUmVzdG9yaW5nIG9yaWdpbmFsIHZhbHVlIG9mIFwiYmFyb25cIiBnbG9iYWwgdmFyXG4gICAgICAgIHJldHVybiBiYXJvbjtcbiAgICB9O1xuXG4gICAgYmFyb24udmVyc2lvbiA9ICcwLjYuNic7XG5cbiAgICBpZiAoJCAmJiAkLmZuKSB7IC8vIEFkZGluZyBiYXJvbiB0byBqUXVlcnkgYXMgcGx1Z2luXG4gICAgICAgICQuZm4uYmFyb24gPSBiYXJvbjtcbiAgICB9XG4gICAgd2luZG93LmJhcm9uID0gYmFyb247IC8vIFVzZSBub0NvbmZsaWN0IG1ldGhvZCBpZiB5b3UgbmVlZCB3aW5kb3cuYmFyb24gdmFyIGZvciBhbm90aGVyIHB1cnBvc2VzXG5cbiAgICB2YXIgZml4ID0gZnVuY3Rpb24odXNlclBhcmFtcykge1xuICAgICAgICB2YXIgZWxlbWVudHMsIHZpZXdQb3J0U2l6ZSxcbiAgICAgICAgICAgIHBhcmFtcyA9IHsgLy8gRGVmYXVsdCBwYXJhbXNcbiAgICAgICAgICAgICAgICBvdXRzaWRlOiAnJyxcbiAgICAgICAgICAgICAgICBiZWZvcmU6ICcnLFxuICAgICAgICAgICAgICAgIGFmdGVyOiAnJyxcbiAgICAgICAgICAgICAgICBwYXN0OiAnJyxcbiAgICAgICAgICAgICAgICBmdXR1cmU6ICcnLFxuICAgICAgICAgICAgICAgIHJhZGl1czogMCxcbiAgICAgICAgICAgICAgICBtaW5WaWV3OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9wRml4SGVpZ2h0cyA9IFtdLCAvLyBpbmxpbmUgc3R5bGUgZm9yIGVsZW1lbnRcbiAgICAgICAgICAgIHRvcFJlYWxIZWlnaHRzID0gW10sIC8vIHJlYWwgb2Zmc2V0IHBvc2l0aW9uIHdoZW4gbm90IGZpeGVkXG4gICAgICAgICAgICBoZWFkZXJUb3BzID0gW10sXG4gICAgICAgICAgICBzY3JvbGxlciA9IHRoaXMuc2Nyb2xsZXIsXG4gICAgICAgICAgICBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50LFxuICAgICAgICAgICAgJCA9IHRoaXMuJCxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpeEVsZW1lbnQoaSwgcG9zKSB7XG4gICAgICAgICAgICBpZiAodmlld1BvcnRTaXplIDwgKHBhcmFtcy5taW5WaWV3IHx8IDApKSB7IC8vIE5vIGhlYWRlcnMgZml4aW5nIHdoZW4gbm8gZW5vdWdodCBzcGFjZSBmb3Igdmlld3BvcnRcbiAgICAgICAgICAgICAgICBwb3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBvcyArPSAncHgnO1xuICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuY3NzKHRoaXMub3JpZ2luLnBvcywgcG9zKS5hZGRDbGFzcyhwYXJhbXMub3V0c2lkZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuY3NzKHRoaXMub3JpZ2luLnBvcywgJycpLnJlbW92ZUNsYXNzKHBhcmFtcy5vdXRzaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGJ1YmJsZVdoZWVsKGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdXaGVlbEV2ZW50Jyk7IC8vIGkgLSBmb3IgZXh0cmEgYnl0ZVxuICAgICAgICAgICAgICAgIC8vIGV2dC5pbml0V2ViS2l0V2hlZWxFdmVudChkZWx0YVgsIGRlbHRhWSwgd2luZG93LCBzY3JlZW5YLCBzY3JlZW5ZLCBjbGllbnRYLCBjbGllbnRZLCBjdHJsS2V5LCBhbHRLZXksIHNoaWZ0S2V5LCBtZXRhS2V5KTtcbiAgICAgICAgICAgICAgICBpLmluaXRXZWJLaXRXaGVlbEV2ZW50KGUub3JpZ2luYWxFdmVudC53aGVlbERlbHRhWCwgZS5vcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFZKTtcbiAgICAgICAgICAgICAgICBzY3JvbGxlci5kaXNwYXRjaEV2ZW50KGkpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0KF9wYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBwb3M7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBfcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2tleV0gPSBfcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnRzID0gdGhpcy4kKHBhcmFtcy5lbGVtZW50cywgdGhpcy5zY3JvbGxlcik7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHZpZXdQb3J0U2l6ZSA9IHRoaXMuc2Nyb2xsZXJbdGhpcy5vcmlnaW4uY2xpZW50XTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBlbGVtZW50cy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFyaWFibGUgaGVhZGVyIGhlaWdodHNcbiAgICAgICAgICAgICAgICAgICAgcG9zID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBvc1t0aGlzLm9yaWdpbi5zaXplXSA9IGVsZW1lbnRzW2ldW3RoaXMub3JpZ2luLm9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1tpXS5wYXJlbnROb2RlICE9PSB0aGlzLnNjcm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0ucGFyZW50Tm9kZSkuY3NzKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBvc1t0aGlzLm9yaWdpbi5jcm9zc1NpemVdID0gZWxlbWVudHNbaV0ucGFyZW50Tm9kZVt0aGlzLm9yaWdpbi5jcm9zc0NsaWVudF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuY3NzKHBvcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmV0d2VlbiBmaXhlZCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIHZpZXdQb3J0U2l6ZSAtPSBlbGVtZW50c1tpXVt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlclRvcHNbaV0gPSBlbGVtZW50c1tpXS5wYXJlbnROb2RlW3RoaXMub3JpZ2luLm9mZnNldFBvc107IC8vIE5vIHBhZGRpbmdzIGZvciBwYXJlbnROb2RlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VtbWFyeSBlbGVtZW50cyBoZWlnaHQgYWJvdmUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICB0b3BGaXhIZWlnaHRzW2ldID0gKHRvcEZpeEhlaWdodHNbaSAtIDFdIHx8IDApOyAvLyBOb3QgemVybyBiZWNhdXNlIG9mIG5lZ2F0aXZlIG1hcmdpbnNcbiAgICAgICAgICAgICAgICAgICAgdG9wUmVhbEhlaWdodHNbaV0gPSAodG9wUmVhbEhlaWdodHNbaSAtIDFdIHx8IE1hdGgubWluKGhlYWRlclRvcHNbaV0sIDApKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbaSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BGaXhIZWlnaHRzW2ldICs9IGVsZW1lbnRzW2kgLSAxXVt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wUmVhbEhlaWdodHNbaV0gKz0gZWxlbWVudHNbaSAtIDFdW3RoaXMub3JpZ2luLm9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoICEoaSA9PSAwICYmIGhlYWRlclRvcHNbaV0gPT0gMCkvKiAmJiBmb3JjZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudChlbGVtZW50c1tpXSwgJ21vdXNld2hlZWwnLCBidWJibGVXaGVlbCwgJ29mZicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudChlbGVtZW50c1tpXSwgJ21vdXNld2hlZWwnLCBidWJibGVXaGVlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxpbWl0ZXIgJiYgZWxlbWVudHNbMF0pIHsgLy8gQm90dG9tIGVkZ2Ugb2YgZmlyc3QgaGVhZGVyIGFzIHRvcCBsaW1pdCBmb3IgdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2sgJiYgdGhpcy50cmFjayAhPSB0aGlzLnNjcm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc1t0aGlzLm9yaWdpbi5wb3NdID0gZWxlbWVudHNbMF0ucGFyZW50Tm9kZVt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kKHRoaXMudHJhY2spLmNzcyhwb3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXJUb3BMaW1pdCA9IGVsZW1lbnRzWzBdLnBhcmVudE5vZGVbdGhpcy5vcmlnaW4ub2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmJhclRvcExpbWl0ID0gZWxlbWVudHNbMF0ucGFyZW50Tm9kZVt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGltaXRlciA9PT0gZmFsc2UpIHsgLy8gdW5kZWZpbmVkIChpbiBzZWNvbmQgZml4IGluc3RhbmNlKSBzaG91bGQgaGF2ZSBubyBpbmZsdWVuY2Ugb24gYmFyIGxpbWl0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFyVG9wTGltaXQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRzLFxuXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAkKHRoaXMpWzBdLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBwYXJlbnQub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmRpbmcgbnVtIC0+IGVsZW1lbnRzW251bV0gPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZWxlbWVudHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldID09PSB0aGlzKSBudW0gPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IHRvcCAtIHRvcEZpeEhlaWdodHNbbnVtXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnNjcm9sbCkgeyAvLyBVc2VyIGRlZmluZWQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zY3JvbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxOiBzZWxmLnNjcm9sbGVyLnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MjogcG9zXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHR5cGU6ICdjbGljaydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuY2xpY2thYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVycy5wdXNoKGV2ZW50KTsgLy8gRm9yIGF1dG8tZGlzcG9zZVxuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlcihldmVudC5lbGVtZW50LCBldmVudC50eXBlLCBldmVudC5oYW5kbGVyLCAnb2ZmJyk7XG4gICAgICAgICAgICAgICAgZXZlbnRNYW5hZ2VyKGV2ZW50LmVsZW1lbnQsIGV2ZW50LnR5cGUsIGV2ZW50LmhhbmRsZXIsICdvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbignaW5pdCcsIGluaXQsIHVzZXJQYXJhbXMpO1xuXG4gICAgICAgIHRoaXMub24oJ2luaXQgc2Nyb2xsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZml4U3RhdGUsIGhUb3AsXG4gICAgICAgICAgICAgICAgZml4RmxhZyA9IFtdOyAvLyAxIC0gcGFzdCwgMiAtIGZ1dHVyZSwgMyAtIGN1cnJlbnQgKG5vdCBmaXhlZClcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZTtcblxuICAgICAgICAgICAgICAgIC8vIGZpeEZsYWcgdXBkYXRlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZWxlbWVudHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpeFN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlclRvcHNbaV0gLSB0aGlzLnBvcygpIDwgdG9wUmVhbEhlaWdodHNbaV0gKyBwYXJhbXMucmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIZWFkZXIgdHJ5aW5nIHRvIGdvIHVwXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBoVG9wID0gdG9wRml4SGVpZ2h0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJUb3BzW2ldIC0gdGhpcy5wb3MoKSA+IHRvcFJlYWxIZWlnaHRzW2ldICsgdmlld1BvcnRTaXplIC0gcGFyYW1zLnJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVhZGVyIHRyeWluZyB0byBnbyBkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhTdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBoVG9wID0gdG9wRml4SGVpZ2h0c1tpXSArIHZpZXdQb3J0U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlYWRlciBpbiB2aWV3cG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgZml4U3RhdGUgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaFRvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZml4U3RhdGUgIT0gZml4RmxhZ1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZml4RWxlbWVudC5jYWxsKHRoaXMsIGksIGhUb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZml4RmxhZ1tpXSA9IGZpeFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZGluZyBwb3NpdGlvbmluZyBjbGFzc2VzIChvbiBsYXN0IHRvcCBhbmQgZmlyc3QgYm90dG9tIGhlYWRlcilcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlKSB7IC8vIEF0IGxlYXRzIG9uZSBjaGFuZ2UgaW4gZWxlbWVudHMgZmxhZyBzdHJ1Y3R1cmUgb2NjdXJlZFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IGVsZW1lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpeEZsYWdbaV0gPT0gMSAmJiBwYXJhbXMucGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuYWRkQ2xhc3MocGFyYW1zLnBhc3QpLnJlbW92ZUNsYXNzKHBhcmFtcy5mdXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZml4RmxhZ1tpXSA9PSAyICYmIHBhcmFtcy5mdXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0pLmFkZENsYXNzKHBhcmFtcy5mdXR1cmUpLnJlbW92ZUNsYXNzKHBhcmFtcy5wYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpeEZsYWdbaV0gPT0gMyAmJiAocGFyYW1zLmZ1dHVyZSB8fCBwYXJhbXMucGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0pLnJlbW92ZUNsYXNzKHBhcmFtcy5wYXN0KS5yZW1vdmVDbGFzcyhwYXJhbXMuZnV0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpeEZsYWdbaV0gIT0gZml4RmxhZ1tpICsgMV0gJiYgZml4RmxhZ1tpXSA9PSAxICYmIHBhcmFtcy5iZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0pLmFkZENsYXNzKHBhcmFtcy5iZWZvcmUpLnJlbW92ZUNsYXNzKHBhcmFtcy5hZnRlcik7IC8vIExhc3QgdG9wIGZpeGVkIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaXhGbGFnW2ldICE9IGZpeEZsYWdbaSAtIDFdICYmIGZpeEZsYWdbaV0gPT0gMiAmJiBwYXJhbXMuYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0pLmFkZENsYXNzKHBhcmFtcy5hZnRlcikucmVtb3ZlQ2xhc3MocGFyYW1zLmJlZm9yZSk7IC8vIEZpcnN0IGJvdHRvbSBmaXhlZCBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kKGVsZW1lbnRzW2ldKS5yZW1vdmVDbGFzcyhwYXJhbXMuYmVmb3JlKS5yZW1vdmVDbGFzcyhwYXJhbXMuYWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9uKCdyZXNpemUgdXBkJywgZnVuY3Rpb24odXBkUGFyYW1zKSB7XG4gICAgICAgICAgICBpbml0LmNhbGwodGhpcywgdXBkUGFyYW1zICYmIHVwZFBhcmFtcy5maXgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYmFyb24uZm4uZml4ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgZml4LmNhbGwodGhpc1tpXSwgcGFyYW1zKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgY29udHJvbHMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGZvcndhcmQsIGJhY2t3YXJkLCB0cmFjaywgc2NyZWVuLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7IC8vIEFBQUFBQSEhISEhMTFcblxuICAgICAgICBzY3JlZW4gPSBwYXJhbXMuc2NyZWVuIHx8IDAuOTtcblxuICAgICAgICBpZiAocGFyYW1zLmZvcndhcmQpIHtcbiAgICAgICAgICAgIGZvcndhcmQgPSB0aGlzLiQocGFyYW1zLmZvcndhcmQsIHRoaXMuY2xpcHBlcik7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnQoZm9yd2FyZCwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzZWxmLnBvcygpIC0gcGFyYW1zLmRlbHRhIHx8IDMwO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5wb3MoeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuYmFja3dhcmQpIHtcbiAgICAgICAgICAgIGJhY2t3YXJkID0gdGhpcy4kKHBhcmFtcy5iYWNrd2FyZCwgdGhpcy5jbGlwcGVyKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudChiYWNrd2FyZCwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzZWxmLnBvcygpICsgcGFyYW1zLmRlbHRhIHx8IDMwO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5wb3MoeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMudHJhY2spIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMudHJhY2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0cmFjayA9IHRoaXMudHJhY2s7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNrID0gdGhpcy4kKHBhcmFtcy50cmFjaywgdGhpcy5jbGlwcGVyKVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCh0cmFjaywgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlWydvZmZzZXQnICsgc2VsZi5vcmlnaW4ueF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmFyID0gc2VsZi5iYXJbc2VsZi5vcmlnaW4ub2Zmc2V0UG9zXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ24gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgeEJhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHggPiB4QmFyICsgc2VsZi5iYXJbc2VsZi5vcmlnaW4ub2Zmc2V0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHNlbGYucG9zKCkgKyBzaWduICogc2NyZWVuICogc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5jbGllbnRdO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBvcyh5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIGJhcm9uLmZuLmNvbnRyb2xzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgY29udHJvbHMuY2FsbCh0aGlzW2ldLCBwYXJhbXMpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBwdWxsID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBibG9jayA9IHRoaXMuJChwYXJhbXMuYmxvY2spLFxuICAgICAgICAgICAgc2l6ZSA9IHBhcmFtcy5zaXplIHx8IHRoaXMub3JpZ2luLnNpemUsXG4gICAgICAgICAgICBsaW1pdCA9IHBhcmFtcy5saW1pdCB8fCA4MCxcbiAgICAgICAgICAgIG9uRXhwYW5kID0gcGFyYW1zLm9uRXhwYW5kLFxuICAgICAgICAgICAgZWxlbWVudHMgPSBwYXJhbXMuZWxlbWVudHMgfHwgW10sXG4gICAgICAgICAgICBpblByb2dyZXNzID0gcGFyYW1zLmluUHJvZ3Jlc3MgfHwgJycsXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIF9pbnNpc3RlbmNlID0gMCxcbiAgICAgICAgICAgIF96ZXJvWENvdW50ID0gMCxcbiAgICAgICAgICAgIF9pbnRlcnZhbCxcbiAgICAgICAgICAgIF90aW1lcixcbiAgICAgICAgICAgIF94ID0gMCxcbiAgICAgICAgICAgIF9vbkV4cGFuZENhbGxlZCxcbiAgICAgICAgICAgIF93YWl0aW5nID0gcGFyYW1zLndhaXRpbmcgfHwgNTAwLFxuICAgICAgICAgICAgX29uO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5zY3JvbGxdICsgc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2Nyb2xsZXIgY29udGVudCBoZWlnaHRcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGVudFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5zY3JvbGxTaXplXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNjcm9sbGVyIGhlaWdodFxuICAgICAgICBmdW5jdGlvbiBnZXRTY3JvbGxlclNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5jbGllbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RlcCh4LCBmb3JjZSkge1xuICAgICAgICAgICAgdmFyIGsgPSB4ICogMC4wMDA1O1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihmb3JjZSAtIGsgKiAoeCArIDU1MCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdG9nZ2xlKG9uKSB7XG4gICAgICAgICAgICBfb24gPSBvbjtcblxuICAgICAgICAgICAgaWYgKG9uKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7IC8vIEZpcnN0IHRpbWUgd2l0aCBubyBkZWxheVxuICAgICAgICAgICAgICAgIF9pbnRlcnZhbCA9IHNldEludGVydmFsKHVwZGF0ZSwgMjAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChfaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHt9LFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGdldFNpemUoKSxcbiAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSBnZXRDb250ZW50U2l6ZSgpLFxuICAgICAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgICAgIG9wNCxcbiAgICAgICAgICAgICAgICBzY3JvbGxJblByb2dyZXNzID0gX2luc2lzdGVuY2UgPT0gMTtcblxuICAgICAgICAgICAgb3A0ID0gMDsgLy8g0JLQvtC30LLRgNCw0YnQsNGO0YnQsNGPINGB0LjQu9CwXG4gICAgICAgICAgICBpZiAoX2luc2lzdGVuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgb3A0ID0gNDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIChfaW5zaXN0ZW5jZSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZHggPSBzdGVwKF94LCBvcDQpO1xuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPj0gc2Nyb2xsSGVpZ2h0IC0gX3ggJiYgX2luc2lzdGVuY2UgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ggKz0gZHg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfeCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF94IDwgMCkgX3ggPSAwO1xuXG4gICAgICAgICAgICAgICAgcG9zW3NpemVdID0gX3ggKyAncHgnO1xuICAgICAgICAgICAgICAgIGlmIChnZXRTY3JvbGxlclNpemUoKSA8PSBnZXRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJChibG9jaykuY3NzKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGVsZW1lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi4kKGVsZW1lbnRzW2ldLnNlbGYpLmNzcyhlbGVtZW50c1tpXS5wcm9wZXJ0eSwgTWF0aC5taW4oX3ggLyBsaW1pdCAqIDEwMCwgMTAwKSArICclJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5Qcm9ncmVzcyAmJiBfeCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLiQoc2VsZi5yb290KS5hZGRDbGFzcyhpblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3ggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLm9uQ29sbGFwc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5vbkNvbGxhcHNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfaW5zaXN0ZW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgX2luc2lzdGVuY2UgPSAtMTtcbiAgICAgICAgICAgICAgICB9LCBfd2FpdGluZyk7XG4gICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgaWYgKG9uRXhwYW5kICYmIF94ID4gbGltaXQgJiYgIV9vbkV4cGFuZENhbGxlZCkge1xuICAgICAgICAgICAgICAgIG9uRXhwYW5kKCk7XG4gICAgICAgICAgICAgICAgX29uRXhwYW5kQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF94ID09IDApIHtcbiAgICAgICAgICAgICAgICBfemVyb1hDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfemVyb1hDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfemVyb1hDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0b2dnbGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIF9vbkV4cGFuZENhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJChzZWxmLnJvb3QpLnJlbW92ZUNsYXNzKGluUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub24oJ2luaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRvZ2dsZSh0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudCh0aGlzLnNjcm9sbGVyLCAnbW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBkb3duID0gZS53aGVlbERlbHRhIDwgMCB8fCAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC53aGVlbERlbHRhIDwgMCkgfHwgZS5kZXRhaWwgPiAwO1xuXG4gICAgICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgICAgICAgIF9pbnNpc3RlbmNlID0gMTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RpbWVyKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9vbiAmJiBnZXRTaXplKCkgPj0gZ2V0Q29udGVudFNpemUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gIGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIHRvZ2dsZShmYWxzZSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBiYXJvbi5mbi5wdWxsID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgcHVsbC5jYWxsKHRoaXNbaV0sIHBhcmFtcyk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufSkod2luZG93KTtcbiJdfQ==
